+++
date = '2025-08-03T17:17:50+08:00'
draft = false
title = '智能座舱软件开发 CI/CD 流程技术说明文档'
+++

## **1. 概述**

本文档旨在详细阐述智能座舱软件开发从代码下载到最终OTA（Over-the-Air）发布的端到端自动化流程。该流程基于行业主流的 DevOps 和 CI/CD 实践，旨在通过高度自动化、严格的质量门禁和清晰的发布路径，确保软件开发的敏捷性、高质量和可追溯性。

**核心组件:**
* **版本控制与代码审查**: Git, Repo, Gerrit
* **持续集成/持续交付 (CI/CD)**: Jenkins
* **质量管理**: SonarQube
* **制品库管理**: JFrog Artifactory
* **测试平台**: HIL (硬件在环) / SIL (软件在环)
* **部署与发布**: OTA 服务器, TSP (车载信息服务提供商) 服务器


---

## **2. 详细流程与技术实现原理**

![](/ethenslab/images/Intelligent-cabin-software-development-and-release-process.png)

### **阶段 1 & 2: 开发者工作流**

此阶段是所有开发的起点，核心是为开发者提供一个高效、规范的本地开发环境。

* **[00] `repo init` 获取项目清单**:
    * **技术原理**: `repo` 是 Google 为管理 Android 这类包含数百个 Git 仓库的超大型项目而开发的工具。`repo init` 命令的核心是克隆一个特殊的 **Manifest 仓库**。该仓库包含一个 `manifest.xml` 文件，此 XML 文件以声明式的方式定义了整个智能座舱项目由哪些 Git 仓库（`<project>`）、在哪个路径（`path`）、以及使用哪个分支或 Tag（`revision`）组成。

* **[01] `repo sync` 同步所有源码**:
    * **技术原理**: `repo` 工具解析 `manifest.xml` 文件，然后以极高的并发度（可配置）为每个 `<project>` 执行 `git clone` 或 `git fetch` 操作。在我们的流程中，所有 Git 仓库都由 **Gerrit** 管理。Gerrit 在这里不仅是代码审查工具，也扮演着所有 Git 仓库的智能代理，负责所有 Git 操作的认证和权限控制。

* **[02] `repo start & git commit` 本地开发**:
    * **技术原理**: `repo start <branch_name> .` 是一个便捷命令，它会为清单中定义的所有项目统一创建一个同名的本地开发分支。开发者完成代码修改后，执行 `git commit`。一个关键的技术点是，`repo init` 时会自动在每个 Git 仓库的 `.git/hooks/` 目录下安装一个 `commit-msg` 钩子。此钩子会在每次提交时自动生成一个唯一的 `Change-Id`，Gerrit 依靠此 ID 来跟踪同一次代码提交的多个不同版本（Patchset）。

* **[03] `repo upload` 提交代码审核**:
    * **技术原理**: 这是连接本地开发与CI流程的关键。`repo upload` 会扫描本地分支上所有已提交但尚未上传的 commit，并将它们推送到 Gerrit 一个特殊的 Git 引用（Ref）上：`refs/for/<target_branch>`。例如，推送到 `develop` 分支进行审核，实际推送的地址是 `refs/for/develop`。Gerrit 监听到这个特殊引用上有推送时，不会直接合并代码，而是将其转化为一个可供审查的变更（Change）。

### **阶段 3: 审核与验证 (门禁)**

这是流程的自动化核心，通过“机器验证”和“人工评审”两个并行维度，建立起第一道质量门禁。

* **[04] `[Webhook]` 触发 CI 验证**:
    * **技术原理**: Gerrit 通过其事件监听插件（如 its-hooks），在“新 Patchset 创建（PatchSet Created）”事件发生时，向 Jenkins 服务器预先配置的 URL 发送一个 HTTP POST 请求，即 Webhook。该请求的 Body 是一个 JSON 对象，包含了触发验证所需的所有元数据，如项目名、分支、Gerrit Change URL 以及最重要的 Git Checkout 引用（例如 `refs/changes/23/12323/1`）。

* **[05-15] Jenkins CI 验证流水线**:
    * **拉取 Patchset**: Jenkins 中的 Gerrit Trigger 插件会解析 Webhook 传入的 JSON，并使用其中的 Git 引用，精确地只拉取开发者提交的那个变更版本进行验证，而不是整个主干。
    * **[06-07] 静态代码分析**: Jenkins 调用 SonarQube Scanner 工具。Scanner 会在 Jenkins 的工作空间内分析代码，并将分析结果（代码异味、Bug、漏洞、覆盖率等）上报给 SonarQube 服务器。上报后，Jenkins 会通过 API 回调 SonarQube，检查本次分析是否通过了预设的**质量门禁 (Quality Gate)**。
    * **[08-09] 拉取构建依赖**: 为加速编译，大型二进制依赖（如交叉编译工具链、SDK、第三方库）都预先存储在 **JFrog Artifactory** 中。Jenkins 通过 Artifactory 插件或 `curl` 命令，在编译前将这些依赖下载到构建环境中。
    * **编译与单元测试**: Jenkins 执行项目的编译脚本（如 `make`, `bitbake`），并在编译成功后运行单元测试套件（如 GoogleTest 框架生成的测试程序）。
    * **[12-15] 结果反馈**: Jenkins Pipeline 脚本会汇总以上所有步骤的执行结果（成功/失败）。然后，通过 Gerrit Trigger 插件提供的函数或直接调用 Gerrit 的 REST API，将结果写回 Gerrit。这包括一个标准化的评分（`Verified +1` 或 `-1`）和一个指向 Jenkins 构建日志的链接，实现了自动化的闭环反馈。

* **[16] 人工评审**:
    * **技术原理**: Gerrit 提供了一个可视化的 Web UI，允许审核者（Reviewer）对代码进行逐行评论、提出修改建议，并最终给出 `Code-Review` 评分。Gerrit 内部有强大的权限管理系统，可以配置只有特定用户组（如 Team Leader）才能给出 `+2`（最高批准分）。

### **阶段 4: 代码入库**

* **[17] `[Merge]` 合并到主分支**:
    * **技术原理**: 当一个 Gerrit Change 同时满足所有预设的标签条件（例如 `Verified +1` 和 `Code-Review +2`）后，其状态变为 “Ready to Submit”。拥有提交权限的用户点击 “Submit” 按钮，Gerrit 服务器会亲自执行 `git merge` (或 `git rebase`，取决于项目策略) 操作，将这次提交安全地合入到目标主干分支。整个过程由 Gerrit 服务端完成，保证了主干的稳定和一致性。

### **阶段 5: Daily/Weekly 发布**

此阶段的目标是持续地产出可供测试团队使用的、集成了所有最新功能的完整系统版本。

* **[18] `[Time Trigger]` 触发构建**:
    * **技术原理**: 这是 Jenkins 的核心功能之一，通过 Cron 表达式（如 `H 2 * * *` 代表每天凌晨2点）来配置定时任务。定时器会准时触发一个预设的 Release 构建流水线。

* **[19-22] Release 构建与归档**:
    * **执行完整构建**: 与 CI 验证不同，此任务会拉取主干分支在特定时间点的最新代码，执行一次完整的、干净的系统级构建。
    * **创建 Git 标签**: 构建成功后，Jenkins 会执行 `git tag` 命令，在代码仓库中为此次构建对应的 Commit 打上一个唯一的、不可变的标签（如 `v2.5.0-daily-20250927`），这对于版本追溯至关重要。
    * **上传构建产物**: Jenkins 使用 Artifactory 插件，将所有构建产物（系统镜像、SDK、map 文件、OTA 增量包等）连同元数据（如 Git Tag、构建耗时）一同上传到 JFrog Artifactory 的特定仓库（如 `daily-releases`）中进行版本化归档。

* **[23-26] 自动化集成测试**:
    * **技术原理**: 构建产物成功上传到 Artifactory 后，可以触发 Webhook 通知 Jenkins 执行下一步的集成测试任务。该任务包含自动化脚本（如 Ansible, Python），能够将 Artifactory 中的系统镜像自动部署（刷写）到 **HIL/SIL 测试平台**。部署完成后，会自动执行一套**构建验证测试 (BVT)** 脚本，检查系统的基本功能（如启动、联网、核心应用运行）是否正常，并生成测试报告。

### **阶段 6 & 7: OTA 发布与更新**

此阶段是将经过充分测试的稳定版本安全、可靠地推送到最终用户车辆上的过程。

* **[27-31] OTA 包制作与部署**:
    * **版本挑选与签名**: 版本经理从 Artifactory 中挑选一个质量合格的稳定版。一个专门的部署服务器（或 Jenkins Job）会下载该版本，并使用生产环境的**私钥**对其进行数字签名。这个签名是车辆验证 OTA 包合法性的唯一依据。
    * **上传至 OTA 服务器**: 签名后的 OTA 包连同其元数据（版本号、更新日志、文件大小、哈希值等）通过 API 上传到 **OTA 服务器**。

* **[32-43] OTA 推送与车辆更新**:
    * **[32] 升级活动 (Campaign) 创建**: 版本经理在 OTA 服务器的管理后台创建一个升级活动，定义升级策略，如目标车辆群体（可通过 VIN 码、地区、车型等筛选）、发布方式（灰度、分批）和时间。
    * **[33-35] 服务器协同与通知**: OTA 服务器与 **TSP 服务器**协同工作。TSP 负责车辆的连接和身份管理。OTA 服务器请求 TSP 查询符合条件的车辆列表，然后由 TSP 通过其与车辆保持的**长连接通道**（如 MQTT）向目标车辆推送一个轻量级的升级通知。
    * **[36-43] 车辆端更新流程**:
        1.  **检查与下载**: 车辆的车机（IVI）或网关（Gateway）收到通知后，会主动向 OTA 服务器发起 HTTPS 请求检查更新详情，并在满足预设条件（如电量充足、网络良好、非行驶状态）时下载 OTA 包。
        2.  **验证与升级**: 下载完成后，车辆会使用其内部存储的**公钥**对 OTA 包的数字签名进行验证。验证通过后，才会进入升级流程（如 A/B 分区切换）。
        3.  **结果上报**: 升级完成后，车辆会将结果（成功/失败/错误码）上报给 TSP 服务器，TSP 再将状态同步给 OTA 服务器，用于监控整个升级活动的成功率。

---

