<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QNN HTP (ONNX Runtime) 架构与调用流程详解 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 概述
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node "Qualcomm SoC (System on Chip)" {

    &#39; --- CPU Subsystem (Android) ---
    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. Android User Space (APK Process)" as LAYER_APP {
            component "Business Logic\n(Kotlin/Java/C++)" as AppCode
            note right of AppCode
               <b>关键配置:</b>
               setenv("ADSP_LIBRARY_PATH", 
               nativeLibraryDir, 1);
            end note

            package "Native Libraries (jniLibs / lib/arm64)" {
                component "libonnxruntime.so" as ORT
                component "libonnxruntime_providers_qnn.so" as QNN_EP
                
                package "QNN SDK CPU Libs" {
                    component "libQnnHtp.so\n(Backend Manager)" as QnnHtp
                    component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub
                }
                
                component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile
                note bottom of SkelFile
                   <b>Skel 文件</b>
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component "Assets (model.onnx)" as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle "2. Android System / Vendor Libs" as LAYER_SYS {
            component "libadsprpc.so (FastRPC Framework)" as FastRPC
        }

        rectangle "3. Linux Kernel Space" as LAYER_KERNEL {
            component "adsprpc.ko (FastRPC Driver)" as Driver
            component "ION / SMMU\n(Shared Memory)" as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN {
        component "QuRT OS (Real-time Kernel)" as QuRT

        package "Signed PD (Protection Domain)" {
            component "Skel Instance (Running Code)" as SkelRun
            component "HTP Hardware (Tensor Cores)" as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-> ORT : 1. Run()
ORT .left.> Model: Read & Parse
ORT -down-> QNN_EP : 2. Get EP
QNN_EP -down-> QnnHtp : 3. Create Backend
QnnHtp -down-> QnnStub : 4. Load specific Stub

QnnStub -down-> FastRPC : 5. remote_handle_open()
FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver <-> QuRT : 7. Context Switch / Wake up

QuRT .up.> Driver : 8. Request Skel
Driver .up.> FastRPC : 9. Callback
FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.> Mem : 11. Map to ION
Mem .down.> SkelRun : 12. Load into PD

QuRT -down-> SkelRun : 13. Execute Graph
SkelRun -down-> HTP_HW : 14. Compute
@enduml
2. 核心组件分层
2.1 Android User Space (应用层)
这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="QNN HTP (ONNX Runtime) 架构与调用流程详解"><meta property="og:description" content='1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node "Qualcomm SoC (System on Chip)" { &#39; --- CPU Subsystem (Android) --- rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN { rectangle "1. Android User Space (APK Process)" as LAYER_APP { component "Business Logic\n(Kotlin/Java/C++)" as AppCode note right of AppCode <b>关键配置:</b> setenv("ADSP_LIBRARY_PATH", nativeLibraryDir, 1); end note package "Native Libraries (jniLibs / lib/arm64)" { component "libonnxruntime.so" as ORT component "libonnxruntime_providers_qnn.so" as QNN_EP package "QNN SDK CPU Libs" { component "libQnnHtp.so\n(Backend Manager)" as QnnHtp component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub } component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile note bottom of SkelFile <b>Skel 文件</b> 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component "Assets (model.onnx)" as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle "2. Android System / Vendor Libs" as LAYER_SYS { component "libadsprpc.so (FastRPC Framework)" as FastRPC } rectangle "3. Linux Kernel Space" as LAYER_KERNEL { component "adsprpc.ko (FastRPC Driver)" as Driver component "ION / SMMU\n(Shared Memory)" as Mem } } &#39; --- DSP Subsystem --- rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN { component "QuRT OS (Real-time Kernel)" as QuRT package "Signed PD (Protection Domain)" { component "Skel Instance (Running Code)" as SkelRun component "HTP Hardware (Tensor Cores)" as HTP_HW } } } &#39; --- 详细调用关系 --- AppCode -down-> ORT : 1. Run() ORT .left.> Model: Read & Parse ORT -down-> QNN_EP : 2. Get EP QNN_EP -down-> QnnHtp : 3. Create Backend QnnHtp -down-> QnnStub : 4. Load specific Stub QnnStub -down-> FastRPC : 5. remote_handle_open() FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver <-> QuRT : 7. Context Switch / Wake up QuRT .up.> Driver : 8. Request Skel Driver .up.> FastRPC : 9. Callback FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.> Mem : 11. Map to ION Mem .down.> SkelRun : 12. Load into PD QuRT -down-> SkelRun : 13. Execute Graph SkelRun -down-> HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="explore-ai"><meta property="article:published_time" content="2025-08-27T17:17:50+08:00"><meta property="article:modified_time" content="2025-08-27T17:17:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QNN HTP (ONNX Runtime) 架构与调用流程详解"><meta name=twitter:description content='1. 概述
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node "Qualcomm SoC (System on Chip)" {

    &#39; --- CPU Subsystem (Android) ---
    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. Android User Space (APK Process)" as LAYER_APP {
            component "Business Logic\n(Kotlin/Java/C++)" as AppCode
            note right of AppCode
               <b>关键配置:</b>
               setenv("ADSP_LIBRARY_PATH", 
               nativeLibraryDir, 1);
            end note

            package "Native Libraries (jniLibs / lib/arm64)" {
                component "libonnxruntime.so" as ORT
                component "libonnxruntime_providers_qnn.so" as QNN_EP
                
                package "QNN SDK CPU Libs" {
                    component "libQnnHtp.so\n(Backend Manager)" as QnnHtp
                    component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub
                }
                
                component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile
                note bottom of SkelFile
                   <b>Skel 文件</b>
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component "Assets (model.onnx)" as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle "2. Android System / Vendor Libs" as LAYER_SYS {
            component "libadsprpc.so (FastRPC Framework)" as FastRPC
        }

        rectangle "3. Linux Kernel Space" as LAYER_KERNEL {
            component "adsprpc.ko (FastRPC Driver)" as Driver
            component "ION / SMMU\n(Shared Memory)" as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN {
        component "QuRT OS (Real-time Kernel)" as QuRT

        package "Signed PD (Protection Domain)" {
            component "Skel Instance (Running Code)" as SkelRun
            component "HTP Hardware (Tensor Cores)" as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-> ORT : 1. Run()
ORT .left.> Model: Read & Parse
ORT -down-> QNN_EP : 2. Get EP
QNN_EP -down-> QnnHtp : 3. Create Backend
QnnHtp -down-> QnnStub : 4. Load specific Stub

QnnStub -down-> FastRPC : 5. remote_handle_open()
FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver <-> QuRT : 7. Context Switch / Wake up

QuRT .up.> Driver : 8. Request Skel
Driver .up.> FastRPC : 9. Callback
FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.> Mem : 11. Map to ION
Mem .down.> SkelRun : 12. Load into PD

QuRT -down-> SkelRun : 13. Execute Graph
SkelRun -down-> HTP_HW : 14. Compute
@enduml
2. 核心组件分层
2.1 Android User Space (应用层)
这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Explore AI","item":"https://ethen-cao.github.io/ethenslab/explore-ai/"},{"@type":"ListItem","position":2,"name":"QNN HTP (ONNX Runtime) 架构与调用流程详解","item":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNN HTP (ONNX Runtime) 架构与调用流程详解","name":"QNN HTP (ONNX Runtime) 架构与调用流程详解","description":"1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。\n@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node \u0026#34;Qualcomm SoC (System on Chip)\u0026#34; { \u0026#39; --- CPU Subsystem (Android) --- rectangle \u0026#34;CPU Subsystem (Application Processor)\u0026#34; as CPU_DOMAIN { rectangle \u0026#34;1. Android User Space (APK Process)\u0026#34; as LAYER_APP { component \u0026#34;Business Logic\\n(Kotlin/Java/C++)\u0026#34; as AppCode note right of AppCode \u0026lt;b\u0026gt;关键配置:\u0026lt;/b\u0026gt; setenv(\u0026#34;ADSP_LIBRARY_PATH\u0026#34;, nativeLibraryDir, 1); end note package \u0026#34;Native Libraries (jniLibs / lib/arm64)\u0026#34; { component \u0026#34;libonnxruntime.so\u0026#34; as ORT component \u0026#34;libonnxruntime_providers_qnn.so\u0026#34; as QNN_EP package \u0026#34;QNN SDK CPU Libs\u0026#34; { component \u0026#34;libQnnHtp.so\\n(Backend Manager)\u0026#34; as QnnHtp component \u0026#34;libQnnHtpV[xx]Stub.so\\n(CPU Proxy)\u0026#34; as QnnStub } component \u0026#34;libQnnHtpV[xx]Skel.so\\n(DSP Executable)\u0026#34; as SkelFile note bottom of SkelFile \u0026lt;b\u0026gt;Skel 文件\u0026lt;/b\u0026gt; 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component \u0026#34;Assets (model.onnx)\u0026#34; as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle \u0026#34;2. Android System / Vendor Libs\u0026#34; as LAYER_SYS { component \u0026#34;libadsprpc.so (FastRPC Framework)\u0026#34; as FastRPC } rectangle \u0026#34;3. Linux Kernel Space\u0026#34; as LAYER_KERNEL { component \u0026#34;adsprpc.ko (FastRPC Driver)\u0026#34; as Driver component \u0026#34;ION / SMMU\\n(Shared Memory)\u0026#34; as Mem } } \u0026#39; --- DSP Subsystem --- rectangle \u0026#34;DSP Subsystem (Hexagon cDSP/HTP)\u0026#34; as DSP_DOMAIN { component \u0026#34;QuRT OS (Real-time Kernel)\u0026#34; as QuRT package \u0026#34;Signed PD (Protection Domain)\u0026#34; { component \u0026#34;Skel Instance (Running Code)\u0026#34; as SkelRun component \u0026#34;HTP Hardware (Tensor Cores)\u0026#34; as HTP_HW } } } \u0026#39; --- 详细调用关系 --- AppCode -down-\u0026gt; ORT : 1. Run() ORT .left.\u0026gt; Model: Read \u0026amp; Parse ORT -down-\u0026gt; QNN_EP : 2. Get EP QNN_EP -down-\u0026gt; QnnHtp : 3. Create Backend QnnHtp -down-\u0026gt; QnnStub : 4. Load specific Stub QnnStub -down-\u0026gt; FastRPC : 5. remote_handle_open() FastRPC -down-\u0026gt; Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver \u0026lt;-\u0026gt; QuRT : 7. Context Switch / Wake up QuRT .up.\u0026gt; Driver : 8. Request Skel Driver .up.\u0026gt; FastRPC : 9. Callback FastRPC .left.\u0026gt; SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.\u0026gt; Mem : 11. Map to ION Mem .down.\u0026gt; SkelRun : 12. Load into PD QuRT -down-\u0026gt; SkelRun : 13. Execute Graph SkelRun -down-\u0026gt; HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。\n","keywords":[],"articleBody":"1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。\n@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node \"Qualcomm SoC (System on Chip)\" { ' --- CPU Subsystem (Android) --- rectangle \"CPU Subsystem (Application Processor)\" as CPU_DOMAIN { rectangle \"1. Android User Space (APK Process)\" as LAYER_APP { component \"Business Logic\\n(Kotlin/Java/C++)\" as AppCode note right of AppCode 关键配置: setenv(\"ADSP_LIBRARY_PATH\", nativeLibraryDir, 1); end note package \"Native Libraries (jniLibs / lib/arm64)\" { component \"libonnxruntime.so\" as ORT component \"libonnxruntime_providers_qnn.so\" as QNN_EP package \"QNN SDK CPU Libs\" { component \"libQnnHtp.so\\n(Backend Manager)\" as QnnHtp component \"libQnnHtpV[xx]Stub.so\\n(CPU Proxy)\" as QnnStub } component \"libQnnHtpV[xx]Skel.so\\n(DSP Executable)\" as SkelFile note bottom of SkelFile Skel 文件 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component \"Assets (model.onnx)\" as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle \"2. Android System / Vendor Libs\" as LAYER_SYS { component \"libadsprpc.so (FastRPC Framework)\" as FastRPC } rectangle \"3. Linux Kernel Space\" as LAYER_KERNEL { component \"adsprpc.ko (FastRPC Driver)\" as Driver component \"ION / SMMU\\n(Shared Memory)\" as Mem } } ' --- DSP Subsystem --- rectangle \"DSP Subsystem (Hexagon cDSP/HTP)\" as DSP_DOMAIN { component \"QuRT OS (Real-time Kernel)\" as QuRT package \"Signed PD (Protection Domain)\" { component \"Skel Instance (Running Code)\" as SkelRun component \"HTP Hardware (Tensor Cores)\" as HTP_HW } } } ' --- 详细调用关系 --- AppCode -down-\u003e ORT : 1. Run() ORT .left.\u003e Model: Read \u0026 Parse ORT -down-\u003e QNN_EP : 2. Get EP QNN_EP -down-\u003e QnnHtp : 3. Create Backend QnnHtp -down-\u003e QnnStub : 4. Load specific Stub QnnStub -down-\u003e FastRPC : 5. remote_handle_open() FastRPC -down-\u003e Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver \u003c-\u003e QuRT : 7. Context Switch / Wake up QuRT .up.\u003e Driver : 8. Request Skel Driver .up.\u003e FastRPC : 9. Callback FastRPC .left.\u003e SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.\u003e Mem : 11. Map to ION Mem .down.\u003e SkelRun : 12. Load into PD QuRT -down-\u003e SkelRun : 13. Execute Graph SkelRun -down-\u003e HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。\nBusiness Logic: 你的业务代码（Kotlin/Java/C++）。\n关键配置: 必须在初始化时设置环境变量 setenv(\"ADSP_LIBRARY_PATH\", nativeLibraryDir, 1)，否则 FastRPC 将无法找到 Skel 文件。\nONNX Runtime (ORT): 微软提供的统一推理引擎 (libonnxruntime.so)。\nQNN Execution Provider (EP): ORT 与 QNN 之间的适配层 (libonnxruntime_providers_qnn.so)。\nQNN CPU Libraries:\nlibQnnHtp.so: Backend Manager，负责管理 HTP 后端的生命周期。\nlibQnnHtpV[xx]Stub.so: CPU Proxy (桩)，负责在 CPU 端打包数据和指令，并通过 RPC 发送给 DSP。\nSkel File (关键):\nlibQnnHtpV[xx]Skel.so: DSP Executable (骨架)。这是真正运行在 NPU 上的“服务端”代码。\n注意: 尽管它物理上存储在 APK 的 lib/arm64 目录下（CPU 文件系统），但它不在 CPU 上执行，而是被传输到 DSP 内存中运行。\n2.2 Android System \u0026 Kernel (系统与内核层) 负责 CPU 与 DSP 之间的通信桥梁。\nlibadsprpc.so (FastRPC Framework): Android 系统提供的用户空间库，用于发起 RPC 调用。 adsprpc.ko (FastRPC Driver): Linux 内核驱动，负责处理内存映射、中断和跨核通信。 ION / SMMU: 共享内存管理器。允许 CPU 和 DSP 访问同一块物理内存（零拷贝），显著提高大数据传输效率。 2.3 DSP Subsystem (硬件层) 高通 Hexagon 处理器的运行环境。\nQuRT OS: 高通的实时微内核 (Real-time Kernel)，管理 DSP 资源。 Signed PD (Protection Domain): 受保护的进程域。为了安全，未签名的代码无法在此运行。 Skel Instance: 加载进内存并正在运行的 Skel.so 实例。 HTP Hardware: 实际执行张量计算的硬件核心。 3. 详细调用流程 (Step-by-Step) 流程分为五个主要阶段，对应图中的编号 1-14。\n第一阶段：应用发起 (App Invocation) Run(): 业务代码调用 ONNX Runtime 的推理接口。 Get EP: ORT 识别到配置了 QNN，将任务分发给 QNN EP。 Create Backend: EP 调用 libQnnHtp.so 初始化 HTP 后端。 Load Stub: 后端管理器根据当前芯片型号，加载对应的桩文件（如 libQnnHtpV81Stub.so）。 第二阶段：RPC 桥接 (RPC Bridging) remote_handle_open(): Stub 库调用系统的 libadsprpc.so，请求连接 DSP。 ioctl (INVOKE): 用户空间库通过 ioctl 系统调用进入内核驱动 adsprpc.ko。 第三阶段：DSP 唤醒 (Wake up) Context Switch: 内核驱动发送硬件中断，唤醒沉睡中的 DSP 子系统 (QuRT OS)。 第四阶段：Skel 加载回环 (The Side-load Loop) —— 最关键步骤 这是最容易出错的环节。DSP 自身没有文件系统，它需要“反向”请求 CPU 提供代码文件。 8. Request Skel: QuRT 发现需要运行 V81 版本的代码，向内核驱动请求 libQnnHtpV81Skel.so。 9. Callback: 驱动无法直接读文件，于是回调 (Callback) 到用户空间的 libadsprpc.so。 10. Read file (Red Arrow): libadsprpc.so 根据之前设置的 ADSP_LIBRARY_PATH 环境变量，在 APK 的安装目录下找到并读取 Skel 文件。 11. Map to ION: 将读取的文件内容写入 ION 共享内存。 12. Load into PD: DSP 从共享内存中读取代码，通过签名验证后，加载到保护域 (PD) 中成为可执行实例。\n第五阶段：硬件执行 (Execution) Execute Graph: QuRT 调度 Skel Instance 开始工作。 Compute: Skel 驱动底层的 HTP 硬件进行矩阵运算，并将结果原路返回。 模型加载运行过程 @startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 13 skinparam defaultFontColor black skinparam arrowColor #333333 skinparam nodesep 50 skinparam ranksep 40 skinparam linetype ortho ' --- 样式定义 --- skinparam rectangle { BackgroundColor #F5F5F5 BorderColor #9E9E9E RoundCorner 6 } skinparam component { BackgroundColor #E3F2FD BorderColor #1E88E5 } skinparam file { BackgroundColor #FFF9C4 BorderColor #FBC02D } title QNN HTP Architecture: Full Lifecycle (Fixed Directions) ' --- 图例 (Legend) --- legend right | 颜色 | 阶段 / 含义 | | \u003c#FF0000\u003e | Phase 1: 初始化与建图 (只运行一次) | | \u003c#0000FF\u003e | Side-load 回环 (驱动加载 Skel 文件) | | \u003c#008000\u003e | Phase 2: 推理执行 (每帧运行, 高频) | endlegend node \"Qualcomm SoC\" { rectangle \"CPU Subsystem (Application Processor)\" as CPU_DOMAIN { rectangle \"1. App Process Space\" as LAYER_APP { component \"App Code\" as AppCode file \"Assets/model.onnx\" as Model rectangle \"Native Libraries\" { component \"ONNX Runtime\" as ORT component \"QNN EP\" as QNN_EP package \"QNN SDK\" { component \"Backend Manager\\n(libQnnHtp.so)\" as QnnHtp component \"Stub(CPU Proxy)\\t\\t\" as QnnStub } file \"libQnnHtpVxxSkel.so\\n(Disk Artifact)\" as SkelFile } } rectangle \"2. System / Kernel\" as LAYER_SYS { component \"FastRPC Lib\" as FastRPC component \"FastRPC Driver\" as Driver database \"Shared Memory\\n(ION / DMA-BUF)\" as Mem } } rectangle \"DSP Subsystem\" as DSP_DOMAIN { component \"QuRT OS\" as QuRT package \"Signed PD\" { component \"Skel Instance\\n(Running Code)\" as SkelRun component \"HTP Hardware\\n(NPU)\" as HTP_HW } } } ' ======================= ' 逻辑连线 (已修复方向问题) ' ======================= ' --- Phase 1: Initialization (红色箭头) --- AppCode -[#FF0000]down-\u003e ORT : 1. CreateSession ORT .[#FF0000]right.\u003e Model : 2. Parse ORT -[#FF0000]down-\u003e QNN_EP : 3. Delegate QNN_EP -[#FF0000]down-\u003e QnnHtp : 4. Init QnnHtp -[#FF0000]down-\u003e QnnStub : 5. Load Stub ' RPC 建立 QnnStub -[#FF0000]down-\u003e FastRPC : 6. Open Session FastRPC -[#FF0000]down-\u003e Driver : 7. ioctl ' DSP 唤醒 Driver -[#FF0000]down-\u003e QuRT : 8. WakeUp \u0026 Create PD ' --- Side-load Loop (蓝色箭头 - 加载回环) --- QuRT .[#0000FF]up.\u003e Driver : 9. Request Load Driver .[#0000FF]up.\u003e FastRPC : 10. Upcall FastRPC .[#0000FF]left.\u003e SkelFile : 11. READ FILE FastRPC .[#0000FF]down.\u003e Mem : 12. Map to Shared Mem Mem .[#0000FF]down.\u003e SkelRun : 13. Load into DSP Mem ' --- Phase 2: Execution (绿色箭头 - 已修复方向) --- AppCode -[#008000]right-\u003e ORT : Run(Input) ' 修复点：添加了 down 方向 ORT -[#008000]down-\u003e QNN_EP QNN_EP -[#008000]down-\u003e QnnStub ' 写入共享内存 (使用 dotted 线表示数据流，solid 线表示控制流) QnnStub .[#008000]right.\u003e Mem : 14. Write Input Tensor\\n数据不走 RPC 拷贝而是走共享内存 ' RPC 执行链 QnnStub -[#008000]down-\u003e FastRPC : 15. Invoke Execute FastRPC -[#008000]down-\u003e Driver Driver -[#008000]down-\u003e SkelRun : 16. Signal SkelRun -[#008000]down-\u003e HTP_HW : 17. Compute @enduml 这是一段针对该 QNN HTP 架构流程图的详细专业解说。这段解说将图表分为三个逻辑阶段，清晰阐述了模型从加载到硬件执行的完整生命周期。\nQNN HTP 架构全生命周期解说 这张架构图展示了使用 ONNX Runtime (ORT) 配合 QNN SDK 在高通 Hexagon NPU (HTP) 上运行 AI 模型的完整技术链路。流程被清晰地划分为三个阶段：初始化（红色）、Side-load 回环（蓝色）以及推理执行（绿色）。\n第一阶段：初始化与建图 (Phase 1: Initialization) 图例颜色：红色 ──\u003e 这是“准备工作”，通常在应用启动时执行一次，耗时较长。\n应用发起：业务代码 (App Code) 调用 ORT 的 CreateSession 接口。 模型解析 (CPU)：关键点！ ORT 在 CPU 侧直接读取并解析 Assets/model.onnx 文件。模型文件本身不会被发送到 DSP，ORT 负责理解网络结构并进行图分割。 任务委托：ORT 识别到支持 NPU 加速的节点，将其委托给 QNN EP，随后层层传递至 Backend Manager 和 Stub。 握手与唤醒：Stub (CPU 代理) 通过 FastRPC 向底层驱动发起 open 请求，驱动负责唤醒沉睡的 DSP 子系统，并在其上创建一个受保护的进程域 (Signed PD)。 第二阶段：Skel 加载回环 (The Side-load Loop) 图例颜色：蓝色 ..\u003e 这是 QNN 架构的核心机制，发生在初始化阶段的内部，解决了 DSP 如何获取执行代码的问题。\n反向请求 (Upcall)：DSP 被唤醒后，其内部的系统（QuRT/Loader）发现需要加载 HTP 硬件驱动逻辑，于是向 CPU 发起一个“请求加载文件”的反向 RPC 调用。 文件读取：CPU 端的 FastRPC Lib 收到请求，根据环境变量（ADSP_LIBRARY_PATH）在磁盘的 Native 库路径下找到 libQnnHtpVxxSkel.so (Skel 文件)。 共享内存传输：FastRPC 不通过慢速的 RPC 协议拷贝文件内容，而是将文件直接映射到 共享内存 (ION/DMA-BUF) 中。 DSP 加载：DSP 直接从共享内存读取 Skel 镜像并完成加载。至此，Skel Instance (服务端) 就位，准备好控制 HTP 硬件。 第三阶段：推理执行 (Phase 2: Execution) 图例颜色：绿色 ──\u003e 这是高频运行的阶段（如相机预览流每秒 30 帧），追求极致性能。\n零拷贝输入：当应用调用 Run() 时，输入数据（如图片张量）被直接写入 共享内存 (Mem)。注意图中虚线所示，大数据不走 RPC 协议拷贝，这是高性能的关键。 轻量级指令：QnnStub 仅通过 RPC 发送一条轻量级的 Execute 指令，告知 DSP 数据在共享内存的哪个位置。 硬件计算：DSP 端的 SkelRun 收到指令，指挥 HTP Hardware (Tensor Cores) 全速运转。 结果返回：计算完成后，结果同样通过共享内存返回给 CPU，完成一次推理。 核心总结 物理隔离：模型文件 (model.onnx) 由 CPU 解析，Skel 库 (.so) 由 DSP 加载，两者物理存储位置和加载时机完全不同。 反向加载：DSP 是“大脑”，但它需要 CPU 这个“管家”帮忙从磁盘拿代码（Skel），这就是 Side-load 机制。 性能优化：控制流走 FastRPC，数据流走共享内存，实现了控制与数据分离，最大化了吞吐量。 4. 开发与调试重点 Skel 文件必须打包: 务必确保 libQnnHtpV[xx]Skel.so 被正确打包进 APK 的 jniLibs 或 assets 中。如果 DSP 请求文件时（步骤 8-10）在路径中找不到文件，初始化将直接失败。 环境变量设置: 图中 Note 提到的 setenv(\"ADSP_LIBRARY_PATH\", ...) 是必不可少的。因为系统的 FastRPC 库默认不知道你的 App 安装在哪个随机生成的路径下，必须显式告知。 版本匹配: Stub（CPU侧）和 Skel（DSP侧）必须属于同一个 QNN SDK 版本，否则在握手阶段会因协议不一致而崩溃。 ","wordCount":"1259","inLanguage":"en","datePublished":"2025-08-27T17:17:50+08:00","dateModified":"2025-08-27T17:17:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/explore-ai/>Explore AI</a></div><h1 class="post-title entry-hint-parent">QNN HTP (ONNX Runtime) 架构与调用流程详解</h1><div class=post-meta><span title='2025-08-27 17:17:50 +0800 CST'>August 27, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1259 words</div></header><div class=post-content><h2 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><p>本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 <strong>FastRPC</strong> 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node &#34;Qualcomm SoC (System on Chip)&#34; {

    &#39; --- CPU Subsystem (Android) ---
    rectangle &#34;CPU Subsystem (Application Processor)&#34; as CPU_DOMAIN {

        rectangle &#34;1. Android User Space (APK Process)&#34; as LAYER_APP {
            component &#34;Business Logic\n(Kotlin/Java/C++)&#34; as AppCode
            note right of AppCode
               &lt;b&gt;关键配置:&lt;/b&gt;
               setenv(&#34;ADSP_LIBRARY_PATH&#34;, 
               nativeLibraryDir, 1);
            end note

            package &#34;Native Libraries (jniLibs / lib/arm64)&#34; {
                component &#34;libonnxruntime.so&#34; as ORT
                component &#34;libonnxruntime_providers_qnn.so&#34; as QNN_EP
                
                package &#34;QNN SDK CPU Libs&#34; {
                    component &#34;libQnnHtp.so\n(Backend Manager)&#34; as QnnHtp
                    component &#34;libQnnHtpV[xx]Stub.so\n(CPU Proxy)&#34; as QnnStub
                }
                
                component &#34;libQnnHtpV[xx]Skel.so\n(DSP Executable)&#34; as SkelFile
                note bottom of SkelFile
                   &lt;b&gt;Skel 文件&lt;/b&gt;
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component &#34;Assets (model.onnx)&#34; as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle &#34;2. Android System / Vendor Libs&#34; as LAYER_SYS {
            component &#34;libadsprpc.so (FastRPC Framework)&#34; as FastRPC
        }

        rectangle &#34;3. Linux Kernel Space&#34; as LAYER_KERNEL {
            component &#34;adsprpc.ko (FastRPC Driver)&#34; as Driver
            component &#34;ION / SMMU\n(Shared Memory)&#34; as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle &#34;DSP Subsystem (Hexagon cDSP/HTP)&#34; as DSP_DOMAIN {
        component &#34;QuRT OS (Real-time Kernel)&#34; as QuRT

        package &#34;Signed PD (Protection Domain)&#34; {
            component &#34;Skel Instance (Running Code)&#34; as SkelRun
            component &#34;HTP Hardware (Tensor Cores)&#34; as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-&gt; ORT : 1. Run()
ORT .left.&gt; Model: Read &amp; Parse
ORT -down-&gt; QNN_EP : 2. Get EP
QNN_EP -down-&gt; QnnHtp : 3. Create Backend
QnnHtp -down-&gt; QnnStub : 4. Load specific Stub

QnnStub -down-&gt; FastRPC : 5. remote_handle_open()
FastRPC -down-&gt; Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver &lt;-&gt; QuRT : 7. Context Switch / Wake up

QuRT .up.&gt; Driver : 8. Request Skel
Driver .up.&gt; FastRPC : 9. Callback
FastRPC .left.&gt; SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.&gt; Mem : 11. Map to ION
Mem .down.&gt; SkelRun : 12. Load into PD

QuRT -down-&gt; SkelRun : 13. Execute Graph
SkelRun -down-&gt; HTP_HW : 14. Compute
@enduml
</code></pre><h2 id=2-核心组件分层>2. 核心组件分层<a hidden class=anchor aria-hidden=true href=#2-核心组件分层>#</a></h2><h3 id=21-android-user-space-应用层>2.1 Android User Space (应用层)<a hidden class=anchor aria-hidden=true href=#21-android-user-space-应用层>#</a></h3><p>这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。</p><ul><li><p><strong>Business Logic</strong>: 你的业务代码（Kotlin/Java/C++）。</p></li><li><p><strong>关键配置</strong>: 必须在初始化时设置环境变量 <code>setenv("ADSP_LIBRARY_PATH", nativeLibraryDir, 1)</code>，否则 FastRPC 将无法找到 Skel 文件。</p></li><li><p><strong>ONNX Runtime (ORT)</strong>: 微软提供的统一推理引擎 (<code>libonnxruntime.so</code>)。</p></li><li><p><strong>QNN Execution Provider (EP)</strong>: ORT 与 QNN 之间的适配层 (<code>libonnxruntime_providers_qnn.so</code>)。</p></li><li><p><strong>QNN CPU Libraries</strong>:</p></li><li><p><code>libQnnHtp.so</code>: <strong>Backend Manager</strong>，负责管理 HTP 后端的生命周期。</p></li><li><p><code>libQnnHtpV[xx]Stub.so</code>: <strong>CPU Proxy (桩)</strong>，负责在 CPU 端打包数据和指令，并通过 RPC 发送给 DSP。</p></li><li><p><strong>Skel File (关键)</strong>:</p></li><li><p><code>libQnnHtpV[xx]Skel.so</code>: <strong>DSP Executable (骨架)</strong>。这是真正运行在 NPU 上的“服务端”代码。</p></li><li><p><strong>注意</strong>: 尽管它物理上存储在 APK 的 <code>lib/arm64</code> 目录下（CPU 文件系统），但它<strong>不</strong>在 CPU 上执行，而是被传输到 DSP 内存中运行。</p></li></ul><h3 id=22-android-system--kernel-系统与内核层>2.2 Android System & Kernel (系统与内核层)<a hidden class=anchor aria-hidden=true href=#22-android-system--kernel-系统与内核层>#</a></h3><p>负责 CPU 与 DSP 之间的通信桥梁。</p><ul><li><strong>libadsprpc.so (FastRPC Framework)</strong>: Android 系统提供的用户空间库，用于发起 RPC 调用。</li><li><strong>adsprpc.ko (FastRPC Driver)</strong>: Linux 内核驱动，负责处理内存映射、中断和跨核通信。</li><li><strong>ION / SMMU</strong>: 共享内存管理器。允许 CPU 和 DSP 访问同一块物理内存（零拷贝），显著提高大数据传输效率。</li></ul><h3 id=23-dsp-subsystem-硬件层>2.3 DSP Subsystem (硬件层)<a hidden class=anchor aria-hidden=true href=#23-dsp-subsystem-硬件层>#</a></h3><p>高通 Hexagon 处理器的运行环境。</p><ul><li><strong>QuRT OS</strong>: 高通的实时微内核 (Real-time Kernel)，管理 DSP 资源。</li><li><strong>Signed PD (Protection Domain)</strong>: 受保护的进程域。为了安全，未签名的代码无法在此运行。</li><li><strong>Skel Instance</strong>: 加载进内存并正在运行的 <code>Skel.so</code> 实例。</li><li><strong>HTP Hardware</strong>: 实际执行张量计算的硬件核心。</li></ul><hr><h2 id=3-详细调用流程-step-by-step>3. 详细调用流程 (Step-by-Step)<a hidden class=anchor aria-hidden=true href=#3-详细调用流程-step-by-step>#</a></h2><p>流程分为五个主要阶段，对应图中的编号 <strong>1-14</strong>。</p><h3 id=第一阶段应用发起-app-invocation>第一阶段：应用发起 (App Invocation)<a hidden class=anchor aria-hidden=true href=#第一阶段应用发起-app-invocation>#</a></h3><ol><li><strong>Run()</strong>: 业务代码调用 ONNX Runtime 的推理接口。</li><li><strong>Get EP</strong>: ORT 识别到配置了 QNN，将任务分发给 QNN EP。</li><li><strong>Create Backend</strong>: EP 调用 <code>libQnnHtp.so</code> 初始化 HTP 后端。</li><li><strong>Load Stub</strong>: 后端管理器根据当前芯片型号，加载对应的桩文件（如 <code>libQnnHtpV81Stub.so</code>）。</li></ol><h3 id=第二阶段rpc-桥接-rpc-bridging>第二阶段：RPC 桥接 (RPC Bridging)<a hidden class=anchor aria-hidden=true href=#第二阶段rpc-桥接-rpc-bridging>#</a></h3><ol start=5><li><strong>remote_handle_open()</strong>: Stub 库调用系统的 <code>libadsprpc.so</code>，请求连接 DSP。</li><li><strong>ioctl (INVOKE)</strong>: 用户空间库通过 <code>ioctl</code> 系统调用进入内核驱动 <code>adsprpc.ko</code>。</li></ol><h3 id=第三阶段dsp-唤醒-wake-up>第三阶段：DSP 唤醒 (Wake up)<a hidden class=anchor aria-hidden=true href=#第三阶段dsp-唤醒-wake-up>#</a></h3><ol start=7><li><strong>Context Switch</strong>: 内核驱动发送硬件中断，唤醒沉睡中的 DSP 子系统 (QuRT OS)。</li></ol><h3 id=第四阶段skel-加载回环-the-side-load-loop--最关键步骤>第四阶段：Skel 加载回环 (The Side-load Loop) —— <strong>最关键步骤</strong><a hidden class=anchor aria-hidden=true href=#第四阶段skel-加载回环-the-side-load-loop--最关键步骤>#</a></h3><p>这是最容易出错的环节。DSP 自身没有文件系统，它需要“反向”请求 CPU 提供代码文件。
8. <strong>Request Skel</strong>: QuRT 发现需要运行 V81 版本的代码，向内核驱动请求 <code>libQnnHtpV81Skel.so</code>。
9. <strong>Callback</strong>: 驱动无法直接读文件，于是<strong>回调</strong> (Callback) 到用户空间的 <code>libadsprpc.so</code>。
10. <strong>Read file (Red Arrow)</strong>: <code>libadsprpc.so</code> 根据之前设置的 <code>ADSP_LIBRARY_PATH</code> 环境变量，在 APK 的安装目录下找到并读取 Skel 文件。
11. <strong>Map to ION</strong>: 将读取的文件内容写入 ION 共享内存。
12. <strong>Load into PD</strong>: DSP 从共享内存中读取代码，通过签名验证后，加载到保护域 (PD) 中成为可执行实例。</p><h3 id=第五阶段硬件执行-execution>第五阶段：硬件执行 (Execution)<a hidden class=anchor aria-hidden=true href=#第五阶段硬件执行-execution>#</a></h3><ol start=13><li><strong>Execute Graph</strong>: QuRT 调度 <code>Skel Instance</code> 开始工作。</li><li><strong>Compute</strong>: Skel 驱动底层的 HTP 硬件进行矩阵运算，并将结果原路返回。</li></ol><hr><h2 id=模型加载运行过程>模型加载运行过程<a hidden class=anchor aria-hidden=true href=#模型加载运行过程>#</a></h2><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 13
skinparam defaultFontColor black
skinparam arrowColor #333333
skinparam nodesep 50
skinparam ranksep 40
skinparam linetype ortho

&#39; --- 样式定义 ---
skinparam rectangle {
    BackgroundColor #F5F5F5
    BorderColor #9E9E9E
    RoundCorner 6
}
skinparam component {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
}
skinparam file {
    BackgroundColor #FFF9C4
    BorderColor #FBC02D
}

title QNN HTP Architecture: Full Lifecycle (Fixed Directions)

&#39; --- 图例 (Legend) ---
legend right
    | 颜色 | 阶段 / 含义 |
    | &lt;#FF0000&gt; | &lt;b&gt;Phase 1: 初始化与建图&lt;/b&gt; (只运行一次) |
    | &lt;#0000FF&gt; | &lt;b&gt;Side-load 回环&lt;/b&gt; (驱动加载 Skel 文件) |
    | &lt;#008000&gt; | &lt;b&gt;Phase 2: 推理执行&lt;/b&gt; (每帧运行, 高频) |
endlegend

node &#34;Qualcomm SoC&#34; {

    rectangle &#34;CPU Subsystem (Application Processor)&#34; as CPU_DOMAIN {

        rectangle &#34;1. App Process Space&#34; as LAYER_APP {
            component &#34;App Code&#34; as AppCode
            file &#34;Assets/model.onnx&#34; as Model

            rectangle &#34;Native Libraries&#34; {
                component &#34;ONNX Runtime&#34; as ORT
                component &#34;QNN EP&#34; as QNN_EP
                
                package &#34;QNN SDK&#34; {
                    component &#34;Backend Manager\n(libQnnHtp.so)&#34; as QnnHtp
                    component &#34;Stub(CPU Proxy)\t\t&#34; as QnnStub
                }
                
                file &#34;libQnnHtpVxxSkel.so\n(Disk Artifact)&#34; as SkelFile
            }
        }

        rectangle &#34;2. System / Kernel&#34; as LAYER_SYS {
            component &#34;FastRPC Lib&#34; as FastRPC
            component &#34;FastRPC Driver&#34; as Driver
            database &#34;Shared Memory\n(ION / DMA-BUF)&#34; as Mem
        }
    }

    rectangle &#34;DSP Subsystem&#34; as DSP_DOMAIN {
        component &#34;QuRT OS&#34; as QuRT

        package &#34;Signed PD&#34; {
            component &#34;Skel Instance\n(Running Code)&#34; as SkelRun
            component &#34;HTP Hardware\n(NPU)&#34; as HTP_HW
        }
    }
}

&#39; =======================
&#39; 逻辑连线 (已修复方向问题)
&#39; =======================

&#39; --- Phase 1: Initialization (红色箭头) ---
AppCode -[#FF0000]down-&gt; ORT : 1. CreateSession
ORT .[#FF0000]right.&gt; Model : 2. Parse
ORT -[#FF0000]down-&gt; QNN_EP : 3. Delegate
QNN_EP -[#FF0000]down-&gt; QnnHtp : 4. Init
QnnHtp -[#FF0000]down-&gt; QnnStub : 5. Load Stub

&#39; RPC 建立
QnnStub -[#FF0000]down-&gt; FastRPC : 6. Open Session
FastRPC -[#FF0000]down-&gt; Driver : 7. ioctl

&#39; DSP 唤醒
Driver -[#FF0000]down-&gt; QuRT : 8. WakeUp &amp; Create PD

&#39; --- Side-load Loop (蓝色箭头 - 加载回环) ---
QuRT .[#0000FF]up.&gt; Driver : 9. Request Load
Driver .[#0000FF]up.&gt; FastRPC : 10. Upcall
FastRPC .[#0000FF]left.&gt; SkelFile : 11. READ FILE
FastRPC .[#0000FF]down.&gt; Mem : 12. Map to Shared Mem
Mem .[#0000FF]down.&gt; SkelRun : 13. Load into DSP Mem

&#39; --- Phase 2: Execution (绿色箭头 - 已修复方向) ---
AppCode -[#008000]right-&gt; ORT : Run(Input)

&#39; 修复点：添加了 down 方向
ORT -[#008000]down-&gt; QNN_EP
QNN_EP -[#008000]down-&gt; QnnStub

&#39; 写入共享内存 (使用 dotted 线表示数据流，solid 线表示控制流)
QnnStub .[#008000]right.&gt; Mem : 14. Write Input Tensor\n数据不走 RPC 拷贝而是走共享内存

&#39; RPC 执行链
QnnStub -[#008000]down-&gt; FastRPC : 15. Invoke Execute
FastRPC -[#008000]down-&gt; Driver
Driver -[#008000]down-&gt; SkelRun : 16. Signal
SkelRun -[#008000]down-&gt; HTP_HW : 17. Compute

@enduml
</code></pre><p>这是一段针对该 QNN HTP 架构流程图的详细专业解说。这段解说将图表分为三个逻辑阶段，清晰阐述了模型从加载到硬件执行的完整生命周期。</p><hr><h3 id=qnn-htp-架构全生命周期解说><strong>QNN HTP 架构全生命周期解说</strong><a hidden class=anchor aria-hidden=true href=#qnn-htp-架构全生命周期解说>#</a></h3><p>这张架构图展示了使用 ONNX Runtime (ORT) 配合 QNN SDK 在高通 Hexagon NPU (HTP) 上运行 AI 模型的完整技术链路。流程被清晰地划分为三个阶段：<strong>初始化（红色）</strong>、<strong>Side-load 回环（蓝色）以及推理执行（绿色）</strong>。</p><h4 id=第一阶段初始化与建图-phase-1-initialization><strong>第一阶段：初始化与建图 (Phase 1: Initialization)</strong><a hidden class=anchor aria-hidden=true href=#第一阶段初始化与建图-phase-1-initialization>#</a></h4><blockquote><p><strong>图例颜色：红色 <font color=red>──></font></strong>
<em>这是“准备工作”，通常在应用启动时执行一次，耗时较长。</em></p></blockquote><ol><li><strong>应用发起</strong>：业务代码 (<code>App Code</code>) 调用 ORT 的 <code>CreateSession</code> 接口。</li><li><strong>模型解析 (CPU)</strong>：<strong>关键点！</strong> ORT 在 CPU 侧直接读取并解析 <code>Assets/model.onnx</code> 文件。模型文件本身<strong>不会</strong>被发送到 DSP，ORT 负责理解网络结构并进行图分割。</li><li><strong>任务委托</strong>：ORT 识别到支持 NPU 加速的节点，将其委托给 <code>QNN EP</code>，随后层层传递至 <code>Backend Manager</code> 和 <code>Stub</code>。</li><li><strong>握手与唤醒</strong>：<code>Stub</code> (CPU 代理) 通过 <code>FastRPC</code> 向底层驱动发起 <code>open</code> 请求，驱动负责唤醒沉睡的 DSP 子系统，并在其上创建一个受保护的进程域 (Signed PD)。</li></ol><h4 id=第二阶段skel-加载回环-the-side-load-loop><strong>第二阶段：Skel 加载回环 (The Side-load Loop)</strong><a hidden class=anchor aria-hidden=true href=#第二阶段skel-加载回环-the-side-load-loop>#</a></h4><blockquote><p><strong>图例颜色：蓝色 <font color=blue>..></font></strong>
<em>这是 QNN 架构的核心机制，发生在初始化阶段的内部，解决了 DSP 如何获取执行代码的问题。</em></p></blockquote><ol><li><strong>反向请求 (Upcall)</strong>：DSP 被唤醒后，其内部的系统（QuRT/Loader）发现需要加载 HTP 硬件驱动逻辑，于是向 CPU 发起一个“请求加载文件”的反向 RPC 调用。</li><li><strong>文件读取</strong>：CPU 端的 <code>FastRPC Lib</code> 收到请求，根据环境变量（<code>ADSP_LIBRARY_PATH</code>）在磁盘的 Native 库路径下找到 <code>libQnnHtpVxxSkel.so</code> (Skel 文件)。</li><li><strong>共享内存传输</strong>：FastRPC <strong>不</strong>通过慢速的 RPC 协议拷贝文件内容，而是将文件直接映射到 <strong>共享内存 (ION/DMA-BUF)</strong> 中。</li><li><strong>DSP 加载</strong>：DSP 直接从共享内存读取 Skel 镜像并完成加载。至此，<code>Skel Instance</code> (服务端) 就位，准备好控制 HTP 硬件。</li></ol><h4 id=第三阶段推理执行-phase-2-execution><strong>第三阶段：推理执行 (Phase 2: Execution)</strong><a hidden class=anchor aria-hidden=true href=#第三阶段推理执行-phase-2-execution>#</a></h4><blockquote><p><strong>图例颜色：绿色 <font color=green>──></font></strong>
<em>这是高频运行的阶段（如相机预览流每秒 30 帧），追求极致性能。</em></p></blockquote><ol><li><strong>零拷贝输入</strong>：当应用调用 <code>Run()</code> 时，输入数据（如图片张量）被直接写入 <strong>共享内存 (Mem)</strong>。注意图中虚线所示，<strong>大数据不走 RPC 协议拷贝</strong>，这是高性能的关键。</li><li><strong>轻量级指令</strong>：<code>QnnStub</code> 仅通过 RPC 发送一条轻量级的 <code>Execute</code> 指令，告知 DSP 数据在共享内存的哪个位置。</li><li><strong>硬件计算</strong>：DSP 端的 <code>SkelRun</code> 收到指令，指挥 <code>HTP Hardware</code> (Tensor Cores) 全速运转。</li><li><strong>结果返回</strong>：计算完成后，结果同样通过共享内存返回给 CPU，完成一次推理。</li></ol><hr><h3 id=核心总结><strong>核心总结</strong><a hidden class=anchor aria-hidden=true href=#核心总结>#</a></h3><ul><li><strong>物理隔离</strong>：模型文件 (<code>model.onnx</code>) 由 CPU 解析，Skel 库 (<code>.so</code>) 由 DSP 加载，两者物理存储位置和加载时机完全不同。</li><li><strong>反向加载</strong>：DSP 是“大脑”，但它需要 CPU 这个“管家”帮忙从磁盘拿代码（Skel），这就是 Side-load 机制。</li><li><strong>性能优化</strong>：控制流走 FastRPC，数据流走共享内存，实现了控制与数据分离，最大化了吞吐量。</li></ul><h2 id=4-开发与调试重点>4. 开发与调试重点<a hidden class=anchor aria-hidden=true href=#4-开发与调试重点>#</a></h2><ul><li><strong>Skel 文件必须打包</strong>: 务必确保 <code>libQnnHtpV[xx]Skel.so</code> 被正确打包进 APK 的 <code>jniLibs</code> 或 <code>assets</code> 中。如果 DSP 请求文件时（步骤 8-10）在路径中找不到文件，初始化将直接失败。</li><li><strong>环境变量设置</strong>: 图中 Note 提到的 <code>setenv("ADSP_LIBRARY_PATH", ...)</code> 是必不可少的。因为系统的 FastRPC 库默认不知道你的 App 安装在哪个随机生成的路径下，必须显式告知。</li><li><strong>版本匹配</strong>: Stub（CPU侧）和 Skel（DSP侧）必须属于同一个 QNN SDK 版本，否则在握手阶段会因协议不一致而崩溃。</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>