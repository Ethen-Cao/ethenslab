<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QNN HTP (ONNX Runtime) 架构原理与全链路调用详解 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 架构全景图
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。
核心设计理念在于 控制与数据分离：

控制流：利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。
数据流：利用 ION/DMA-BUF 共享内存实现零拷贝传输，确保证推理性能。


  @startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 13
skinparam defaultFontColor black
skinparam arrowColor #333333
skinparam nodesep 50
skinparam ranksep 40
skinparam linetype ortho

&#39; --- 样式定义 ---
skinparam rectangle {
    BackgroundColor #F5F5F5
    BorderColor #9E9E9E
    RoundCorner 6
}
skinparam component {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
}
skinparam file {
    BackgroundColor #FFF9C4
    BorderColor #FBC02D
}

title QNN HTP Architecture: Full Lifecycle

&#39; --- 图例 (Legend) ---
legend right
    | 颜色 | 阶段 / 含义 |
    | <#FF0000> | <b>Phase 1: 初始化与建图</b> (只运行一次) |
    | <#0000FF> | <b>Side-load 回环</b> (驱动加载 Skel 文件) |
    | <#008000> | <b>Phase 2: 推理执行</b> (每帧运行, 高频) |
endlegend

node "Qualcomm SoC" {

    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. App Process Space" as LAYER_APP {
            component "\tApp Code\t" as AppCode
            file "Assets/model.onnx" as Model

            rectangle "Native Libraries" {
                component "ONNX Runtime" as ORT
                component "\t\tQNN EP\t\t" as QNN_EP
                
                package "QNN SDK" {
                    component "Backend Manager\n(libQnnHtp.so)" as QnnHtp
                    component "\t\t\t\t\t\tStub(CPU Proxy)\t\t\t\t\t\t" as QnnStub
                }
                
                file "libQnnHtpVxxSkel.so\n(Disk Artifact)" as SkelFile
            }
        }

        rectangle "2. System / Kernel" as LAYER_SYS {
            component "\t\tFastRPC Lib\t\t" as FastRPC
            component "\t\t\tFastRPC Driver\t\t\t" as Driver
            database "Shared Memory\n(ION / DMA-BUF)" as Mem
        }
    }

    rectangle "DSP Subsystem" as DSP_DOMAIN {
        component "\t\tQuRT OS\t\t" as QuRT

        package "Signed PD" {
            component "Skel Instance\n(Running Code)" as SkelRun
            component "HTP Hardware\n(NPU)" as HTP_HW
        }
    }
}

&#39; =======================
&#39; 逻辑连线
&#39; =======================

&#39; --- Phase 1: Initialization (红色箭头) ---
AppCode -[#FF0000]down-> ORT : 1. CreateSession
ORT .[#FF0000]right.> Model : 2. Parse
ORT -[#FF0000]down-> QNN_EP : 3. Delegate
QNN_EP -[#FF0000]down-> QnnHtp : 4. Init
QnnHtp -[#FF0000]down-> QnnStub : 5. Load Stub

&#39; RPC 建立
QnnStub -[#FF0000]down-> FastRPC : 6. Open Session
FastRPC -[#FF0000]down-> Driver : 7. ioctl

&#39; DSP 唤醒
Driver -[#FF0000]down-> QuRT : 8. WakeUp & Create PD

&#39; --- Side-load Loop (蓝色箭头 - 加载回环) ---
QuRT .[#0000FF]up.> Driver : 9. Request Load
Driver .[#0000FF]up.> FastRPC : 10. Upcall
FastRPC .[#0000FF]left.> SkelFile : 11. READ FILE
FastRPC .[#0000FF]down.> Mem : 12. Map to Shared Mem
Mem .[#0000FF]down.> SkelRun : 13. Load into DSP Mem

&#39; --- Phase 2: Execution (绿色箭头 - 高频路径) ---
AppCode -[#008000]right-> ORT : Run(Input)
ORT -[#008000]down-> QNN_EP
QNN_EP -[#008000]down-> QnnStub

&#39; 写入共享内存
QnnStub .[#008000]right.> Mem : 14. Write Input Tensor\n(Zero-Copy)

&#39; RPC 执行链
QnnStub -[#008000]down-> FastRPC : 15. Invoke Execute
FastRPC -[#008000]down-> Driver
Driver -[#008000]down-> SkelRun : 16. Signal
SkelRun -[#008000]down-> HTP_HW : 17. Compute

@enduml

2. 核心全生命周期解说
整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="QNN HTP (ONNX Runtime) 架构原理与全链路调用详解"><meta property="og:description" content='1. 架构全景图 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。
核心设计理念在于 控制与数据分离：
控制流：利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。 数据流：利用 ION/DMA-BUF 共享内存实现零拷贝传输，确保证推理性能。 @startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 13 skinparam defaultFontColor black skinparam arrowColor #333333 skinparam nodesep 50 skinparam ranksep 40 skinparam linetype ortho &#39; --- 样式定义 --- skinparam rectangle { BackgroundColor #F5F5F5 BorderColor #9E9E9E RoundCorner 6 } skinparam component { BackgroundColor #E3F2FD BorderColor #1E88E5 } skinparam file { BackgroundColor #FFF9C4 BorderColor #FBC02D } title QNN HTP Architecture: Full Lifecycle &#39; --- 图例 (Legend) --- legend right | 颜色 | 阶段 / 含义 | | <#FF0000> | <b>Phase 1: 初始化与建图</b> (只运行一次) | | <#0000FF> | <b>Side-load 回环</b> (驱动加载 Skel 文件) | | <#008000> | <b>Phase 2: 推理执行</b> (每帧运行, 高频) | endlegend node "Qualcomm SoC" { rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN { rectangle "1. App Process Space" as LAYER_APP { component "\tApp Code\t" as AppCode file "Assets/model.onnx" as Model rectangle "Native Libraries" { component "ONNX Runtime" as ORT component "\t\tQNN EP\t\t" as QNN_EP package "QNN SDK" { component "Backend Manager\n(libQnnHtp.so)" as QnnHtp component "\t\t\t\t\t\tStub(CPU Proxy)\t\t\t\t\t\t" as QnnStub } file "libQnnHtpVxxSkel.so\n(Disk Artifact)" as SkelFile } } rectangle "2. System / Kernel" as LAYER_SYS { component "\t\tFastRPC Lib\t\t" as FastRPC component "\t\t\tFastRPC Driver\t\t\t" as Driver database "Shared Memory\n(ION / DMA-BUF)" as Mem } } rectangle "DSP Subsystem" as DSP_DOMAIN { component "\t\tQuRT OS\t\t" as QuRT package "Signed PD" { component "Skel Instance\n(Running Code)" as SkelRun component "HTP Hardware\n(NPU)" as HTP_HW } } } &#39; ======================= &#39; 逻辑连线 &#39; ======================= &#39; --- Phase 1: Initialization (红色箭头) --- AppCode -[#FF0000]down-> ORT : 1. CreateSession ORT .[#FF0000]right.> Model : 2. Parse ORT -[#FF0000]down-> QNN_EP : 3. Delegate QNN_EP -[#FF0000]down-> QnnHtp : 4. Init QnnHtp -[#FF0000]down-> QnnStub : 5. Load Stub &#39; RPC 建立 QnnStub -[#FF0000]down-> FastRPC : 6. Open Session FastRPC -[#FF0000]down-> Driver : 7. ioctl &#39; DSP 唤醒 Driver -[#FF0000]down-> QuRT : 8. WakeUp & Create PD &#39; --- Side-load Loop (蓝色箭头 - 加载回环) --- QuRT .[#0000FF]up.> Driver : 9. Request Load Driver .[#0000FF]up.> FastRPC : 10. Upcall FastRPC .[#0000FF]left.> SkelFile : 11. READ FILE FastRPC .[#0000FF]down.> Mem : 12. Map to Shared Mem Mem .[#0000FF]down.> SkelRun : 13. Load into DSP Mem &#39; --- Phase 2: Execution (绿色箭头 - 高频路径) --- AppCode -[#008000]right-> ORT : Run(Input) ORT -[#008000]down-> QNN_EP QNN_EP -[#008000]down-> QnnStub &#39; 写入共享内存 QnnStub .[#008000]right.> Mem : 14. Write Input Tensor\n(Zero-Copy) &#39; RPC 执行链 QnnStub -[#008000]down-> FastRPC : 15. Invoke Execute FastRPC -[#008000]down-> Driver Driver -[#008000]down-> SkelRun : 16. Signal SkelRun -[#008000]down-> HTP_HW : 17. Compute @enduml 2. 核心全生命周期解说 整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="explore-ai"><meta property="article:published_time" content="2025-08-27T17:17:50+08:00"><meta property="article:modified_time" content="2025-08-27T17:17:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QNN HTP (ONNX Runtime) 架构原理与全链路调用详解"><meta name=twitter:description content='1. 架构全景图
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。
核心设计理念在于 控制与数据分离：

控制流：利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。
数据流：利用 ION/DMA-BUF 共享内存实现零拷贝传输，确保证推理性能。


  @startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 13
skinparam defaultFontColor black
skinparam arrowColor #333333
skinparam nodesep 50
skinparam ranksep 40
skinparam linetype ortho

&#39; --- 样式定义 ---
skinparam rectangle {
    BackgroundColor #F5F5F5
    BorderColor #9E9E9E
    RoundCorner 6
}
skinparam component {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
}
skinparam file {
    BackgroundColor #FFF9C4
    BorderColor #FBC02D
}

title QNN HTP Architecture: Full Lifecycle

&#39; --- 图例 (Legend) ---
legend right
    | 颜色 | 阶段 / 含义 |
    | <#FF0000> | <b>Phase 1: 初始化与建图</b> (只运行一次) |
    | <#0000FF> | <b>Side-load 回环</b> (驱动加载 Skel 文件) |
    | <#008000> | <b>Phase 2: 推理执行</b> (每帧运行, 高频) |
endlegend

node "Qualcomm SoC" {

    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. App Process Space" as LAYER_APP {
            component "\tApp Code\t" as AppCode
            file "Assets/model.onnx" as Model

            rectangle "Native Libraries" {
                component "ONNX Runtime" as ORT
                component "\t\tQNN EP\t\t" as QNN_EP
                
                package "QNN SDK" {
                    component "Backend Manager\n(libQnnHtp.so)" as QnnHtp
                    component "\t\t\t\t\t\tStub(CPU Proxy)\t\t\t\t\t\t" as QnnStub
                }
                
                file "libQnnHtpVxxSkel.so\n(Disk Artifact)" as SkelFile
            }
        }

        rectangle "2. System / Kernel" as LAYER_SYS {
            component "\t\tFastRPC Lib\t\t" as FastRPC
            component "\t\t\tFastRPC Driver\t\t\t" as Driver
            database "Shared Memory\n(ION / DMA-BUF)" as Mem
        }
    }

    rectangle "DSP Subsystem" as DSP_DOMAIN {
        component "\t\tQuRT OS\t\t" as QuRT

        package "Signed PD" {
            component "Skel Instance\n(Running Code)" as SkelRun
            component "HTP Hardware\n(NPU)" as HTP_HW
        }
    }
}

&#39; =======================
&#39; 逻辑连线
&#39; =======================

&#39; --- Phase 1: Initialization (红色箭头) ---
AppCode -[#FF0000]down-> ORT : 1. CreateSession
ORT .[#FF0000]right.> Model : 2. Parse
ORT -[#FF0000]down-> QNN_EP : 3. Delegate
QNN_EP -[#FF0000]down-> QnnHtp : 4. Init
QnnHtp -[#FF0000]down-> QnnStub : 5. Load Stub

&#39; RPC 建立
QnnStub -[#FF0000]down-> FastRPC : 6. Open Session
FastRPC -[#FF0000]down-> Driver : 7. ioctl

&#39; DSP 唤醒
Driver -[#FF0000]down-> QuRT : 8. WakeUp & Create PD

&#39; --- Side-load Loop (蓝色箭头 - 加载回环) ---
QuRT .[#0000FF]up.> Driver : 9. Request Load
Driver .[#0000FF]up.> FastRPC : 10. Upcall
FastRPC .[#0000FF]left.> SkelFile : 11. READ FILE
FastRPC .[#0000FF]down.> Mem : 12. Map to Shared Mem
Mem .[#0000FF]down.> SkelRun : 13. Load into DSP Mem

&#39; --- Phase 2: Execution (绿色箭头 - 高频路径) ---
AppCode -[#008000]right-> ORT : Run(Input)
ORT -[#008000]down-> QNN_EP
QNN_EP -[#008000]down-> QnnStub

&#39; 写入共享内存
QnnStub .[#008000]right.> Mem : 14. Write Input Tensor\n(Zero-Copy)

&#39; RPC 执行链
QnnStub -[#008000]down-> FastRPC : 15. Invoke Execute
FastRPC -[#008000]down-> Driver
Driver -[#008000]down-> SkelRun : 16. Signal
SkelRun -[#008000]down-> HTP_HW : 17. Compute

@enduml

2. 核心全生命周期解说
整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Explore AI","item":"https://ethen-cao.github.io/ethenslab/explore-ai/"},{"@type":"ListItem","position":2,"name":"QNN HTP (ONNX Runtime) 架构原理与全链路调用详解","item":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNN HTP (ONNX Runtime) 架构原理与全链路调用详解","name":"QNN HTP (ONNX Runtime) 架构原理与全链路调用详解","description":"1. 架构全景图 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。\n核心设计理念在于 控制与数据分离：\n控制流：利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。 数据流：利用 ION/DMA-BUF 共享内存实现零拷贝传输，确保证推理性能。 @startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 13 skinparam defaultFontColor black skinparam arrowColor #333333 skinparam nodesep 50 skinparam ranksep 40 skinparam linetype ortho \u0026#39; --- 样式定义 --- skinparam rectangle { BackgroundColor #F5F5F5 BorderColor #9E9E9E RoundCorner 6 } skinparam component { BackgroundColor #E3F2FD BorderColor #1E88E5 } skinparam file { BackgroundColor #FFF9C4 BorderColor #FBC02D } title QNN HTP Architecture: Full Lifecycle \u0026#39; --- 图例 (Legend) --- legend right | 颜色 | 阶段 / 含义 | | \u0026lt;#FF0000\u0026gt; | \u0026lt;b\u0026gt;Phase 1: 初始化与建图\u0026lt;/b\u0026gt; (只运行一次) | | \u0026lt;#0000FF\u0026gt; | \u0026lt;b\u0026gt;Side-load 回环\u0026lt;/b\u0026gt; (驱动加载 Skel 文件) | | \u0026lt;#008000\u0026gt; | \u0026lt;b\u0026gt;Phase 2: 推理执行\u0026lt;/b\u0026gt; (每帧运行, 高频) | endlegend node \u0026#34;Qualcomm SoC\u0026#34; { rectangle \u0026#34;CPU Subsystem (Application Processor)\u0026#34; as CPU_DOMAIN { rectangle \u0026#34;1. App Process Space\u0026#34; as LAYER_APP { component \u0026#34;\\tApp Code\\t\u0026#34; as AppCode file \u0026#34;Assets/model.onnx\u0026#34; as Model rectangle \u0026#34;Native Libraries\u0026#34; { component \u0026#34;ONNX Runtime\u0026#34; as ORT component \u0026#34;\\t\\tQNN EP\\t\\t\u0026#34; as QNN_EP package \u0026#34;QNN SDK\u0026#34; { component \u0026#34;Backend Manager\\n(libQnnHtp.so)\u0026#34; as QnnHtp component \u0026#34;\\t\\t\\t\\t\\t\\tStub(CPU Proxy)\\t\\t\\t\\t\\t\\t\u0026#34; as QnnStub } file \u0026#34;libQnnHtpVxxSkel.so\\n(Disk Artifact)\u0026#34; as SkelFile } } rectangle \u0026#34;2. System / Kernel\u0026#34; as LAYER_SYS { component \u0026#34;\\t\\tFastRPC Lib\\t\\t\u0026#34; as FastRPC component \u0026#34;\\t\\t\\tFastRPC Driver\\t\\t\\t\u0026#34; as Driver database \u0026#34;Shared Memory\\n(ION / DMA-BUF)\u0026#34; as Mem } } rectangle \u0026#34;DSP Subsystem\u0026#34; as DSP_DOMAIN { component \u0026#34;\\t\\tQuRT OS\\t\\t\u0026#34; as QuRT package \u0026#34;Signed PD\u0026#34; { component \u0026#34;Skel Instance\\n(Running Code)\u0026#34; as SkelRun component \u0026#34;HTP Hardware\\n(NPU)\u0026#34; as HTP_HW } } } \u0026#39; ======================= \u0026#39; 逻辑连线 \u0026#39; ======================= \u0026#39; --- Phase 1: Initialization (红色箭头) --- AppCode -[#FF0000]down-\u0026gt; ORT : 1. CreateSession ORT .[#FF0000]right.\u0026gt; Model : 2. Parse ORT -[#FF0000]down-\u0026gt; QNN_EP : 3. Delegate QNN_EP -[#FF0000]down-\u0026gt; QnnHtp : 4. Init QnnHtp -[#FF0000]down-\u0026gt; QnnStub : 5. Load Stub \u0026#39; RPC 建立 QnnStub -[#FF0000]down-\u0026gt; FastRPC : 6. Open Session FastRPC -[#FF0000]down-\u0026gt; Driver : 7. ioctl \u0026#39; DSP 唤醒 Driver -[#FF0000]down-\u0026gt; QuRT : 8. WakeUp \u0026amp; Create PD \u0026#39; --- Side-load Loop (蓝色箭头 - 加载回环) --- QuRT .[#0000FF]up.\u0026gt; Driver : 9. Request Load Driver .[#0000FF]up.\u0026gt; FastRPC : 10. Upcall FastRPC .[#0000FF]left.\u0026gt; SkelFile : 11. READ FILE FastRPC .[#0000FF]down.\u0026gt; Mem : 12. Map to Shared Mem Mem .[#0000FF]down.\u0026gt; SkelRun : 13. Load into DSP Mem \u0026#39; --- Phase 2: Execution (绿色箭头 - 高频路径) --- AppCode -[#008000]right-\u0026gt; ORT : Run(Input) ORT -[#008000]down-\u0026gt; QNN_EP QNN_EP -[#008000]down-\u0026gt; QnnStub \u0026#39; 写入共享内存 QnnStub .[#008000]right.\u0026gt; Mem : 14. Write Input Tensor\\n(Zero-Copy) \u0026#39; RPC 执行链 QnnStub -[#008000]down-\u0026gt; FastRPC : 15. Invoke Execute FastRPC -[#008000]down-\u0026gt; Driver Driver -[#008000]down-\u0026gt; SkelRun : 16. Signal SkelRun -[#008000]down-\u0026gt; HTP_HW : 17. Compute @enduml 2. 核心全生命周期解说 整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。\n","keywords":[],"articleBody":"1. 架构全景图 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。\n核心设计理念在于 控制与数据分离：\n控制流：利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。 数据流：利用 ION/DMA-BUF 共享内存实现零拷贝传输，确保证推理性能。 @startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 13 skinparam defaultFontColor black skinparam arrowColor #333333 skinparam nodesep 50 skinparam ranksep 40 skinparam linetype ortho ' --- 样式定义 --- skinparam rectangle { BackgroundColor #F5F5F5 BorderColor #9E9E9E RoundCorner 6 } skinparam component { BackgroundColor #E3F2FD BorderColor #1E88E5 } skinparam file { BackgroundColor #FFF9C4 BorderColor #FBC02D } title QNN HTP Architecture: Full Lifecycle ' --- 图例 (Legend) --- legend right | 颜色 | 阶段 / 含义 | | \u003c#FF0000\u003e | Phase 1: 初始化与建图 (只运行一次) | | \u003c#0000FF\u003e | Side-load 回环 (驱动加载 Skel 文件) | | \u003c#008000\u003e | Phase 2: 推理执行 (每帧运行, 高频) | endlegend node \"Qualcomm SoC\" { rectangle \"CPU Subsystem (Application Processor)\" as CPU_DOMAIN { rectangle \"1. App Process Space\" as LAYER_APP { component \"\\tApp Code\\t\" as AppCode file \"Assets/model.onnx\" as Model rectangle \"Native Libraries\" { component \"ONNX Runtime\" as ORT component \"\\t\\tQNN EP\\t\\t\" as QNN_EP package \"QNN SDK\" { component \"Backend Manager\\n(libQnnHtp.so)\" as QnnHtp component \"\\t\\t\\t\\t\\t\\tStub(CPU Proxy)\\t\\t\\t\\t\\t\\t\" as QnnStub } file \"libQnnHtpVxxSkel.so\\n(Disk Artifact)\" as SkelFile } } rectangle \"2. System / Kernel\" as LAYER_SYS { component \"\\t\\tFastRPC Lib\\t\\t\" as FastRPC component \"\\t\\t\\tFastRPC Driver\\t\\t\\t\" as Driver database \"Shared Memory\\n(ION / DMA-BUF)\" as Mem } } rectangle \"DSP Subsystem\" as DSP_DOMAIN { component \"\\t\\tQuRT OS\\t\\t\" as QuRT package \"Signed PD\" { component \"Skel Instance\\n(Running Code)\" as SkelRun component \"HTP Hardware\\n(NPU)\" as HTP_HW } } } ' ======================= ' 逻辑连线 ' ======================= ' --- Phase 1: Initialization (红色箭头) --- AppCode -[#FF0000]down-\u003e ORT : 1. CreateSession ORT .[#FF0000]right.\u003e Model : 2. Parse ORT -[#FF0000]down-\u003e QNN_EP : 3. Delegate QNN_EP -[#FF0000]down-\u003e QnnHtp : 4. Init QnnHtp -[#FF0000]down-\u003e QnnStub : 5. Load Stub ' RPC 建立 QnnStub -[#FF0000]down-\u003e FastRPC : 6. Open Session FastRPC -[#FF0000]down-\u003e Driver : 7. ioctl ' DSP 唤醒 Driver -[#FF0000]down-\u003e QuRT : 8. WakeUp \u0026 Create PD ' --- Side-load Loop (蓝色箭头 - 加载回环) --- QuRT .[#0000FF]up.\u003e Driver : 9. Request Load Driver .[#0000FF]up.\u003e FastRPC : 10. Upcall FastRPC .[#0000FF]left.\u003e SkelFile : 11. READ FILE FastRPC .[#0000FF]down.\u003e Mem : 12. Map to Shared Mem Mem .[#0000FF]down.\u003e SkelRun : 13. Load into DSP Mem ' --- Phase 2: Execution (绿色箭头 - 高频路径) --- AppCode -[#008000]right-\u003e ORT : Run(Input) ORT -[#008000]down-\u003e QNN_EP QNN_EP -[#008000]down-\u003e QnnStub ' 写入共享内存 QnnStub .[#008000]right.\u003e Mem : 14. Write Input Tensor\\n(Zero-Copy) ' RPC 执行链 QnnStub -[#008000]down-\u003e FastRPC : 15. Invoke Execute FastRPC -[#008000]down-\u003e Driver Driver -[#008000]down-\u003e SkelRun : 16. Signal SkelRun -[#008000]down-\u003e HTP_HW : 17. Compute @enduml 2. 核心全生命周期解说 整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。\n第一阶段：初始化与建图 (Phase 1: Initialization) 图例颜色：红色 ──\u003e 此阶段通常在应用启动时执行一次，负责建立上下文。\n模型解析 (CPU)：关键点！ ORT 在 CPU 侧直接读取并解析 model.onnx 文件。模型结构被解析为内存对象，ORT 识别出支持 NPU 加速的节点，将其委托给 QNN EP。 任务委托：调用链经过 QNN EP -\u003e Backend Manager -\u003e Stub。 握手与唤醒：Stub (CPU 代理) 通过 FastRPC 向底层驱动发起 open 请求。底层驱动唤醒沉睡的 DSP 子系统，并在其上创建一个受保护的进程域 (Signed PD)。 第二阶段：Skel 加载回环 (The Side-load Loop) 图例颜色：蓝色 ..\u003e 这是 QNN 架构最核心的“反向加载”机制。\n反向请求 (Upcall)：DSP 启动后，发现需要加载 HTP 硬件驱动逻辑，于是向 CPU 发起一个“请求读取文件”的反向 RPC 调用。 文件定位：CPU 端的 FastRPC Lib 收到请求，根据环境变量（ADSP_LIBRARY_PATH）在 APK 的 Native 库路径下搜索并定位 libQnnHtpVxxSkel.so。 共享内存传输：FastRPC 不通过慢速的 RPC 协议拷贝文件内容，而是将文件直接映射到 共享内存 (ION/DMA-BUF) 中。 DSP 加载：DSP 直接从共享内存读取 Skel 镜像并完成加载。至此，Skel Instance (服务端) 就位。 第三阶段：推理执行 (Phase 2: Execution) 图例颜色：绿色 ──\u003e 此阶段为高频运行（如每秒 30 帧），追求极致的低延迟。\n零拷贝输入：当应用调用 Run() 时，大的输入数据（如图片张量）被直接写入 共享内存 (Mem)。 轻量级指令：QnnStub 仅通过 RPC 发送一条轻量级的 Execute 指令（包含数据在共享内存中的句柄/地址）。 硬件计算：DSP 端的 SkelRun 收到指令，指挥 HTP Hardware (Tensor Cores) 全速运转。 结果返回：计算结果同样写入共享内存，CPU 直接读取，全程无数据拷贝。 3. 核心组件与物理隔离 理解 QNN HTP 架构，必须明确以下组件的物理存储与运行位置的隔离性：\n3.1 Android User Space (应用层) 模型文件 (model.onnx):\n存储: Assets 或 App 私有文件目录 (/data/user/0/.../files)。\n解析: 仅在 CPU 端由 ORT 解析，不传输给 DSP。\nSkel 库 (libQnnHtpVxxSkel.so):\n存储: 系统 Native 库目录 (/data/app/~~xxx/lib/arm64)。\n运行: 虽然存放在 CPU 磁盘上，但必须通过 FastRPC 加载到 DSP 内存 中运行。\nStub 库 (libQnnHtpVxxStub.so):\n运行: 在 CPU 端运行，负责参数编组 (Marshalling)，是 FastRPC 的客户端。\n3.2 Android System \u0026 Kernel libadsprpc.so: 提供了 apps_std_fopen_with_env 等关键函数，用于响应 DSP 的文件读取请求。 ION / DMA-BUF: 现代 Android 的共享内存机制，是 CPU 与 DSP 高性能通信的基石。 3.3 DSP Subsystem Signed PD: 受签名的保护域，类似于 Linux 的用户空间进程。如果 Skel 版本不匹配或签名校验失败，加载将在此处终止。 4. 开发与调试避坑指南 环境变量至关重要: 必须在初始化 ORT/QNN 之前设置：setenv(\"ADSP_LIBRARY_PATH\", nativeLibraryDir, 1)。 原因: FastRPC 是系统库，它不知道你 APK 的安装路径。如果不设置，它无法在“Side-load 回环”阶段找到 Skel.so，导致初始化失败。 Skel 文件必须打包: 务必确保 libQnnHtpV[xx]Skel.so 被正确打包进 APK 的 jniLibs 中。它是 DSP 侧的“驱动”，没有它 NPU 无法工作。 版本强一致性 (Strict ABI): Stub (CPU) 和 Skel (DSP) 必须属于同一个 QNN SDK 版本。 后果: 如果 Stub 发送 V2 协议的数据包，而 DSP 加载了 V1 版本的 Skel，会导致内存解析错误、签名不匹配 (Signature Mismatch) 或直接 Crash。 ","wordCount":"679","inLanguage":"en","datePublished":"2025-08-27T17:17:50+08:00","dateModified":"2025-08-27T17:17:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/explore-ai/>Explore AI</a></div><h1 class="post-title entry-hint-parent">QNN HTP (ONNX Runtime) 架构原理与全链路调用详解</h1><div class=post-meta><span title='2025-08-27 17:17:50 +0800 CST'>August 27, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;679 words</div></header><div class=post-content><h2 id=1-架构全景图>1. 架构全景图<a hidden class=anchor aria-hidden=true href=#1-架构全景图>#</a></h2><p>本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。</p><p>核心设计理念在于 <strong>控制与数据分离</strong>：</p><ul><li><strong>控制流</strong>：利用 <strong>FastRPC</strong> 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态“侧载” (Side-load) 到 DSP 中运行。</li><li><strong>数据流</strong>：利用 <strong>ION/DMA-BUF</strong> 共享内存实现零拷贝传输，确保证推理性能。</li></ul><pre class=plantuml-container style=display:none>
  <code class=language-plantuml>@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 13
skinparam defaultFontColor black
skinparam arrowColor #333333
skinparam nodesep 50
skinparam ranksep 40
skinparam linetype ortho

&#39; --- 样式定义 ---
skinparam rectangle {
    BackgroundColor #F5F5F5
    BorderColor #9E9E9E
    RoundCorner 6
}
skinparam component {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
}
skinparam file {
    BackgroundColor #FFF9C4
    BorderColor #FBC02D
}

title QNN HTP Architecture: Full Lifecycle

&#39; --- 图例 (Legend) ---
legend right
    | 颜色 | 阶段 / 含义 |
    | &lt;#FF0000&gt; | &lt;b&gt;Phase 1: 初始化与建图&lt;/b&gt; (只运行一次) |
    | &lt;#0000FF&gt; | &lt;b&gt;Side-load 回环&lt;/b&gt; (驱动加载 Skel 文件) |
    | &lt;#008000&gt; | &lt;b&gt;Phase 2: 推理执行&lt;/b&gt; (每帧运行, 高频) |
endlegend

node &#34;Qualcomm SoC&#34; {

    rectangle &#34;CPU Subsystem (Application Processor)&#34; as CPU_DOMAIN {

        rectangle &#34;1. App Process Space&#34; as LAYER_APP {
            component &#34;\tApp Code\t&#34; as AppCode
            file &#34;Assets/model.onnx&#34; as Model

            rectangle &#34;Native Libraries&#34; {
                component &#34;ONNX Runtime&#34; as ORT
                component &#34;\t\tQNN EP\t\t&#34; as QNN_EP
                
                package &#34;QNN SDK&#34; {
                    component &#34;Backend Manager\n(libQnnHtp.so)&#34; as QnnHtp
                    component &#34;\t\t\t\t\t\tStub(CPU Proxy)\t\t\t\t\t\t&#34; as QnnStub
                }
                
                file &#34;libQnnHtpVxxSkel.so\n(Disk Artifact)&#34; as SkelFile
            }
        }

        rectangle &#34;2. System / Kernel&#34; as LAYER_SYS {
            component &#34;\t\tFastRPC Lib\t\t&#34; as FastRPC
            component &#34;\t\t\tFastRPC Driver\t\t\t&#34; as Driver
            database &#34;Shared Memory\n(ION / DMA-BUF)&#34; as Mem
        }
    }

    rectangle &#34;DSP Subsystem&#34; as DSP_DOMAIN {
        component &#34;\t\tQuRT OS\t\t&#34; as QuRT

        package &#34;Signed PD&#34; {
            component &#34;Skel Instance\n(Running Code)&#34; as SkelRun
            component &#34;HTP Hardware\n(NPU)&#34; as HTP_HW
        }
    }
}

&#39; =======================
&#39; 逻辑连线
&#39; =======================

&#39; --- Phase 1: Initialization (红色箭头) ---
AppCode -[#FF0000]down-&gt; ORT : 1. CreateSession
ORT .[#FF0000]right.&gt; Model : 2. Parse
ORT -[#FF0000]down-&gt; QNN_EP : 3. Delegate
QNN_EP -[#FF0000]down-&gt; QnnHtp : 4. Init
QnnHtp -[#FF0000]down-&gt; QnnStub : 5. Load Stub

&#39; RPC 建立
QnnStub -[#FF0000]down-&gt; FastRPC : 6. Open Session
FastRPC -[#FF0000]down-&gt; Driver : 7. ioctl

&#39; DSP 唤醒
Driver -[#FF0000]down-&gt; QuRT : 8. WakeUp &amp; Create PD

&#39; --- Side-load Loop (蓝色箭头 - 加载回环) ---
QuRT .[#0000FF]up.&gt; Driver : 9. Request Load
Driver .[#0000FF]up.&gt; FastRPC : 10. Upcall
FastRPC .[#0000FF]left.&gt; SkelFile : 11. READ FILE
FastRPC .[#0000FF]down.&gt; Mem : 12. Map to Shared Mem
Mem .[#0000FF]down.&gt; SkelRun : 13. Load into DSP Mem

&#39; --- Phase 2: Execution (绿色箭头 - 高频路径) ---
AppCode -[#008000]right-&gt; ORT : Run(Input)
ORT -[#008000]down-&gt; QNN_EP
QNN_EP -[#008000]down-&gt; QnnStub

&#39; 写入共享内存
QnnStub .[#008000]right.&gt; Mem : 14. Write Input Tensor\n(Zero-Copy)

&#39; RPC 执行链
QnnStub -[#008000]down-&gt; FastRPC : 15. Invoke Execute
FastRPC -[#008000]down-&gt; Driver
Driver -[#008000]down-&gt; SkelRun : 16. Signal
SkelRun -[#008000]down-&gt; HTP_HW : 17. Compute

@enduml</code>
</pre><hr><h2 id=2-核心全生命周期解说>2. 核心全生命周期解说<a hidden class=anchor aria-hidden=true href=#2-核心全生命周期解说>#</a></h2><p>整个运行过程分为三个严格的时序阶段，对应架构图中的三种颜色。</p><h3 id=第一阶段初始化与建图-phase-1-initialization>第一阶段：初始化与建图 (Phase 1: Initialization)<a hidden class=anchor aria-hidden=true href=#第一阶段初始化与建图-phase-1-initialization>#</a></h3><blockquote><p><strong>图例颜色：红色 <font color=red>──></font></strong>
<em>此阶段通常在应用启动时执行一次，负责建立上下文。</em></p></blockquote><ol><li><strong>模型解析 (CPU)</strong>：<strong>关键点！</strong> ORT 在 CPU 侧直接读取并解析 <code>model.onnx</code> 文件。模型结构被解析为内存对象，ORT 识别出支持 NPU 加速的节点，将其委托给 <code>QNN EP</code>。</li><li><strong>任务委托</strong>：调用链经过 <code>QNN EP</code> -> <code>Backend Manager</code> -> <code>Stub</code>。</li><li><strong>握手与唤醒</strong>：<code>Stub</code> (CPU 代理) 通过 <code>FastRPC</code> 向底层驱动发起 <code>open</code> 请求。底层驱动唤醒沉睡的 DSP 子系统，并在其上创建一个受保护的进程域 (Signed PD)。</li></ol><h3 id=第二阶段skel-加载回环-the-side-load-loop>第二阶段：Skel 加载回环 (The Side-load Loop)<a hidden class=anchor aria-hidden=true href=#第二阶段skel-加载回环-the-side-load-loop>#</a></h3><blockquote><p><strong>图例颜色：蓝色 <font color=blue>..></font></strong>
<em>这是 QNN 架构最核心的“反向加载”机制。</em></p></blockquote><ol><li><strong>反向请求 (Upcall)</strong>：DSP 启动后，发现需要加载 HTP 硬件驱动逻辑，于是向 CPU 发起一个“请求读取文件”的反向 RPC 调用。</li><li><strong>文件定位</strong>：CPU 端的 <code>FastRPC Lib</code> 收到请求，根据环境变量（<code>ADSP_LIBRARY_PATH</code>）在 APK 的 Native 库路径下搜索并定位 <code>libQnnHtpVxxSkel.so</code>。</li><li><strong>共享内存传输</strong>：FastRPC <strong>不</strong>通过慢速的 RPC 协议拷贝文件内容，而是将文件直接映射到 <strong>共享内存 (ION/DMA-BUF)</strong> 中。</li><li><strong>DSP 加载</strong>：DSP 直接从共享内存读取 Skel 镜像并完成加载。至此，<code>Skel Instance</code> (服务端) 就位。</li></ol><h3 id=第三阶段推理执行-phase-2-execution>第三阶段：推理执行 (Phase 2: Execution)<a hidden class=anchor aria-hidden=true href=#第三阶段推理执行-phase-2-execution>#</a></h3><blockquote><p><strong>图例颜色：绿色 <font color=green>──></font></strong>
<em>此阶段为高频运行（如每秒 30 帧），追求极致的低延迟。</em></p></blockquote><ol><li><strong>零拷贝输入</strong>：当应用调用 <code>Run()</code> 时，大的输入数据（如图片张量）被直接写入 <strong>共享内存 (Mem)</strong>。</li><li><strong>轻量级指令</strong>：<code>QnnStub</code> 仅通过 RPC 发送一条轻量级的 <code>Execute</code> 指令（包含数据在共享内存中的句柄/地址）。</li><li><strong>硬件计算</strong>：DSP 端的 <code>SkelRun</code> 收到指令，指挥 <code>HTP Hardware</code> (Tensor Cores) 全速运转。</li><li><strong>结果返回</strong>：计算结果同样写入共享内存，CPU 直接读取，全程无数据拷贝。</li></ol><hr><h2 id=3-核心组件与物理隔离>3. 核心组件与物理隔离<a hidden class=anchor aria-hidden=true href=#3-核心组件与物理隔离>#</a></h2><p>理解 QNN HTP 架构，必须明确以下组件的物理存储与运行位置的隔离性：</p><h3 id=31-android-user-space-应用层>3.1 Android User Space (应用层)<a hidden class=anchor aria-hidden=true href=#31-android-user-space-应用层>#</a></h3><ul><li><p><strong>模型文件 (<code>model.onnx</code>)</strong>:</p></li><li><p><strong>存储</strong>: <code>Assets</code> 或 App 私有文件目录 (<code>/data/user/0/.../files</code>)。</p></li><li><p><strong>解析</strong>: 仅在 <strong>CPU</strong> 端由 ORT 解析，<strong>不</strong>传输给 DSP。</p></li><li><p><strong>Skel 库 (<code>libQnnHtpVxxSkel.so</code>)</strong>:</p></li><li><p><strong>存储</strong>: 系统 Native 库目录 (<code>/data/app/~~xxx/lib/arm64</code>)。</p></li><li><p><strong>运行</strong>: 虽然存放在 CPU 磁盘上，但必须通过 FastRPC 加载到 <strong>DSP 内存</strong> 中运行。</p></li><li><p><strong>Stub 库 (<code>libQnnHtpVxxStub.so</code>)</strong>:</p></li><li><p><strong>运行</strong>: 在 <strong>CPU</strong> 端运行，负责参数编组 (Marshalling)，是 FastRPC 的客户端。</p></li></ul><h3 id=32-android-system--kernel>3.2 Android System & Kernel<a hidden class=anchor aria-hidden=true href=#32-android-system--kernel>#</a></h3><ul><li><strong>libadsprpc.so</strong>: 提供了 <code>apps_std_fopen_with_env</code> 等关键函数，用于响应 DSP 的文件读取请求。</li><li><strong>ION / DMA-BUF</strong>: 现代 Android 的共享内存机制，是 CPU 与 DSP 高性能通信的基石。</li></ul><h3 id=33-dsp-subsystem>3.3 DSP Subsystem<a hidden class=anchor aria-hidden=true href=#33-dsp-subsystem>#</a></h3><ul><li><strong>Signed PD</strong>: 受签名的保护域，类似于 Linux 的用户空间进程。如果 Skel 版本不匹配或签名校验失败，加载将在此处终止。</li></ul><hr><h2 id=4-开发与调试避坑指南>4. 开发与调试避坑指南<a hidden class=anchor aria-hidden=true href=#4-开发与调试避坑指南>#</a></h2><ol><li><strong>环境变量至关重要</strong>:</li></ol><ul><li>必须在初始化 ORT/QNN 之前设置：<code>setenv("ADSP_LIBRARY_PATH", nativeLibraryDir, 1)</code>。</li><li><strong>原因</strong>: FastRPC 是系统库，它不知道你 APK 的安装路径。如果不设置，它无法在“Side-load 回环”阶段找到 <code>Skel.so</code>，导致初始化失败。</li></ul><ol start=2><li><strong>Skel 文件必须打包</strong>:</li></ol><ul><li>务必确保 <code>libQnnHtpV[xx]Skel.so</code> 被正确打包进 APK 的 <code>jniLibs</code> 中。它是 DSP 侧的“驱动”，没有它 NPU 无法工作。</li></ul><ol start=3><li><strong>版本强一致性 (Strict ABI)</strong>:</li></ol><ul><li><strong>Stub (CPU)</strong> 和 <strong>Skel (DSP)</strong> 必须属于同一个 QNN SDK 版本。</li><li><strong>后果</strong>: 如果 Stub 发送 V2 协议的数据包，而 DSP 加载了 V1 版本的 Skel，会导致内存解析错误、签名不匹配 (Signature Mismatch) 或直接 Crash。</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>