<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QNN HTP (ONNX Runtime) 架构与调用流程详解 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 概述
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node "Qualcomm SoC (System on Chip)" {

    &#39; --- CPU Subsystem (Android) ---
    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. Android User Space (APK Process)" as LAYER_APP {
            component "Business Logic\n(Kotlin/Java/C++)" as AppCode
            note right of AppCode
               <b>关键配置:</b>
               setenv("ADSP_LIBRARY_PATH", 
               nativeLibraryDir, 1);
            end note

            package "Native Libraries (jniLibs / lib/arm64)" {
                component "libonnxruntime.so" as ORT
                component "libonnxruntime_providers_qnn.so" as QNN_EP
                
                package "QNN SDK CPU Libs" {
                    component "libQnnHtp.so\n(Backend Manager)" as QnnHtp
                    component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub
                }
                
                component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile
                note bottom of SkelFile
                   <b>Skel 文件</b>
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component "Assets (model.onnx)" as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle "2. Android System / Vendor Libs" as LAYER_SYS {
            component "libadsprpc.so (FastRPC Framework)" as FastRPC
        }

        rectangle "3. Linux Kernel Space" as LAYER_KERNEL {
            component "adsprpc.ko (FastRPC Driver)" as Driver
            component "ION / SMMU\n(Shared Memory)" as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN {
        component "QuRT OS (Real-time Kernel)" as QuRT

        package "Signed PD (Protection Domain)" {
            component "Skel Instance (Running Code)" as SkelRun
            component "HTP Hardware (Tensor Cores)" as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-> ORT : 1. Run()
ORT .left.> Model: Read & Parse
ORT -down-> QNN_EP : 2. Get EP
QNN_EP -down-> QnnHtp : 3. Create Backend
QnnHtp -down-> QnnStub : 4. Load specific Stub

QnnStub -down-> FastRPC : 5. remote_handle_open()
FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver <-> QuRT : 7. Context Switch / Wake up

QuRT .up.> Driver : 8. Request Skel
Driver .up.> FastRPC : 9. Callback
FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.> Mem : 11. Map to ION
Mem .down.> SkelRun : 12. Load into PD

QuRT -down-> SkelRun : 13. Execute Graph
SkelRun -down-> HTP_HW : 14. Compute
@enduml
2. 核心组件分层
2.1 Android User Space (应用层)
这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="QNN HTP (ONNX Runtime) 架构与调用流程详解"><meta property="og:description" content='1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node "Qualcomm SoC (System on Chip)" { &#39; --- CPU Subsystem (Android) --- rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN { rectangle "1. Android User Space (APK Process)" as LAYER_APP { component "Business Logic\n(Kotlin/Java/C++)" as AppCode note right of AppCode <b>关键配置:</b> setenv("ADSP_LIBRARY_PATH", nativeLibraryDir, 1); end note package "Native Libraries (jniLibs / lib/arm64)" { component "libonnxruntime.so" as ORT component "libonnxruntime_providers_qnn.so" as QNN_EP package "QNN SDK CPU Libs" { component "libQnnHtp.so\n(Backend Manager)" as QnnHtp component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub } component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile note bottom of SkelFile <b>Skel 文件</b> 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component "Assets (model.onnx)" as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle "2. Android System / Vendor Libs" as LAYER_SYS { component "libadsprpc.so (FastRPC Framework)" as FastRPC } rectangle "3. Linux Kernel Space" as LAYER_KERNEL { component "adsprpc.ko (FastRPC Driver)" as Driver component "ION / SMMU\n(Shared Memory)" as Mem } } &#39; --- DSP Subsystem --- rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN { component "QuRT OS (Real-time Kernel)" as QuRT package "Signed PD (Protection Domain)" { component "Skel Instance (Running Code)" as SkelRun component "HTP Hardware (Tensor Cores)" as HTP_HW } } } &#39; --- 详细调用关系 --- AppCode -down-> ORT : 1. Run() ORT .left.> Model: Read & Parse ORT -down-> QNN_EP : 2. Get EP QNN_EP -down-> QnnHtp : 3. Create Backend QnnHtp -down-> QnnStub : 4. Load specific Stub QnnStub -down-> FastRPC : 5. remote_handle_open() FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver <-> QuRT : 7. Context Switch / Wake up QuRT .up.> Driver : 8. Request Skel Driver .up.> FastRPC : 9. Callback FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.> Mem : 11. Map to ION Mem .down.> SkelRun : 12. Load into PD QuRT -down-> SkelRun : 13. Execute Graph SkelRun -down-> HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="explore-ai"><meta property="article:published_time" content="2025-08-27T17:17:50+08:00"><meta property="article:modified_time" content="2025-08-27T17:17:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QNN HTP (ONNX Runtime) 架构与调用流程详解"><meta name=twitter:description content='1. 概述
本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。
@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node "Qualcomm SoC (System on Chip)" {

    &#39; --- CPU Subsystem (Android) ---
    rectangle "CPU Subsystem (Application Processor)" as CPU_DOMAIN {

        rectangle "1. Android User Space (APK Process)" as LAYER_APP {
            component "Business Logic\n(Kotlin/Java/C++)" as AppCode
            note right of AppCode
               <b>关键配置:</b>
               setenv("ADSP_LIBRARY_PATH", 
               nativeLibraryDir, 1);
            end note

            package "Native Libraries (jniLibs / lib/arm64)" {
                component "libonnxruntime.so" as ORT
                component "libonnxruntime_providers_qnn.so" as QNN_EP
                
                package "QNN SDK CPU Libs" {
                    component "libQnnHtp.so\n(Backend Manager)" as QnnHtp
                    component "libQnnHtpV[xx]Stub.so\n(CPU Proxy)" as QnnStub
                }
                
                component "libQnnHtpV[xx]Skel.so\n(DSP Executable)" as SkelFile
                note bottom of SkelFile
                   <b>Skel 文件</b>
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component "Assets (model.onnx)" as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle "2. Android System / Vendor Libs" as LAYER_SYS {
            component "libadsprpc.so (FastRPC Framework)" as FastRPC
        }

        rectangle "3. Linux Kernel Space" as LAYER_KERNEL {
            component "adsprpc.ko (FastRPC Driver)" as Driver
            component "ION / SMMU\n(Shared Memory)" as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle "DSP Subsystem (Hexagon cDSP/HTP)" as DSP_DOMAIN {
        component "QuRT OS (Real-time Kernel)" as QuRT

        package "Signed PD (Protection Domain)" {
            component "Skel Instance (Running Code)" as SkelRun
            component "HTP Hardware (Tensor Cores)" as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-> ORT : 1. Run()
ORT .left.> Model: Read & Parse
ORT -down-> QNN_EP : 2. Get EP
QNN_EP -down-> QnnHtp : 3. Create Backend
QnnHtp -down-> QnnStub : 4. Load specific Stub

QnnStub -down-> FastRPC : 5. remote_handle_open()
FastRPC -down-> Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver <-> QuRT : 7. Context Switch / Wake up

QuRT .up.> Driver : 8. Request Skel
Driver .up.> FastRPC : 9. Callback
FastRPC .left.> SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.> Mem : 11. Map to ION
Mem .down.> SkelRun : 12. Load into PD

QuRT -down-> SkelRun : 13. Execute Graph
SkelRun -down-> HTP_HW : 14. Compute
@enduml
2. 核心组件分层
2.1 Android User Space (应用层)
这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Explore AI","item":"https://ethen-cao.github.io/ethenslab/explore-ai/"},{"@type":"ListItem","position":2,"name":"QNN HTP (ONNX Runtime) 架构与调用流程详解","item":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNN HTP (ONNX Runtime) 架构与调用流程详解","name":"QNN HTP (ONNX Runtime) 架构与调用流程详解","description":"1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。\n@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node \u0026#34;Qualcomm SoC (System on Chip)\u0026#34; { \u0026#39; --- CPU Subsystem (Android) --- rectangle \u0026#34;CPU Subsystem (Application Processor)\u0026#34; as CPU_DOMAIN { rectangle \u0026#34;1. Android User Space (APK Process)\u0026#34; as LAYER_APP { component \u0026#34;Business Logic\\n(Kotlin/Java/C++)\u0026#34; as AppCode note right of AppCode \u0026lt;b\u0026gt;关键配置:\u0026lt;/b\u0026gt; setenv(\u0026#34;ADSP_LIBRARY_PATH\u0026#34;, nativeLibraryDir, 1); end note package \u0026#34;Native Libraries (jniLibs / lib/arm64)\u0026#34; { component \u0026#34;libonnxruntime.so\u0026#34; as ORT component \u0026#34;libonnxruntime_providers_qnn.so\u0026#34; as QNN_EP package \u0026#34;QNN SDK CPU Libs\u0026#34; { component \u0026#34;libQnnHtp.so\\n(Backend Manager)\u0026#34; as QnnHtp component \u0026#34;libQnnHtpV[xx]Stub.so\\n(CPU Proxy)\u0026#34; as QnnStub } component \u0026#34;libQnnHtpV[xx]Skel.so\\n(DSP Executable)\u0026#34; as SkelFile note bottom of SkelFile \u0026lt;b\u0026gt;Skel 文件\u0026lt;/b\u0026gt; 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component \u0026#34;Assets (model.onnx)\u0026#34; as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle \u0026#34;2. Android System / Vendor Libs\u0026#34; as LAYER_SYS { component \u0026#34;libadsprpc.so (FastRPC Framework)\u0026#34; as FastRPC } rectangle \u0026#34;3. Linux Kernel Space\u0026#34; as LAYER_KERNEL { component \u0026#34;adsprpc.ko (FastRPC Driver)\u0026#34; as Driver component \u0026#34;ION / SMMU\\n(Shared Memory)\u0026#34; as Mem } } \u0026#39; --- DSP Subsystem --- rectangle \u0026#34;DSP Subsystem (Hexagon cDSP/HTP)\u0026#34; as DSP_DOMAIN { component \u0026#34;QuRT OS (Real-time Kernel)\u0026#34; as QuRT package \u0026#34;Signed PD (Protection Domain)\u0026#34; { component \u0026#34;Skel Instance (Running Code)\u0026#34; as SkelRun component \u0026#34;HTP Hardware (Tensor Cores)\u0026#34; as HTP_HW } } } \u0026#39; --- 详细调用关系 --- AppCode -down-\u0026gt; ORT : 1. Run() ORT .left.\u0026gt; Model: Read \u0026amp; Parse ORT -down-\u0026gt; QNN_EP : 2. Get EP QNN_EP -down-\u0026gt; QnnHtp : 3. Create Backend QnnHtp -down-\u0026gt; QnnStub : 4. Load specific Stub QnnStub -down-\u0026gt; FastRPC : 5. remote_handle_open() FastRPC -down-\u0026gt; Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver \u0026lt;-\u0026gt; QuRT : 7. Context Switch / Wake up QuRT .up.\u0026gt; Driver : 8. Request Skel Driver .up.\u0026gt; FastRPC : 9. Callback FastRPC .left.\u0026gt; SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.\u0026gt; Mem : 11. Map to ION Mem .down.\u0026gt; SkelRun : 12. Load into PD QuRT -down-\u0026gt; SkelRun : 13. Execute Graph SkelRun -down-\u0026gt; HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。\n","keywords":[],"articleBody":"1. 概述 本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 FastRPC 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。\n@startuml !theme plain skinparam backgroundColor white skinparam defaultFontName Arial skinparam defaultFontSize 14 skinparam defaultFontColor black skinparam arrowColor black skinparam nodesep 60 skinparam ranksep 50 skinparam rectangle { BackgroundColor #ECEFF1 BorderColor #607D8B RoundCorner 8 } skinparam package { BackgroundColor #E3F2FD BorderColor #1E88E5 FontStyle bold } skinparam component { BackgroundColor #E8F5E9 BorderColor #2E7D32 } title QNN HTP (ONNX Runtime) Architecture Flow node \"Qualcomm SoC (System on Chip)\" { ' --- CPU Subsystem (Android) --- rectangle \"CPU Subsystem (Application Processor)\" as CPU_DOMAIN { rectangle \"1. Android User Space (APK Process)\" as LAYER_APP { component \"Business Logic\\n(Kotlin/Java/C++)\" as AppCode note right of AppCode 关键配置: setenv(\"ADSP_LIBRARY_PATH\", nativeLibraryDir, 1); end note package \"Native Libraries (jniLibs / lib/arm64)\" { component \"libonnxruntime.so\" as ORT component \"libonnxruntime_providers_qnn.so\" as QNN_EP package \"QNN SDK CPU Libs\" { component \"libQnnHtp.so\\n(Backend Manager)\" as QnnHtp component \"libQnnHtpV[xx]Stub.so\\n(CPU Proxy)\" as QnnStub } component \"libQnnHtpV[xx]Skel.so\\n(DSP Executable)\" as SkelFile note bottom of SkelFile Skel 文件 虽然打包在 CPU 文件系统 但必须由 FastRPC 读取并 加载到 DSP 运行 end note } component \"Assets (model.onnx)\" as Model note top of Model 由 ORT 在 CPU 端 直接读取并解析 end note } rectangle \"2. Android System / Vendor Libs\" as LAYER_SYS { component \"libadsprpc.so (FastRPC Framework)\" as FastRPC } rectangle \"3. Linux Kernel Space\" as LAYER_KERNEL { component \"adsprpc.ko (FastRPC Driver)\" as Driver component \"ION / SMMU\\n(Shared Memory)\" as Mem } } ' --- DSP Subsystem --- rectangle \"DSP Subsystem (Hexagon cDSP/HTP)\" as DSP_DOMAIN { component \"QuRT OS (Real-time Kernel)\" as QuRT package \"Signed PD (Protection Domain)\" { component \"Skel Instance (Running Code)\" as SkelRun component \"HTP Hardware (Tensor Cores)\" as HTP_HW } } } ' --- 详细调用关系 --- AppCode -down-\u003e ORT : 1. Run() ORT .left.\u003e Model: Read \u0026 Parse ORT -down-\u003e QNN_EP : 2. Get EP QNN_EP -down-\u003e QnnHtp : 3. Create Backend QnnHtp -down-\u003e QnnStub : 4. Load specific Stub QnnStub -down-\u003e FastRPC : 5. remote_handle_open() FastRPC -down-\u003e Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE) Driver \u003c-\u003e QuRT : 7. Context Switch / Wake up QuRT .up.\u003e Driver : 8. Request Skel Driver .up.\u003e FastRPC : 9. Callback FastRPC .left.\u003e SkelFile : 10. Read from ADSP_LIBRARY_PATH FastRPC .down.\u003e Mem : 11. Map to ION Mem .down.\u003e SkelRun : 12. Load into PD QuRT -down-\u003e SkelRun : 13. Execute Graph SkelRun -down-\u003e HTP_HW : 14. Compute @enduml 2. 核心组件分层 2.1 Android User Space (应用层) 这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。\nBusiness Logic: 你的业务代码（Kotlin/Java/C++）。\n关键配置: 必须在初始化时设置环境变量 setenv(\"ADSP_LIBRARY_PATH\", nativeLibraryDir, 1)，否则 FastRPC 将无法找到 Skel 文件。\nONNX Runtime (ORT): 微软提供的统一推理引擎 (libonnxruntime.so)。\nQNN Execution Provider (EP): ORT 与 QNN 之间的适配层 (libonnxruntime_providers_qnn.so)。\nQNN CPU Libraries:\nlibQnnHtp.so: Backend Manager，负责管理 HTP 后端的生命周期。\nlibQnnHtpV[xx]Stub.so: CPU Proxy (桩)，负责在 CPU 端打包数据和指令，并通过 RPC 发送给 DSP。\nSkel File (关键):\nlibQnnHtpV[xx]Skel.so: DSP Executable (骨架)。这是真正运行在 NPU 上的“服务端”代码。\n注意: 尽管它物理上存储在 APK 的 lib/arm64 目录下（CPU 文件系统），但它不在 CPU 上执行，而是被传输到 DSP 内存中运行。\n2.2 Android System \u0026 Kernel (系统与内核层) 负责 CPU 与 DSP 之间的通信桥梁。\nlibadsprpc.so (FastRPC Framework): Android 系统提供的用户空间库，用于发起 RPC 调用。 adsprpc.ko (FastRPC Driver): Linux 内核驱动，负责处理内存映射、中断和跨核通信。 ION / SMMU: 共享内存管理器。允许 CPU 和 DSP 访问同一块物理内存（零拷贝），显著提高大数据传输效率。 2.3 DSP Subsystem (硬件层) 高通 Hexagon 处理器的运行环境。\nQuRT OS: 高通的实时微内核 (Real-time Kernel)，管理 DSP 资源。 Signed PD (Protection Domain): 受保护的进程域。为了安全，未签名的代码无法在此运行。 Skel Instance: 加载进内存并正在运行的 Skel.so 实例。 HTP Hardware: 实际执行张量计算的硬件核心。 3. 详细调用流程 (Step-by-Step) 流程分为五个主要阶段，对应图中的编号 1-14。\n第一阶段：应用发起 (App Invocation) Run(): 业务代码调用 ONNX Runtime 的推理接口。 Get EP: ORT 识别到配置了 QNN，将任务分发给 QNN EP。 Create Backend: EP 调用 libQnnHtp.so 初始化 HTP 后端。 Load Stub: 后端管理器根据当前芯片型号，加载对应的桩文件（如 libQnnHtpV81Stub.so）。 第二阶段：RPC 桥接 (RPC Bridging) remote_handle_open(): Stub 库调用系统的 libadsprpc.so，请求连接 DSP。 ioctl (INVOKE): 用户空间库通过 ioctl 系统调用进入内核驱动 adsprpc.ko。 第三阶段：DSP 唤醒 (Wake up) Context Switch: 内核驱动发送硬件中断，唤醒沉睡中的 DSP 子系统 (QuRT OS)。 第四阶段：Skel 加载回环 (The Side-load Loop) —— 最关键步骤 这是最容易出错的环节。DSP 自身没有文件系统，它需要“反向”请求 CPU 提供代码文件。 8. Request Skel: QuRT 发现需要运行 V81 版本的代码，向内核驱动请求 libQnnHtpV81Skel.so。 9. Callback: 驱动无法直接读文件，于是回调 (Callback) 到用户空间的 libadsprpc.so。 10. Read file (Red Arrow): libadsprpc.so 根据之前设置的 ADSP_LIBRARY_PATH 环境变量，在 APK 的安装目录下找到并读取 Skel 文件。 11. Map to ION: 将读取的文件内容写入 ION 共享内存。 12. Load into PD: DSP 从共享内存中读取代码，通过签名验证后，加载到保护域 (PD) 中成为可执行实例。\n第五阶段：硬件执行 (Execution) Execute Graph: QuRT 调度 Skel Instance 开始工作。 Compute: Skel 驱动底层的 HTP 硬件进行矩阵运算，并将结果原路返回。 4. 开发与调试重点 Skel 文件必须打包: 务必确保 libQnnHtpV[xx]Skel.so 被正确打包进 APK 的 jniLibs 或 assets 中。如果 DSP 请求文件时（步骤 8-10）在路径中找不到文件，初始化将直接失败。 环境变量设置: 图中 Note 提到的 setenv(\"ADSP_LIBRARY_PATH\", ...) 是必不可少的。因为系统的 FastRPC 库默认不知道你的 App 安装在哪个随机生成的路径下，必须显式告知。 版本匹配: Stub（CPU侧）和 Skel（DSP侧）必须属于同一个 QNN SDK 版本，否则在握手阶段会因协议不一致而崩溃。 ","wordCount":"675","inLanguage":"en","datePublished":"2025-08-27T17:17:50+08:00","dateModified":"2025-08-27T17:17:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/explore-ai/onnx-runtime/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/explore-ai/>Explore AI</a></div><h1 class="post-title entry-hint-parent">QNN HTP (ONNX Runtime) 架构与调用流程详解</h1><div class=post-meta><span title='2025-08-27 17:17:50 +0800 CST'>August 27, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;675 words</div></header><div class=post-content><h2 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><p>本架构图展示了从 Android 应用层（CPU）到高通 Hexagon DSP（NPU）层的完整调用链路。核心机制是利用 <strong>FastRPC</strong> 跨越处理器边界，将存储在 CPU 文件系统中的 NPU 驱动代码（Skel）动态加载到 DSP 中运行，从而实现模型的高性能推理。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
skinparam backgroundColor white
skinparam defaultFontName Arial
skinparam defaultFontSize 14
skinparam defaultFontColor black
skinparam arrowColor black
skinparam nodesep 60
skinparam ranksep 50
skinparam rectangle {
    BackgroundColor #ECEFF1
    BorderColor #607D8B
    RoundCorner 8
}
skinparam package {
    BackgroundColor #E3F2FD
    BorderColor #1E88E5
    FontStyle bold
}
skinparam component {
    BackgroundColor #E8F5E9
    BorderColor #2E7D32
}

title QNN HTP (ONNX Runtime) Architecture Flow

node &#34;Qualcomm SoC (System on Chip)&#34; {

    &#39; --- CPU Subsystem (Android) ---
    rectangle &#34;CPU Subsystem (Application Processor)&#34; as CPU_DOMAIN {

        rectangle &#34;1. Android User Space (APK Process)&#34; as LAYER_APP {
            component &#34;Business Logic\n(Kotlin/Java/C++)&#34; as AppCode
            note right of AppCode
               &lt;b&gt;关键配置:&lt;/b&gt;
               setenv(&#34;ADSP_LIBRARY_PATH&#34;, 
               nativeLibraryDir, 1);
            end note

            package &#34;Native Libraries (jniLibs / lib/arm64)&#34; {
                component &#34;libonnxruntime.so&#34; as ORT
                component &#34;libonnxruntime_providers_qnn.so&#34; as QNN_EP
                
                package &#34;QNN SDK CPU Libs&#34; {
                    component &#34;libQnnHtp.so\n(Backend Manager)&#34; as QnnHtp
                    component &#34;libQnnHtpV[xx]Stub.so\n(CPU Proxy)&#34; as QnnStub
                }
                
                component &#34;libQnnHtpV[xx]Skel.so\n(DSP Executable)&#34; as SkelFile
                note bottom of SkelFile
                   &lt;b&gt;Skel 文件&lt;/b&gt;
                   虽然打包在 CPU 文件系统
                   但必须由 FastRPC 读取并
                   加载到 DSP 运行
                end note
            }

            component &#34;Assets (model.onnx)&#34; as Model
            note top of Model
               由 ORT 在 CPU 端
               直接读取并解析
            end note
        }

        rectangle &#34;2. Android System / Vendor Libs&#34; as LAYER_SYS {
            component &#34;libadsprpc.so (FastRPC Framework)&#34; as FastRPC
        }

        rectangle &#34;3. Linux Kernel Space&#34; as LAYER_KERNEL {
            component &#34;adsprpc.ko (FastRPC Driver)&#34; as Driver
            component &#34;ION / SMMU\n(Shared Memory)&#34; as Mem
        }
    }

    &#39; --- DSP Subsystem ---
    rectangle &#34;DSP Subsystem (Hexagon cDSP/HTP)&#34; as DSP_DOMAIN {
        component &#34;QuRT OS (Real-time Kernel)&#34; as QuRT

        package &#34;Signed PD (Protection Domain)&#34; {
            component &#34;Skel Instance (Running Code)&#34; as SkelRun
            component &#34;HTP Hardware (Tensor Cores)&#34; as HTP_HW
        }
    }
}

&#39; --- 详细调用关系 ---
AppCode -down-&gt; ORT : 1. Run()
ORT .left.&gt; Model: Read &amp; Parse
ORT -down-&gt; QNN_EP : 2. Get EP
QNN_EP -down-&gt; QnnHtp : 3. Create Backend
QnnHtp -down-&gt; QnnStub : 4. Load specific Stub

QnnStub -down-&gt; FastRPC : 5. remote_handle_open()
FastRPC -down-&gt; Driver : 6. ioctl (FASTRPC_IOCTL_INVOKE)
Driver &lt;-&gt; QuRT : 7. Context Switch / Wake up

QuRT .up.&gt; Driver : 8. Request Skel
Driver .up.&gt; FastRPC : 9. Callback
FastRPC .left.&gt; SkelFile : 10. Read from ADSP_LIBRARY_PATH
FastRPC .down.&gt; Mem : 11. Map to ION
Mem .down.&gt; SkelRun : 12. Load into PD

QuRT -down-&gt; SkelRun : 13. Execute Graph
SkelRun -down-&gt; HTP_HW : 14. Compute
@enduml
</code></pre><h2 id=2-核心组件分层>2. 核心组件分层<a hidden class=anchor aria-hidden=true href=#2-核心组件分层>#</a></h2><h3 id=21-android-user-space-应用层>2.1 Android User Space (应用层)<a hidden class=anchor aria-hidden=true href=#21-android-user-space-应用层>#</a></h3><p>这是应用程序运行的进程空间，包含了业务代码和所有的第三方依赖库。</p><ul><li><p><strong>Business Logic</strong>: 你的业务代码（Kotlin/Java/C++）。</p></li><li><p><strong>关键配置</strong>: 必须在初始化时设置环境变量 <code>setenv("ADSP_LIBRARY_PATH", nativeLibraryDir, 1)</code>，否则 FastRPC 将无法找到 Skel 文件。</p></li><li><p><strong>ONNX Runtime (ORT)</strong>: 微软提供的统一推理引擎 (<code>libonnxruntime.so</code>)。</p></li><li><p><strong>QNN Execution Provider (EP)</strong>: ORT 与 QNN 之间的适配层 (<code>libonnxruntime_providers_qnn.so</code>)。</p></li><li><p><strong>QNN CPU Libraries</strong>:</p></li><li><p><code>libQnnHtp.so</code>: <strong>Backend Manager</strong>，负责管理 HTP 后端的生命周期。</p></li><li><p><code>libQnnHtpV[xx]Stub.so</code>: <strong>CPU Proxy (桩)</strong>，负责在 CPU 端打包数据和指令，并通过 RPC 发送给 DSP。</p></li><li><p><strong>Skel File (关键)</strong>:</p></li><li><p><code>libQnnHtpV[xx]Skel.so</code>: <strong>DSP Executable (骨架)</strong>。这是真正运行在 NPU 上的“服务端”代码。</p></li><li><p><strong>注意</strong>: 尽管它物理上存储在 APK 的 <code>lib/arm64</code> 目录下（CPU 文件系统），但它<strong>不</strong>在 CPU 上执行，而是被传输到 DSP 内存中运行。</p></li></ul><h3 id=22-android-system--kernel-系统与内核层>2.2 Android System & Kernel (系统与内核层)<a hidden class=anchor aria-hidden=true href=#22-android-system--kernel-系统与内核层>#</a></h3><p>负责 CPU 与 DSP 之间的通信桥梁。</p><ul><li><strong>libadsprpc.so (FastRPC Framework)</strong>: Android 系统提供的用户空间库，用于发起 RPC 调用。</li><li><strong>adsprpc.ko (FastRPC Driver)</strong>: Linux 内核驱动，负责处理内存映射、中断和跨核通信。</li><li><strong>ION / SMMU</strong>: 共享内存管理器。允许 CPU 和 DSP 访问同一块物理内存（零拷贝），显著提高大数据传输效率。</li></ul><h3 id=23-dsp-subsystem-硬件层>2.3 DSP Subsystem (硬件层)<a hidden class=anchor aria-hidden=true href=#23-dsp-subsystem-硬件层>#</a></h3><p>高通 Hexagon 处理器的运行环境。</p><ul><li><strong>QuRT OS</strong>: 高通的实时微内核 (Real-time Kernel)，管理 DSP 资源。</li><li><strong>Signed PD (Protection Domain)</strong>: 受保护的进程域。为了安全，未签名的代码无法在此运行。</li><li><strong>Skel Instance</strong>: 加载进内存并正在运行的 <code>Skel.so</code> 实例。</li><li><strong>HTP Hardware</strong>: 实际执行张量计算的硬件核心。</li></ul><hr><h2 id=3-详细调用流程-step-by-step>3. 详细调用流程 (Step-by-Step)<a hidden class=anchor aria-hidden=true href=#3-详细调用流程-step-by-step>#</a></h2><p>流程分为五个主要阶段，对应图中的编号 <strong>1-14</strong>。</p><h3 id=第一阶段应用发起-app-invocation>第一阶段：应用发起 (App Invocation)<a hidden class=anchor aria-hidden=true href=#第一阶段应用发起-app-invocation>#</a></h3><ol><li><strong>Run()</strong>: 业务代码调用 ONNX Runtime 的推理接口。</li><li><strong>Get EP</strong>: ORT 识别到配置了 QNN，将任务分发给 QNN EP。</li><li><strong>Create Backend</strong>: EP 调用 <code>libQnnHtp.so</code> 初始化 HTP 后端。</li><li><strong>Load Stub</strong>: 后端管理器根据当前芯片型号，加载对应的桩文件（如 <code>libQnnHtpV81Stub.so</code>）。</li></ol><h3 id=第二阶段rpc-桥接-rpc-bridging>第二阶段：RPC 桥接 (RPC Bridging)<a hidden class=anchor aria-hidden=true href=#第二阶段rpc-桥接-rpc-bridging>#</a></h3><ol start=5><li><strong>remote_handle_open()</strong>: Stub 库调用系统的 <code>libadsprpc.so</code>，请求连接 DSP。</li><li><strong>ioctl (INVOKE)</strong>: 用户空间库通过 <code>ioctl</code> 系统调用进入内核驱动 <code>adsprpc.ko</code>。</li></ol><h3 id=第三阶段dsp-唤醒-wake-up>第三阶段：DSP 唤醒 (Wake up)<a hidden class=anchor aria-hidden=true href=#第三阶段dsp-唤醒-wake-up>#</a></h3><ol start=7><li><strong>Context Switch</strong>: 内核驱动发送硬件中断，唤醒沉睡中的 DSP 子系统 (QuRT OS)。</li></ol><h3 id=第四阶段skel-加载回环-the-side-load-loop--最关键步骤>第四阶段：Skel 加载回环 (The Side-load Loop) —— <strong>最关键步骤</strong><a hidden class=anchor aria-hidden=true href=#第四阶段skel-加载回环-the-side-load-loop--最关键步骤>#</a></h3><p>这是最容易出错的环节。DSP 自身没有文件系统，它需要“反向”请求 CPU 提供代码文件。
8. <strong>Request Skel</strong>: QuRT 发现需要运行 V81 版本的代码，向内核驱动请求 <code>libQnnHtpV81Skel.so</code>。
9. <strong>Callback</strong>: 驱动无法直接读文件，于是<strong>回调</strong> (Callback) 到用户空间的 <code>libadsprpc.so</code>。
10. <strong>Read file (Red Arrow)</strong>: <code>libadsprpc.so</code> 根据之前设置的 <code>ADSP_LIBRARY_PATH</code> 环境变量，在 APK 的安装目录下找到并读取 Skel 文件。
11. <strong>Map to ION</strong>: 将读取的文件内容写入 ION 共享内存。
12. <strong>Load into PD</strong>: DSP 从共享内存中读取代码，通过签名验证后，加载到保护域 (PD) 中成为可执行实例。</p><h3 id=第五阶段硬件执行-execution>第五阶段：硬件执行 (Execution)<a hidden class=anchor aria-hidden=true href=#第五阶段硬件执行-execution>#</a></h3><ol start=13><li><strong>Execute Graph</strong>: QuRT 调度 <code>Skel Instance</code> 开始工作。</li><li><strong>Compute</strong>: Skel 驱动底层的 HTP 硬件进行矩阵运算，并将结果原路返回。</li></ol><hr><h2 id=4-开发与调试重点>4. 开发与调试重点<a hidden class=anchor aria-hidden=true href=#4-开发与调试重点>#</a></h2><ul><li><strong>Skel 文件必须打包</strong>: 务必确保 <code>libQnnHtpV[xx]Skel.so</code> 被正确打包进 APK 的 <code>jniLibs</code> 或 <code>assets</code> 中。如果 DSP 请求文件时（步骤 8-10）在路径中找不到文件，初始化将直接失败。</li><li><strong>环境变量设置</strong>: 图中 Note 提到的 <code>setenv("ADSP_LIBRARY_PATH", ...)</code> 是必不可少的。因为系统的 FastRPC 库默认不知道你的 App 安装在哪个随机生成的路径下，必须显式告知。</li><li><strong>版本匹配</strong>: Stub（CPU侧）和 Skel（DSP侧）必须属于同一个 QNN SDK 版本，否则在握手阶段会因协议不一致而崩溃。</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>