<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OEM 多品牌多用户动态主题引擎 — 软件架构设计文档 | Ethen 的实验室</title><meta name=keywords content><meta name=description content="版本历史
版本：1.0
日期：2025-08-08
作者：Assistant (基于您提供的需求与设计稿)

目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。


目录

概述
需求映射（与优先级）
总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）
组件设计与职责
主题包规范与安装流程（manifest、校验、签名）
个性化定制实现（推荐方案）
AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）
数据模型（ThemeDB）与同步策略
安全与权限方案
性能优化要点与进程/刷新策略
测试计划与上线验证要点
替代方案对比与决策理由（含“动态生成 RRO APK”结论）
风险清单与缓解措施
迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构


1. 概述
本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。

2. 需求映射（优先级）
将原始 14 项需求按优先级分为必需/强烈期望/可选：

必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。
强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。
可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。

架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。

3. 总体架构（两种部署选型）
概览
主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="OEM 多品牌多用户动态主题引擎 — 软件架构设计文档"><meta property="og:description" content="版本历史 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)
目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。
目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。
2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：
必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。
3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="explore-ai"><meta property="article:published_time" content="2025-08-03T17:17:50+08:00"><meta property="article:modified_time" content="2025-08-03T17:17:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="OEM 多品牌多用户动态主题引擎 — 软件架构设计文档"><meta name=twitter:description content="版本历史
版本：1.0
日期：2025-08-08
作者：Assistant (基于您提供的需求与设计稿)

目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。


目录

概述
需求映射（与优先级）
总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）
组件设计与职责
主题包规范与安装流程（manifest、校验、签名）
个性化定制实现（推荐方案）
AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）
数据模型（ThemeDB）与同步策略
安全与权限方案
性能优化要点与进程/刷新策略
测试计划与上线验证要点
替代方案对比与决策理由（含“动态生成 RRO APK”结论）
风险清单与缓解措施
迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构


1. 概述
本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。

2. 需求映射（优先级）
将原始 14 项需求按优先级分为必需/强烈期望/可选：

必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。
强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。
可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。

架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。

3. 总体架构（两种部署选型）
概览
主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Explore AI","item":"https://ethen-cao.github.io/ethenslab/explore-ai/"},{"@type":"ListItem","position":2,"name":"OEM 多品牌多用户动态主题引擎 — 软件架构设计文档","item":"https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OEM 多品牌多用户动态主题引擎 — 软件架构设计文档","name":"OEM 多品牌多用户动态主题引擎 — 软件架构设计文档","description":"版本历史 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)\n目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。\n目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。\n2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：\n必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。\n3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。\n","keywords":[],"articleBody":"版本历史 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)\n目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。\n目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。\n2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：\n必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。\n3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。\n方案 A（推荐用于安全优先 / 多客户端复用） TMS 作为框架级系统服务，驻留在 system_server，通过 AIDL 对授权客户端（主题商店、运营工具）提供能力。 优点：安全、可复用、生命周期与系统一致。 缺点：迭代需 OTA，开发门槛高。 方案 B（推荐用于单一官方商店、快速迭代） TMS 集成到主题商店 App（system app / shared-signature），直接调用 OMS/PMS，管理 ThemeDB。 优点：迭代快、实现简单。 缺点：安全依赖 App 权限、难以对第三方开放 API。 选择策略：如果 OEM 需要多个授权客户端或极高安全性，选方案 A；若仅官方商店并追求快速迭代，选方案 B。文档后文以方案 A 为主展开（需 AIDL、ThemeDB 层）并在适当位置指出方案 B 的变体实现方式。\n4. 组件设计与职责 4.1 ThemeManagerService (TMS) —（若方案 A） 职责\n主题包生命周期管理（install / uninstall / upgrade / rollback） 主题元数据管理（ThemeDB 读写） 兼容性检查（minSdkVersion / targetPlatform / RRO 依赖） 签名与来源校验（结合 PMS） AIDL 接口暴露：installThemeForUser, applyThemeForUser, getThemeListForUser, applyCustomization, rollbackTheme… 生成/应用“定制策略”（但不在设备端编译新的、未签名 APK） 实现要点\nTMS 执行敏感操作在系统权限上下文（system_uid）并进行审计日志。 不在设备端进行 platform 签名操作；若需服务器签名则协调云端流程。 4.2 Theme Store App (StoreApp) 职责\nUI / 商城 / 下载逻辑 解压 .zip、MD5 校验、通过 FileProvider 提供 APK Uri 发起 installThemeForUser 的 AIDL 调用（方案 A）或直接调用 PMS/OMS（方案 B） 主题预览（使用 Context.createPackageContext 加载 RRO 资源） 4.3 OverlayManagerService (OMS) 负责启用/停用 overlay（RRO） TMS/StoreApp 请求时做 enable/disable，并发出资源变更通知 4.4 PackageManagerService (PMS) 负责 APK 安装流程（签名校验、包管理） TMS 调用 PMS 安装时，PMS 返回安装结果 4.5 AssetManager / ResourcesImpl 读取已安装 RRO 中实际资源 推荐：为“可定制参数”提供运行时参数 hook（若 OEM 接受对 Framework 修改） 4.6 ThemeDB（持久层） 存储主题元数据、已安装主题、用户当前主题、版本/时间戳、兼容性状态、定制参数元数据 访问方式：方案 A：仅 TMS 直接访问 DB，外部通过 AIDL；方案 B：StoreApp 可直接管理但应使用 ContentProvider 或 API 层避免并发。 5. 主题包规范与安装流程 5.1 主题包（主题.zip）结构（建议） theme.zip ├─ manifest.json // themeId, name, versionName, zipMd5, rroApks[] ├─ rros/ │ ├─ framework-res.apk │ ├─ systemui.apk │ └─ ... └─ previews/ ├─ preview_lock.png └─ preview_home.png manifest.json 中每个 rroApk 应包含 file, targetPackage, md5, versionCode, minSdkVersion, isCustomizable。\n5.2 签名与校验 必须：每个 RRO APK 要求云端签名（platform 或 OEM 签名与目标 overlay 签名相兼容），设备侧仅做签名验证，不重签。\n下载逻辑：\nStoreApp 下载 zip 并比对 zipMd5； 解压后逐个对比每个 APK 的 md5 与 manifest 中记录； 通过 FileProvider 提交 APK Uri 给 TMS（AIDL）或直接用 PMS 安装（B 方案）。 若 APK 签名不匹配 → 标记为“不兼容”并拒绝安装。\n5.3 安装/回滚流程（概要） 在 TMS 中实现事务化安装：逐个安装 RRO APK，若任一失败则回滚已安装的 RRO（卸载）。 安装成功后写入 ThemeDB，并调用 OMS 启用（或等待用户 apply）。 回滚：调用 OMS 停用并卸载无效 APK，恢复上一个版本的 metadata。 （参见附录 PlantUML 安装/应用序列示例）\n6. 个性化定制实现（推荐方案） 设计目标：支持用户调色/字体等“微调”，在量产设备上无需设备端 platform 私钥、不会重新签名 APK，且能实时/准即时生效。\n推荐混合方案（强烈推荐） 主要思路：组合 预编译 Overlay 套件（覆盖常见选项） + 参数化运行时替换（Framework hook 或受控运行时映射）。\n预编译多套 Overlay：覆盖常见的颜色/字体/图标形状组合（快速切换、零签名）。\n个性化（任意颜色值）采用“参数表 + 轻量替换机制”：\n方案 6.A（若可修改 Framework）：在 ResourcesImpl/AssetManager 增加参数映射层（theme_params.json），系统资源读取时优先查映射（支持即时生效，最优用户体验）。 方案 6.B（不改 Framework）：预置一个“可写资源宿主”RRO模板（已签名）在系统分区中，里面使用占位资源引用；StoreApp 只更新该模板 RRO 外部的资产（例如放在 /data/system/theme_assets/ 并由 SystemUI/Launcher 等进程读取）。该方案需要受控的 App 支持（SystemUI/Launcher 加载外部 assets）。 动态生成完整 APK 并在设备端签名 不可行（量产设备无 platform 私钥）。\n具体实现（方案 6.A 假设可改 Framework） 新增 ThemeParamManager（SystemService 或 TMS 子组件）：\n存放 /data/system/theme_params.json（userId 隔离） 提供 getParam(resourceId) 接口给 ResourcesImpl 当用户修改参数时写入 JSON 并发出 ThemeParamChanged 广播；ResourcesImpl 在下一次资源加载查询新值并生效（可配合进程级刷新） 优点：即时生效、无 APK 安装、灵活\n缺点：需要 ROM 修改，维护成本增加\n7. AIDL / API 设计（方案 A：TMS 在 framework） 下面是核心 AIDL 接口草案（简化版，实际需更多错误码与安全校验）：\n文件: IThemeManagerService.aidl\npackage com.oem.themes; import android.net.Uri; import com.oem.themes.ThemeInfo; import com.oem.themes.CustomizationRequest; interface IThemeManagerService { boolean installThemeForUser(in List apkUris, int userId); List getThemeListForUser(int userId); ThemeInfo getThemeInfoForUser(String themeId, int userId); boolean applyThemeForUser(String themeId, int userId); ThemeInfo getAppliedThemeForUser(int userId); boolean rollbackTheme(String themeId, int userId); boolean deleteThemeForUser(String themeId, int userId); boolean applyCustomization(in CustomizationRequest request, int userId); boolean clearCustomization(int userId); boolean restoreDefaultTheme(int userId); } CustomizationRequest 包含：map 参数（colorPrimary 等）、baseThemeId、timestamp、requestId。\n鉴权：只有具有 MANAGE_THEME 权限或 platform-signed 的客户端方可调用敏感方法。所有调用均记录审计。\n8. 数据模型（ThemeDB）与同步策略 8.1 ThemeDB 表结构（简化） themes:\nthemeId TEXT PRIMARY KEY name TEXT author TEXT version TEXT zipMd5 TEXT installed BOOLEAN installed_at TIMESTAMP compatible BOOLEAN isCustomizable BOOLEAN rro_entries:\nid INTEGER PK themeId TEXT FK apkFile TEXT targetPackage TEXT md5 TEXT user_applied:\nuserId INTEGER themeId TEXT customParams JSON applied_at TIMESTAMP audit_log:\nid, action, caller, userId, timestamp, details 8.2 云同步策略 云端保存 themeId、appliedTheme、customParams、lastModifiedTs。\n同步策略：\n使用 Last-Write-Wins（按 timestamp）作为默认，若冲突则提示用户选择或采用 device-preferred 策略。 远程下发仅传 themeId + diff(customParams)；若设备缺少 theme package，则提示下载或自动下载（需用户授权或商店策略）。 9. 安全与权限方案 要点 签名校验：PMS 必须校验 RRO APK 签名，且 RRO 的签名必须与 target 包策略相兼容（通常与系统/框架签名匹配或在白名单内）。 最小权限：AIDL 接口加权限注解，只有经过授权的包（platform-signed 或持有 MANAGE_THEME）才可调用。 来源白名单：仅允许来自 OEM 云端或被白名单的域名下载的 theme.zip（在商店端做校验）。 审计与回滚：重要操作写审计 log；异常安装需自动回滚并上报。 SELinux：为 theme assets、临时目录设置合适的 SELinux 文件上下文，避免越权访问。 Network：下载使用 HTTPS，校验证书并校验 hash。 10. 性能优化要点与刷新策略 性能优化 异步安装/IO：安装、校验、DB 写入均在后台线程，不阻塞 UI。 并发限制：限制同时安装主题包数量（例如单线程队列）以避免 IO 瓶颈。 缓存：TMS 可缓存 ThemeDB 的热数据，定期持久化。 预热：安装主题包后，不立即启用全部 overlay，可延迟到用户 apply 时启用，减少开机时间开销。 精准刷新策略 资源分级刷新：\nSystemUI/Launcher/Settings：必需重启进程或调用 Activity.recreate()。 普通应用：仅当使用了 framework 资源时才触发（使用 notifyChange 列表过滤）。 避免全局重启：通过 OMS/AMS 的通知机制，仅重启受影响的进程，减少卡顿。\n11. 测试计划与上线验证要点 测试维度 功能测试：安装、卸载、启用、回滚、预览、定制、跨设备同步。 兼容性测试：不同 Android 版本，目标包的 minSdk/targetSdk 检查。 性能测试：安装时间、启用 overlay 的延迟、内存/CPU 影响、开机时间影响。 安全测试：签名绕过、篡改主题包、权限滥用（模拟非授权 App 调用）。 多用户测试：不同用户的隔离性、并发切换边界条件。 回归测试：系统升级（OTA）后，主题状态保持/兼容检测。 上线验证 小批量灰度（10% 设备），记录异常上报。 开启详细审计日志与故障自动回滚开关，确保用户能回退到出厂主题。 12. 替代方案对比与决策理由 动态生成 RRO APK（设备端构建 + 签名）——不可行（量产环境） 理由：设备无 platform 私钥；本地签名无法通过签名校验；伪造签名或绕过检查会破坏安全模型。除非将签名流程放在受控的服务器端并将签名后的 APK 下发设备（延迟高、复杂）。 可行备选 预编译 Overlay 组合（主方式）：高稳定性、快速切换、零签名问题。缺点：组合数量爆炸需平衡。 参数化运行时替换（需 Framework 改动）：最佳用户体验（即时生效），但需要 ROM 改动与维护。 模板 RRO + 外部 assets（部分方案）：能在不签名的前提下让 SystemUI/Launcher 加载外部资源，但需要 App 与系统组件配合。 决策建议（基于需求）：采用 预编译 Overlay + 参数化运行时替换（若可改 Framework 则启用） 的混合方案。TMS 放置：若安全/多客户端需求高 → 放在 framework；若仅官方商店且追求迭代 → 集成在 store app。\n13. 风险清单与缓解措施 风险 严重度 缓解 动态本地签名 RRO 不可行 高 改用云端签名或模板/参数化方案 未授权安装恶意 RRO 高 严格签名+来源校验+安装白名单 ThemeDB 并发冲突 中 通过 Service 封装访问或 ContentProvider + 事务 主题切换导致 SystemUI 崩溃 高 上线自动回滚；在启用 overlay 前做兼容性 dry-run 多设备同步冲突 中 使用 timestamp/version；冲突提示用户 性能（切换卡顿） 中 精准刷新、只重启受影响进程；预编译 Overlay 14. 迭代路线图（建议） Sprint 0（原型）：实现 StoreApp 下载流程、manifest 校验、用现有预编译 Overlay 实现 install/apply（方案 B 最快）— 验证端到端流程。 Sprint 1（TMS 基本版）：设计并实现 TMS（框架版）最小可用接口：install/apply/getList/rollback。搭建 ThemeDB、审计日志。 Sprint 2（个性化）：实现预编译 Overlay 的组合映射；引入参数化机制原型（若可改 Framework）。 Sprint 3（安全/云）：上线签名验证、来源白名单、云端签名流水线（仅 server 端签名生产）。 Sprint 4（优化/量产）：性能调优、回归测试、灰度发布、监控与上报。 附录 PlantUML：安装与应用序列（TMS 在 framework） @startuml actor User participant \"ThemeStore App\" as Store participant \"ThemeManagerService (TMS)\" as TMS participant \"PackageManagerService (PMS)\" as PMS participant \"OverlayManagerService (OMS)\" as OMS database \"ThemeDB\" as DB User -\u003e Store: 选择下载 theme.zip Store -\u003e Store: 下载并校验 zipMd5 Store -\u003e Store: 解压并校验每个 APK md5 Store -\u003e TMS: installThemeForUser(listOfUris, userId) TMS -\u003e PMS: installPackage(uri) PMS --\u003e TMS: installResult(success) TMS -\u003e DB: insert theme metadata TMS --\u003e Store: installThemeForUser result Store -\u003e TMS: applyThemeForUser(themeId, userId) TMS -\u003e OMS: setEnabled(rroA, true, userId) TMS -\u003e OMS: setEnabled(rroB, true, userId) TMS -\u003e DB: update user_applied OMS -\u003e SystemUI: notify resources changed SystemUI -\u003e SystemUI: reload/recreate @enduml 示例 ThemeDB 建表（SQL） CREATE TABLE themes ( themeId TEXT PRIMARY KEY, name TEXT, author TEXT, version TEXT, zipMd5 TEXT, installed INTEGER, installed_at INTEGER, compatible INTEGER, isCustomizable INTEGER ); CREATE TABLE rro_entries ( id INTEGER PRIMARY KEY AUTOINCREMENT, themeId TEXT, apkFile TEXT, targetPackage TEXT, md5 TEXT ); CREATE TABLE user_applied ( userId INTEGER, themeId TEXT, customParams TEXT, applied_at INTEGER, PRIMARY KEY (userId) ); CREATE TABLE audit_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, action TEXT, caller TEXT, userId INTEGER, timestamp INTEGER, details TEXT ); 总结（行动项） 选择 TMS 放置位置（framework vs App）— 按你们对安全/迭代的权衡给出决策。若需我可基于你们组织偏好给出直接建议。\n放弃设备端动态签名 RRO 的实现，改用“预编译 Overlay + 参数化运行时替换”的混合实现。\n下一步交付：我可以（任选其一）：\n生成完整的 IThemeManagerService.aidl 及 Java 框架层骨架代码；或 生成主题商店（StoreApp）侧的安装/预览/同步详细实现样例；或 给出 Framework hook (ResourcesImpl) 的详细设计与伪代码，用于实现参数化运行时替换。 你想优先让我做哪一项？我会直接做出对应交付。\n","wordCount":"966","inLanguage":"en","datePublished":"2025-08-03T17:17:50+08:00","dateModified":"2025-08-03T17:17:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/explore-ai/>Explore AI</a></div><h1 class="post-title entry-hint-parent">OEM 多品牌多用户动态主题引擎 — 软件架构设计文档</h1><div class=post-meta><span title='2025-08-03 17:17:50 +0800 CST'>August 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;966 words</div></header><div class=post-content><h1 id=版本历史>版本历史<a hidden class=anchor aria-hidden=true href=#版本历史>#</a></h1><p><strong>版本</strong>：1.0
<strong>日期</strong>：2025-08-08
<strong>作者</strong>：Assistant (基于您提供的需求与设计稿)</p><blockquote><p>目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。</p></blockquote><hr><h1 id=目录>目录<a hidden class=anchor aria-hidden=true href=#目录>#</a></h1><ol><li>概述</li><li>需求映射（与优先级）</li><li>总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）</li><li>组件设计与职责</li><li>主题包规范与安装流程（manifest、校验、签名）</li><li>个性化定制实现（推荐方案）</li><li>AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）</li><li>数据模型（ThemeDB）与同步策略</li><li>安全与权限方案</li><li>性能优化要点与进程/刷新策略</li><li>测试计划与上线验证要点</li><li>替代方案对比与决策理由（含“动态生成 RRO APK”结论）</li><li>风险清单与缓解措施</li><li>迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构</li></ol><hr><h1 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h1><p>本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：<strong>安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度</strong>。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。</p><hr><h1 id=2-需求映射优先级>2. 需求映射（优先级）<a hidden class=anchor aria-hidden=true href=#2-需求映射优先级>#</a></h1><p>将原始 14 项需求按优先级分为必需/强烈期望/可选：</p><ul><li><strong>必需（M）</strong>：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。</li><li><strong>强烈期望（H）</strong>：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。</li><li><strong>可选/增强（L）</strong>：个性化定制（9），跨设备同步（10），多语言（13）。</li></ul><p>架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。</p><hr><h1 id=3-总体架构两种部署选型>3. 总体架构（两种部署选型）<a hidden class=anchor aria-hidden=true href=#3-总体架构两种部署选型>#</a></h1><h2 id=概览>概览<a hidden class=anchor aria-hidden=true href=#概览>#</a></h2><p>主要参与方：<strong>主题商店 App (StoreApp)</strong>、<strong>ThemeManagerService (TMS)</strong>、<strong>OverlayManagerService (OMS)</strong>、<strong>PackageManagerService (PMS)</strong>、<strong>AssetManager</strong>、<strong>ThemeDB</strong> 与 <strong>OEM 云服务</strong>（Server / AccountServer）。</p><h3 id=方案-a推荐用于安全优先--多客户端复用>方案 A（推荐用于安全优先 / 多客户端复用）<a hidden class=anchor aria-hidden=true href=#方案-a推荐用于安全优先--多客户端复用>#</a></h3><ul><li><strong>TMS 作为框架级系统服务</strong>，驻留在 <code>system_server</code>，通过 AIDL 对授权客户端（主题商店、运营工具）提供能力。</li><li>优点：安全、可复用、生命周期与系统一致。</li><li>缺点：迭代需 OTA，开发门槛高。</li></ul><h3 id=方案-b推荐用于单一官方商店快速迭代>方案 B（推荐用于单一官方商店、快速迭代）<a hidden class=anchor aria-hidden=true href=#方案-b推荐用于单一官方商店快速迭代>#</a></h3><ul><li><strong>TMS 集成到主题商店 App</strong>（system app / shared-signature），直接调用 OMS/PMS，管理 ThemeDB。</li><li>优点：迭代快、实现简单。</li><li>缺点：安全依赖 App 权限、难以对第三方开放 API。</li></ul><p><strong>选择策略</strong>：如果 OEM 需要多个授权客户端或极高安全性，选方案 A；若仅官方商店并追求快速迭代，选方案 B。文档后文以方案 A 为主展开（需 AIDL、ThemeDB 层）并在适当位置指出方案 B 的变体实现方式。</p><hr><h1 id=4-组件设计与职责>4. 组件设计与职责<a hidden class=anchor aria-hidden=true href=#4-组件设计与职责>#</a></h1><h2 id=41-thememanagerservice-tms-若方案-a>4.1 ThemeManagerService (TMS) —（若方案 A）<a hidden class=anchor aria-hidden=true href=#41-thememanagerservice-tms-若方案-a>#</a></h2><p><strong>职责</strong></p><ul><li>主题包生命周期管理（install / uninstall / upgrade / rollback）</li><li>主题元数据管理（ThemeDB 读写）</li><li>兼容性检查（minSdkVersion / targetPlatform / RRO 依赖）</li><li>签名与来源校验（结合 PMS）</li><li>AIDL 接口暴露：installThemeForUser, applyThemeForUser, getThemeListForUser, applyCustomization, rollbackTheme&mldr;</li><li>生成/应用“定制策略”（但不在设备端编译新的、未签名 APK）</li></ul><p><strong>实现要点</strong></p><ul><li>TMS 执行敏感操作在系统权限上下文（system_uid）并进行审计日志。</li><li>不在设备端进行 platform 签名操作；若需服务器签名则协调云端流程。</li></ul><h2 id=42-theme-store-app-storeapp>4.2 Theme Store App (StoreApp)<a hidden class=anchor aria-hidden=true href=#42-theme-store-app-storeapp>#</a></h2><p><strong>职责</strong></p><ul><li>UI / 商城 / 下载逻辑</li><li>解压 .zip、MD5 校验、通过 FileProvider 提供 APK Uri</li><li>发起 installThemeForUser 的 AIDL 调用（方案 A）或直接调用 PMS/OMS（方案 B）</li><li>主题预览（使用 Context.createPackageContext 加载 RRO 资源）</li></ul><h2 id=43-overlaymanagerservice-oms>4.3 OverlayManagerService (OMS)<a hidden class=anchor aria-hidden=true href=#43-overlaymanagerservice-oms>#</a></h2><ul><li>负责启用/停用 overlay（RRO）</li><li>TMS/StoreApp 请求时做 enable/disable，并发出资源变更通知</li></ul><h2 id=44-packagemanagerservice-pms>4.4 PackageManagerService (PMS)<a hidden class=anchor aria-hidden=true href=#44-packagemanagerservice-pms>#</a></h2><ul><li>负责 APK 安装流程（签名校验、包管理）</li><li>TMS 调用 PMS 安装时，PMS 返回安装结果</li></ul><h2 id=45-assetmanager--resourcesimpl>4.5 AssetManager / ResourcesImpl<a hidden class=anchor aria-hidden=true href=#45-assetmanager--resourcesimpl>#</a></h2><ul><li>读取已安装 RRO 中实际资源</li><li>推荐：为“可定制参数”提供运行时参数 hook（若 OEM 接受对 Framework 修改）</li></ul><h2 id=46-themedb持久层>4.6 ThemeDB（持久层）<a hidden class=anchor aria-hidden=true href=#46-themedb持久层>#</a></h2><ul><li>存储主题元数据、已安装主题、用户当前主题、版本/时间戳、兼容性状态、定制参数元数据</li><li>访问方式：<strong>方案 A</strong>：仅 TMS 直接访问 DB，外部通过 AIDL；<strong>方案 B</strong>：StoreApp 可直接管理但应使用 ContentProvider 或 API 层避免并发。</li></ul><hr><h1 id=5-主题包规范与安装流程>5. 主题包规范与安装流程<a hidden class=anchor aria-hidden=true href=#5-主题包规范与安装流程>#</a></h1><h2 id=51-主题包主题zip结构建议>5.1 主题包（主题.zip）结构（建议）<a hidden class=anchor aria-hidden=true href=#51-主题包主题zip结构建议>#</a></h2><pre tabindex=0><code>theme.zip
├─ manifest.json           // themeId, name, versionName, zipMd5, rroApks[]
├─ rros/
│   ├─ framework-res.apk
│   ├─ systemui.apk
│   └─ ... 
└─ previews/
    ├─ preview_lock.png
    └─ preview_home.png
</code></pre><p><code>manifest.json</code> 中每个 rroApk 应包含 <code>file</code>, <code>targetPackage</code>, <code>md5</code>, <code>versionCode</code>, <code>minSdkVersion</code>, <code>isCustomizable</code>。</p><h2 id=52-签名与校验>5.2 签名与校验<a hidden class=anchor aria-hidden=true href=#52-签名与校验>#</a></h2><ul><li><p><strong>必须</strong>：每个 RRO APK 要求云端签名（platform 或 OEM 签名与目标 overlay 签名相兼容），设备侧仅做签名验证，不重签。</p></li><li><p>下载逻辑：</p><ol><li>StoreApp 下载 zip 并比对 <code>zipMd5</code>；</li><li>解压后逐个对比每个 APK 的 md5 与 manifest 中记录；</li><li>通过 FileProvider 提交 APK Uri 给 TMS（AIDL）或直接用 PMS 安装（B 方案）。</li></ol></li><li><p>若 APK 签名不匹配 → 标记为“不兼容”并拒绝安装。</p></li></ul><h2 id=53-安装回滚流程概要>5.3 安装/回滚流程（概要）<a hidden class=anchor aria-hidden=true href=#53-安装回滚流程概要>#</a></h2><ul><li>在 TMS 中实现事务化安装：逐个安装 RRO APK，若任一失败则回滚已安装的 RRO（卸载）。</li><li>安装成功后写入 ThemeDB，并调用 OMS 启用（或等待用户 apply）。</li><li>回滚：调用 OMS 停用并卸载无效 APK，恢复上一个版本的 metadata。</li></ul><p>（参见附录 PlantUML 安装/应用序列示例）</p><hr><h1 id=6-个性化定制实现推荐方案>6. 个性化定制实现（推荐方案）<a hidden class=anchor aria-hidden=true href=#6-个性化定制实现推荐方案>#</a></h1><p><strong>设计目标</strong>：支持用户调色/字体等“微调”，在量产设备上无需设备端 platform 私钥、不会重新签名 APK，且能实时/准即时生效。</p><h2 id=推荐混合方案强烈推荐>推荐混合方案（强烈推荐）<a hidden class=anchor aria-hidden=true href=#推荐混合方案强烈推荐>#</a></h2><ul><li><p><strong>主要思路</strong>：组合 <strong>预编译 Overlay 套件（覆盖常见选项） + 参数化运行时替换（Framework hook 或受控运行时映射）</strong>。</p><ul><li><p>预编译多套 Overlay：覆盖常见的颜色/字体/图标形状组合（快速切换、零签名）。</p></li><li><p>个性化（任意颜色值）采用“参数表 + 轻量替换机制”：</p><ul><li><strong>方案 6.A（若可修改 Framework）</strong>：在 ResourcesImpl/AssetManager 增加参数映射层（theme_params.json），系统资源读取时优先查映射（支持即时生效，最优用户体验）。</li><li><strong>方案 6.B（不改 Framework）</strong>：预置一个“可写资源宿主”RRO模板（已签名）在系统分区中，里面使用占位资源引用；StoreApp 只更新该模板 RRO 外部的资产（例如放在 <code>/data/system/theme_assets/</code> 并由 SystemUI/Launcher 等进程读取）。该方案需要受控的 App 支持（SystemUI/Launcher 加载外部 assets）。</li></ul></li><li><p>动态生成完整 APK 并在设备端签名 <strong>不可行</strong>（量产设备无 platform 私钥）。</p></li></ul></li></ul><h2 id=具体实现方案-6a-假设可改-framework>具体实现（方案 6.A 假设可改 Framework）<a hidden class=anchor aria-hidden=true href=#具体实现方案-6a-假设可改-framework>#</a></h2><ul><li><p>新增 <code>ThemeParamManager</code>（SystemService 或 TMS 子组件）：</p><ul><li>存放 <code>/data/system/theme_params.json</code>（userId 隔离）</li><li>提供 <code>getParam(resourceId)</code> 接口给 ResourcesImpl</li><li>当用户修改参数时写入 JSON 并发出 <code>ThemeParamChanged</code> 广播；ResourcesImpl 在下一次资源加载查询新值并生效（可配合进程级刷新）</li></ul></li><li><p>优点：即时生效、无 APK 安装、灵活</p></li><li><p>缺点：需要 ROM 修改，维护成本增加</p></li></ul><hr><h1 id=7-aidl--api-设计方案-atms-在-framework>7. AIDL / API 设计（方案 A：TMS 在 framework）<a hidden class=anchor aria-hidden=true href=#7-aidl--api-设计方案-atms-在-framework>#</a></h1><p>下面是核心 AIDL 接口草案（简化版，实际需更多错误码与安全校验）：</p><p><strong>文件</strong>: <code>IThemeManagerService.aidl</code></p><pre tabindex=0><code class=language-aidl data-lang=aidl>package com.oem.themes;

import android.net.Uri;
import com.oem.themes.ThemeInfo;
import com.oem.themes.CustomizationRequest;

interface IThemeManagerService {
    boolean installThemeForUser(in List&lt;Uri&gt; apkUris, int userId);
    List&lt;ThemeInfo&gt; getThemeListForUser(int userId);
    ThemeInfo getThemeInfoForUser(String themeId, int userId);
    boolean applyThemeForUser(String themeId, int userId);
    ThemeInfo getAppliedThemeForUser(int userId);
    boolean rollbackTheme(String themeId, int userId);
    boolean deleteThemeForUser(String themeId, int userId);
    boolean applyCustomization(in CustomizationRequest request, int userId);
    boolean clearCustomization(int userId);
    boolean restoreDefaultTheme(int userId);
}
</code></pre><p><strong>CustomizationRequest</strong> 包含：map&lt;String,String> 参数（colorPrimary 等）、baseThemeId、timestamp、requestId。</p><p><strong>鉴权</strong>：只有具有 <code>MANAGE_THEME</code> 权限或 platform-signed 的客户端方可调用敏感方法。所有调用均记录审计。</p><hr><h1 id=8-数据模型themedb与同步策略>8. 数据模型（ThemeDB）与同步策略<a hidden class=anchor aria-hidden=true href=#8-数据模型themedb与同步策略>#</a></h1><h2 id=81-themedb-表结构简化>8.1 ThemeDB 表结构（简化）<a hidden class=anchor aria-hidden=true href=#81-themedb-表结构简化>#</a></h2><ul><li><p><code>themes</code>:</p><ul><li><code>themeId</code> TEXT PRIMARY KEY</li><li><code>name</code> TEXT</li><li><code>author</code> TEXT</li><li><code>version</code> TEXT</li><li><code>zipMd5</code> TEXT</li><li><code>installed</code> BOOLEAN</li><li><code>installed_at</code> TIMESTAMP</li><li><code>compatible</code> BOOLEAN</li><li><code>isCustomizable</code> BOOLEAN</li></ul></li><li><p><code>rro_entries</code>:</p><ul><li><code>id</code> INTEGER PK</li><li><code>themeId</code> TEXT FK</li><li><code>apkFile</code> TEXT</li><li><code>targetPackage</code> TEXT</li><li><code>md5</code> TEXT</li></ul></li><li><p><code>user_applied</code>:</p><ul><li><code>userId</code> INTEGER</li><li><code>themeId</code> TEXT</li><li><code>customParams</code> JSON</li><li><code>applied_at</code> TIMESTAMP</li></ul></li><li><p><code>audit_log</code>:</p><ul><li><code>id</code>, <code>action</code>, <code>caller</code>, <code>userId</code>, <code>timestamp</code>, <code>details</code></li></ul></li></ul><h2 id=82-云同步策略>8.2 云同步策略<a hidden class=anchor aria-hidden=true href=#82-云同步策略>#</a></h2><ul><li><p>云端保存 <code>themeId</code>、<code>appliedTheme</code>、<code>customParams</code>、<code>lastModifiedTs</code>。</p></li><li><p>同步策略：</p><ul><li>使用 <strong>Last-Write-Wins</strong>（按 timestamp）作为默认，若冲突则提示用户选择或采用 device-preferred 策略。</li><li>远程下发仅传 <code>themeId + diff(customParams)</code>；若设备缺少 theme package，则提示下载或自动下载（需用户授权或商店策略）。</li></ul></li></ul><hr><h1 id=9-安全与权限方案>9. 安全与权限方案<a hidden class=anchor aria-hidden=true href=#9-安全与权限方案>#</a></h1><h2 id=要点>要点<a hidden class=anchor aria-hidden=true href=#要点>#</a></h2><ul><li><strong>签名校验</strong>：PMS 必须校验 RRO APK 签名，且 RRO 的签名必须与 target 包策略相兼容（通常与系统/框架签名匹配或在白名单内）。</li><li><strong>最小权限</strong>：AIDL 接口加权限注解，只有经过授权的包（platform-signed 或持有 MANAGE_THEME）才可调用。</li><li><strong>来源白名单</strong>：仅允许来自 OEM 云端或被白名单的域名下载的 theme.zip（在商店端做校验）。</li><li><strong>审计与回滚</strong>：重要操作写审计 log；异常安装需自动回滚并上报。</li><li><strong>SELinux</strong>：为 theme assets、临时目录设置合适的 SELinux 文件上下文，避免越权访问。</li><li><strong>Network</strong>：下载使用 HTTPS，校验证书并校验 hash。</li></ul><hr><h1 id=10-性能优化要点与刷新策略>10. 性能优化要点与刷新策略<a hidden class=anchor aria-hidden=true href=#10-性能优化要点与刷新策略>#</a></h1><h2 id=性能优化>性能优化<a hidden class=anchor aria-hidden=true href=#性能优化>#</a></h2><ul><li><strong>异步安装/IO</strong>：安装、校验、DB 写入均在后台线程，不阻塞 UI。</li><li><strong>并发限制</strong>：限制同时安装主题包数量（例如单线程队列）以避免 IO 瓶颈。</li><li><strong>缓存</strong>：TMS 可缓存 ThemeDB 的热数据，定期持久化。</li><li><strong>预热</strong>：安装主题包后，不立即启用全部 overlay，可延迟到用户 apply 时启用，减少开机时间开销。</li></ul><h2 id=精准刷新策略>精准刷新策略<a hidden class=anchor aria-hidden=true href=#精准刷新策略>#</a></h2><ul><li><p><strong>资源分级刷新</strong>：</p><ul><li><strong>SystemUI/Launcher/Settings</strong>：必需重启进程或调用 <code>Activity.recreate()</code>。</li><li><strong>普通应用</strong>：仅当使用了 framework 资源时才触发（使用 <code>notifyChange</code> 列表过滤）。</li></ul></li><li><p><strong>避免全局重启</strong>：通过 OMS/AMS 的通知机制，仅重启受影响的进程，减少卡顿。</p></li></ul><hr><h1 id=11-测试计划与上线验证要点>11. 测试计划与上线验证要点<a hidden class=anchor aria-hidden=true href=#11-测试计划与上线验证要点>#</a></h1><h2 id=测试维度>测试维度<a hidden class=anchor aria-hidden=true href=#测试维度>#</a></h2><ul><li><strong>功能测试</strong>：安装、卸载、启用、回滚、预览、定制、跨设备同步。</li><li><strong>兼容性测试</strong>：不同 Android 版本，目标包的 minSdk/targetSdk 检查。</li><li><strong>性能测试</strong>：安装时间、启用 overlay 的延迟、内存/CPU 影响、开机时间影响。</li><li><strong>安全测试</strong>：签名绕过、篡改主题包、权限滥用（模拟非授权 App 调用）。</li><li><strong>多用户测试</strong>：不同用户的隔离性、并发切换边界条件。</li><li><strong>回归测试</strong>：系统升级（OTA）后，主题状态保持/兼容检测。</li></ul><h2 id=上线验证>上线验证<a hidden class=anchor aria-hidden=true href=#上线验证>#</a></h2><ul><li>小批量灰度（10% 设备），记录异常上报。</li><li>开启详细审计日志与故障自动回滚开关，确保用户能回退到出厂主题。</li></ul><hr><h1 id=12-替代方案对比与决策理由>12. 替代方案对比与决策理由<a hidden class=anchor aria-hidden=true href=#12-替代方案对比与决策理由>#</a></h1><h2 id=动态生成-rro-apk设备端构建--签名不可行量产环境>动态生成 RRO APK（设备端构建 + 签名）——<strong>不可行（量产环境）</strong><a hidden class=anchor aria-hidden=true href=#动态生成-rro-apk设备端构建--签名不可行量产环境>#</a></h2><ul><li><strong>理由</strong>：设备无 platform 私钥；本地签名无法通过签名校验；伪造签名或绕过检查会破坏安全模型。除非将签名流程放在受控的服务器端并将签名后的 APK 下发设备（延迟高、复杂）。</li></ul><h2 id=可行备选>可行备选<a hidden class=anchor aria-hidden=true href=#可行备选>#</a></h2><ul><li><strong>预编译 Overlay 组合（主方式）</strong>：高稳定性、快速切换、零签名问题。缺点：组合数量爆炸需平衡。</li><li><strong>参数化运行时替换（需 Framework 改动）</strong>：最佳用户体验（即时生效），但需要 ROM 改动与维护。</li><li><strong>模板 RRO + 外部 assets（部分方案）</strong>：能在不签名的前提下让 SystemUI/Launcher 加载外部资源，但需要 App 与系统组件配合。</li></ul><p><strong>决策建议</strong>（基于需求）：采用 <strong>预编译 Overlay + 参数化运行时替换（若可改 Framework 则启用）</strong> 的混合方案。TMS 放置：若安全/多客户端需求高 → 放在 framework；若仅官方商店且追求迭代 → 集成在 store app。</p><hr><h1 id=13-风险清单与缓解措施>13. 风险清单与缓解措施<a hidden class=anchor aria-hidden=true href=#13-风险清单与缓解措施>#</a></h1><table><thead><tr><th>风险</th><th style=text-align:right>严重度</th><th>缓解</th></tr></thead><tbody><tr><td>动态本地签名 RRO 不可行</td><td style=text-align:right>高</td><td>改用云端签名或模板/参数化方案</td></tr><tr><td>未授权安装恶意 RRO</td><td style=text-align:right>高</td><td>严格签名+来源校验+安装白名单</td></tr><tr><td>ThemeDB 并发冲突</td><td style=text-align:right>中</td><td>通过 Service 封装访问或 ContentProvider + 事务</td></tr><tr><td>主题切换导致 SystemUI 崩溃</td><td style=text-align:right>高</td><td>上线自动回滚；在启用 overlay 前做兼容性 dry-run</td></tr><tr><td>多设备同步冲突</td><td style=text-align:right>中</td><td>使用 timestamp/version；冲突提示用户</td></tr><tr><td>性能（切换卡顿）</td><td style=text-align:right>中</td><td>精准刷新、只重启受影响进程；预编译 Overlay</td></tr></tbody></table><hr><h1 id=14-迭代路线图建议>14. 迭代路线图（建议）<a hidden class=anchor aria-hidden=true href=#14-迭代路线图建议>#</a></h1><ul><li><strong>Sprint 0（原型）</strong>：实现 StoreApp 下载流程、manifest 校验、用现有预编译 Overlay 实现 install/apply（方案 B 最快）— 验证端到端流程。</li><li><strong>Sprint 1（TMS 基本版）</strong>：设计并实现 TMS（框架版）最小可用接口：install/apply/getList/rollback。搭建 ThemeDB、审计日志。</li><li><strong>Sprint 2（个性化）</strong>：实现预编译 Overlay 的组合映射；引入参数化机制原型（若可改 Framework）。</li><li><strong>Sprint 3（安全/云）</strong>：上线签名验证、来源白名单、云端签名流水线（仅 server 端签名生产）。</li><li><strong>Sprint 4（优化/量产）</strong>：性能调优、回归测试、灰度发布、监控与上报。</li></ul><hr><h1 id=附录>附录<a hidden class=anchor aria-hidden=true href=#附录>#</a></h1><h2 id=plantuml安装与应用序列tms-在-framework>PlantUML：安装与应用序列（TMS 在 framework）<a hidden class=anchor aria-hidden=true href=#plantuml安装与应用序列tms-在-framework>#</a></h2><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
actor User
participant &#34;ThemeStore App&#34; as Store
participant &#34;ThemeManagerService (TMS)&#34; as TMS
participant &#34;PackageManagerService (PMS)&#34; as PMS
participant &#34;OverlayManagerService (OMS)&#34; as OMS
database &#34;ThemeDB&#34; as DB

User -&gt; Store: 选择下载 theme.zip
Store -&gt; Store: 下载并校验 zipMd5
Store -&gt; Store: 解压并校验每个 APK md5
Store -&gt; TMS: installThemeForUser(listOfUris, userId)
TMS -&gt; PMS: installPackage(uri)
PMS --&gt; TMS: installResult(success)
TMS -&gt; DB: insert theme metadata
TMS --&gt; Store: installThemeForUser result
Store -&gt; TMS: applyThemeForUser(themeId, userId)
TMS -&gt; OMS: setEnabled(rroA, true, userId)
TMS -&gt; OMS: setEnabled(rroB, true, userId)
TMS -&gt; DB: update user_applied
OMS -&gt; SystemUI: notify resources changed
SystemUI -&gt; SystemUI: reload/recreate
@enduml
</code></pre><h2 id=示例-themedb-建表sql>示例 ThemeDB 建表（SQL）<a hidden class=anchor aria-hidden=true href=#示例-themedb-建表sql>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> themes (
</span></span><span style=display:flex><span>  themeId TEXT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name TEXT,
</span></span><span style=display:flex><span>  author TEXT,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>version</span> TEXT,
</span></span><span style=display:flex><span>  zipMd5 TEXT,
</span></span><span style=display:flex><span>  installed INTEGER,
</span></span><span style=display:flex><span>  installed_at INTEGER,
</span></span><span style=display:flex><span>  compatible INTEGER,
</span></span><span style=display:flex><span>  isCustomizable INTEGER
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> rro_entries (
</span></span><span style=display:flex><span>  id INTEGER <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> AUTOINCREMENT,
</span></span><span style=display:flex><span>  themeId TEXT,
</span></span><span style=display:flex><span>  apkFile TEXT,
</span></span><span style=display:flex><span>  targetPackage TEXT,
</span></span><span style=display:flex><span>  md5 TEXT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> user_applied (
</span></span><span style=display:flex><span>  userId INTEGER,
</span></span><span style=display:flex><span>  themeId TEXT,
</span></span><span style=display:flex><span>  customParams TEXT,
</span></span><span style=display:flex><span>  applied_at INTEGER,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (userId)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> audit_log (
</span></span><span style=display:flex><span>  id INTEGER <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> AUTOINCREMENT,
</span></span><span style=display:flex><span>  action TEXT,
</span></span><span style=display:flex><span>  caller TEXT,
</span></span><span style=display:flex><span>  userId INTEGER,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>timestamp</span> INTEGER,
</span></span><span style=display:flex><span>  details TEXT
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><hr><h1 id=总结行动项>总结（行动项）<a hidden class=anchor aria-hidden=true href=#总结行动项>#</a></h1><ol><li><p><strong>选择 TMS 放置位置</strong>（framework vs App）— 按你们对安全/迭代的权衡给出决策。若需我可基于你们组织偏好给出直接建议。</p></li><li><p><strong>放弃设备端动态签名 RRO 的实现</strong>，改用“预编译 Overlay + 参数化运行时替换”的混合实现。</p></li><li><p><strong>下一步交付</strong>：我可以（任选其一）：</p><ul><li>生成完整的 <code>IThemeManagerService.aidl</code> 及 Java 框架层骨架代码；或</li><li>生成主题商店（StoreApp）侧的安装/预览/同步详细实现样例；或</li><li>给出 Framework hook (ResourcesImpl) 的详细设计与伪代码，用于实现参数化运行时替换。</li></ul></li></ol><p>你想优先让我做哪一项？我会直接做出对应交付。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>