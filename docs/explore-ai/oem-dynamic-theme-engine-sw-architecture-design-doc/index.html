<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OEM 多品牌多用户动态主题引擎 — 软件架构设计文档 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="
版本：1.0
日期：2025-08-08
作者：Assistant (基于您提供的需求与设计稿)

目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。

目录

概述
需求映射（与优先级）
总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）
组件设计与职责
主题包规范与安装流程（manifest、校验、签名）
个性化定制实现（推荐方案）
AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）
数据模型（ThemeDB）与同步策略
安全与权限方案
性能优化要点与进程/刷新策略
测试计划与上线验证要点
替代方案对比与决策理由（含“动态生成 RRO APK”结论）
风险清单与缓解措施
迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构


1. 概述
本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。

2. 需求映射（优先级）
将原始 14 项需求按优先级分为必需/强烈期望/可选：

必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。
强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。
可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。

架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。

3. 总体架构（两种部署选型）
概览
主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css" integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="OEM 多品牌多用户动态主题引擎 — 软件架构设计文档">
  <meta property="og:description" content=" 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)
目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。
目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。
2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：
必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。
3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="explore-ai">
    <meta property="article:published_time" content="2025-08-03T17:17:50+08:00">
    <meta property="article:modified_time" content="2025-08-03T17:17:50+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OEM 多品牌多用户动态主题引擎 — 软件架构设计文档">
<meta name="twitter:description" content="
版本：1.0
日期：2025-08-08
作者：Assistant (基于您提供的需求与设计稿)

目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。

目录

概述
需求映射（与优先级）
总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）
组件设计与职责
主题包规范与安装流程（manifest、校验、签名）
个性化定制实现（推荐方案）
AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）
数据模型（ThemeDB）与同步策略
安全与权限方案
性能优化要点与进程/刷新策略
测试计划与上线验证要点
替代方案对比与决策理由（含“动态生成 RRO APK”结论）
风险清单与缓解措施
迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构


1. 概述
本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。

2. 需求映射（优先级）
将原始 14 项需求按优先级分为必需/强烈期望/可选：

必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。
强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。
可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。

架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。

3. 总体架构（两种部署选型）
概览
主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Explore AI",
      "item": "https://ethen-cao.github.io/ethenslab/explore-ai/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OEM 多品牌多用户动态主题引擎 — 软件架构设计文档",
      "item": "https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OEM 多品牌多用户动态主题引擎 — 软件架构设计文档",
  "name": "OEM 多品牌多用户动态主题引擎 — 软件架构设计文档",
  "description": " 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)\n目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。\n目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。\n2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：\n必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。\n3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。\n",
  "keywords": [
    
  ],
  "articleBody": " 版本：1.0 日期：2025-08-08 作者：Assistant (基于您提供的需求与设计稿)\n目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。\n目录 概述 需求映射（与优先级） 总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS） 组件设计与职责 主题包规范与安装流程（manifest、校验、签名） 个性化定制实现（推荐方案） AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案） 数据模型（ThemeDB）与同步策略 安全与权限方案 性能优化要点与进程/刷新策略 测试计划与上线验证要点 替代方案对比与决策理由（含“动态生成 RRO APK”结论） 风险清单与缓解措施 迭代路线图（短中长期建议） 附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构 1. 概述 本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。\n2. 需求映射（优先级） 将原始 14 项需求按优先级分为必需/强烈期望/可选：\n必需（M）：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。 强烈期望（H）：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。 可选/增强（L）：个性化定制（9），跨设备同步（10），多语言（13）。 架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。\n3. 总体架构（两种部署选型） 概览 主要参与方：主题商店 App (StoreApp)、ThemeManagerService (TMS)、OverlayManagerService (OMS)、PackageManagerService (PMS)、AssetManager、ThemeDB 与 OEM 云服务（Server / AccountServer）。\n方案 A（推荐用于安全优先 / 多客户端复用） TMS 作为框架级系统服务，驻留在 system_server，通过 AIDL 对授权客户端（主题商店、运营工具）提供能力。 优点：安全、可复用、生命周期与系统一致。 缺点：迭代需 OTA，开发门槛高。 方案 B（推荐用于单一官方商店、快速迭代） TMS 集成到主题商店 App（system app / shared-signature），直接调用 OMS/PMS，管理 ThemeDB。 优点：迭代快、实现简单。 缺点：安全依赖 App 权限、难以对第三方开放 API。 选择策略：如果 OEM 需要多个授权客户端或极高安全性，选方案 A；若仅官方商店并追求快速迭代，选方案 B。文档后文以方案 A 为主展开（需 AIDL、ThemeDB 层）并在适当位置指出方案 B 的变体实现方式。\n4. 组件设计与职责 4.1 ThemeManagerService (TMS) —（若方案 A） 职责\n主题包生命周期管理（install / uninstall / upgrade / rollback） 主题元数据管理（ThemeDB 读写） 兼容性检查（minSdkVersion / targetPlatform / RRO 依赖） 签名与来源校验（结合 PMS） AIDL 接口暴露：installThemeForUser, applyThemeForUser, getThemeListForUser, applyCustomization, rollbackTheme… 生成/应用“定制策略”（但不在设备端编译新的、未签名 APK） 实现要点\nTMS 执行敏感操作在系统权限上下文（system_uid）并进行审计日志。 不在设备端进行 platform 签名操作；若需服务器签名则协调云端流程。 4.2 Theme Store App (StoreApp) 职责\nUI / 商城 / 下载逻辑 解压 .zip、MD5 校验、通过 FileProvider 提供 APK Uri 发起 installThemeForUser 的 AIDL 调用（方案 A）或直接调用 PMS/OMS（方案 B） 主题预览（使用 Context.createPackageContext 加载 RRO 资源） 4.3 OverlayManagerService (OMS) 负责启用/停用 overlay（RRO） TMS/StoreApp 请求时做 enable/disable，并发出资源变更通知 4.4 PackageManagerService (PMS) 负责 APK 安装流程（签名校验、包管理） TMS 调用 PMS 安装时，PMS 返回安装结果 4.5 AssetManager / ResourcesImpl 读取已安装 RRO 中实际资源 推荐：为“可定制参数”提供运行时参数 hook（若 OEM 接受对 Framework 修改） 4.6 ThemeDB（持久层） 存储主题元数据、已安装主题、用户当前主题、版本/时间戳、兼容性状态、定制参数元数据 访问方式：方案 A：仅 TMS 直接访问 DB，外部通过 AIDL；方案 B：StoreApp 可直接管理但应使用 ContentProvider 或 API 层避免并发。 5. 主题包规范与安装流程 5.1 主题包（主题.zip）结构（建议） theme.zip ├─ manifest.json // themeId, name, versionName, zipMd5, rroApks[] ├─ rros/ │ ├─ framework-res.apk │ ├─ systemui.apk │ └─ ... └─ previews/ ├─ preview_lock.png └─ preview_home.png manifest.json 中每个 rroApk 应包含 file, targetPackage, md5, versionCode, minSdkVersion, isCustomizable。\n5.2 签名与校验 必须：每个 RRO APK 要求云端签名（platform 或 OEM 签名与目标 overlay 签名相兼容），设备侧仅做签名验证，不重签。\n下载逻辑：\nStoreApp 下载 zip 并比对 zipMd5； 解压后逐个对比每个 APK 的 md5 与 manifest 中记录； 通过 FileProvider 提交 APK Uri 给 TMS（AIDL）或直接用 PMS 安装（B 方案）。 若 APK 签名不匹配 → 标记为“不兼容”并拒绝安装。\n5.3 安装/回滚流程（概要） 在 TMS 中实现事务化安装：逐个安装 RRO APK，若任一失败则回滚已安装的 RRO（卸载）。 安装成功后写入 ThemeDB，并调用 OMS 启用（或等待用户 apply）。 回滚：调用 OMS 停用并卸载无效 APK，恢复上一个版本的 metadata。 （参见附录 PlantUML 安装/应用序列示例）\n6. 个性化定制实现（推荐方案） 设计目标：支持用户调色/字体等“微调”，在量产设备上无需设备端 platform 私钥、不会重新签名 APK，且能实时/准即时生效。\n推荐混合方案（强烈推荐） 主要思路：组合 预编译 Overlay 套件（覆盖常见选项） + 参数化运行时替换（Framework hook 或受控运行时映射）。\n预编译多套 Overlay：覆盖常见的颜色/字体/图标形状组合（快速切换、零签名）。\n个性化（任意颜色值）采用“参数表 + 轻量替换机制”：\n方案 6.A（若可修改 Framework）：在 ResourcesImpl/AssetManager 增加参数映射层（theme_params.json），系统资源读取时优先查映射（支持即时生效，最优用户体验）。 方案 6.B（不改 Framework）：预置一个“可写资源宿主”RRO模板（已签名）在系统分区中，里面使用占位资源引用；StoreApp 只更新该模板 RRO 外部的资产（例如放在 /data/system/theme_assets/ 并由 SystemUI/Launcher 等进程读取）。该方案需要受控的 App 支持（SystemUI/Launcher 加载外部 assets）。 动态生成完整 APK 并在设备端签名 不可行（量产设备无 platform 私钥）。\n具体实现（方案 6.A 假设可改 Framework） 新增 ThemeParamManager（SystemService 或 TMS 子组件）：\n存放 /data/system/theme_params.json（userId 隔离） 提供 getParam(resourceId) 接口给 ResourcesImpl 当用户修改参数时写入 JSON 并发出 ThemeParamChanged 广播；ResourcesImpl 在下一次资源加载查询新值并生效（可配合进程级刷新） 优点：即时生效、无 APK 安装、灵活\n缺点：需要 ROM 修改，维护成本增加\n7. AIDL / API 设计（方案 A：TMS 在 framework） 下面是核心 AIDL 接口草案（简化版，实际需更多错误码与安全校验）：\n文件: IThemeManagerService.aidl\npackage com.oem.themes; import android.net.Uri; import com.oem.themes.ThemeInfo; import com.oem.themes.CustomizationRequest; interface IThemeManagerService { boolean installThemeForUser(in List apkUris, int userId); List getThemeListForUser(int userId); ThemeInfo getThemeInfoForUser(String themeId, int userId); boolean applyThemeForUser(String themeId, int userId); ThemeInfo getAppliedThemeForUser(int userId); boolean rollbackTheme(String themeId, int userId); boolean deleteThemeForUser(String themeId, int userId); boolean applyCustomization(in CustomizationRequest request, int userId); boolean clearCustomization(int userId); boolean restoreDefaultTheme(int userId); } CustomizationRequest 包含：map 参数（colorPrimary 等）、baseThemeId、timestamp、requestId。\n鉴权：只有具有 MANAGE_THEME 权限或 platform-signed 的客户端方可调用敏感方法。所有调用均记录审计。\n8. 数据模型（ThemeDB）与同步策略 8.1 ThemeDB 表结构（简化） themes:\nthemeId TEXT PRIMARY KEY name TEXT author TEXT version TEXT zipMd5 TEXT installed BOOLEAN installed_at TIMESTAMP compatible BOOLEAN isCustomizable BOOLEAN rro_entries:\nid INTEGER PK themeId TEXT FK apkFile TEXT targetPackage TEXT md5 TEXT user_applied:\nuserId INTEGER themeId TEXT customParams JSON applied_at TIMESTAMP audit_log:\nid, action, caller, userId, timestamp, details 8.2 云同步策略 云端保存 themeId、appliedTheme、customParams、lastModifiedTs。\n同步策略：\n使用 Last-Write-Wins（按 timestamp）作为默认，若冲突则提示用户选择或采用 device-preferred 策略。 远程下发仅传 themeId + diff(customParams)；若设备缺少 theme package，则提示下载或自动下载（需用户授权或商店策略）。 9. 安全与权限方案 要点 签名校验：PMS 必须校验 RRO APK 签名，且 RRO 的签名必须与 target 包策略相兼容（通常与系统/框架签名匹配或在白名单内）。 最小权限：AIDL 接口加权限注解，只有经过授权的包（platform-signed 或持有 MANAGE_THEME）才可调用。 来源白名单：仅允许来自 OEM 云端或被白名单的域名下载的 theme.zip（在商店端做校验）。 审计与回滚：重要操作写审计 log；异常安装需自动回滚并上报。 SELinux：为 theme assets、临时目录设置合适的 SELinux 文件上下文，避免越权访问。 Network：下载使用 HTTPS，校验证书并校验 hash。 10. 性能优化要点与刷新策略 性能优化 异步安装/IO：安装、校验、DB 写入均在后台线程，不阻塞 UI。 并发限制：限制同时安装主题包数量（例如单线程队列）以避免 IO 瓶颈。 缓存：TMS 可缓存 ThemeDB 的热数据，定期持久化。 预热：安装主题包后，不立即启用全部 overlay，可延迟到用户 apply 时启用，减少开机时间开销。 精准刷新策略 资源分级刷新：\nSystemUI/Launcher/Settings：必需重启进程或调用 Activity.recreate()。 普通应用：仅当使用了 framework 资源时才触发（使用 notifyChange 列表过滤）。 避免全局重启：通过 OMS/AMS 的通知机制，仅重启受影响的进程，减少卡顿。\n11. 测试计划与上线验证要点 测试维度 功能测试：安装、卸载、启用、回滚、预览、定制、跨设备同步。 兼容性测试：不同 Android 版本，目标包的 minSdk/targetSdk 检查。 性能测试：安装时间、启用 overlay 的延迟、内存/CPU 影响、开机时间影响。 安全测试：签名绕过、篡改主题包、权限滥用（模拟非授权 App 调用）。 多用户测试：不同用户的隔离性、并发切换边界条件。 回归测试：系统升级（OTA）后，主题状态保持/兼容检测。 上线验证 小批量灰度（10% 设备），记录异常上报。 开启详细审计日志与故障自动回滚开关，确保用户能回退到出厂主题。 12. 替代方案对比与决策理由 动态生成 RRO APK（设备端构建 + 签名）——不可行（量产环境） 理由：设备无 platform 私钥；本地签名无法通过签名校验；伪造签名或绕过检查会破坏安全模型。除非将签名流程放在受控的服务器端并将签名后的 APK 下发设备（延迟高、复杂）。 可行备选 预编译 Overlay 组合（主方式）：高稳定性、快速切换、零签名问题。缺点：组合数量爆炸需平衡。 参数化运行时替换（需 Framework 改动）：最佳用户体验（即时生效），但需要 ROM 改动与维护。 模板 RRO + 外部 assets（部分方案）：能在不签名的前提下让 SystemUI/Launcher 加载外部资源，但需要 App 与系统组件配合。 决策建议（基于需求）：采用 预编译 Overlay + 参数化运行时替换（若可改 Framework 则启用） 的混合方案。TMS 放置：若安全/多客户端需求高 → 放在 framework；若仅官方商店且追求迭代 → 集成在 store app。\n13. 风险清单与缓解措施 风险 严重度 缓解 动态本地签名 RRO 不可行 高 改用云端签名或模板/参数化方案 未授权安装恶意 RRO 高 严格签名+来源校验+安装白名单 ThemeDB 并发冲突 中 通过 Service 封装访问或 ContentProvider + 事务 主题切换导致 SystemUI 崩溃 高 上线自动回滚；在启用 overlay 前做兼容性 dry-run 多设备同步冲突 中 使用 timestamp/version；冲突提示用户 性能（切换卡顿） 中 精准刷新、只重启受影响进程；预编译 Overlay 14. 迭代路线图（建议） Sprint 0（原型）：实现 StoreApp 下载流程、manifest 校验、用现有预编译 Overlay 实现 install/apply（方案 B 最快）— 验证端到端流程。 Sprint 1（TMS 基本版）：设计并实现 TMS（框架版）最小可用接口：install/apply/getList/rollback。搭建 ThemeDB、审计日志。 Sprint 2（个性化）：实现预编译 Overlay 的组合映射；引入参数化机制原型（若可改 Framework）。 Sprint 3（安全/云）：上线签名验证、来源白名单、云端签名流水线（仅 server 端签名生产）。 Sprint 4（优化/量产）：性能调优、回归测试、灰度发布、监控与上报。 附录 PlantUML：安装与应用序列（TMS 在 framework） @startuml actor User participant \"ThemeStore App\" as Store participant \"ThemeManagerService (TMS)\" as TMS participant \"PackageManagerService (PMS)\" as PMS participant \"OverlayManagerService (OMS)\" as OMS database \"ThemeDB\" as DB User -\u003e Store: 选择下载 theme.zip Store -\u003e Store: 下载并校验 zipMd5 Store -\u003e Store: 解压并校验每个 APK md5 Store -\u003e TMS: installThemeForUser(listOfUris, userId) TMS -\u003e PMS: installPackage(uri) PMS --\u003e TMS: installResult(success) TMS -\u003e DB: insert theme metadata TMS --\u003e Store: installThemeForUser result Store -\u003e TMS: applyThemeForUser(themeId, userId) TMS -\u003e OMS: setEnabled(rroA, true, userId) TMS -\u003e OMS: setEnabled(rroB, true, userId) TMS -\u003e DB: update user_applied OMS -\u003e SystemUI: notify resources changed SystemUI -\u003e SystemUI: reload/recreate @enduml 示例 ThemeDB 建表（SQL） CREATE TABLE themes ( themeId TEXT PRIMARY KEY, name TEXT, author TEXT, version TEXT, zipMd5 TEXT, installed INTEGER, installed_at INTEGER, compatible INTEGER, isCustomizable INTEGER ); CREATE TABLE rro_entries ( id INTEGER PRIMARY KEY AUTOINCREMENT, themeId TEXT, apkFile TEXT, targetPackage TEXT, md5 TEXT ); CREATE TABLE user_applied ( userId INTEGER, themeId TEXT, customParams TEXT, applied_at INTEGER, PRIMARY KEY (userId) ); CREATE TABLE audit_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, action TEXT, caller TEXT, userId INTEGER, timestamp INTEGER, details TEXT ); 总结（行动项） 选择 TMS 放置位置（framework vs App）— 按你们对安全/迭代的权衡给出决策。若需我可基于你们组织偏好给出直接建议。\n放弃设备端动态签名 RRO 的实现，改用“预编译 Overlay + 参数化运行时替换”的混合实现。\n下一步交付：我可以（任选其一）：\n生成完整的 IThemeManagerService.aidl 及 Java 框架层骨架代码；或 生成主题商店（StoreApp）侧的安装/预览/同步详细实现样例；或 给出 Framework hook (ResourcesImpl) 的详细设计与伪代码，用于实现参数化运行时替换。 你想优先让我做哪一项？我会直接做出对应交付。\n",
  "wordCount" : "965",
  "inLanguage": "en",
  "datePublished": "2025-08-03T17:17:50+08:00",
  "dateModified": "2025-08-03T17:17:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/qnx/" title="QNX开发">
                    <span>QNX开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/explore-ai/">Explore AI</a></div>
    <h1 class="post-title entry-hint-parent">
      OEM 多品牌多用户动态主题引擎 — 软件架构设计文档
    </h1>
    <div class="post-meta"><span title='2025-08-03 17:17:50 +0800 CST'>August 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;965 words

</div>
  </header> 
  <div class="post-content"><h1></h1>
<p><strong>版本</strong>：1.0
<strong>日期</strong>：2025-08-08
<strong>作者</strong>：Assistant (基于您提供的需求与设计稿)</p>
<blockquote>
<p>目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。</p></blockquote>
<hr>
<h1 id="目录">目录<a hidden class="anchor" aria-hidden="true" href="#目录">#</a></h1>
<ol>
<li>概述</li>
<li>需求映射（与优先级）</li>
<li>总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）</li>
<li>组件设计与职责</li>
<li>主题包规范与安装流程（manifest、校验、签名）</li>
<li>个性化定制实现（推荐方案）</li>
<li>AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）</li>
<li>数据模型（ThemeDB）与同步策略</li>
<li>安全与权限方案</li>
<li>性能优化要点与进程/刷新策略</li>
<li>测试计划与上线验证要点</li>
<li>替代方案对比与决策理由（含“动态生成 RRO APK”结论）</li>
<li>风险清单与缓解措施</li>
<li>迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构</li>
</ol>
<hr>
<h1 id="1-概述">1. 概述<a hidden class="anchor" aria-hidden="true" href="#1-概述">#</a></h1>
<p>本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：<strong>安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度</strong>。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。</p>
<hr>
<h1 id="2-需求映射优先级">2. 需求映射（优先级）<a hidden class="anchor" aria-hidden="true" href="#2-需求映射优先级">#</a></h1>
<p>将原始 14 项需求按优先级分为必需/强烈期望/可选：</p>
<ul>
<li><strong>必需（M）</strong>：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。</li>
<li><strong>强烈期望（H）</strong>：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。</li>
<li><strong>可选/增强（L）</strong>：个性化定制（9），跨设备同步（10），多语言（13）。</li>
</ul>
<p>架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。</p>
<hr>
<h1 id="3-总体架构两种部署选型">3. 总体架构（两种部署选型）<a hidden class="anchor" aria-hidden="true" href="#3-总体架构两种部署选型">#</a></h1>
<h2 id="概览">概览<a hidden class="anchor" aria-hidden="true" href="#概览">#</a></h2>
<p>主要参与方：<strong>主题商店 App (StoreApp)</strong>、<strong>ThemeManagerService (TMS)</strong>、<strong>OverlayManagerService (OMS)</strong>、<strong>PackageManagerService (PMS)</strong>、<strong>AssetManager</strong>、<strong>ThemeDB</strong> 与 <strong>OEM 云服务</strong>（Server / AccountServer）。</p>
<h3 id="方案-a推荐用于安全优先--多客户端复用">方案 A（推荐用于安全优先 / 多客户端复用）<a hidden class="anchor" aria-hidden="true" href="#方案-a推荐用于安全优先--多客户端复用">#</a></h3>
<ul>
<li><strong>TMS 作为框架级系统服务</strong>，驻留在 <code>system_server</code>，通过 AIDL 对授权客户端（主题商店、运营工具）提供能力。</li>
<li>优点：安全、可复用、生命周期与系统一致。</li>
<li>缺点：迭代需 OTA，开发门槛高。</li>
</ul>
<h3 id="方案-b推荐用于单一官方商店快速迭代">方案 B（推荐用于单一官方商店、快速迭代）<a hidden class="anchor" aria-hidden="true" href="#方案-b推荐用于单一官方商店快速迭代">#</a></h3>
<ul>
<li><strong>TMS 集成到主题商店 App</strong>（system app / shared-signature），直接调用 OMS/PMS，管理 ThemeDB。</li>
<li>优点：迭代快、实现简单。</li>
<li>缺点：安全依赖 App 权限、难以对第三方开放 API。</li>
</ul>
<p><strong>选择策略</strong>：如果 OEM 需要多个授权客户端或极高安全性，选方案 A；若仅官方商店并追求快速迭代，选方案 B。文档后文以方案 A 为主展开（需 AIDL、ThemeDB 层）并在适当位置指出方案 B 的变体实现方式。</p>
<hr>
<h1 id="4-组件设计与职责">4. 组件设计与职责<a hidden class="anchor" aria-hidden="true" href="#4-组件设计与职责">#</a></h1>
<h2 id="41-thememanagerservice-tms-若方案-a">4.1 ThemeManagerService (TMS) —（若方案 A）<a hidden class="anchor" aria-hidden="true" href="#41-thememanagerservice-tms-若方案-a">#</a></h2>
<p><strong>职责</strong></p>
<ul>
<li>主题包生命周期管理（install / uninstall / upgrade / rollback）</li>
<li>主题元数据管理（ThemeDB 读写）</li>
<li>兼容性检查（minSdkVersion / targetPlatform / RRO 依赖）</li>
<li>签名与来源校验（结合 PMS）</li>
<li>AIDL 接口暴露：installThemeForUser, applyThemeForUser, getThemeListForUser, applyCustomization, rollbackTheme&hellip;</li>
<li>生成/应用“定制策略”（但不在设备端编译新的、未签名 APK）</li>
</ul>
<p><strong>实现要点</strong></p>
<ul>
<li>TMS 执行敏感操作在系统权限上下文（system_uid）并进行审计日志。</li>
<li>不在设备端进行 platform 签名操作；若需服务器签名则协调云端流程。</li>
</ul>
<h2 id="42-theme-store-app-storeapp">4.2 Theme Store App (StoreApp)<a hidden class="anchor" aria-hidden="true" href="#42-theme-store-app-storeapp">#</a></h2>
<p><strong>职责</strong></p>
<ul>
<li>UI / 商城 / 下载逻辑</li>
<li>解压 .zip、MD5 校验、通过 FileProvider 提供 APK Uri</li>
<li>发起 installThemeForUser 的 AIDL 调用（方案 A）或直接调用 PMS/OMS（方案 B）</li>
<li>主题预览（使用 Context.createPackageContext 加载 RRO 资源）</li>
</ul>
<h2 id="43-overlaymanagerservice-oms">4.3 OverlayManagerService (OMS)<a hidden class="anchor" aria-hidden="true" href="#43-overlaymanagerservice-oms">#</a></h2>
<ul>
<li>负责启用/停用 overlay（RRO）</li>
<li>TMS/StoreApp 请求时做 enable/disable，并发出资源变更通知</li>
</ul>
<h2 id="44-packagemanagerservice-pms">4.4 PackageManagerService (PMS)<a hidden class="anchor" aria-hidden="true" href="#44-packagemanagerservice-pms">#</a></h2>
<ul>
<li>负责 APK 安装流程（签名校验、包管理）</li>
<li>TMS 调用 PMS 安装时，PMS 返回安装结果</li>
</ul>
<h2 id="45-assetmanager--resourcesimpl">4.5 AssetManager / ResourcesImpl<a hidden class="anchor" aria-hidden="true" href="#45-assetmanager--resourcesimpl">#</a></h2>
<ul>
<li>读取已安装 RRO 中实际资源</li>
<li>推荐：为“可定制参数”提供运行时参数 hook（若 OEM 接受对 Framework 修改）</li>
</ul>
<h2 id="46-themedb持久层">4.6 ThemeDB（持久层）<a hidden class="anchor" aria-hidden="true" href="#46-themedb持久层">#</a></h2>
<ul>
<li>存储主题元数据、已安装主题、用户当前主题、版本/时间戳、兼容性状态、定制参数元数据</li>
<li>访问方式：<strong>方案 A</strong>：仅 TMS 直接访问 DB，外部通过 AIDL；<strong>方案 B</strong>：StoreApp 可直接管理但应使用 ContentProvider 或 API 层避免并发。</li>
</ul>
<hr>
<h1 id="5-主题包规范与安装流程">5. 主题包规范与安装流程<a hidden class="anchor" aria-hidden="true" href="#5-主题包规范与安装流程">#</a></h1>
<h2 id="51-主题包主题zip结构建议">5.1 主题包（主题.zip）结构（建议）<a hidden class="anchor" aria-hidden="true" href="#51-主题包主题zip结构建议">#</a></h2>
<pre tabindex="0"><code>theme.zip
├─ manifest.json           // themeId, name, versionName, zipMd5, rroApks[]
├─ rros/
│   ├─ framework-res.apk
│   ├─ systemui.apk
│   └─ ... 
└─ previews/
    ├─ preview_lock.png
    └─ preview_home.png
</code></pre><p><code>manifest.json</code> 中每个 rroApk 应包含 <code>file</code>, <code>targetPackage</code>, <code>md5</code>, <code>versionCode</code>, <code>minSdkVersion</code>, <code>isCustomizable</code>。</p>
<h2 id="52-签名与校验">5.2 签名与校验<a hidden class="anchor" aria-hidden="true" href="#52-签名与校验">#</a></h2>
<ul>
<li>
<p><strong>必须</strong>：每个 RRO APK 要求云端签名（platform 或 OEM 签名与目标 overlay 签名相兼容），设备侧仅做签名验证，不重签。</p>
</li>
<li>
<p>下载逻辑：</p>
<ol>
<li>StoreApp 下载 zip 并比对 <code>zipMd5</code>；</li>
<li>解压后逐个对比每个 APK 的 md5 与 manifest 中记录；</li>
<li>通过 FileProvider 提交 APK Uri 给 TMS（AIDL）或直接用 PMS 安装（B 方案）。</li>
</ol>
</li>
<li>
<p>若 APK 签名不匹配 → 标记为“不兼容”并拒绝安装。</p>
</li>
</ul>
<h2 id="53-安装回滚流程概要">5.3 安装/回滚流程（概要）<a hidden class="anchor" aria-hidden="true" href="#53-安装回滚流程概要">#</a></h2>
<ul>
<li>在 TMS 中实现事务化安装：逐个安装 RRO APK，若任一失败则回滚已安装的 RRO（卸载）。</li>
<li>安装成功后写入 ThemeDB，并调用 OMS 启用（或等待用户 apply）。</li>
<li>回滚：调用 OMS 停用并卸载无效 APK，恢复上一个版本的 metadata。</li>
</ul>
<p>（参见附录 PlantUML 安装/应用序列示例）</p>
<hr>
<h1 id="6-个性化定制实现推荐方案">6. 个性化定制实现（推荐方案）<a hidden class="anchor" aria-hidden="true" href="#6-个性化定制实现推荐方案">#</a></h1>
<p><strong>设计目标</strong>：支持用户调色/字体等“微调”，在量产设备上无需设备端 platform 私钥、不会重新签名 APK，且能实时/准即时生效。</p>
<h2 id="推荐混合方案强烈推荐">推荐混合方案（强烈推荐）<a hidden class="anchor" aria-hidden="true" href="#推荐混合方案强烈推荐">#</a></h2>
<ul>
<li>
<p><strong>主要思路</strong>：组合 <strong>预编译 Overlay 套件（覆盖常见选项） + 参数化运行时替换（Framework hook 或受控运行时映射）</strong>。</p>
<ul>
<li>
<p>预编译多套 Overlay：覆盖常见的颜色/字体/图标形状组合（快速切换、零签名）。</p>
</li>
<li>
<p>个性化（任意颜色值）采用“参数表 + 轻量替换机制”：</p>
<ul>
<li><strong>方案 6.A（若可修改 Framework）</strong>：在 ResourcesImpl/AssetManager 增加参数映射层（theme_params.json），系统资源读取时优先查映射（支持即时生效，最优用户体验）。</li>
<li><strong>方案 6.B（不改 Framework）</strong>：预置一个“可写资源宿主”RRO模板（已签名）在系统分区中，里面使用占位资源引用；StoreApp 只更新该模板 RRO 外部的资产（例如放在 <code>/data/system/theme_assets/</code> 并由 SystemUI/Launcher 等进程读取）。该方案需要受控的 App 支持（SystemUI/Launcher 加载外部 assets）。</li>
</ul>
</li>
<li>
<p>动态生成完整 APK 并在设备端签名 <strong>不可行</strong>（量产设备无 platform 私钥）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="具体实现方案-6a-假设可改-framework">具体实现（方案 6.A 假设可改 Framework）<a hidden class="anchor" aria-hidden="true" href="#具体实现方案-6a-假设可改-framework">#</a></h2>
<ul>
<li>
<p>新增 <code>ThemeParamManager</code>（SystemService 或 TMS 子组件）：</p>
<ul>
<li>存放 <code>/data/system/theme_params.json</code>（userId 隔离）</li>
<li>提供 <code>getParam(resourceId)</code> 接口给 ResourcesImpl</li>
<li>当用户修改参数时写入 JSON 并发出 <code>ThemeParamChanged</code> 广播；ResourcesImpl 在下一次资源加载查询新值并生效（可配合进程级刷新）</li>
</ul>
</li>
<li>
<p>优点：即时生效、无 APK 安装、灵活</p>
</li>
<li>
<p>缺点：需要 ROM 修改，维护成本增加</p>
</li>
</ul>
<hr>
<h1 id="7-aidl--api-设计方案-atms-在-framework">7. AIDL / API 设计（方案 A：TMS 在 framework）<a hidden class="anchor" aria-hidden="true" href="#7-aidl--api-设计方案-atms-在-framework">#</a></h1>
<p>下面是核心 AIDL 接口草案（简化版，实际需更多错误码与安全校验）：</p>
<p><strong>文件</strong>: <code>IThemeManagerService.aidl</code></p>
<pre tabindex="0"><code class="language-aidl" data-lang="aidl">package com.oem.themes;

import android.net.Uri;
import com.oem.themes.ThemeInfo;
import com.oem.themes.CustomizationRequest;

interface IThemeManagerService {
    boolean installThemeForUser(in List&lt;Uri&gt; apkUris, int userId);
    List&lt;ThemeInfo&gt; getThemeListForUser(int userId);
    ThemeInfo getThemeInfoForUser(String themeId, int userId);
    boolean applyThemeForUser(String themeId, int userId);
    ThemeInfo getAppliedThemeForUser(int userId);
    boolean rollbackTheme(String themeId, int userId);
    boolean deleteThemeForUser(String themeId, int userId);
    boolean applyCustomization(in CustomizationRequest request, int userId);
    boolean clearCustomization(int userId);
    boolean restoreDefaultTheme(int userId);
}
</code></pre><p><strong>CustomizationRequest</strong> 包含：map&lt;String,String&gt; 参数（colorPrimary 等）、baseThemeId、timestamp、requestId。</p>
<p><strong>鉴权</strong>：只有具有 <code>MANAGE_THEME</code> 权限或 platform-signed 的客户端方可调用敏感方法。所有调用均记录审计。</p>
<hr>
<h1 id="8-数据模型themedb与同步策略">8. 数据模型（ThemeDB）与同步策略<a hidden class="anchor" aria-hidden="true" href="#8-数据模型themedb与同步策略">#</a></h1>
<h2 id="81-themedb-表结构简化">8.1 ThemeDB 表结构（简化）<a hidden class="anchor" aria-hidden="true" href="#81-themedb-表结构简化">#</a></h2>
<ul>
<li>
<p><code>themes</code>:</p>
<ul>
<li><code>themeId</code> TEXT PRIMARY KEY</li>
<li><code>name</code> TEXT</li>
<li><code>author</code> TEXT</li>
<li><code>version</code> TEXT</li>
<li><code>zipMd5</code> TEXT</li>
<li><code>installed</code> BOOLEAN</li>
<li><code>installed_at</code> TIMESTAMP</li>
<li><code>compatible</code> BOOLEAN</li>
<li><code>isCustomizable</code> BOOLEAN</li>
</ul>
</li>
<li>
<p><code>rro_entries</code>:</p>
<ul>
<li><code>id</code> INTEGER PK</li>
<li><code>themeId</code> TEXT FK</li>
<li><code>apkFile</code> TEXT</li>
<li><code>targetPackage</code> TEXT</li>
<li><code>md5</code> TEXT</li>
</ul>
</li>
<li>
<p><code>user_applied</code>:</p>
<ul>
<li><code>userId</code> INTEGER</li>
<li><code>themeId</code> TEXT</li>
<li><code>customParams</code> JSON</li>
<li><code>applied_at</code> TIMESTAMP</li>
</ul>
</li>
<li>
<p><code>audit_log</code>:</p>
<ul>
<li><code>id</code>, <code>action</code>, <code>caller</code>, <code>userId</code>, <code>timestamp</code>, <code>details</code></li>
</ul>
</li>
</ul>
<h2 id="82-云同步策略">8.2 云同步策略<a hidden class="anchor" aria-hidden="true" href="#82-云同步策略">#</a></h2>
<ul>
<li>
<p>云端保存 <code>themeId</code>、<code>appliedTheme</code>、<code>customParams</code>、<code>lastModifiedTs</code>。</p>
</li>
<li>
<p>同步策略：</p>
<ul>
<li>使用 <strong>Last-Write-Wins</strong>（按 timestamp）作为默认，若冲突则提示用户选择或采用 device-preferred 策略。</li>
<li>远程下发仅传 <code>themeId + diff(customParams)</code>；若设备缺少 theme package，则提示下载或自动下载（需用户授权或商店策略）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="9-安全与权限方案">9. 安全与权限方案<a hidden class="anchor" aria-hidden="true" href="#9-安全与权限方案">#</a></h1>
<h2 id="要点">要点<a hidden class="anchor" aria-hidden="true" href="#要点">#</a></h2>
<ul>
<li><strong>签名校验</strong>：PMS 必须校验 RRO APK 签名，且 RRO 的签名必须与 target 包策略相兼容（通常与系统/框架签名匹配或在白名单内）。</li>
<li><strong>最小权限</strong>：AIDL 接口加权限注解，只有经过授权的包（platform-signed 或持有 MANAGE_THEME）才可调用。</li>
<li><strong>来源白名单</strong>：仅允许来自 OEM 云端或被白名单的域名下载的 theme.zip（在商店端做校验）。</li>
<li><strong>审计与回滚</strong>：重要操作写审计 log；异常安装需自动回滚并上报。</li>
<li><strong>SELinux</strong>：为 theme assets、临时目录设置合适的 SELinux 文件上下文，避免越权访问。</li>
<li><strong>Network</strong>：下载使用 HTTPS，校验证书并校验 hash。</li>
</ul>
<hr>
<h1 id="10-性能优化要点与刷新策略">10. 性能优化要点与刷新策略<a hidden class="anchor" aria-hidden="true" href="#10-性能优化要点与刷新策略">#</a></h1>
<h2 id="性能优化">性能优化<a hidden class="anchor" aria-hidden="true" href="#性能优化">#</a></h2>
<ul>
<li><strong>异步安装/IO</strong>：安装、校验、DB 写入均在后台线程，不阻塞 UI。</li>
<li><strong>并发限制</strong>：限制同时安装主题包数量（例如单线程队列）以避免 IO 瓶颈。</li>
<li><strong>缓存</strong>：TMS 可缓存 ThemeDB 的热数据，定期持久化。</li>
<li><strong>预热</strong>：安装主题包后，不立即启用全部 overlay，可延迟到用户 apply 时启用，减少开机时间开销。</li>
</ul>
<h2 id="精准刷新策略">精准刷新策略<a hidden class="anchor" aria-hidden="true" href="#精准刷新策略">#</a></h2>
<ul>
<li>
<p><strong>资源分级刷新</strong>：</p>
<ul>
<li><strong>SystemUI/Launcher/Settings</strong>：必需重启进程或调用 <code>Activity.recreate()</code>。</li>
<li><strong>普通应用</strong>：仅当使用了 framework 资源时才触发（使用 <code>notifyChange</code> 列表过滤）。</li>
</ul>
</li>
<li>
<p><strong>避免全局重启</strong>：通过 OMS/AMS 的通知机制，仅重启受影响的进程，减少卡顿。</p>
</li>
</ul>
<hr>
<h1 id="11-测试计划与上线验证要点">11. 测试计划与上线验证要点<a hidden class="anchor" aria-hidden="true" href="#11-测试计划与上线验证要点">#</a></h1>
<h2 id="测试维度">测试维度<a hidden class="anchor" aria-hidden="true" href="#测试维度">#</a></h2>
<ul>
<li><strong>功能测试</strong>：安装、卸载、启用、回滚、预览、定制、跨设备同步。</li>
<li><strong>兼容性测试</strong>：不同 Android 版本，目标包的 minSdk/targetSdk 检查。</li>
<li><strong>性能测试</strong>：安装时间、启用 overlay 的延迟、内存/CPU 影响、开机时间影响。</li>
<li><strong>安全测试</strong>：签名绕过、篡改主题包、权限滥用（模拟非授权 App 调用）。</li>
<li><strong>多用户测试</strong>：不同用户的隔离性、并发切换边界条件。</li>
<li><strong>回归测试</strong>：系统升级（OTA）后，主题状态保持/兼容检测。</li>
</ul>
<h2 id="上线验证">上线验证<a hidden class="anchor" aria-hidden="true" href="#上线验证">#</a></h2>
<ul>
<li>小批量灰度（10% 设备），记录异常上报。</li>
<li>开启详细审计日志与故障自动回滚开关，确保用户能回退到出厂主题。</li>
</ul>
<hr>
<h1 id="12-替代方案对比与决策理由">12. 替代方案对比与决策理由<a hidden class="anchor" aria-hidden="true" href="#12-替代方案对比与决策理由">#</a></h1>
<h2 id="动态生成-rro-apk设备端构建--签名不可行量产环境">动态生成 RRO APK（设备端构建 + 签名）——<strong>不可行（量产环境）</strong><a hidden class="anchor" aria-hidden="true" href="#动态生成-rro-apk设备端构建--签名不可行量产环境">#</a></h2>
<ul>
<li><strong>理由</strong>：设备无 platform 私钥；本地签名无法通过签名校验；伪造签名或绕过检查会破坏安全模型。除非将签名流程放在受控的服务器端并将签名后的 APK 下发设备（延迟高、复杂）。</li>
</ul>
<h2 id="可行备选">可行备选<a hidden class="anchor" aria-hidden="true" href="#可行备选">#</a></h2>
<ul>
<li><strong>预编译 Overlay 组合（主方式）</strong>：高稳定性、快速切换、零签名问题。缺点：组合数量爆炸需平衡。</li>
<li><strong>参数化运行时替换（需 Framework 改动）</strong>：最佳用户体验（即时生效），但需要 ROM 改动与维护。</li>
<li><strong>模板 RRO + 外部 assets（部分方案）</strong>：能在不签名的前提下让 SystemUI/Launcher 加载外部资源，但需要 App 与系统组件配合。</li>
</ul>
<p><strong>决策建议</strong>（基于需求）：采用 <strong>预编译 Overlay + 参数化运行时替换（若可改 Framework 则启用）</strong> 的混合方案。TMS 放置：若安全/多客户端需求高 → 放在 framework；若仅官方商店且追求迭代 → 集成在 store app。</p>
<hr>
<h1 id="13-风险清单与缓解措施">13. 风险清单与缓解措施<a hidden class="anchor" aria-hidden="true" href="#13-风险清单与缓解措施">#</a></h1>
<table>
  <thead>
      <tr>
          <th>风险</th>
          <th style="text-align: right">严重度</th>
          <th>缓解</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>动态本地签名 RRO 不可行</td>
          <td style="text-align: right">高</td>
          <td>改用云端签名或模板/参数化方案</td>
      </tr>
      <tr>
          <td>未授权安装恶意 RRO</td>
          <td style="text-align: right">高</td>
          <td>严格签名+来源校验+安装白名单</td>
      </tr>
      <tr>
          <td>ThemeDB 并发冲突</td>
          <td style="text-align: right">中</td>
          <td>通过 Service 封装访问或 ContentProvider + 事务</td>
      </tr>
      <tr>
          <td>主题切换导致 SystemUI 崩溃</td>
          <td style="text-align: right">高</td>
          <td>上线自动回滚；在启用 overlay 前做兼容性 dry-run</td>
      </tr>
      <tr>
          <td>多设备同步冲突</td>
          <td style="text-align: right">中</td>
          <td>使用 timestamp/version；冲突提示用户</td>
      </tr>
      <tr>
          <td>性能（切换卡顿）</td>
          <td style="text-align: right">中</td>
          <td>精准刷新、只重启受影响进程；预编译 Overlay</td>
      </tr>
  </tbody>
</table>
<hr>
<h1 id="14-迭代路线图建议">14. 迭代路线图（建议）<a hidden class="anchor" aria-hidden="true" href="#14-迭代路线图建议">#</a></h1>
<ul>
<li><strong>Sprint 0（原型）</strong>：实现 StoreApp 下载流程、manifest 校验、用现有预编译 Overlay 实现 install/apply（方案 B 最快）— 验证端到端流程。</li>
<li><strong>Sprint 1（TMS 基本版）</strong>：设计并实现 TMS（框架版）最小可用接口：install/apply/getList/rollback。搭建 ThemeDB、审计日志。</li>
<li><strong>Sprint 2（个性化）</strong>：实现预编译 Overlay 的组合映射；引入参数化机制原型（若可改 Framework）。</li>
<li><strong>Sprint 3（安全/云）</strong>：上线签名验证、来源白名单、云端签名流水线（仅 server 端签名生产）。</li>
<li><strong>Sprint 4（优化/量产）</strong>：性能调优、回归测试、灰度发布、监控与上报。</li>
</ul>
<hr>
<h1 id="附录">附录<a hidden class="anchor" aria-hidden="true" href="#附录">#</a></h1>
<h2 id="plantuml安装与应用序列tms-在-framework">PlantUML：安装与应用序列（TMS 在 framework）<a hidden class="anchor" aria-hidden="true" href="#plantuml安装与应用序列tms-在-framework">#</a></h2>
<pre tabindex="0"><code class="language-plantuml" data-lang="plantuml">@startuml
actor User
participant &#34;ThemeStore App&#34; as Store
participant &#34;ThemeManagerService (TMS)&#34; as TMS
participant &#34;PackageManagerService (PMS)&#34; as PMS
participant &#34;OverlayManagerService (OMS)&#34; as OMS
database &#34;ThemeDB&#34; as DB

User -&gt; Store: 选择下载 theme.zip
Store -&gt; Store: 下载并校验 zipMd5
Store -&gt; Store: 解压并校验每个 APK md5
Store -&gt; TMS: installThemeForUser(listOfUris, userId)
TMS -&gt; PMS: installPackage(uri)
PMS --&gt; TMS: installResult(success)
TMS -&gt; DB: insert theme metadata
TMS --&gt; Store: installThemeForUser result
Store -&gt; TMS: applyThemeForUser(themeId, userId)
TMS -&gt; OMS: setEnabled(rroA, true, userId)
TMS -&gt; OMS: setEnabled(rroB, true, userId)
TMS -&gt; DB: update user_applied
OMS -&gt; SystemUI: notify resources changed
SystemUI -&gt; SystemUI: reload/recreate
@enduml
</code></pre><h2 id="示例-themedb-建表sql">示例 ThemeDB 建表（SQL）<a hidden class="anchor" aria-hidden="true" href="#示例-themedb-建表sql">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> themes (
</span></span><span style="display:flex;"><span>  themeId TEXT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>  name TEXT,
</span></span><span style="display:flex;"><span>  author TEXT,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">version</span> TEXT,
</span></span><span style="display:flex;"><span>  zipMd5 TEXT,
</span></span><span style="display:flex;"><span>  installed INTEGER,
</span></span><span style="display:flex;"><span>  installed_at INTEGER,
</span></span><span style="display:flex;"><span>  compatible INTEGER,
</span></span><span style="display:flex;"><span>  isCustomizable INTEGER
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> rro_entries (
</span></span><span style="display:flex;"><span>  id INTEGER <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> AUTOINCREMENT,
</span></span><span style="display:flex;"><span>  themeId TEXT,
</span></span><span style="display:flex;"><span>  apkFile TEXT,
</span></span><span style="display:flex;"><span>  targetPackage TEXT,
</span></span><span style="display:flex;"><span>  md5 TEXT
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> user_applied (
</span></span><span style="display:flex;"><span>  userId INTEGER,
</span></span><span style="display:flex;"><span>  themeId TEXT,
</span></span><span style="display:flex;"><span>  customParams TEXT,
</span></span><span style="display:flex;"><span>  applied_at INTEGER,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (userId)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> audit_log (
</span></span><span style="display:flex;"><span>  id INTEGER <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> AUTOINCREMENT,
</span></span><span style="display:flex;"><span>  action TEXT,
</span></span><span style="display:flex;"><span>  caller TEXT,
</span></span><span style="display:flex;"><span>  userId INTEGER,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">timestamp</span> INTEGER,
</span></span><span style="display:flex;"><span>  details TEXT
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><hr>
<h1 id="总结行动项">总结（行动项）<a hidden class="anchor" aria-hidden="true" href="#总结行动项">#</a></h1>
<ol>
<li>
<p><strong>选择 TMS 放置位置</strong>（framework vs App）— 按你们对安全/迭代的权衡给出决策。若需我可基于你们组织偏好给出直接建议。</p>
</li>
<li>
<p><strong>放弃设备端动态签名 RRO 的实现</strong>，改用“预编译 Overlay + 参数化运行时替换”的混合实现。</p>
</li>
<li>
<p><strong>下一步交付</strong>：我可以（任选其一）：</p>
<ul>
<li>生成完整的 <code>IThemeManagerService.aidl</code> 及 Java 框架层骨架代码；或</li>
<li>生成主题商店（StoreApp）侧的安装/预览/同步详细实现样例；或</li>
<li>给出 Framework hook (ResourcesImpl) 的详细设计与伪代码，用于实现参数化运行时替换。</li>
</ul>
</li>
</ol>
<p>你想优先让我做哪一项？我会直接做出对应交付。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
