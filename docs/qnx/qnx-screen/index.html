<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>QNX Screen基础原理与流程 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="QNX图形栈

一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：


准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。


提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。


第一阶段：准备与渲染 (Steps 1-6)
步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)

执行者：QNX Application, QNX Screen
关键 API：screen_create_window_buffers()

一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令

执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver
关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl)

应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.8d92b99258d2a8aea36dee98116af3631ad91e255aef20c2caa81c9459a68fd8.css" integrity="sha256-jZK5kljSqK6jbe6YEWrzYxrZHiVa7yDCyqgclFmmj9g=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="QNX Screen基础原理与流程">
  <meta property="og:description" content="QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：
准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。
提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。
第一阶段：准备与渲染 (Steps 1-6) 步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="qnx">
    <meta property="article:published_time" content="2025-08-03T17:17:50+08:00">
    <meta property="article:modified_time" content="2025-08-03T17:17:50+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QNX Screen基础原理与流程">
<meta name="twitter:description" content="QNX图形栈

一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：


准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。


提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。


第一阶段：准备与渲染 (Steps 1-6)
步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)

执行者：QNX Application, QNX Screen
关键 API：screen_create_window_buffers()

一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令

执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver
关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl)

应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "QNX基础原理",
      "item": "https://ethen-cao.github.io/ethenslab/qnx/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "QNX Screen基础原理与流程",
      "item": "https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "QNX Screen基础原理与流程",
  "name": "QNX Screen基础原理与流程",
  "description": "QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。\n整个过程可以分为两个核心阶段：\n准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。\n提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。\n第一阶段：准备与渲染 (Steps 1-6) 步骤 1 \u0026amp; 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。\nQNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。\n步骤 3 \u0026amp; 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES + EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。\n",
  "keywords": [
    
  ],
  "articleBody": "QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。\n整个过程可以分为两个核心阶段：\n准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。\n提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。\n第一阶段：准备与渲染 (Steps 1-6) 步骤 1 \u0026 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。\nQNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。\n步骤 3 \u0026 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES + EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。\n当应用程序完成一帧的全部绘图指令描述后，它会调用一个像 eglSwapBuffers() 这样的关键函数。这个函数的调用意味着“我已经定义好这一帧的所有内容了”。EGL 函数库会将这些高级的绘图指令打包，通过 QNX 的 IPC 机制（通常是 devctl），将指令发送到 GPU Driver 这个独立的用户空间进程。\neglSwapBuffers() 的作用 eglSwapBuffers() 不是把图像“提交给 GPU”，而是：\nFlush/提交之前累积的 OpenGL ES 命令，告诉 GPU 驱动“这些命令可以执行了”。\n交换前后缓冲区：把渲染目标从后台 buffer 翻转成前台 buffer。对 QNX/高通平台：这一步完成后，GPU 开始执行命令，把结果真正写进后台 buffer（即 framebuffer）。\n在 QNX + 高通平台下，后台 buffer 的分配路径大致如下：\n应用创建 EGL surface 或 QNX Screen window：调用 eglCreateWindowSurface() 或 screen_create_window_buffers()。 Screen 负责分配 buffer：Screen 作为窗口系统和 buffer allocator，会根据需求分配 2～3 个 buffer（双缓冲或三缓冲）。 分配时考虑：\n必须是 物理可连续 / 可 DMA 的内存 必须满足 GPU tiling/对齐要求 必须能被 Display Controller 直接 scanout 底层内存分配机制\n在高通 BSP 中，这一步通常通过 ION/DMABUF 完成：\nION/DMABUF 分配一块显存 返回一个 fd / handle Screen 管理这些 handle，并把它映射到 EGL/应用进程的地址空间 应用得到 buffer handle 应用最终拿到的不是“物理地址”，而是一个 handle (screen_buffer_t) 或 EGL surface 绑定的 framebuffer。 GPU driver 使用这个 handle 来写像素，Display driver 使用同一个 handle 来做 scanout。 Fence同步 异步执行与 Fence 创建：eglSwapBuffers() 的核心就是将渲染任务“提交”出去，然后立即返回，让应用程序（CPU）可以继续处理下一帧的逻辑。GPU Driver 在接收到任务后，会创建一个与该任务关联的 Fence，这个 Fence 相当于一个“任务完成的回执单”。 Fence 的传递： EGL 在把 buffer 返回给 Screen 时，会把这个 Fence 一起交给 Screen。 Screen 在调用 OpenWFD / Display Driver 时，会附带这个 Fence。 Display Driver 不会立刻用 buffer，而是等待 Fence signal 触发（即 GPU 真正画完）后，才做 pointer flip 等待与执行：Display Driver 作为消费者，拿到了这个“带条件”的 Buffer。它不会盲目地直接将其用于显示。它会等待这个 Fence 发出信号（signaled），这个信号的含义就是“GPU 已经画完了，这个 Buffer 的内容是完整且有效的”。只有确认了这一点，Display Driver 才会安全地执行 Pointer Flip，让显示控制器去读取这块内存。 步骤 5 \u0026 6：硬件加速渲染 执行者：GPU Driver, GPU (Hardware), Framebuffers (Shared Memory) GPU Driver 进程接收到来自 EGL 的绘图指令。它的职责是将这些指令翻译成 GPU 硬件能直接执行的命令。接着，驱动程序会通过微内核仲裁来获得对硬件的访问权，并将这些命令提交给 GPU。\nGPU 是一个高度并行化的处理器，它会极速执行这些命令，进行顶点变换、光栅化、着色等一系列运算。最终，GPU 将计算出的像素颜色值，通过直接内存访问 (DMA) 的方式，直接写入到步骤 2 中分配好的那个离屏缓冲区 (off-screen buffer) 中。这个过程 CPU 基本不参与，效率极高。\n至此，新的一帧画面已经在一个用户看不见的内存缓冲区中准备就绪。\n第二阶段：提交与显示 (Steps 7-12) 步骤 7：通知绘制完成 执行者：QNX Application, QNX Screen 关键 API：screen_post_window() eglSwapBuffers() 函数在内部通常会触发 screen_post_window() 的调用。这是整个流程中的关键交接点。应用程序通过这个 API 调用，正式通知 QNX Screen：“我已经画好了，这个 Buffer 现在归你了，你可以拿去显示了”。完成通知后，应用程序就可以立即使用另一个空闲的 Buffer 来开始准备下一帧的内容，实现流畅的动画效果。\n步骤 8 \u0026 9：更新显示管线 执行者：QNX Screen, OpenWFD Driver, Display Driver 关键 API/机制：wfdDeviceCommit(), devctl QNX Screen 作为画面合成器 (Compositor)，接收到来自应用程序的通知。它会根据窗口的层级、可见性等状态，决定何时更新屏幕。当决定更新时，它会调用 OpenWFD 函数库提供的 API（例如 wfdDeviceCommit）。\nOpenWFD 函数库会将这个高级的显示请求，转换成一个具体的 devctl 指令，发送给 Display Driver 这个用户空间进程。这个指令的核心内容是：“请将屏幕上的第 N 层 (Layer)，指向这个新的 Buffer 的物理地址”。\n步骤 10：更新显示控制器 (指针翻转) 执行者：Display Driver, Display Controller (Hardware) Display Driver 接收到指令后，它的任务非常单纯且关键：与硬件通信。它会向 Display Controller 硬件的特定寄存器写入一个新的内存地址——也就是那块已经绘制好内容的新 Buffer 的起始地址。\n这个操作被称为 “指针翻转”(Pointer Flip)。它本身几乎不耗费任何时间，因为没有复制任何像素数据，仅仅是改变了一个指针。\n步骤 11 \u0026 12：硬件扫描输出 执行者：Display Controller (Hardware), Framebuffers, Physical Display Display Controller 是一个独立工作的硬件单元。它会以固定的频率（例如 60Hz）不断地从它被告知的内存地址开始，逐行读取像素数据，这个过程称为“扫描输出”(Scanout)。\n在下一个刷新周期（例如未来的 1/60 秒内），Display Controller 就会自动地从步骤 10 设置的新地址开始读取数据。读取到的像素数据被转换成视频信号（如 HDMI），最终发送到实体屏幕上。\n至此，用户终于在屏幕上看到了应用程序绘制的新画面。整个高效、流畅的渲染流程宣告完成。\nscreen_post_window opengles \u0026 EGL 在图形编程里 OpenGL ES 和 EGL 经常一起出现，但它们的职责完全不同：\n🔹 1. OpenGL ES 全称：OpenGL for Embedded Systems\n定位：一个 图形渲染 API\n作用：\n提供一套函数（API），让应用能调用 GPU 来做 绘制。 主要负责 “画什么”：三角形、纹理、光照、着色器等。 核心功能：\n定义图形流水线（顶点着色器、片段着色器）。 绘制 2D/3D 图形。 控制渲染状态、纹理、FrameBuffer 等。 类比：像一个画家，专注于如何画图。\n👉 但 OpenGL ES 自己并不知道图要画到哪儿去（屏幕？窗口？内存？）\n🔹 2. EGL 全称：Embedded-System Graphics Library (不是 OpenGL 的子集，独立标准)\n定位：上下文管理 \u0026 平台接口库\n作用：\n负责 “在哪里画、怎么画”。 建立应用和底层窗口系统/驱动之间的桥梁。 核心功能：\n连接窗口系统（比如 Android 的 SurfaceFlinger / Linux 的 X11 / Wayland / QNX Screen）。 创建渲染上下文（OpenGL ES 必须依赖一个 Context 才能工作）。 管理 Surface（屏幕上的窗口、离屏缓冲区等）。 缓冲区交换（eglSwapBuffers()，把 GPU 渲染结果显示到屏幕）。 类比：像一个舞台管理者，负责搭建舞台、安排画布，最后通知观众看画。\n👉 EGL 不负责绘图，它只提供“画布+上下文+显示通道”。绘制的动作要靠 OpenGL ES。\n🔹 3. 关系 应用 → 调用 EGL：\n选一个显示系统的窗口 / Surface。 创建一个 EGLContext。 应用 → 使用 OpenGL ES：\n在 EGLContext 里调用 glDrawArrays()、glDrawElements() 之类的函数来画图。 应用 → 调用 EGL：\neglSwapBuffers() 把绘制结果显示出来。 🔹 4. 举个例子（Android / QNX） EGL：连接到 SurfaceFlinger / QNX Screen，分配缓冲区，创建 EGLContext。 OpenGL ES：用着色器绘制一个三角形到缓冲区。 EGL：调用 eglSwapBuffers() 把三角形送到显示器。 ✅ 一句话总结\nOpenGL ES = 画图工具（怎么画） EGL = 舞台管理（在哪画 \u0026 把图送到屏幕） ！\n",
  "wordCount" : "512",
  "inLanguage": "en",
  "datePublished": "2025-08-03T17:17:50+08:00",
  "dateModified": "2025-08-03T17:17:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/qnx/" title="QNX开发">
                    <span>QNX开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/qnx/">QNX基础原理</a></div>
    <h1 class="post-title entry-hint-parent">
      QNX Screen基础原理与流程
    </h1>
    <div class="post-meta"><span title='2025-08-03 17:17:50 +0800 CST'>August 3, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words

</div>
  </header> 
  <div class="post-content"><h2 id="qnx图形栈">QNX图形栈<a hidden class="anchor" aria-hidden="true" href="#qnx图形栈">#</a></h2>
<p><img alt="screen_post_window" loading="lazy" src="/ethenslab/images/qnx-screen-overview.png"></p>
<p>一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。</p>
<p>整个过程可以分为两个核心阶段：</p>
<ol>
<li>
<p><strong>准备与渲染阶段</strong>：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。</p>
</li>
<li>
<p><strong>提交与显示阶段</strong>：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。</p>
</li>
</ol>
<h3 id="第一阶段准备与渲染-steps-1-6">第一阶段：准备与渲染 (Steps 1-6)<a hidden class="anchor" aria-hidden="true" href="#第一阶段准备与渲染-steps-1-6">#</a></h3>
<h4 id="步骤-1--2请求并获取窗口缓冲区-buffer"><strong>步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-1--2请求并获取窗口缓冲区-buffer">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>QNX Screen</code></li>
<li><strong>关键 API</strong>：<code>screen_create_window_buffers()</code></li>
</ul>
<p>一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。</p>
<p><code>QNX Screen</code> 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) <strong>请求</strong> <code>Display/GPU Driver</code> (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 <code>Screen</code>。最后，<code>Screen</code> 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。</p>
<h4 id="步骤-3--4提交绘图指令"><strong>步骤 3 &amp; 4：提交绘图指令</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-3--4提交绘图指令">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>Graphics API (OpenGL ES + EGL)</code>, <code>GPU Driver</code></li>
<li><strong>关键 API/机制</strong>：<code>eglSwapBuffers()</code>, QNX IPC (<code>msg</code>/<code>devctl</code>)</li>
</ul>
<p>应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。</p>
<p>当应用程序完成一帧的全部绘图指令描述后，它会调用一个像 <code>eglSwapBuffers()</code> 这样的关键函数。这个函数的调用意味着“我已经定义好这一帧的所有内容了”。EGL 函数库会将这些高级的绘图指令打包，通过 QNX 的 IPC 机制（通常是 <code>devctl</code>），将指令发送到 <code>GPU Driver</code> 这个独立的用户空间进程。</p>
<h5 id="eglswapbuffers-的作用">eglSwapBuffers() 的作用<a hidden class="anchor" aria-hidden="true" href="#eglswapbuffers-的作用">#</a></h5>
<p>eglSwapBuffers() 不是把图像“提交给 GPU”，而是：</p>
<ul>
<li>
<p>Flush/提交之前累积的 OpenGL ES 命令，告诉 GPU 驱动“这些命令可以执行了”。</p>
</li>
<li>
<p>交换前后缓冲区：把渲染目标从后台 buffer 翻转成前台 buffer。对 QNX/高通平台：这一步完成后，GPU 开始执行命令，把结果真正写进后台 buffer（即 framebuffer）。</p>
</li>
</ul>
<p>在 QNX + 高通平台下，后台 buffer 的分配路径大致如下：</p>
<ul>
<li>应用创建 EGL surface 或 QNX Screen window：调用 eglCreateWindowSurface() 或 screen_create_window_buffers()。</li>
<li>Screen 负责分配 buffer：Screen 作为窗口系统和 buffer allocator，会根据需求分配 2～3 个 buffer（双缓冲或三缓冲）。</li>
</ul>
<p>分配时考虑：</p>
<ul>
<li>必须是 物理可连续 / 可 DMA 的内存</li>
<li>必须满足 GPU tiling/对齐要求</li>
<li>必须能被 Display Controller 直接 scanout</li>
</ul>
<p>底层内存分配机制</p>
<p>在高通 BSP 中，这一步通常通过 ION/DMABUF 完成：</p>
<ul>
<li>ION/DMABUF 分配一块显存</li>
<li>返回一个 fd / handle</li>
<li>Screen 管理这些 handle，并把它映射到 EGL/应用进程的地址空间</li>
<li>应用得到 buffer handle</li>
<li>应用最终拿到的不是“物理地址”，而是一个 handle (screen_buffer_t) 或 EGL surface 绑定的 framebuffer。</li>
<li>GPU driver 使用这个 handle 来写像素，Display driver 使用同一个 handle 来做 scanout。</li>
</ul>
<h5 id="fence同步">Fence同步<a hidden class="anchor" aria-hidden="true" href="#fence同步">#</a></h5>
<ul>
<li>异步执行与 Fence 创建：eglSwapBuffers() 的核心就是将渲染任务“提交”出去，然后立即返回，让应用程序（CPU）可以继续处理下一帧的逻辑。GPU Driver 在接收到任务后，会创建一个与该任务关联的 Fence，这个 Fence 相当于一个“任务完成的回执单”。</li>
<li>Fence 的传递：
<ul>
<li>EGL 在把 buffer 返回给 Screen 时，会把这个 Fence 一起交给 Screen。</li>
<li>Screen 在调用 OpenWFD / Display Driver 时，会附带这个 Fence。</li>
<li>Display Driver 不会立刻用 buffer，而是等待 Fence signal 触发（即 GPU 真正画完）后，才做 pointer flip</li>
</ul>
</li>
<li>等待与执行：Display Driver 作为消费者，拿到了这个“带条件”的 Buffer。它不会盲目地直接将其用于显示。它会等待这个 Fence 发出信号（signaled），这个信号的含义就是“GPU 已经画完了，这个 Buffer 的内容是完整且有效的”。只有确认了这一点，Display Driver 才会安全地执行 Pointer Flip，让显示控制器去读取这块内存。</li>
</ul>
<h4 id="步骤-5--6硬件加速渲染"><strong>步骤 5 &amp; 6：硬件加速渲染</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-5--6硬件加速渲染">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>GPU Driver</code>, <code>GPU (Hardware)</code>, <code>Framebuffers (Shared Memory)</code></li>
</ul>
<p><code>GPU Driver</code> 进程接收到来自 EGL 的绘图指令。它的职责是将这些指令翻译成 GPU 硬件能直接执行的命令。接着，驱动程序会通过微内核仲裁来获得对硬件的访问权，并将这些命令提交给 <code>GPU</code>。</p>
<p><code>GPU</code> 是一个高度并行化的处理器，它会极速执行这些命令，进行顶点变换、光栅化、着色等一系列运算。最终，GPU 将计算出的像素颜色值，通过直接内存访问 (DMA) 的方式，<strong>直接写入</strong>到步骤 2 中分配好的那个离屏缓冲区 (off-screen buffer) 中。这个过程 CPU 基本不参与，效率极高。</p>
<p><strong>至此，新的一帧画面已经在一个用户看不见的内存缓冲区中准备就绪。</strong></p>
<h3 id="第二阶段提交与显示-steps-7-12">第二阶段：提交与显示 (Steps 7-12)<a hidden class="anchor" aria-hidden="true" href="#第二阶段提交与显示-steps-7-12">#</a></h3>
<h4 id="步骤-7通知绘制完成"><strong>步骤 7：通知绘制完成</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-7通知绘制完成">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>QNX Screen</code></li>
<li><strong>关键 API</strong>：<code>screen_post_window()</code></li>
</ul>
<p><code>eglSwapBuffers()</code> 函数在内部通常会触发 <code>screen_post_window()</code> 的调用。这是整个流程中的<strong>关键交接点</strong>。应用程序通过这个 API 调用，正式通知 <code>QNX Screen</code>：“我已经画好了，这个 Buffer 现在归你了，你可以拿去显示了”。完成通知后，应用程序就可以立即使用另一个空闲的 Buffer 来开始准备下一帧的内容，实现流畅的动画效果。</p>
<h4 id="步骤-8--9更新显示管线"><strong>步骤 8 &amp; 9：更新显示管线</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-8--9更新显示管线">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Screen</code>, <code>OpenWFD Driver</code>, <code>Display Driver</code></li>
<li><strong>关键 API/机制</strong>：<code>wfdDeviceCommit()</code>, <code>devctl</code></li>
</ul>
<p><code>QNX Screen</code> 作为画面合成器 (Compositor)，接收到来自应用程序的通知。它会根据窗口的层级、可见性等状态，决定何时更新屏幕。当决定更新时，它会调用 <code>OpenWFD</code> 函数库提供的 API（例如 <code>wfdDeviceCommit</code>）。</p>
<p><code>OpenWFD</code> 函数库会将这个高级的显示请求，转换成一个具体的 <code>devctl</code> 指令，发送给 <code>Display Driver</code> 这个用户空间进程。这个指令的核心内容是：“请将屏幕上的第 N 层 (Layer)，指向这个新的 Buffer 的物理地址”。</p>
<h4 id="步骤-10更新显示控制器-指针翻转"><strong>步骤 10：更新显示控制器 (指针翻转)</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-10更新显示控制器-指针翻转">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>Display Driver</code>, <code>Display Controller (Hardware)</code></li>
</ul>
<p><code>Display Driver</code> 接收到指令后，它的任务非常单纯且关键：与硬件通信。它会向 <code>Display Controller</code> 硬件的特定寄存器写入一个新的内存地址——也就是那块已经绘制好内容的新 Buffer 的起始地址。</p>
<p>这个操作被称为 <strong>“指针翻转”(Pointer Flip)</strong>。它本身几乎不耗费任何时间，因为没有复制任何像素数据，仅仅是改变了一个指针。</p>
<h4 id="步骤-11--12硬件扫描输出"><strong>步骤 11 &amp; 12：硬件扫描输出</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-11--12硬件扫描输出">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>Display Controller (Hardware)</code>, <code>Framebuffers</code>, <code>Physical Display</code></li>
</ul>
<p><code>Display Controller</code> 是一个独立工作的硬件单元。它会以固定的频率（例如 60Hz）不断地从它被告知的内存地址开始，逐行读取像素数据，这个过程称为“扫描输出”(Scanout)。</p>
<p>在下一个刷新周期（例如未来的 1/60 秒内），<code>Display Controller</code> 就会自动地从步骤 10 设置的<strong>新地址</strong>开始读取数据。读取到的像素数据被转换成视频信号（如 HDMI），最终发送到实体屏幕上。</p>
<p><strong>至此，用户终于在屏幕上看到了应用程序绘制的新画面。整个高效、流畅的渲染流程宣告完成。</strong></p>
<h2 id="screen_post_window">screen_post_window<a hidden class="anchor" aria-hidden="true" href="#screen_post_window">#</a></h2>
<p><img alt="screen_post_window" loading="lazy" src="/ethenslab/images/qnx-screen-screen_post_window.png"></p>
<h2 id="opengles--egl">opengles &amp; EGL<a hidden class="anchor" aria-hidden="true" href="#opengles--egl">#</a></h2>
<p>在图形编程里 <strong>OpenGL ES</strong> 和 <strong>EGL</strong> 经常一起出现，但它们的职责完全不同：</p>
<h3 id="-1-opengl-es">🔹 1. <strong>OpenGL ES</strong><a hidden class="anchor" aria-hidden="true" href="#-1-opengl-es">#</a></h3>
<ul>
<li>
<p><strong>全称</strong>：OpenGL for Embedded Systems</p>
</li>
<li>
<p><strong>定位</strong>：一个 <strong>图形渲染 API</strong></p>
</li>
<li>
<p><strong>作用</strong>：</p>
<ul>
<li>提供一套函数（API），让应用能调用 GPU 来做 <strong>绘制</strong>。</li>
<li>主要负责 <strong>&ldquo;画什么&rdquo;</strong>：三角形、纹理、光照、着色器等。</li>
</ul>
</li>
<li>
<p><strong>核心功能</strong>：</p>
<ul>
<li>定义图形流水线（顶点着色器、片段着色器）。</li>
<li>绘制 2D/3D 图形。</li>
<li>控制渲染状态、纹理、FrameBuffer 等。</li>
</ul>
</li>
<li>
<p><strong>类比</strong>：像一个画家，专注于如何画图。</p>
</li>
</ul>
<p>👉 <strong>但 OpenGL ES 自己并不知道图要画到哪儿去（屏幕？窗口？内存？）</strong></p>
<h3 id="-2-egl">🔹 2. <strong>EGL</strong><a hidden class="anchor" aria-hidden="true" href="#-2-egl">#</a></h3>
<ul>
<li>
<p><strong>全称</strong>：Embedded-System Graphics Library (不是 OpenGL 的子集，独立标准)</p>
</li>
<li>
<p><strong>定位</strong>：<strong>上下文管理 &amp; 平台接口库</strong></p>
</li>
<li>
<p><strong>作用</strong>：</p>
<ul>
<li>负责 <strong>&ldquo;在哪里画、怎么画&rdquo;</strong>。</li>
<li>建立应用和底层窗口系统/驱动之间的桥梁。</li>
</ul>
</li>
<li>
<p><strong>核心功能</strong>：</p>
<ol>
<li><strong>连接窗口系统</strong>（比如 Android 的 SurfaceFlinger / Linux 的 X11 / Wayland / QNX Screen）。</li>
<li><strong>创建渲染上下文</strong>（OpenGL ES 必须依赖一个 Context 才能工作）。</li>
<li><strong>管理 Surface</strong>（屏幕上的窗口、离屏缓冲区等）。</li>
<li><strong>缓冲区交换</strong>（<code>eglSwapBuffers()</code>，把 GPU 渲染结果显示到屏幕）。</li>
</ol>
</li>
<li>
<p><strong>类比</strong>：像一个舞台管理者，负责搭建舞台、安排画布，最后通知观众看画。</p>
</li>
</ul>
<p>👉 <strong>EGL 不负责绘图，它只提供“画布+上下文+显示通道”。绘制的动作要靠 OpenGL ES。</strong></p>
<hr>
<h3 id="-3-关系">🔹 3. 关系<a hidden class="anchor" aria-hidden="true" href="#-3-关系">#</a></h3>
<ul>
<li>
<p><strong>应用</strong> → 调用 EGL：</p>
<ul>
<li>选一个显示系统的窗口 / Surface。</li>
<li>创建一个 EGLContext。</li>
</ul>
</li>
<li>
<p><strong>应用</strong> → 使用 OpenGL ES：</p>
<ul>
<li>在 EGLContext 里调用 <code>glDrawArrays()</code>、<code>glDrawElements()</code> 之类的函数来画图。</li>
</ul>
</li>
<li>
<p><strong>应用</strong> → 调用 EGL：</p>
<ul>
<li><code>eglSwapBuffers()</code> 把绘制结果显示出来。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="-4-举个例子android--qnx">🔹 4. 举个例子（Android / QNX）<a hidden class="anchor" aria-hidden="true" href="#-4-举个例子android--qnx">#</a></h3>
<ol>
<li>EGL：连接到 SurfaceFlinger / QNX Screen，分配缓冲区，创建 EGLContext。</li>
<li>OpenGL ES：用着色器绘制一个三角形到缓冲区。</li>
<li>EGL：调用 <code>eglSwapBuffers()</code> 把三角形送到显示器。</li>
</ol>
<p>✅ <strong>一句话总结</strong></p>
<ul>
<li><strong>OpenGL ES</strong> = 画图工具（怎么画）</li>
<li><strong>EGL</strong> = 舞台管理（在哪画 &amp; 把图送到屏幕）</li>
</ul>
<p>！<a href="/ethenslab/images/qnx-screen-overview.png"></a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
