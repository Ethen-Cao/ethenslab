<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>QNX Screen基础原理与流程 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="QNX图形栈

一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：

准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。
提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。

第一阶段：准备与渲染 (Steps 1-6)
步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)

执行者：QNX Application, QNX Screen
关键 API：screen_create_window_buffers()

一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令

执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver
关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl)

应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.8d92b99258d2a8aea36dee98116af3631ad91e255aef20c2caa81c9459a68fd8.css" integrity="sha256-jZK5kljSqK6jbe6YEWrzYxrZHiVa7yDCyqgclFmmj9g=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="QNX Screen基础原理与流程">
  <meta property="og:description" content="QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：
准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。 提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。 第一阶段：准备与渲染 (Steps 1-6) 步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="qnx">
    <meta property="article:published_time" content="2025-08-03T17:17:50+08:00">
    <meta property="article:modified_time" content="2025-08-03T17:17:50+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QNX Screen基础原理与流程">
<meta name="twitter:description" content="QNX图形栈

一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。
整个过程可以分为两个核心阶段：

准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。
提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。

第一阶段：准备与渲染 (Steps 1-6)
步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)

执行者：QNX Application, QNX Screen
关键 API：screen_create_window_buffers()

一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。
QNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。
步骤 3 &amp; 4：提交绘图指令

执行者：QNX Application, Graphics API (OpenGL ES &#43; EGL), GPU Driver
关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl)

应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "QNX基础原理",
      "item": "https://ethen-cao.github.io/ethenslab/qnx/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "QNX Screen基础原理与流程",
      "item": "https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "QNX Screen基础原理与流程",
  "name": "QNX Screen基础原理与流程",
  "description": "QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。\n整个过程可以分为两个核心阶段：\n准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。 提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。 第一阶段：准备与渲染 (Steps 1-6) 步骤 1 \u0026amp; 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。\nQNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。\n步骤 3 \u0026amp; 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES + EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。\n",
  "keywords": [
    
  ],
  "articleBody": "QNX图形栈 一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。\n整个过程可以分为两个核心阶段：\n准备与渲染阶段：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。 提交与显示阶段：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。 第一阶段：准备与渲染 (Steps 1-6) 步骤 1 \u0026 2：请求并获取窗口缓冲区 (Buffer) 执行者：QNX Application, QNX Screen 关键 API：screen_create_window_buffers() 一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。\nQNX Screen 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) 请求 Display/GPU Driver (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 Screen。最后，Screen 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。\n步骤 3 \u0026 4：提交绘图指令 执行者：QNX Application, Graphics API (OpenGL ES + EGL), GPU Driver 关键 API/机制：eglSwapBuffers(), QNX IPC (msg/devctl) 应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。\n当应用程序完成一帧的全部绘图指令描述后，它会调用一个像 eglSwapBuffers() 这样的关键函数。这个函数的调用意味着“我已经定义好这一帧的所有内容了”。EGL 函数库会将这些高级的绘图指令打包，通过 QNX 的 IPC 机制（通常是 devctl），将指令发送到 GPU Driver 这个独立的用户空间进程。\n步骤 5 \u0026 6：硬件加速渲染 执行者：GPU Driver, GPU (Hardware), Framebuffers (Shared Memory) GPU Driver 进程接收到来自 EGL 的绘图指令。它的职责是将这些指令翻译成 GPU 硬件能直接执行的命令。接着，驱动程序会通过微内核仲裁来获得对硬件的访问权，并将这些命令提交给 GPU。\nGPU 是一个高度并行化的处理器，它会极速执行这些命令，进行顶点变换、光栅化、着色等一系列运算。最终，GPU 将计算出的像素颜色值，通过直接内存访问 (DMA) 的方式，直接写入到步骤 2 中分配好的那个离屏缓冲区 (off-screen buffer) 中。这个过程 CPU 基本不参与，效率极高。\n至此，新的一帧画面已经在一个用户看不见的内存缓冲区中准备就绪。\n第二阶段：提交与显示 (Steps 7-12) 步骤 7：通知绘制完成 执行者：QNX Application, QNX Screen 关键 API：screen_post_window() eglSwapBuffers() 函数在内部通常会触发 screen_post_window() 的调用。这是整个流程中的关键交接点。应用程序通过这个 API 调用，正式通知 QNX Screen：“我已经画好了，这个 Buffer 现在归你了，你可以拿去显示了”。完成通知后，应用程序就可以立即使用另一个空闲的 Buffer 来开始准备下一帧的内容，实现流畅的动画效果。\n步骤 8 \u0026 9：更新显示管线 执行者：QNX Screen, OpenWFD Driver, Display Driver 关键 API/机制：wfdDeviceCommit(), devctl QNX Screen 作为画面合成器 (Compositor)，接收到来自应用程序的通知。它会根据窗口的层级、可见性等状态，决定何时更新屏幕。当决定更新时，它会调用 OpenWFD 函数库提供的 API（例如 wfdDeviceCommit）。\nOpenWFD 函数库会将这个高级的显示请求，转换成一个具体的 devctl 指令，发送给 Display Driver 这个用户空间进程。这个指令的核心内容是：“请将屏幕上的第 N 层 (Layer)，指向这个新的 Buffer 的物理地址”。\n步骤 10：更新显示控制器 (指针翻转) 执行者：Display Driver, Display Controller (Hardware) Display Driver 接收到指令后，它的任务非常单纯且关键：与硬件通信。它会向 Display Controller 硬件的特定寄存器写入一个新的内存地址——也就是那块已经绘制好内容的新 Buffer 的起始地址。\n这个操作被称为 “指针翻转”(Pointer Flip)。它本身几乎不耗费任何时间，因为没有复制任何像素数据，仅仅是改变了一个指针。\n步骤 11 \u0026 12：硬件扫描输出 执行者：Display Controller (Hardware), Framebuffers, Physical Display Display Controller 是一个独立工作的硬件单元。它会以固定的频率（例如 60Hz）不断地从它被告知的内存地址开始，逐行读取像素数据，这个过程称为“扫描输出”(Scanout)。\n在下一个刷新周期（例如未来的 1/60 秒内），Display Controller 就会自动地从步骤 10 设置的新地址开始读取数据。读取到的像素数据被转换成视频信号（如 HDMI），最终发送到实体屏幕上。\n至此，用户终于在屏幕上看到了应用程序绘制的新画面。整个高效、流畅的渲染流程宣告完成。\nscreen_post_window ",
  "wordCount" : "221",
  "inLanguage": "en",
  "datePublished": "2025-08-03T17:17:50+08:00",
  "dateModified": "2025-08-03T17:17:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/qnx/" title="QNX开发">
                    <span>QNX开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/qnx/">QNX基础原理</a></div>
    <h1 class="post-title entry-hint-parent">
      QNX Screen基础原理与流程
    </h1>
    <div class="post-meta"><span title='2025-08-03 17:17:50 +0800 CST'>August 3, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;221 words

</div>
  </header> 
  <div class="post-content"><h2 id="qnx图形栈">QNX图形栈<a hidden class="anchor" aria-hidden="true" href="#qnx图形栈">#</a></h2>
<p><img alt="screen_post_window" loading="lazy" src="/ethenslab/images/qnx-screen-overview.png"></p>
<p>一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。</p>
<p>整个过程可以分为两个核心阶段：</p>
<ol>
<li><strong>准备与渲染阶段</strong>：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。</li>
<li><strong>提交与显示阶段</strong>：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。</li>
</ol>
<h3 id="第一阶段准备与渲染-steps-1-6">第一阶段：准备与渲染 (Steps 1-6)<a hidden class="anchor" aria-hidden="true" href="#第一阶段准备与渲染-steps-1-6">#</a></h3>
<h4 id="步骤-1--2请求并获取窗口缓冲区-buffer"><strong>步骤 1 &amp; 2：请求并获取窗口缓冲区 (Buffer)</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-1--2请求并获取窗口缓冲区-buffer">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>QNX Screen</code></li>
<li><strong>关键 API</strong>：<code>screen_create_window_buffers()</code></li>
</ul>
<p>一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。</p>
<p><code>QNX Screen</code> 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) <strong>请求</strong> <code>Display/GPU Driver</code> (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 <code>Screen</code>。最后，<code>Screen</code> 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。</p>
<h4 id="步骤-3--4提交绘图指令"><strong>步骤 3 &amp; 4：提交绘图指令</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-3--4提交绘图指令">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>Graphics API (OpenGL ES + EGL)</code>, <code>GPU Driver</code></li>
<li><strong>关键 API/机制</strong>：<code>eglSwapBuffers()</code>, QNX IPC (<code>msg</code>/<code>devctl</code>)</li>
</ul>
<p>应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。</p>
<p>当应用程序完成一帧的全部绘图指令描述后，它会调用一个像 <code>eglSwapBuffers()</code> 这样的关键函数。这个函数的调用意味着“我已经定义好这一帧的所有内容了”。EGL 函数库会将这些高级的绘图指令打包，通过 QNX 的 IPC 机制（通常是 <code>devctl</code>），将指令发送到 <code>GPU Driver</code> 这个独立的用户空间进程。</p>
<h4 id="步骤-5--6硬件加速渲染"><strong>步骤 5 &amp; 6：硬件加速渲染</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-5--6硬件加速渲染">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>GPU Driver</code>, <code>GPU (Hardware)</code>, <code>Framebuffers (Shared Memory)</code></li>
</ul>
<p><code>GPU Driver</code> 进程接收到来自 EGL 的绘图指令。它的职责是将这些指令翻译成 GPU 硬件能直接执行的命令。接着，驱动程序会通过微内核仲裁来获得对硬件的访问权，并将这些命令提交给 <code>GPU</code>。</p>
<p><code>GPU</code> 是一个高度并行化的处理器，它会极速执行这些命令，进行顶点变换、光栅化、着色等一系列运算。最终，GPU 将计算出的像素颜色值，通过直接内存访问 (DMA) 的方式，<strong>直接写入</strong>到步骤 2 中分配好的那个离屏缓冲区 (off-screen buffer) 中。这个过程 CPU 基本不参与，效率极高。</p>
<p><strong>至此，新的一帧画面已经在一个用户看不见的内存缓冲区中准备就绪。</strong></p>
<h3 id="第二阶段提交与显示-steps-7-12">第二阶段：提交与显示 (Steps 7-12)<a hidden class="anchor" aria-hidden="true" href="#第二阶段提交与显示-steps-7-12">#</a></h3>
<h4 id="步骤-7通知绘制完成"><strong>步骤 7：通知绘制完成</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-7通知绘制完成">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Application</code>, <code>QNX Screen</code></li>
<li><strong>关键 API</strong>：<code>screen_post_window()</code></li>
</ul>
<p><code>eglSwapBuffers()</code> 函数在内部通常会触发 <code>screen_post_window()</code> 的调用。这是整个流程中的<strong>关键交接点</strong>。应用程序通过这个 API 调用，正式通知 <code>QNX Screen</code>：“我已经画好了，这个 Buffer 现在归你了，你可以拿去显示了”。完成通知后，应用程序就可以立即使用另一个空闲的 Buffer 来开始准备下一帧的内容，实现流畅的动画效果。</p>
<h4 id="步骤-8--9更新显示管线"><strong>步骤 8 &amp; 9：更新显示管线</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-8--9更新显示管线">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>QNX Screen</code>, <code>OpenWFD Driver</code>, <code>Display Driver</code></li>
<li><strong>关键 API/机制</strong>：<code>wfdDeviceCommit()</code>, <code>devctl</code></li>
</ul>
<p><code>QNX Screen</code> 作为画面合成器 (Compositor)，接收到来自应用程序的通知。它会根据窗口的层级、可见性等状态，决定何时更新屏幕。当决定更新时，它会调用 <code>OpenWFD</code> 函数库提供的 API（例如 <code>wfdDeviceCommit</code>）。</p>
<p><code>OpenWFD</code> 函数库会将这个高级的显示请求，转换成一个具体的 <code>devctl</code> 指令，发送给 <code>Display Driver</code> 这个用户空间进程。这个指令的核心内容是：“请将屏幕上的第 N 层 (Layer)，指向这个新的 Buffer 的物理地址”。</p>
<h4 id="步骤-10更新显示控制器-指针翻转"><strong>步骤 10：更新显示控制器 (指针翻转)</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-10更新显示控制器-指针翻转">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>Display Driver</code>, <code>Display Controller (Hardware)</code></li>
</ul>
<p><code>Display Driver</code> 接收到指令后，它的任务非常单纯且关键：与硬件通信。它会向 <code>Display Controller</code> 硬件的特定寄存器写入一个新的内存地址——也就是那块已经绘制好内容的新 Buffer 的起始地址。</p>
<p>这个操作被称为 <strong>“指针翻转”(Pointer Flip)</strong>。它本身几乎不耗费任何时间，因为没有复制任何像素数据，仅仅是改变了一个指针。</p>
<h4 id="步骤-11--12硬件扫描输出"><strong>步骤 11 &amp; 12：硬件扫描输出</strong><a hidden class="anchor" aria-hidden="true" href="#步骤-11--12硬件扫描输出">#</a></h4>
<ul>
<li><strong>执行者</strong>：<code>Display Controller (Hardware)</code>, <code>Framebuffers</code>, <code>Physical Display</code></li>
</ul>
<p><code>Display Controller</code> 是一个独立工作的硬件单元。它会以固定的频率（例如 60Hz）不断地从它被告知的内存地址开始，逐行读取像素数据，这个过程称为“扫描输出”(Scanout)。</p>
<p>在下一个刷新周期（例如未来的 1/60 秒内），<code>Display Controller</code> 就会自动地从步骤 10 设置的<strong>新地址</strong>开始读取数据。读取到的像素数据被转换成视频信号（如 HDMI），最终发送到实体屏幕上。</p>
<p><strong>至此，用户终于在屏幕上看到了应用程序绘制的新画面。整个高效、流畅的渲染流程宣告完成。</strong></p>
<h2 id="screen_post_window">screen_post_window<a hidden class="anchor" aria-hidden="true" href="#screen_post_window">#</a></h2>
<p><img alt="screen_post_window" loading="lazy" src="/ethenslab/images/qnx-screen-screen_post_window.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
