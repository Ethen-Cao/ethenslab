<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QNX-Android IVI 架构中的 virtio-net 通信 | Ethen 的实验室</title><meta name=keywords content><meta name=description content="本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。


1. 概述
在典型的 QNX-Android 车机（IVI）架构中：

Android guest 负责 UI、应用、车载 App；
QNX Host 作为宿主 OS，负责底层驱动、网络、网关逻辑等；
两者之间通过 QNX Hypervisor 实现虚拟化隔离；
virtio-net 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 T-Box / 外部网络。


2. 整体架构总览
按图的布局，从右到左是：

Android guest
Hypervisor（在底部，负责虚拟化）
QNX Host（包含 io-pkt / qvm / 驱动等）
T-Box / 外部网络

自顶向下的数据路径（单向发送）可以概括为：

Android App
→ Java 网络库
→ libc
→ Linux 网络协议栈
→ virtio-net 驱动
→ virtqueue / shared memory
→ qvm process 中的 vdev-virtio-net
→ QNX Host io-pkt 中的 vdevpeer
→ bridge / route / VLAN
→ 物理网卡驱动
→ T-Box / 外部网络"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/qnx/qnx_hypervisor_net/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/qnx/qnx_hypervisor_net/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/qnx/qnx_hypervisor_net/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="QNX-Android IVI 架构中的 virtio-net 通信"><meta property="og:description" content="本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。
1. 概述 在典型的 QNX-Android 车机（IVI）架构中：
Android guest 负责 UI、应用、车载 App； QNX Host 作为宿主 OS，负责底层驱动、网络、网关逻辑等； 两者之间通过 QNX Hypervisor 实现虚拟化隔离； virtio-net 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 T-Box / 外部网络。 2. 整体架构总览 按图的布局，从右到左是：
Android guest Hypervisor（在底部，负责虚拟化） QNX Host（包含 io-pkt / qvm / 驱动等） T-Box / 外部网络 自顶向下的数据路径（单向发送）可以概括为：
Android App → Java 网络库 → libc → Linux 网络协议栈 → virtio-net 驱动 → virtqueue / shared memory → qvm process 中的 vdev-virtio-net → QNX Host io-pkt 中的 vdevpeer → bridge / route / VLAN → 物理网卡驱动 → T-Box / 外部网络"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="qnx"><meta property="article:published_time" content="2025-11-15T17:17:50+08:00"><meta property="article:modified_time" content="2025-11-15T17:17:50+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QNX-Android IVI 架构中的 virtio-net 通信"><meta name=twitter:description content="本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。


1. 概述
在典型的 QNX-Android 车机（IVI）架构中：

Android guest 负责 UI、应用、车载 App；
QNX Host 作为宿主 OS，负责底层驱动、网络、网关逻辑等；
两者之间通过 QNX Hypervisor 实现虚拟化隔离；
virtio-net 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 T-Box / 外部网络。


2. 整体架构总览
按图的布局，从右到左是：

Android guest
Hypervisor（在底部，负责虚拟化）
QNX Host（包含 io-pkt / qvm / 驱动等）
T-Box / 外部网络

自顶向下的数据路径（单向发送）可以概括为：

Android App
→ Java 网络库
→ libc
→ Linux 网络协议栈
→ virtio-net 驱动
→ virtqueue / shared memory
→ qvm process 中的 vdev-virtio-net
→ QNX Host io-pkt 中的 vdevpeer
→ bridge / route / VLAN
→ 物理网卡驱动
→ T-Box / 外部网络"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"QNX基础原理","item":"https://ethen-cao.github.io/ethenslab/qnx/"},{"@type":"ListItem","position":2,"name":"QNX-Android IVI 架构中的 virtio-net 通信","item":"https://ethen-cao.github.io/ethenslab/qnx/qnx_hypervisor_net/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNX-Android IVI 架构中的 virtio-net 通信","name":"QNX-Android IVI 架构中的 virtio-net 通信","description":"本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。\n1. 概述 在典型的 QNX-Android 车机（IVI）架构中：\nAndroid guest 负责 UI、应用、车载 App； QNX Host 作为宿主 OS，负责底层驱动、网络、网关逻辑等； 两者之间通过 QNX Hypervisor 实现虚拟化隔离； virtio-net 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 T-Box / 外部网络。 2. 整体架构总览 按图的布局，从右到左是：\nAndroid guest Hypervisor（在底部，负责虚拟化） QNX Host（包含 io-pkt / qvm / 驱动等） T-Box / 外部网络 自顶向下的数据路径（单向发送）可以概括为：\nAndroid App → Java 网络库 → libc → Linux 网络协议栈 → virtio-net 驱动 → virtqueue / shared memory → qvm process 中的 vdev-virtio-net → QNX Host io-pkt 中的 vdevpeer → bridge / route / VLAN → 物理网卡驱动 → T-Box / 外部网络\n","keywords":[],"articleBody":"本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。\n1. 概述 在典型的 QNX-Android 车机（IVI）架构中：\nAndroid guest 负责 UI、应用、车载 App； QNX Host 作为宿主 OS，负责底层驱动、网络、网关逻辑等； 两者之间通过 QNX Hypervisor 实现虚拟化隔离； virtio-net 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 T-Box / 外部网络。 2. 整体架构总览 按图的布局，从右到左是：\nAndroid guest Hypervisor（在底部，负责虚拟化） QNX Host（包含 io-pkt / qvm / 驱动等） T-Box / 外部网络 自顶向下的数据路径（单向发送）可以概括为：\nAndroid App → Java 网络库 → libc → Linux 网络协议栈 → virtio-net 驱动 → virtqueue / shared memory → qvm process 中的 vdev-virtio-net → QNX Host io-pkt 中的 vdevpeer → bridge / route / VLAN → 物理网卡驱动 → T-Box / 外部网络\n下面分模块拆开说明。\n3. 关键组件角色 3.1 Android guest 侧 图右侧的 Android guest 中，自上而下是：\nAndroid App\n普通应用，发起 HTTP/HTTPS 请求。 Java 网络库（Java网络库）\n如 OkHttp、HttpURLConnection 等； 负责 HTTP 协议、TLS 握手、证书校验等。 libc（Bionic）\n提供 socket() / connect() / send() / recv() 等系统调用封装； Java 层最终会落到这些 syscall 上。 Linux 网络协议栈（linux 网络协议栈）\nAndroid guest 内核中的 TCP/IP 栈； 负责三次握手、重传、路由、拥塞控制等； 根据路由表选择出口网卡（这里是 virtio-net 对应的 eth0）。 virtio-net 驱动（virtio-net驱动）\nLinux 内核的 virtio 网卡前端驱动 virtio_net；\n在内核视角，这就是一块网卡；\n向下不直接操作真实硬件，而是：\n把待发送的数据写入 virtqueue（环形队列）； 写 virtio 设备 MMIO 寄存器触发 kick 通知。 3.2 virtqueue / shared memory（virtioqueue） 图中标记为 “virtioqueue（share memory）” 的方框是 Android guest 与 vdev-virtio-net 之间共享的数据结构：\n本质是 共享内存中的环形队列（ring buffer）；\n包含：\ndesc table：每个条目描述一块 guest buffer（addr、len、flags、next）； avail ring：guest 写入，告诉设备“这些 desc 已经准备好可用了”； used ring：设备（vdev）写入，告诉 guest “这些 desc 已经处理完了”。 virtio-net 驱动做两件事：\n写数据：把 skb 对应的 buffer 地址写到 desc table，更新 avail ring； 发事件（kick）：向 virtio 设备 MMIO 地址写 QueueNotify 寄存器，告知某个队列有新数据。 3.3 Hypervisor：截获 kick，触发 VM Exit 图底部的 Hypervisor 条代表虚拟化层，它并不直接画出太多细节，但有两点非常关键：\n虚拟设备 MMIO 区域映射\nvirtio-net 的寄存器（包括 QueueNotify）映射在某一块 guest 物理地址区（例如 loc 0x1b018000，具体取决于配置）； 这块地址在二级页表中被标记为“由 Hypervisor 接管”的设备区域。 截获 kick 事件\n当 guest 对虚拟设备 MMIO 地址做写操作（kick）时，硬件触发 guest exit（VM exit）；\nHypervisor 收到 exit 事件，可得知：\n访问的地址； 写入的值（通常是某个 queue index）； 然后 Hypervisor 让 qvm 的 vCPU 线程从 “run” 系统调用返回，把 exit 信息交给 qvm。\n图中有一条从 virtio-net驱动 → Hypervisor 的连线标注为 kick，以及一个说明框：“Hypervisor 截获 guest 对 loc 等 MMIO 区域的访问：触发 guest exit，携带访问地址/数据”。\n3.4 qvm process 与 vdev-virtio-net 图左中部有一个 “qvm process” 方框，内部包含 “vdev-virtio-net” 组件：\nqvm 是运行在 QNX Host 上的用户态进程：\n创建/管理 VM； 运行各 vCPU 线程； 加载各种 vdev 插件（包括 virtio-net 对应的 vdev-virtio-net）。 vdev-virtio-net 是一个设备后端模块，职责包括：\n初始化 virtio-net 设备（配置队列、feature 协商等）；\n在 kick 事件 到来时处理 virtqueue：\n根据队列号（queue_id）找到对应 TX/RX virtqueue； 扫描 avail ring 找到新 desc； 使用与 guest 共享的地址空间访问 buffer（直接访问 guest memory）； 通过 iov/memcpy 读取或写入以太帧数据； 将帧转发给下一层（vdevpeer / io-pkt）或从下一层接收帧写入 RX virtqueue。 图中的说明框对 vdev-virtio-net 的处理流程有详细文字注释：\n根据 queue_id 找到 TX virtqueue 扫描 avail ring 找新 desc 通过共享地址空间访问 guest buffer 用 iov/memcpy 取出以太帧数据 交给 vdevpeer / io-pkt 3.5 QNX Host：io-pkt、vdevpeer、bridge/VLAN、eth driver 图左侧的 QNX Host 方框内部又包含一个 io-pkt 子框，其内有：\nvdevpeer\n一个 QNX 网络驱动模块（例如 devnp-vdevpeer-net.so）； 一侧通过 /dev/vdevpeer/vp_la 与 vdev-virtio-net peer 相连； 在 io-pkt 中表现为一个虚拟网卡接口（例如 vp_la）。 bridge / route / VLAN\nio-pkt 中的桥接、路由、VLAN 逻辑；\n可以把 vp_la 接入：\nL2 bridge（与物理网卡或 VLAN 接口桥接）； L3 路由/NAT； 不同 VLAN（例如外部交换机的 VLAN10/VLAN20）。 eth driver\nQNX 物理网卡驱动（如 devnp-em.so 等）； 对应物理 eth0 / em0 接口； 最终把以太帧从真实物理口发出去，连到 T-Box。 最左边是一个单独的 T-Box 方框，表示车外/远端设备。\n4. 发送路径：Android → QNX → T-Box 结合图，发包路径可以拆解为：\n4.1 Android guest 内部 App → Java 网络库 → libc\nApp 发出 HTTP/HTTPS 请求； Java 网络库对接 libc，发起 socket()、connect()、send() 等系统调用。 libc → Linux 网络协议栈\n内核 TCP/IP 栈根据路由判断出口网卡为 virtio-net（如 eth0）； 生成 TCP 段、IP 包。 Linux 协议栈 → virtio-net 驱动\n内核把 skb 交给 virtio-net； virtio-net 将数据描述为若干 buffer（可能是一段或 scatter-gather）。 virtio-net → virtqueue / shared memory\n把每个 buffer 的 guest 物理地址写入 desc table； 在 avail ring 填入对应的 desc index； 然后向 virtio QueueNotify MMIO 寄存器写入队列号，触发 kick。 4.2 Hypervisor / qvm / vdev-virtio-net kick → Hypervisor → guest exit\nguest 对 loc 对应的 virtio MMIO 地址写操作； Hypervisor 捕获该 MMIO 写，触发 guest exit； exit 信息中包含访问地址和写入的队列号。 guest exit → qvm vCPU 线程返回\nqvm vCPU 线程原本阻塞在 “run” 系统调用中； 有 guest exit 时返回，带出 exit 信息。 qvm → vdev-virtio-net\nqvm 解析 exit 原因，识别这是 virtio-net 的 QueueNotify；\n调用 vdev-virtio-net 的处理函数：\n找到对应 TX virtqueue； 读取 avail ring 新增的 desc； 通过共享地址空间访问 guest buffer，把帧数据取出来。 4.3 vdev-virtio-net → vdevpeer → io-pkt → T-Box vdev-virtio-net → vdevpeer（/dev/vdevpeer/vp_la）\nvdev-virtio-net 将帧写入 vdevpeer； 在 io-pkt 看来，这就是虚拟网卡 vp_la 收到了一个以太帧。 vdevpeer → bridge / route / VLAN\n如果配置为 bridge：\nvp_la 加入某个 bridge，与物理网卡或 VLAN 接口桥接； 如果配置为路由/NAT：\nvp_la 属于一个内部网段，由 QNX 做三层转发； 如果配置 VLAN：\nvp_la 对接 vlan10/vlan20 等接口，接到车内交换机对应的 VLAN。 bridge / VLAN → eth driver → T-Box\n经过 bridge / VLAN 选择，帧被交给对应物理网卡接口（如 em0）； 物理驱动发送帧到线缆/PHY； T-Box 或外部网络设备收到该包。 5. 接收路径：T-Box → QNX → Android（简述） 接收方向与发送方向对称：\nT-Box / 外部设备 → 物理网卡 (eth driver)\n物理网卡驱动收到以太帧，交给 io-pkt。 eth driver → bridge / route / VLAN → vdevpeer(vp_la)\n根据 bridge / VLAN / 路由策略把帧转发到 vp_la。 vdevpeer → vdev-virtio-net\nvdevpeer 把帧交给 vdev-virtio-net；\nvdev-virtio-net 找到对应的 RX virtqueue：\n从 RX 队列取一个 guest 预先提供的 buffer desc； 把帧写入该 buffer； 在 used ring 标记完成。 vdev-virtio-net → virtqueue → virtio-net 驱动\nvdev 更新 used ring 并触发虚拟中断； guest 内核的 virtio-net 驱动通过中断/轮询发现 RX 队列有新包； 将该 buffer 封装为 skb，交给 Linux 协议栈。 Linux 协议栈 → libc → Java 网络库 → App\n内核 TCP/IP 处理 ACK、重组等； 上交到 socket 层，libc recv() 返回； Java 网络库拿到数据，解析 HTTP/TLS； App 得到响应。 6. 设备节点与配置示例 图中的设计隐含了一些关键设备节点及其关系：\nguest 侧 vdev 节点：\n/dev/qvm/la/la_to_host 由 VM 配置中的 system la + name la_to_host 决定； host 侧 peer 节点：\n/dev/vdevpeer/vp_la 由 devnp-vdevpeer-net.so 或 mods-vdevpeer-net 驱动创建； 两者通过 mount -T io-pkt 或 vpctl 等命令进行绑定，最终在 io-pkt 中形成一个网卡接口 vp_la。\n典型示意（伪代码）：\n# 在 QNX Host 上加载 vdevpeer-net 驱动并绑定 virtio-net vdev mount -T io-pkt \\ -o peer=/dev/qvm/la/la_to_host,bind=/dev/vdevpeer/vp_la,mac=02:df:53:00:00:01 \\ /lib/dll/devnp-vdevpeer-net.so # 之后你就可以看到并配置 vp_la 网卡 ifconfig vp_la up # 再把 vp_la 加入 bridge / VLAN 等 7. 总结与调试建议 通过这套 virtio-net 通道：\nAndroid guest 拥有了 和物理网卡无关、但性能接近直连的虚拟网卡；\nQNX Host 则掌握了整个网络出口：\n可以在 bridge / VLAN 处分流到不同车内网络； 可以做 NAT / 防火墙 / QoS； 也可以根据 vp_la 等接口做精细监控。 排查问题时：\nAndroid 侧：看 ip addr / ip route / tcpdump -i eth0（若支持）；\nQNX Host 侧：看 ifconfig vp_la / ifconfig bridgeX / ifconfig eth0 的 RX/TX 计数，必要时抓包；\n若怀疑 virtio/kick 机制异常，可以关注：\nguest 是否频繁触发 VM exit； vdev-virtio-net 是否正确消费 virtqueue； vdevpeer 与 io-pkt 是否正常工作（包是否到达 vp_la）。 这套 virtio-net 架构是 QNX-Android IVI 系统中最关键的“网络桥”，理解本文描述的路径，有助于在设计 VLAN 分流、应用分网卡（Android 内按 UID 分配 Network）、排查偶发断网等问题时，更有把握地定位到哪一层出了问题。\n","wordCount":"895","inLanguage":"en","datePublished":"2025-11-15T17:17:50+08:00","dateModified":"2025-11-15T17:17:50+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/qnx/qnx_hypervisor_net/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/qnx/>QNX基础原理</a></div><h1 class="post-title entry-hint-parent">QNX-Android IVI 架构中的 virtio-net 通信</h1><div class=post-meta><span title='2025-11-15 17:17:50 +0800 CST'>November 15, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;895 words</div></header><div class=post-content><p>本文基于一张 QNX Host + Android guest + Hypervisor + T-Box 的 virtio-net 架构图整理而成，图中展示了从 Android App 到车外 T-Box 的完整网络路径。</p><p><img loading=lazy src=/ethenslab/images/virtio-net.drawio.png></p><hr><h2 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><p>在典型的 QNX-Android 车机（IVI）架构中：</p><ul><li><strong>Android guest</strong> 负责 UI、应用、车载 App；</li><li><strong>QNX Host</strong> 作为宿主 OS，负责底层驱动、网络、网关逻辑等；</li><li>两者之间通过 <strong>QNX Hypervisor</strong> 实现虚拟化隔离；</li><li><strong>virtio-net</strong> 提供了一条高性能的“虚拟网线”，把 Android guest 的网络栈接入 QNX Host 的网络栈，再通过物理网卡连到车外 <strong>T-Box / 外部网络</strong>。</li></ul><hr><h2 id=2-整体架构总览>2. 整体架构总览<a hidden class=anchor aria-hidden=true href=#2-整体架构总览>#</a></h2><p>按图的布局，从右到左是：</p><ul><li><strong>Android guest</strong></li><li><strong>Hypervisor（在底部，负责虚拟化）</strong></li><li><strong>QNX Host（包含 io-pkt / qvm / 驱动等）</strong></li><li><strong>T-Box / 外部网络</strong></li></ul><p>自顶向下的数据路径（单向发送）可以概括为：</p><blockquote><p>Android App
→ Java 网络库
→ libc
→ Linux 网络协议栈
→ virtio-net 驱动
→ virtqueue / shared memory
→ qvm process 中的 vdev-virtio-net
→ QNX Host io-pkt 中的 vdevpeer
→ bridge / route / VLAN
→ 物理网卡驱动
→ T-Box / 外部网络</p></blockquote><p>下面分模块拆开说明。</p><hr><h2 id=3-关键组件角色>3. 关键组件角色<a hidden class=anchor aria-hidden=true href=#3-关键组件角色>#</a></h2><h3 id=31-android-guest-侧>3.1 Android guest 侧<a hidden class=anchor aria-hidden=true href=#31-android-guest-侧>#</a></h3><p>图右侧的 Android guest 中，自上而下是：</p><ol><li><p><strong>Android App</strong></p><ul><li>普通应用，发起 HTTP/HTTPS 请求。</li></ul></li><li><p><strong>Java 网络库（Java网络库）</strong></p><ul><li>如 OkHttp、HttpURLConnection 等；</li><li>负责 HTTP 协议、TLS 握手、证书校验等。</li></ul></li><li><p><strong>libc（Bionic）</strong></p><ul><li>提供 <code>socket() / connect() / send() / recv()</code> 等系统调用封装；</li><li>Java 层最终会落到这些 syscall 上。</li></ul></li><li><p><strong>Linux 网络协议栈（linux 网络协议栈）</strong></p><ul><li>Android guest 内核中的 TCP/IP 栈；</li><li>负责三次握手、重传、路由、拥塞控制等；</li><li>根据路由表选择出口网卡（这里是 virtio-net 对应的 <code>eth0</code>）。</li></ul></li><li><p><strong>virtio-net 驱动（virtio-net驱动）</strong></p><ul><li><p>Linux 内核的 virtio 网卡前端驱动 <code>virtio_net</code>；</p></li><li><p>在内核视角，这就是一块网卡；</p></li><li><p>向下不直接操作真实硬件，而是：</p><ul><li>把待发送的数据写入 <strong>virtqueue（环形队列）</strong>；</li><li>写 virtio 设备 MMIO 寄存器触发 <strong>kick</strong> 通知。</li></ul></li></ul></li></ol><hr><h3 id=32-virtqueue--shared-memoryvirtioqueue>3.2 virtqueue / shared memory（virtioqueue）<a hidden class=anchor aria-hidden=true href=#32-virtqueue--shared-memoryvirtioqueue>#</a></h3><p>图中标记为 <strong>“virtioqueue（share memory）”</strong> 的方框是 Android guest 与 vdev-virtio-net 之间共享的数据结构：</p><ul><li><p>本质是 <strong>共享内存中的环形队列（ring buffer）</strong>；</p></li><li><p>包含：</p><ul><li><strong>desc table</strong>：每个条目描述一块 guest buffer（addr、len、flags、next）；</li><li><strong>avail ring</strong>：guest 写入，告诉设备“这些 desc 已经准备好可用了”；</li><li><strong>used ring</strong>：设备（vdev）写入，告诉 guest “这些 desc 已经处理完了”。</li></ul></li></ul><p>virtio-net 驱动做两件事：</p><ol><li><strong>写数据</strong>：把 skb 对应的 buffer 地址写到 desc table，更新 avail ring；</li><li><strong>发事件（kick）</strong>：向 virtio 设备 MMIO 地址写 QueueNotify 寄存器，告知某个队列有新数据。</li></ol><hr><h3 id=33-hypervisor截获-kick触发-vm-exit>3.3 Hypervisor：截获 kick，触发 VM Exit<a hidden class=anchor aria-hidden=true href=#33-hypervisor截获-kick触发-vm-exit>#</a></h3><p>图底部的 <strong>Hypervisor</strong> 条代表虚拟化层，它并不直接画出太多细节，但有两点非常关键：</p><ol><li><p><strong>虚拟设备 MMIO 区域映射</strong></p><ul><li>virtio-net 的寄存器（包括 QueueNotify）映射在某一块 guest 物理地址区（例如 <code>loc 0x1b018000</code>，具体取决于配置）；</li><li>这块地址在二级页表中被标记为“由 Hypervisor 接管”的设备区域。</li></ul></li><li><p><strong>截获 kick 事件</strong></p><ul><li><p>当 guest 对虚拟设备 MMIO 地址做写操作（kick）时，硬件触发 <strong>guest exit（VM exit）</strong>；</p></li><li><p>Hypervisor 收到 exit 事件，可得知：</p><ul><li>访问的地址；</li><li>写入的值（通常是某个 queue index）；</li></ul></li><li><p>然后 Hypervisor 让 qvm 的 vCPU 线程从 “run” 系统调用返回，把 exit 信息交给 qvm。</p></li></ul></li></ol><p>图中有一条从 <strong>virtio-net驱动 → Hypervisor</strong> 的连线标注为 <code>kick</code>，以及一个说明框：“Hypervisor 截获 guest 对 loc 等 MMIO 区域的访问：触发 guest exit，携带访问地址/数据”。</p><hr><h3 id=34-qvm-process-与-vdev-virtio-net>3.4 qvm process 与 vdev-virtio-net<a hidden class=anchor aria-hidden=true href=#34-qvm-process-与-vdev-virtio-net>#</a></h3><p>图左中部有一个 <strong>“qvm process”</strong> 方框，内部包含 <strong>“vdev-virtio-net”</strong> 组件：</p><ul><li><p><strong>qvm</strong> 是运行在 <strong>QNX Host 上的用户态进程</strong>：</p><ul><li>创建/管理 VM；</li><li>运行各 vCPU 线程；</li><li>加载各种 vdev 插件（包括 virtio-net 对应的 <code>vdev-virtio-net</code>）。</li></ul></li><li><p><strong>vdev-virtio-net</strong> 是一个设备后端模块，职责包括：</p><ul><li><p>初始化 virtio-net 设备（配置队列、feature 协商等）；</p></li><li><p>在 <strong>kick 事件</strong> 到来时处理 virtqueue：</p><ol><li>根据队列号（queue_id）找到对应 TX/RX virtqueue；</li><li>扫描 avail ring 找到新 desc；</li><li>使用与 guest 共享的地址空间访问 buffer（直接访问 guest memory）；</li><li>通过 iov/memcpy 读取或写入以太帧数据；</li><li>将帧转发给下一层（vdevpeer / io-pkt）或从下一层接收帧写入 RX virtqueue。</li></ol></li></ul></li></ul><p>图中的说明框对 vdev-virtio-net 的处理流程有详细文字注释：</p><blockquote><ol><li>根据 queue_id 找到 TX virtqueue</li><li>扫描 avail ring 找新 desc</li><li>通过共享地址空间访问 guest buffer</li><li>用 iov/memcpy 取出以太帧数据</li><li>交给 vdevpeer / io-pkt</li></ol></blockquote><hr><h3 id=35-qnx-hostio-pktvdevpeerbridgevlaneth-driver>3.5 QNX Host：io-pkt、vdevpeer、bridge/VLAN、eth driver<a hidden class=anchor aria-hidden=true href=#35-qnx-hostio-pktvdevpeerbridgevlaneth-driver>#</a></h3><p>图左侧的 <strong>QNX Host</strong> 方框内部又包含一个 <strong>io-pkt</strong> 子框，其内有：</p><ol><li><p><strong>vdevpeer</strong></p><ul><li>一个 QNX 网络驱动模块（例如 <code>devnp-vdevpeer-net.so</code>）；</li><li>一侧通过 <code>/dev/vdevpeer/vp_la</code> 与 vdev-virtio-net peer 相连；</li><li>在 io-pkt 中表现为一个虚拟网卡接口（例如 <code>vp_la</code>）。</li></ul></li><li><p><strong>bridge / route / VLAN</strong></p><ul><li><p>io-pkt 中的桥接、路由、VLAN 逻辑；</p></li><li><p>可以把 <code>vp_la</code> 接入：</p><ul><li>L2 bridge（与物理网卡或 VLAN 接口桥接）；</li><li>L3 路由/NAT；</li><li>不同 VLAN（例如外部交换机的 VLAN10/VLAN20）。</li></ul></li></ul></li><li><p><strong>eth driver</strong></p><ul><li>QNX 物理网卡驱动（如 <code>devnp-em.so</code> 等）；</li><li>对应物理 <code>eth0</code> / <code>em0</code> 接口；</li><li>最终把以太帧从真实物理口发出去，连到 <strong>T-Box</strong>。</li></ul></li></ol><p>最左边是一个单独的 <strong>T-Box</strong> 方框，表示车外/远端设备。</p><hr><h2 id=4-发送路径android--qnx--t-box>4. 发送路径：Android → QNX → T-Box<a hidden class=anchor aria-hidden=true href=#4-发送路径android--qnx--t-box>#</a></h2><p>结合图，发包路径可以拆解为：</p><h3 id=41-android-guest-内部>4.1 Android guest 内部<a hidden class=anchor aria-hidden=true href=#41-android-guest-内部>#</a></h3><ol><li><p><strong>App → Java 网络库 → libc</strong></p><ul><li>App 发出 HTTP/HTTPS 请求；</li><li>Java 网络库对接 libc，发起 <code>socket()</code>、<code>connect()</code>、<code>send()</code> 等系统调用。</li></ul></li><li><p><strong>libc → Linux 网络协议栈</strong></p><ul><li>内核 TCP/IP 栈根据路由判断出口网卡为 virtio-net（如 <code>eth0</code>）；</li><li>生成 TCP 段、IP 包。</li></ul></li><li><p><strong>Linux 协议栈 → virtio-net 驱动</strong></p><ul><li>内核把 skb 交给 virtio-net；</li><li>virtio-net 将数据描述为若干 buffer（可能是一段或 scatter-gather）。</li></ul></li><li><p><strong>virtio-net → virtqueue / shared memory</strong></p><ul><li>把每个 buffer 的 guest 物理地址写入 <strong>desc table</strong>；</li><li>在 <strong>avail ring</strong> 填入对应的 desc index；</li><li>然后向 virtio QueueNotify MMIO 寄存器写入队列号，触发 <strong>kick</strong>。</li></ul></li></ol><h3 id=42-hypervisor--qvm--vdev-virtio-net>4.2 Hypervisor / qvm / vdev-virtio-net<a hidden class=anchor aria-hidden=true href=#42-hypervisor--qvm--vdev-virtio-net>#</a></h3><ol start=5><li><p><strong>kick → Hypervisor → guest exit</strong></p><ul><li>guest 对 <code>loc</code> 对应的 virtio MMIO 地址写操作；</li><li>Hypervisor 捕获该 MMIO 写，触发 guest exit；</li><li>exit 信息中包含访问地址和写入的队列号。</li></ul></li><li><p><strong>guest exit → qvm vCPU 线程返回</strong></p><ul><li>qvm vCPU 线程原本阻塞在 “run” 系统调用中；</li><li>有 guest exit 时返回，带出 exit 信息。</li></ul></li><li><p><strong>qvm → vdev-virtio-net</strong></p><ul><li><p>qvm 解析 exit 原因，识别这是 virtio-net 的 QueueNotify；</p></li><li><p>调用 vdev-virtio-net 的处理函数：</p><ul><li>找到对应 TX virtqueue；</li><li>读取 avail ring 新增的 desc；</li><li>通过共享地址空间访问 guest buffer，把帧数据取出来。</li></ul></li></ul></li></ol><h3 id=43-vdev-virtio-net--vdevpeer--io-pkt--t-box>4.3 vdev-virtio-net → vdevpeer → io-pkt → T-Box<a hidden class=anchor aria-hidden=true href=#43-vdev-virtio-net--vdevpeer--io-pkt--t-box>#</a></h3><ol start=8><li><p><strong>vdev-virtio-net → vdevpeer（/dev/vdevpeer/vp_la）</strong></p><ul><li>vdev-virtio-net 将帧写入 vdevpeer；</li><li>在 io-pkt 看来，这就是虚拟网卡 <code>vp_la</code> 收到了一个以太帧。</li></ul></li><li><p><strong>vdevpeer → bridge / route / VLAN</strong></p><ul><li><p>如果配置为 bridge：</p><ul><li><code>vp_la</code> 加入某个 bridge，与物理网卡或 VLAN 接口桥接；</li></ul></li><li><p>如果配置为路由/NAT：</p><ul><li><code>vp_la</code> 属于一个内部网段，由 QNX 做三层转发；</li></ul></li><li><p>如果配置 VLAN：</p><ul><li><code>vp_la</code> 对接 <code>vlan10</code>/<code>vlan20</code> 等接口，接到车内交换机对应的 VLAN。</li></ul></li></ul></li><li><p><strong>bridge / VLAN → eth driver → T-Box</strong></p><ul><li>经过 bridge / VLAN 选择，帧被交给对应物理网卡接口（如 <code>em0</code>）；</li><li>物理驱动发送帧到线缆/PHY；</li><li>T-Box 或外部网络设备收到该包。</li></ul></li></ol><hr><h2 id=5-接收路径t-box--qnx--android简述>5. 接收路径：T-Box → QNX → Android（简述）<a hidden class=anchor aria-hidden=true href=#5-接收路径t-box--qnx--android简述>#</a></h2><p>接收方向与发送方向对称：</p><ol><li><p><strong>T-Box / 外部设备 → 物理网卡 (eth driver)</strong></p><ul><li>物理网卡驱动收到以太帧，交给 io-pkt。</li></ul></li><li><p><strong>eth driver → bridge / route / VLAN → vdevpeer(vp_la)</strong></p><ul><li>根据 bridge / VLAN / 路由策略把帧转发到 <code>vp_la</code>。</li></ul></li><li><p><strong>vdevpeer → vdev-virtio-net</strong></p><ul><li><p>vdevpeer 把帧交给 vdev-virtio-net；</p></li><li><p>vdev-virtio-net 找到对应的 RX virtqueue：</p><ul><li>从 RX 队列取一个 guest 预先提供的 buffer desc；</li><li>把帧写入该 buffer；</li><li>在 used ring 标记完成。</li></ul></li></ul></li><li><p><strong>vdev-virtio-net → virtqueue → virtio-net 驱动</strong></p><ul><li>vdev 更新 used ring 并触发虚拟中断；</li><li>guest 内核的 virtio-net 驱动通过中断/轮询发现 RX 队列有新包；</li><li>将该 buffer 封装为 skb，交给 Linux 协议栈。</li></ul></li><li><p><strong>Linux 协议栈 → libc → Java 网络库 → App</strong></p><ul><li>内核 TCP/IP 处理 ACK、重组等；</li><li>上交到 socket 层，libc <code>recv()</code> 返回；</li><li>Java 网络库拿到数据，解析 HTTP/TLS；</li><li>App 得到响应。</li></ul></li></ol><hr><h2 id=6-设备节点与配置示例>6. 设备节点与配置示例<a hidden class=anchor aria-hidden=true href=#6-设备节点与配置示例>#</a></h2><p>图中的设计隐含了一些关键设备节点及其关系：</p><ul><li><p><strong>guest 侧 vdev 节点</strong>：</p><ul><li><code>/dev/qvm/la/la_to_host</code></li><li>由 VM 配置中的 <code>system la</code> + <code>name la_to_host</code> 决定；</li></ul></li><li><p><strong>host 侧 peer 节点</strong>：</p><ul><li><code>/dev/vdevpeer/vp_la</code></li><li>由 <code>devnp-vdevpeer-net.so</code> 或 <code>mods-vdevpeer-net</code> 驱动创建；</li></ul></li><li><p>两者通过 <code>mount -T io-pkt</code> 或 <code>vpctl</code> 等命令进行绑定，最终在 io-pkt 中形成一个网卡接口 <code>vp_la</code>。</p></li></ul><p>典型示意（伪代码）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># 在 QNX Host 上加载 vdevpeer-net 驱动并绑定 virtio-net vdev</span>
</span></span><span style=display:flex><span>mount -T io-pkt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -o peer<span style=color:#f92672>=</span>/dev/qvm/la/la_to_host,bind<span style=color:#f92672>=</span>/dev/vdevpeer/vp_la,mac<span style=color:#f92672>=</span>02:df:53:00:00:01 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  /lib/dll/devnp-vdevpeer-net.so
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 之后你就可以看到并配置 vp_la 网卡</span>
</span></span><span style=display:flex><span>ifconfig vp_la up
</span></span><span style=display:flex><span><span style=color:#75715e># 再把 vp_la 加入 bridge / VLAN 等</span>
</span></span></code></pre></div><hr><h2 id=7-总结与调试建议>7. 总结与调试建议<a hidden class=anchor aria-hidden=true href=#7-总结与调试建议>#</a></h2><p>通过这套 virtio-net 通道：</p><ul><li><p>Android guest 拥有了 <strong>和物理网卡无关</strong>、但性能接近直连的虚拟网卡；</p></li><li><p>QNX Host 则掌握了整个网络出口：</p><ul><li>可以在 bridge / VLAN 处分流到不同车内网络；</li><li>可以做 NAT / 防火墙 / QoS；</li><li>也可以根据 <code>vp_la</code> 等接口做精细监控。</li></ul></li></ul><p>排查问题时：</p><ul><li><p><strong>Android 侧</strong>：看 <code>ip addr</code> / <code>ip route</code> / <code>tcpdump -i eth0</code>（若支持）；</p></li><li><p><strong>QNX Host 侧</strong>：看 <code>ifconfig vp_la</code> / <code>ifconfig bridgeX</code> / <code>ifconfig eth0</code> 的 RX/TX 计数，必要时抓包；</p></li><li><p>若怀疑 virtio/kick 机制异常，可以关注：</p><ul><li>guest 是否频繁触发 VM exit；</li><li>vdev-virtio-net 是否正确消费 virtqueue；</li><li>vdevpeer 与 io-pkt 是否正常工作（包是否到达 <code>vp_la</code>）。</li></ul></li></ul><p>这套 virtio-net 架构是 QNX-Android IVI 系统中最关键的“网络桥”，理解本文描述的路径，有助于在设计 VLAN 分流、应用分网卡（Android 内按 UID 分配 Network）、排查偶发断网等问题时，更有把握地定位到哪一层出了问题。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>