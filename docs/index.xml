<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ethen 的实验室</title>
    <link>https://ethen-cao.github.io/ethenslab/</link>
    <description>Recent content on Ethen 的实验室</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 Aug 2025 19:49:26 +0800</lastBuildDate>
    <atom:link href="https://ethen-cao.github.io/ethenslab/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OEM Dynamic Theme Engine: A Multi-brand, Multi-user Technical Solution</title>
      <link>https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine/</link>
      <pubDate>Fri, 08 Aug 2025 19:49:26 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine/</guid>
      <description>&lt;h1 id=&#34;oem-多品牌多使用者動態主題引擎技術方案&#34;&gt;OEM 多品牌多使用者動態主題引擎技術方案&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;版本&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;日期&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;作者&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;修訂說明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2.18&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2025-08-09&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Gemini&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;在附錄中新增了“7.3 TMS 部署模式”的架構決策分析。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;2.19&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;2025-08-09&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Gemini&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;根據使用者提供的圖表，在 7.3 章節中新增了 TMS 部署模式的 PlantUML 對比圖。&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;1-方案概述-executive-summary&#34;&gt;1. 方案概述 (Executive Summary)&lt;/h2&gt;
&lt;p&gt;本方案旨在為 OEM 廠商設計一套企業級的、功能完備的 Android 動態主題引擎。該引擎不僅能滿足多品牌、多 SKU 的出廠預設風格差異化，更能透過功能強大的&lt;strong&gt;主題商店&lt;/strong&gt;，為使用者提供包括主題預覽、個性化微調、跨裝置同步在內的全方位個性化體驗。&lt;/p&gt;
&lt;p&gt;方案核心是自研一個執行於 system_server 的&lt;strong&gt;主題管理服務 (ThemeManagerService, TMS)&lt;/strong&gt;，它作為主題生態的大腦，負責管理主題包的生命週期、處理多使用者環境下的權限與資料隔離、並向上層的&lt;strong&gt;主題商店應用&lt;/strong&gt;提供穩定的 AIDL 介面。&lt;/p&gt;
&lt;p&gt;最終目標是打造一個穩定、高效、安全且可擴展的主題平台，不僅能強化 OEM 品牌形象，更能構建一個開放的第三方主題生態，提升使用者體驗與黏性。&lt;/p&gt;
&lt;h2 id=&#34;2-核心需求與目標&#34;&gt;2. 核心需求與目標&lt;/h2&gt;
&lt;p&gt;本方案旨在滿足以下 14 項核心需求：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;編號&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;需求描述&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;關鍵目標&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;多品牌預設主題&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;實現不同產品線出廠時擁有獨特、固定的品牌視覺識別 (VI)。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;動態主題切換&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;允許使用者在不重啟設備的情況下，一鍵下載、安裝、應用、刪除主題。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;全域深度美化&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;主題效果需覆蓋系統框架、SystemUI、啟動器等多個核心應用，保證體驗一致性。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;多使用者資料隔離&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;在多使用者模式下，每個使用者的主題選擇和私有主題列表應相互獨立，互不影響。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;版本管理&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支援主題的平滑升級與安全回滾，避免因版本問題導致系統不穩定。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;6&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;第三方生態&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;建立標準化的主題包開發規範，允許第三方開發者參與主題製作與分發。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;7&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能優化&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;主題切換應保證流暢快速，避免系統卡頓和耗電過快。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;8&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;安全與權限控制&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;確保主題包來源可信，防止惡意主題破壞系統安全或洩露使用者隱私。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;9&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;個性化主題定製&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支援使用者對主題進行個性化定製，如調整顏色、字體、圖示樣式等。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;10&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;跨裝置同步&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;支援使用者跨裝置同步主題設定，實現無縫體驗。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;11&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;主題預覽功能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;使用者可在應用前預覽主題效果，提升選擇體驗。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;12&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;主題相容性檢測&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;自動檢測主題與系統版本、應用相容性，避免主題導致功能異常。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;13&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;多語言支援&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;主題管理介面及主題包支援多語言，滿足全球使用者需求。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;14&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;主題恢復預設設定&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;提供一鍵恢復系統預設主題的功能，方便使用者快速回退。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-系統架構-system-architecture&#34;&gt;3. 系統架構 (System Architecture)&lt;/h2&gt;
&lt;p&gt;整體架構以自研的 TMS 為核心，協同系統原生服務，向上層應用提供能力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android DRM 框架</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/</link>
      <pubDate>Fri, 08 Aug 2025 11:36:11 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/</guid>
      <description>&lt;h2 id=&#34;widevine-l1-drm-播放流程解读&#34;&gt;Widevine L1 DRM 播放流程解读&lt;/h2&gt;
&lt;p&gt;下面的时序图展示了 &lt;strong&gt;Android 平台 Widevine L1 DRM&lt;/strong&gt; 的核心工作原理，涵盖了 &lt;strong&gt;设备注册、许可证获取、视频解密与安全渲染&lt;/strong&gt; 三个阶段，并特别标注了 &lt;strong&gt;安全关键点（Secure Path）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/drm-contentkey.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;阶段1设备首次注册--公钥上报&#34;&gt;阶段1：设备首次注册 / 公钥上报&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;App 初始化 DRM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用调用 &lt;code&gt;MediaDrm&lt;/code&gt;，系统初始化 DRM 会话。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TEE 生成设备密钥对&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备在 TEE 内部生成 &lt;strong&gt;Device Key Pair&lt;/strong&gt;（公钥/私钥）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私钥仅存在于 TEE 内部，绝不导出&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设备证书生成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TEE 通过 &lt;code&gt;generateProvisioningRequest()&lt;/code&gt; 生成设备证书，包含设备公钥和签名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上传设备证书&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App 将证书发送给 License Server。&lt;/li&gt;
&lt;li&gt;License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;阶段2许可证请求与-content-key-加密&#34;&gt;阶段2：许可证请求与 Content Key 加密&lt;/h3&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成许可证请求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App 调用 &lt;code&gt;getLicenseRequest(Content ID)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;TEE 使用设备私钥对请求进行签名，保证请求合法性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;发送许可证请求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App 将签名请求发送给 License Server。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;许可证生成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;License Server 验证签名。&lt;/li&gt;
&lt;li&gt;使用设备公钥加密 Content Key，并生成许可证响应。&lt;/li&gt;
&lt;li&gt;加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;许可证下发&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android Theme</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/resource/android-theme/</link>
      <pubDate>Fri, 08 Aug 2025 11:36:11 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/resource/android-theme/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Android的&lt;strong&gt;Theme（主题）&lt;/strong&gt;，简单来说，就是一组预定义的视觉样式和属性集合，应用于整个应用或界面，决定界面元素的颜色、字体、控件样式、间距、背景等外观表现。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;详细解释&#34;&gt;详细解释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：统一管理应用界面风格，保持整体视觉一致性，避免在每个控件上单独设置样式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内容&lt;/strong&gt;：包含颜色（primary color、accent color等）、文字样式、按钮样式、控件默认背景、动画、间距、图标等多种属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：Theme是基于&lt;code&gt;style&lt;/code&gt;构建的，且支持继承，常见有系统默认主题（如&lt;code&gt;Theme.Holo&lt;/code&gt;、&lt;code&gt;Theme.MaterialComponents&lt;/code&gt;），开发者可继承这些主题自定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用范围&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局&lt;/strong&gt;：在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中通过&lt;code&gt;application&lt;/code&gt;标签的&lt;code&gt;android:theme&lt;/code&gt;属性设置，影响整个App。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部&lt;/strong&gt;：可在&lt;code&gt;Activity&lt;/code&gt;或&lt;code&gt;View&lt;/code&gt;中单独设置，覆盖全局主题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 应用主题 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;style&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AppTheme&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parent=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Theme.MaterialComponents.DayNight.NoActionBar&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;item&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;colorPrimary&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;@color/my_primary_color&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;item&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;colorAccent&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;@color/my_accent_color&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- 更多自定义属性 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;application&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;android:theme=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@style/AppTheme&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;主题与样式的区别&#34;&gt;主题与样式的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;样式（Style）&lt;/strong&gt;：作用于单个View控件的外观定义（如按钮颜色、字体大小）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主题（Theme）&lt;/strong&gt;：是作用于整个界面或应用的样式集合，包含大量样式属性，能控制全局控件默认行为和外观。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;主题的演进&#34;&gt;主题的演进&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Theme.Holo&lt;/strong&gt;：Android 3.x 引入的较早现代主题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theme.AppCompat&lt;/strong&gt;：支持旧版本Android的兼容库主题，广泛使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theme.MaterialComponents&lt;/strong&gt;：实现Material Design规范，适合Android 5.0及以上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theme.Material3&lt;/strong&gt;：最新Material You设计，支持动态色彩等新特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Android主题演进和结构的图参考如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Android主题演进&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/theme.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;平台主题&#34;&gt;平台主题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;平台主题（Platform Theme）&lt;/strong&gt;，指的是 Android 操作系统自身提供的、内置在系统框架中的主题样式集合。它们是 Android 系统从一开始就带有的基础视觉风格，定义了系统默认的界面外观和控件样式。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;详细说明&#34;&gt;详细说明&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;由谁提供&lt;/strong&gt;：由 Android 系统平台（Framework）自带，随着系统版本升级而演进和扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：为所有应用和系统界面提供默认的视觉风格基准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含了一系列基础样式属性，例如颜色、字体、控件样式、背景等。&lt;/li&gt;
&lt;li&gt;应用默认继承平台主题（如果没有显式指定主题），保证了不同应用界面风格的一致性。&lt;/li&gt;
&lt;li&gt;是所有兼容库主题（如 AppCompat）和第三方主题的基底。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;常见的平台主题&#34;&gt;常见的平台主题&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;主题名称&lt;/th&gt;
          &lt;th&gt;适用API版本&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Theme&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;API 1+&lt;/td&gt;
          &lt;td&gt;最基础的系统主题&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Theme.Holo&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;API 11（Android 3.0）到API 20&lt;/td&gt;
          &lt;td&gt;现代化蓝色调主题，首次引入较统一的视觉风格&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Theme.Material&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;API 21（Android 5.0）及以后&lt;/td&gt;
          &lt;td&gt;实现 Google Material Design规范&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Theme.DeviceDefault&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;API 14+&lt;/td&gt;
          &lt;td&gt;根据设备定制的默认主题&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h4 id=&#34;为什么要用平台主题&#34;&gt;为什么要用平台主题？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：系统提供的主题保证应用在不同Android版本上的基本一致性和兼容性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;：系统主题经过优化，能保证界面流畅。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：开发者可以基于平台主题进一步自定义自己的主题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;平台主题与appcompat主题的关系&#34;&gt;平台主题与AppCompat主题的关系&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;AppCompat是 Google 支持库提供的兼容方案，允许在旧版本Android（比如API 14以下）也能使用现代风格的控件和主题。&lt;/li&gt;
&lt;li&gt;AppCompat主题是基于平台主题（Holo 或 Material）做了二次封装和增强，实现更广泛的兼容。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;平台主题演进：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用AndroidStudio调试AOSP</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/debug/using-androidstudio-to-debug-aosp/</link>
      <pubDate>Fri, 08 Aug 2025 11:36:11 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/using-androidstudio-to-debug-aosp/</guid>
      <description>&lt;h2 id=&#34;调试java进程&#34;&gt;调试Java进程&lt;/h2&gt;
&lt;p&gt;本文介绍如何在 Android Studio 中调试 AOSP (Android Open Source Project) 进程，尤其是像 system_server 这样的系统进程。调试 AOSP 与普通应用调试有所不同，需要借助 JDWP 协议和 adb 端口转发。&lt;/p&gt;
&lt;h3 id=&#34;前置条件&#34;&gt;前置条件&lt;/h3&gt;
&lt;p&gt;环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一台可以刷入 AOSP 的设备或模拟器&lt;/li&gt;
&lt;li&gt;已编译好的 AOSP（推荐 userdebug 或 eng 构建）&lt;/li&gt;
&lt;li&gt;PC 上安装 Android Studio（最新版）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备必须支持 adb root&lt;/li&gt;
&lt;li&gt;设备需要打开调试属性，例如：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adb root
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adb shell setprop persist.system_server.debuggable &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adb shell stop
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;adb shell start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;上述命令让 system_server 在启动时支持调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调试原理&#34;&gt;调试原理&lt;/h3&gt;
&lt;p&gt;Android 使用 JDWP (Java Debug Wire Protocol) 进行 Java 进程调试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_server 内部：包含一个 JDWP Listener 线程，负责接收调试命令并执行（挂起线程、返回堆栈、单步执行等）。&lt;/li&gt;
&lt;li&gt;adb：提供 adb forward 功能，将 PC 本地端口与设备进程的 JDWP 通道连接起来。&lt;/li&gt;
&lt;li&gt;Android Studio：作为调试器，通过 JDWP 协议与 system_server 通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据流示意：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Technical Design for Seamless Full Screen and Split Screen Switching in AutoNavi Map</title>
      <link>https://ethen-cao.github.io/ethenslab/explore-ai/technical-design-for-seamless-full-screen-and-split-screen-switching-in-autonavi-map/</link>
      <pubDate>Mon, 04 Aug 2025 09:49:58 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/explore-ai/technical-design-for-seamless-full-screen-and-split-screen-switching-in-autonavi-map/</guid>
      <description>&lt;h2 id=&#34;需求背景&#34;&gt;需求背景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;核心功能
基于 Android 平台 及 高德AutoSDK，开发一个车载地图应用。该应用需具备两种核心显示形态：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;全屏模式: 地图占据整个屏幕，提供沉浸式导航体验。&lt;/li&gt;
&lt;li&gt;分屏模式: 屏幕左侧约1/3区域显示车辆信息面板（如车模、转向灯状态等），右侧约2/3区域显示地图信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;交互要求&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;应用界面下方存在一个常驻的Dock栏，栏上有一个“地图”按钮。&lt;/li&gt;
&lt;li&gt;用户通过反复点击此按钮，可以在“全屏模式”与“分屏模式”之间循环切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;质量要求&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;“丝滑”过渡: 两种模式之间的切换过程必须是流畅的动画，不能有任何视觉上的中断。&lt;/li&gt;
&lt;li&gt;“三无”标准: 切换动画过程中，严禁出现任何黑屏、闪烁或卡顿掉帧现象，以确保高端、流畅的用户体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;技术挑战与选型&#34;&gt;技术挑战与选型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主要挑战
在Android平台上，对一个正在进行实时、复杂内容渲染的视图（如地图）进行尺寸和位置的变更，是一项极具挑战性的任务。传统的视图动画或直接改变窗口尺寸的方案，往往会触发底层的Window重绘或Surface重建，这个过程耗时较长，极易导致以下问题：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;闪烁/黑屏: 在旧的Surface被销毁、新的Surface尚未完全渲染内容的短暂间隙，屏幕会出现背景色或黑色，造成视觉闪烁。&lt;/li&gt;
&lt;li&gt;卡顿: 如果布局计算和视图重绘的耗时超过了Android系统的一帧渲染时间（约16.6ms），就会导致掉帧，动画看起来就会卡顿、不连贯。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;核心方案选型
为了克服上述挑战，我们选择采用Android官方推荐的、专为复杂UI动画设计的现代技术栈：MotionLayout + TextureView。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;MotionLayout：作为ConstraintLayout的子类，它专为动画而生。它允许我们以声明式的方式在XML中定义多个布局状态，并由系统在底层高效地计算和执行状态之间的过渡动画，性能极高且能轻松处理多视图联动。&lt;/li&gt;
&lt;li&gt;TextureView：高德SDK默认可能使用SurfaceView渲染，它拥有独立的绘图表面，会“打穿”应用窗口，与Android的常规视图动画体系不兼容，是闪烁的主要根源。通过AMapOptions强制SDK使用TextureView，地图内容将被渲染到一个标准的图形纹理上，可以像普通View一样无缝参与到MotionLayout的动画体系中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;详细实现方案&#34;&gt;详细实现方案&lt;/h2&gt;
&lt;h3 id=&#34;强制textureview并初始化sdk&#34;&gt;强制TextureView并初始化SDK&lt;/h3&gt;
&lt;p&gt;MainActivity.kt&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MainActivity&lt;/span&gt; : AppCompatActivity() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; lateinit &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; motionLayout: MotionLayout
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; lateinit &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapView: TextureMapView
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; lateinit &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; mapContainer: CardView
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; lateinit &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; carModelPanel: LinearLayout
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; lateinit &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; toggleButton: FloatingActionButton
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; isFullScreen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    override fun &lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 设置包含MotionLayout的主布局文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        setContentView(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;layout&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;activity_main_split&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        supportActionBar&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;hide&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        MapsInitializer.&lt;span style=&#34;color:#a6e22e&#34;&gt;updatePrivacyAgree&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        MapsInitializer.&lt;span style=&#34;color:#a6e22e&#34;&gt;updatePrivacyShow&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化视图&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        motionLayout &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findViewById(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;motion_layout_main&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapContainer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findViewById(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map_container_card&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        carModelPanel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findViewById(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;car_model_panel&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        toggleButton &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findViewById(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fab_toggle_map&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. Create the options object&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        val aMapOptions &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AMapOptions()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. CRITICAL: Force the use of TextureView&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//aMapOptions.useTextureView(true)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 3. Pass the options into the MapView constructor&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TextureMapView(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 4. Add the MapView to its container&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        val mapContainer: CardView &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; findViewById(R.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map_container_card&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapContainer.&lt;span style=&#34;color:#a6e22e&#34;&gt;addView&lt;/span&gt;(mapView)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 5. Forward the lifecycle event&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView.&lt;span style=&#34;color:#a6e22e&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// --- 控制动画的核心逻辑 ---&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        toggleButton.&lt;span style=&#34;color:#a6e22e&#34;&gt;setOnClickListener&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isFullScreen) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果当前是全屏，则过渡到分屏状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                motionLayout.&lt;span style=&#34;color:#a6e22e&#34;&gt;transitionToEnd&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果当前是分屏，则过渡回全屏状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                motionLayout.&lt;span style=&#34;color:#a6e22e&#34;&gt;transitionToStart&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isFullScreen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isFullScreen
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// --- 严格管理高德SDK的生命周期 ---&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这是确保地图正常显示、避免内存泄漏的必要步骤&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    override fun &lt;span style=&#34;color:#a6e22e&#34;&gt;onResume&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onResume&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView.&lt;span style=&#34;color:#a6e22e&#34;&gt;onResume&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    override fun &lt;span style=&#34;color:#a6e22e&#34;&gt;onPause&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onPause&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView.&lt;span style=&#34;color:#a6e22e&#34;&gt;onPause&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    override fun &lt;span style=&#34;color:#a6e22e&#34;&gt;onDestroy&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onDestroy&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView.&lt;span style=&#34;color:#a6e22e&#34;&gt;onDestroy&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    override fun &lt;span style=&#34;color:#a6e22e&#34;&gt;onSaveInstanceState&lt;/span&gt;(outState: Bundle) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onSaveInstanceState&lt;/span&gt;(outState)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mapView.&lt;span style=&#34;color:#a6e22e&#34;&gt;onSaveInstanceState&lt;/span&gt;(outState)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;布局实现-motionlayout&#34;&gt;布局实现 (MotionLayout)&lt;/h3&gt;
&lt;p&gt;我们使用MotionLayout作为根布局，并在其中定义两个核心功能区：车模面板和地图容器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DFMEA Introduction</title>
      <link>https://ethen-cao.github.io/ethenslab/ivi-solution/dfmea/dfmea-introduction/</link>
      <pubDate>Sun, 03 Aug 2025 17:17:50 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/ivi-solution/dfmea/dfmea-introduction/</guid>
      <description>&lt;h2 id=&#34;什么是dfmea&#34;&gt;什么是DFMEA&lt;/h2&gt;
&lt;p&gt;DFMEA 的全称是 设计失效模式与影响分析 (Design Failure Mode and Effects Analysis)。&lt;/p&gt;
&lt;p&gt;它是一套系统化、结构化的分析工具，主要应用在产品的设计和开发阶段。它的核心思想是**「事前预防，而非事后补救」**。&lt;/p&gt;
&lt;p&gt;简单来说，DFMEA 就是由一群跨职能的专家团队（通常由设计工程师领导），在产品还处在图纸上或电脑模型中时，就主动去预测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;失效模式 (Failure Mode - FM): 这个设计未来可能会在哪些地方出问题？它如何失效？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失效影响 (Failure Effect - FE): 如果真的出问题了，会对顾客、系统或法规造成什么不好的后果？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失效原因 (Failure Cause - FC): 究竟是什么原因会导致这些问题发生？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在找出这些潜在风险后，团队会评估其严重程度，并采取改进行动，从根本上消除或降低这些设计缺陷，以确保最终产品的质量、可靠性和安全性。&lt;/p&gt;
&lt;h2 id=&#34;dfmea-的目的与好处&#34;&gt;DFMEA 的目的与好处&lt;/h2&gt;
&lt;p&gt;实施DFMEA的主要目的和好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提高产品质量与可靠性： 在设计阶段就识别并消除潜在的缺陷，从而减少产品上市后发生故障的机率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低开发成本与风险： 在开发早期修正设计错误的成本，远低于产品投产后甚至交付客户后进行修改、召回的成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩短开发周期： 减少后期的设计变更和反复试验，可以更顺畅地推进开发流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提升客户满意度： 提供更可靠、更安全的产品，直接提升品牌声誉和客户满意度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立知识库： DFMEA的分析过程和结果会被记录下来，成为公司宝贵的知识资产，为未来新产品的开发提供参考。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dfmea-的核心分析流程&#34;&gt;DFMEA 的核心分析流程&lt;/h2&gt;
&lt;p&gt;根据最新的AIAG &amp;amp; VDA FMEA标准，DFMEA通常遵循一个系统化的“七步法”流程：&lt;/p&gt;
&lt;h3 id=&#34;第一步规划与准备-planning-and-preparation&#34;&gt;第一步：规划与准备 (Planning and Preparation)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;定义范围： 明确要分析的是整个系统、某个子系统，还是一个零件。&lt;/li&gt;
&lt;li&gt;成立团队： 组建一个跨职能团队，成员应包含设计、制造、品质、测试等领域的专家。&lt;/li&gt;
&lt;li&gt;确定分析工具与方法： 规划整个DFMEA活动的时间表和所需资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFMEA第一步，即规划与准备 (Planning and Preparation)，其目的是为整个FMEA活动设定清晰的范围、目标和计划。要做好这一步，团队需要收集并审查一系列关键的输入资料。
可以将这些输入资料看作是开启一次成功FMEA分析的“原材料”。它们主要可以分为以下几大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需求与规格类文档
这是最核心的输入，它定义了设计的目标和约束。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利益相关者需求规格书 (STKRS / L1需求):即在 SYS.1 阶段的输出。包含了客户的原始期望、用户场景、业务目标等。它回答了“客户想要什么？”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Gradle Asm Bytecode Transformation Plugin Principles Explained</title>
      <link>https://ethen-cao.github.io/ethenslab/explore-ai/gradle-asm-bytecode-transformation-plugin-principles-explained/</link>
      <pubDate>Sun, 03 Aug 2025 17:17:50 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/explore-ai/gradle-asm-bytecode-transformation-plugin-principles-explained/</guid>
      <description>&lt;h1 id=&#34;gradle-asm-字节码转换插件原理解析&#34;&gt;Gradle ASM 字节码转换插件原理解析&lt;/h1&gt;
&lt;h2 id=&#34;引言问题与解决方案&#34;&gt;引言：问题与解决方案&lt;/h2&gt;
&lt;p&gt;问题：在软件开发中，我们经常会使用一些在高版本 API 中才出现的新方法。例如，java.io.InputStream.readAllBytes() 方法是在 Java 9 中引入的，对应到 Android 平台则是在 API Level 33 (Android 13) 中才可用。当一个应用设置的 minSdk 低于 33 时，如果在代码中直接调用此方法，应用在低版本 Android 设备上运行时会因为找不到该方法而抛出 NoSuchMethodError 异常，导致程序崩溃。&lt;/p&gt;
&lt;p&gt;解决方案：为了解决这个问题，我们需要一种机制，在应用打包之前，自动将这些新 API 的调用替换为我们自己编写的、能在所有版本上运行的兼容性代码。这个过程通常被称为“API 脱糖 (API Desugaring)”。虽然 Android 的构建工具链内置了部分脱糖功能，但它并不涵盖所有情况。&lt;/p&gt;
&lt;p&gt;我们采用的解决方案是创建一个自定义的 Gradle 插件，它利用 Android Gradle 插件 (AGP) 提供的转换 API 和 ASM 字节码操作框架，在编译期直接修改生成的 .class 文件，从根本上解决 API 的兼容性问题。&lt;/p&gt;
&lt;h2 id=&#34;核心概念&#34;&gt;核心概念&lt;/h2&gt;
&lt;p&gt;要理解这个插件，首先需要了解几个核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java 字节码 (.class 文件)：Java 编译器 (javac) 并不直接生成机器码，而是将 .java 源代码编译成一种平台无关的中间指令集，即 Java 字节码，并保存在 .class 文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Android 运行时 (ART)：Android 设备不直接运行 Java 字节码，而是运行经过优化的 DEX (Dalvik Executable) 格式的字节码。在构建过程中，有一个名为 D8 的工具会将所有的 .class 文件和依赖库转换并合并成一个或多个 classes.dex 文件。&lt;/p&gt;</description>
    </item>
    <item>
      <title>OEM 多品牌多用户动态主题引擎 — 软件架构设计文档</title>
      <link>https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/</link>
      <pubDate>Sun, 03 Aug 2025 17:17:50 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/explore-ai/oem-dynamic-theme-engine-sw-architecture-design-doc/</guid>
      <description>&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;：1.0
&lt;strong&gt;日期&lt;/strong&gt;：2025-08-08
&lt;strong&gt;作者&lt;/strong&gt;：Assistant (基于您提供的需求与设计稿)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：基于您给定的 14 项核心需求，提供一份可执行的软件架构设计，包含架构决策、模块划分、接口定义、数据模型、部署/安全/性能要点、替代方案比较与风险缓解措施。本文档假定目标设备为量产 Android 设备（不可获取 platform 私钥），支持多品牌、多用户、主题商店、云同步、个性化微调。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;需求映射（与优先级）&lt;/li&gt;
&lt;li&gt;总体架构（两套可选部署：A. framework TMS；B. App-integrated TMS）&lt;/li&gt;
&lt;li&gt;组件设计与职责&lt;/li&gt;
&lt;li&gt;主题包规范与安装流程（manifest、校验、签名）&lt;/li&gt;
&lt;li&gt;个性化定制实现（推荐方案）&lt;/li&gt;
&lt;li&gt;AIDL / API 设计（system_server 方案）与 App API（App-integrated 方案）&lt;/li&gt;
&lt;li&gt;数据模型（ThemeDB）与同步策略&lt;/li&gt;
&lt;li&gt;安全与权限方案&lt;/li&gt;
&lt;li&gt;性能优化要点与进程/刷新策略&lt;/li&gt;
&lt;li&gt;测试计划与上线验证要点&lt;/li&gt;
&lt;li&gt;替代方案对比与决策理由（含“动态生成 RRO APK”结论）&lt;/li&gt;
&lt;li&gt;风险清单与缓解措施&lt;/li&gt;
&lt;li&gt;迭代路线图（短中长期建议）
附录：PlantUML 示例（安装/应用序列）与示例 AIDL、表结构&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h1&gt;
&lt;p&gt;本架构旨在实现一个企业级、可扩展的主题引擎，满足 OEM 的多品牌预置需求、运行时主题切换、个性化微调、云端同步与多用户隔离。设计原则：&lt;strong&gt;安全优先 → 稳定性 → 可维护性 → 兼顾迭代速度&lt;/strong&gt;。在关键点（TMS 放置、个性化如何实现）提供两条可选路径并给出推荐。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-需求映射优先级&#34;&gt;2. 需求映射（优先级）&lt;/h1&gt;
&lt;p&gt;将原始 14 项需求按优先级分为必需/强烈期望/可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;必需（M）&lt;/strong&gt;：多品牌预设（1），动态主题切换（2），全局深度美化（3），多用户隔离（4），安全与权限控制（8），兼容性检测与恢复默认（12/14）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强烈期望（H）&lt;/strong&gt;：版本管理（5），性能优化（7），主题预览（11），主题包规范（6）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选/增强（L）&lt;/strong&gt;：个性化定制（9），跨设备同步（10），多语言（13）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;架构设计将优先保证 M/H 级需求实现，并对 L 级给出实用可落地方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3-总体架构两种部署选型&#34;&gt;3. 总体架构（两种部署选型）&lt;/h1&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;主要参与方：&lt;strong&gt;主题商店 App (StoreApp)&lt;/strong&gt;、&lt;strong&gt;ThemeManagerService (TMS)&lt;/strong&gt;、&lt;strong&gt;OverlayManagerService (OMS)&lt;/strong&gt;、&lt;strong&gt;PackageManagerService (PMS)&lt;/strong&gt;、&lt;strong&gt;AssetManager&lt;/strong&gt;、&lt;strong&gt;ThemeDB&lt;/strong&gt; 与 &lt;strong&gt;OEM 云服务&lt;/strong&gt;（Server / AccountServer）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>QNX Screen基础原理与流程</title>
      <link>https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/</link>
      <pubDate>Sun, 03 Aug 2025 17:17:50 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/qnx/qnx-screen/</guid>
      <description>&lt;h2 id=&#34;qnx图形栈&#34;&gt;QNX图形栈&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&#34;screen_post_window&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/qnx-screen-overview.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个 QNX 应用程序从无到有，完成一帧 (frame) 窗口渲染并显示在屏幕上的完整过程。&lt;/p&gt;
&lt;p&gt;整个过程可以分为两个核心阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备与渲染阶段&lt;/strong&gt;：应用程序获取绘图空间 (Buffer)，并使用 GPU 将内容绘制到这个空间中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提交与显示阶段&lt;/strong&gt;：应用程序通知系统绘制完成，由系统和硬件接手，将内容呈现在屏幕上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;第一阶段准备与渲染-steps-1-6&#34;&gt;第一阶段：准备与渲染 (Steps 1-6)&lt;/h3&gt;
&lt;h4 id=&#34;步骤-1--2请求并获取窗口缓冲区-buffer&#34;&gt;&lt;strong&gt;步骤 1 &amp;amp; 2：请求并获取窗口缓冲区 (Buffer)&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;执行者&lt;/strong&gt;：&lt;code&gt;QNX Application&lt;/code&gt;, &lt;code&gt;QNX Screen&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键 API&lt;/strong&gt;：&lt;code&gt;screen_create_window_buffers()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个应用程序（例如 HMI 界面）首先需要一块“画布”来进行绘制。它会调用 QNX Screen 提供的 API，请求创建一个窗口以及与之关联的一组（通常是两个或三个，用于实现双缓冲/三缓冲技术）图形缓冲区 (Framebuffers)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QNX Screen&lt;/code&gt; 作为窗口系统管理者，并不会自己分配这块特殊的内存。它会通过 IPC (进程间通信) &lt;strong&gt;请求&lt;/strong&gt; &lt;code&gt;Display/GPU Driver&lt;/code&gt; (资源管理器) 来分配。驱动程序会分配一块符合硬件要求（例如物理上连续）的共享内存，并将其句柄 (handle) 返回给 &lt;code&gt;Screen&lt;/code&gt;。最后，&lt;code&gt;Screen&lt;/code&gt; 再将代表这些 Buffer 的句柄返回给应用程序。至此，应用程序拥有了可以在上面作画的“画布”。&lt;/p&gt;
&lt;h4 id=&#34;步骤-3--4提交绘图指令&#34;&gt;&lt;strong&gt;步骤 3 &amp;amp; 4：提交绘图指令&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;执行者&lt;/strong&gt;：&lt;code&gt;QNX Application&lt;/code&gt;, &lt;code&gt;Graphics API (OpenGL ES + EGL)&lt;/code&gt;, &lt;code&gt;GPU Driver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键 API/机制&lt;/strong&gt;：&lt;code&gt;eglSwapBuffers()&lt;/code&gt;, QNX IPC (&lt;code&gt;msg&lt;/code&gt;/&lt;code&gt;devctl&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序使用像 OpenGL ES 这样的标准图形 API 来描述要绘制的内容（例如按钮、仪表盘、3D 模型等）。这些 API 调用定义了图元的形状、纹理和颜色。&lt;/p&gt;</description>
    </item>
    <item>
      <title>WindowManagerService 解析</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</link>
      <pubDate>Tue, 29 Jul 2025 10:22:54 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</guid>
      <description>&lt;h2 id=&#34;windowmanagerservice-概述&#34;&gt;WindowManagerService 概述&lt;/h2&gt;
&lt;p&gt;WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。&lt;/p&gt;
&lt;p&gt;作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。&lt;/p&gt;
&lt;p&gt;WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;窗口的创建与管理 (Creation &amp;amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布局与计算 (Layout &amp;amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层级与Z序 (Layer &amp;amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绘制与合成 (Drawing &amp;amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;窗口的创建与管理&#34;&gt;窗口的创建与管理&lt;/h2&gt;
&lt;p&gt;窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;WindowState 创建时序示意图&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/windowstate-creation.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。&lt;/li&gt;
&lt;li&gt;ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。&lt;/li&gt;
&lt;li&gt;Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：
&lt;ul&gt;
&lt;li&gt;Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。
&lt;img alt=&#34;WindowToken创建与使用示意图&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/windowtoken-creation-transport.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WMS 的响应动作&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>ActivityManager 深度解析</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/</link>
      <pubDate>Mon, 29 Jul 2024 10:00:00 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/</guid>
      <description>&lt;p&gt;Activity Manager详解&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
