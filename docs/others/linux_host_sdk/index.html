<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="Linux Host Client SDK (libpolaris_client) 技术需求说明书
版本: v0.2
日期: 2026-02-10
模块: src/client
状态: 待实现 (To Be Implemented)
适用范围: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ polarisd（UDS IPC）

订正历史 (Revision History)

  
      
          版本
          日期
          订正人
          订正摘要
      
  
  
      
          v0.1
          2026-02-10
          -
          初版：定义 C API + Builder + 异步队列 + UDS 发送模型
      
      
          v0.2
          2026-02-10
          -
          量产化修订：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点
      
  


1. 概述 (Overview)
libpolaris_client 是一个 C/C++ 动态链接库 (.so)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 polarisd 守护进程。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/others/linux_host_sdk/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/others/linux_host_sdk/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/others/linux_host_sdk/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="Linux Host Client SDK (libpolaris_client) 技术需求说明书 版本: v0.2 日期: 2026-02-10 模块: src/client 状态: 待实现 (To Be Implemented) 适用范围: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ polarisd（UDS IPC）
订正历史 (Revision History) 版本 日期 订正人 订正摘要 v0.1 2026-02-10 - 初版：定义 C API + Builder + 异步队列 + UDS 发送模型 v0.2 2026-02-10 - 量产化修订：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点 1. 概述 (Overview) libpolaris_client 是一个 C/C++ 动态链接库 (.so)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 polarisd 守护进程。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="others"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Linux Host Client SDK (libpolaris_client) 技术需求说明书
版本: v0.2
日期: 2026-02-10
模块: src/client
状态: 待实现 (To Be Implemented)
适用范围: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ polarisd（UDS IPC）

订正历史 (Revision History)

  
      
          版本
          日期
          订正人
          订正摘要
      
  
  
      
          v0.1
          2026-02-10
          -
          初版：定义 C API + Builder + 异步队列 + UDS 发送模型
      
      
          v0.2
          2026-02-10
          -
          量产化修订：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点
      
  


1. 概述 (Overview)
libpolaris_client 是一个 C/C++ 动态链接库 (.so)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 polarisd 守护进程。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"杂记","item":"https://ethen-cao.github.io/ethenslab/others/"},{"@type":"ListItem","position":2,"name":"","item":"https://ethen-cao.github.io/ethenslab/others/linux_host_sdk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Linux Host Client SDK (libpolaris_client) 技术需求说明书 版本: v0.2 日期: 2026-02-10 模块: src/client 状态: 待实现 (To Be Implemented) 适用范围: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ polarisd（UDS IPC）\n订正历史 (Revision History) 版本 日期 订正人 订正摘要 v0.1 2026-02-10 - 初版：定义 C API + Builder + 异步队列 + UDS 发送模型 v0.2 2026-02-10 - 量产化修订：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点 1. 概述 (Overview) libpolaris_client 是一个 C/C++ 动态链接库 (.so)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 polarisd 守护进程。\n","keywords":[],"articleBody":"Linux Host Client SDK (libpolaris_client) 技术需求说明书 版本: v0.2 日期: 2026-02-10 模块: src/client 状态: 待实现 (To Be Implemented) 适用范围: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ polarisd（UDS IPC）\n订正历史 (Revision History) 版本 日期 订正人 订正摘要 v0.1 2026-02-10 - 初版：定义 C API + Builder + 异步队列 + UDS 发送模型 v0.2 2026-02-10 - 量产化修订：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点 1. 概述 (Overview) libpolaris_client 是一个 C/C++ 动态链接库 (.so)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 polarisd 守护进程。\n1.1 核心设计原则（量产标准） 极低侵入性 (Low Intrusiveness) SDK 的异常（内部错误、线程退出、连接失败、队列满）不得导致宿主进程崩溃或长时间阻塞；不得抛出异常穿透 C API。 业务线程零阻塞 (Non-blocking for callers) 业务线程调用 commit/report 必须快速返回；不得等待 socket 可写、不得等待重连。 懒加载且线程安全 (Thread-safe Lazy Init) 第一次 API 调用触发初始化，且多线程并发只允许初始化一次。 可控资源与可观测 (Bounded \u0026 Observable) 内存/CPU/FD 使用必须有上限；必须提供 drop/重连等核心指标统计（至少内部计数 + 限频日志）。 1.2 投递语义（必须写清，避免误用） 默认语义：Best-effort, at-most-once\n队列满：丢弃（drop） 断线：队列缓存到上限，满则丢弃 不提供“必达/事务/确认”保证（未来如需可基于 CMD_REQ/CMD_RESP + reqId 扩展） 2. 架构设计 (Architecture) 采用 生产者-消费者 模型（业务线程生产、后台线程消费），由单例管理全局资源。\n2.1 核心组件 Facade Layer (C API)：polaris_api.h 对外接口实现层 参数校验、Handle 管理、错误码返回、异常边界保护（catch-all） ClientManager (Singleton)：进程内单例 Init/Deinit（幂等） 维护队列、后台线程、Transport 维护统计指标（drop、重连、发送失败等） AsyncQueue（有界队列 + 字节预算） 建议实现为 MPSC 队列 + 全局 byte budget（更易实现变长 payload 的内存上限） 队列满策略：立即丢弃并返回 -EAGAIN WorkerThread（单线程即可） 从队列取数据 → 通过 Transport 发送 连接失败时执行退避重连 无数据时阻塞等待（CV/eventfd/pipe 任一） Transport (UDS) 负责 connect / send（带 MSG_NOSIGNAL） 负责断线检测与重连 负责发送阻塞策略（非阻塞 + poll/timeout） 3. 功能需求 (Functional Requirements) 3.1 句柄与构建器 (Handle \u0026 Builder) Opaque Handle：PolarisEventHandle 映射到内部 PolarisEventBuilder（C++ 对象）。 自动填充（SDK 内部完成）： process_name 为空：读取 /proc/self/comm，并 trim 末尾换行；注意可能被截断（通常 15/16 字符级别），文档需提示调用方必要时传入更准确的业务进程名。 timestamp_ms：获取当前时间戳（ms） pid：getpid() JSON 库选择： 推荐与服务端一致：jsoncpp（减少 schema/序列化差异） 或使用更轻量库（cJSON）但需确保线程安全使用方式（builder 对象私有，无共享全局 state） 约束：同一个 handle 不允许多线程并发修改（builder 常识），但 SDK 对外需明确该约束并提供安全失败策略（见错误码与日志）。\n3.2 异步发送 (Async Reporting) polaris_event_commit： 在 commit 阶段完成序列化（形成 LSP Payload 所需 JSON 字符串） 将序列化结果 push 到 AsyncQueue 后 立即返回 commit 后 handle 立即失效（SDK 内部释放） 队列满策略（硬约束）： 立即丢弃并返回 -EAGAIN 丢弃必须计数（drop_count++），并限频日志（例如每 1000 次打印一次 warning） 3.3 IPC 通信 (Transport) —— 与服务端严格对齐 3.3.1 Socket AF_UNIX + SOCK_STREAM 地址：/run/polaris/polaris_bridge.sock（需可配置：环境变量/配置文件/编译宏三选一） SDK 不负责 unlink/chmod（避免误删服务端 socket）；权限不足时返回错误码并限频日志。 3.3.2 协议：LSP v1（对齐服务端 LspCodec） Header 总长度：12 bytes 字节序：Little Endian Header 结构： 字段 长度 描述 totalLen 4 包总长度（含 Header + Payload） msgType 2 消息类型（见下） reserved 2 保留字段，必须为 0 reqId 4 请求 ID（事件上报为 0） msgType： EVENT_REPORT = 0x0001 CMD_REQ = 0x0020（可选扩展） CMD_RESP = 0x0021（可选扩展） MAX_PACKET_SIZE：2MB（含 header），超出直接拒绝并丢弃该事件（返回 -E2BIG 或 -EINVAL，二选一但要写死） 3.3.3 发送模型（量产化约束） 业务线程不发 socket；仅入队。 WorkerThread 负责发送： 推荐：socket 设置非阻塞，使用 poll() 等待可写，设置写超时（例如 50~200ms） 若遇 EAGAIN：进入 poll 等待（不得 busy loop） 若遇 EPIPE/ECONNRESET/ENOTCONN：断线 → 进入重连流程 SIGPIPE 防御：所有 send 必须使用 MSG_NOSIGNAL 3.3.4 自动重连（退避重试） connect() 失败或发送断线：进入重连退避 推荐参数（写死默认值，可配置）： 初始退避：100ms 指数退避：×2 最大退避：5s 加抖动：±20%（避免多进程同步风暴） 重连期间产生事件：按队列容量缓存，满则丢弃（drop） 3.4 附件处理 (Log Attachment) log_path 透传给 polarisd SDK 不读取、不上传文件内容 SDK 只做轻量校验（可选）： 为空允许 长度上限（防止异常大字符串） 不做 access() 检查（避免额外 I/O 与权限差异） 4. 非功能需求 (Non-Functional Requirements) 4.1 稳定性与安全性（关键） 异常边界 C API 入口必须 try/catch(...)，禁止异常穿透到宿主进程。 线程安全声明 Builder（同 handle）线程不安全：由调用方保证 polaris_event_commit / polaris_report_raw：线程安全（MPSC 入队） Init/Deinit 幂等 Init 使用 std::call_once/pthread_once 确保只初始化一次 polaris_deinit() 可重复调用，不崩溃 Deinit 与并发上报：上报应安全失败并返回错误码（不 crash、不死锁） 资源上限 队列必须有上限：max_pending_bytes（默认 4MB，可配置） 单条 payload 必须有限制（对齐 MAX_PACKET_SIZE） 权限与安全（与服务端策略对齐） 若服务端采用 SO_PEERCRED 白名单：文档需声明接入方需运行在允许的 UID/GID 下 SDK 不主动弱化安全（不 chmod 0666、不 unlink） 4.2 性能指标（可量化验收） commit/report_raw 平均耗时 \u003c 50us（仅内存拷贝、序列化、入队） 注：序列化成本取决于 params 大小；建议对 payload size 给出推荐上限（如 8KB/16KB）并在超限时拒绝 静态内存开销 \u003c 2MB 队列堆积最大内存 \u003c 4MB（默认） 后台线程空闲时必须阻塞等待（CV/事件驱动），CPU 占用接近 0 5. 数据结构定义 5.1 Event JSON Schema（建议写死） 推荐格式（params 为 Object，量产更稳）：\n{ \"eventId\": 1001, \"timestamp\": 1770312345678, \"pid\": 1234, \"processName\": \"hmi_app\", \"processVer\": \"v1.0\", \"params\": { \"cpu\": 50, \"mem\": 1024 }, \"logf\": \"/tmp/crash.log\" } 兼容说明（可选）：若历史服务端仅支持 params 为字符串，可允许 params 为 stringified JSON，但 v0.2 默认推荐 Object，并在联调阶段完成服务端对齐。\n6. 错误码规范（v0.2 新增，量产必须） 所有返回 int 的 API 统一使用如下约定：\n返回值 含义 0 成功（已入队） -EINVAL 参数非法（NULL、空 key、json_body 非法等） -ENOMEM 内存不足（builder/序列化/入队分配失败） -EAGAIN 队列满，事件被丢弃（drop） -E2BIG 单条 payload 超过上限（\u003e MAX_PACKET_SIZE 或 SDK 配置上限） -ENOTCONN （可选）不允许离线缓存且当前未连接（若采用该策略） 说明：polaris_event_add_* 仍为 void（保持 v0.1 ABI），但 v0.2 要求内部对错误进行 计数 + 限频日志；建议 v0.3 再考虑升级为 int 返回。\n7. 可观测性 (Observability)（v0.2 新增） SDK 内部至少维护以下计数器（原子/无锁）并限频输出日志：\nenqueue_count drop_count（队列满/超限） send_count send_fail_count reconnect_count last_errno（最近一次 socket 错误） pending_bytes（当前队列占用字节） 可选扩展（不破坏 v0.1 ABI）：新增 polaris_get_stats() API 在 v0.2+ 作为增量接口。\n8. 接口实现计划（保持，但补充量产实现约束） src/client/PolarisClient.h/cpp\n单例、call_once init、队列（MPSC + byte budget）、worker、统计指标 src/client/PolarisEventBuilder.h/cpp\nbuilder 存储字段与 params object、commit 阶段序列化 src/client/Transport.h/cpp\nUDS 非阻塞、poll 超时、MSG_NOSIGNAL、指数退避重连 src/client/polaris_api.c\nC ABI、参数校验、catch-all、错误码映射、懒加载触发 9. 对外接口定义（v0.2 保持 v0.1 ABI，补充行为定义） 下面接口签名保持不变；v0.2 的变化体现在：错误码规范、线程语义、协议对齐、资源上限与 drop 统计。\n/* * Copyright (C) 2024 Voyah Polaris Project * * Polaris Event Reporting SDK (C API) * Thread-safe, Lazy-initialized, Opaque Handle based design. * * Semantics (v0.2): * - Best-effort, at-most-once delivery. * - Caller thread MUST NOT block on IPC. * - All APIs return 0 on success, negative errno-style value on failure. */ #ifndef POLARIS_API_H #define POLARIS_API_H #include #include #ifdef __cplusplus extern \"C\" { #endif // ============================================================================ // 0. 返回值规范 (Return Codes) // ============================================================================ // 0: success // \u003c0: failure, errno-style // // Recommended common errors: // -EINVAL invalid args / invalid handle / invalid state // -ENOMEM allocation failure // -E2BIG payload too large / key-value too large // -EAGAIN queue full -\u003e dropped // -ECANCELED handle already canceled // -EALREADY handle already committed / SDK already deinit // -ENOTCONN (optional) policy disallows offline caching and not connected // // Note: We intentionally do NOT expose internal error strings here. // Logging is rate-limited inside SDK. #ifndef POLARIS_OK #define POLARIS_OK 0 #endif // ============================================================================ // 1. 类型定义 (Opaque Handle) // ============================================================================ typedef struct PolarisEventBuilderInternal* PolarisEventHandle; // ============================================================================ // 2. 事件构建流程 (Builder Pattern) // ============================================================================ /** * [步骤 1] 创建事件构建器 * - Lazy init: first successful call triggers SDK initialization. * * @param event_id 事件 ID (必填, \u003e0) * @param process_name 逻辑进程名 (可选，NULL 则自动读取 /proc/self/comm) * @param process_ver 版本号 (可选，NULL 默认为 \"unknown\") * @param out_handle [out] 返回 builder handle * * @return 0 on success; \u003c0 on failure (errno-style) */ int polaris_event_create(uint64_t event_id, const char* process_name, const char* process_ver, PolarisEventHandle* out_handle); /** * [步骤 2] 添加 Key-Value 数据 * - Builder is NOT thread-safe: same handle must not be mutated concurrently. * - On error, builder remains valid unless error indicates invalid handle/state. * * @return 0 on success; \u003c0 on failure */ int polaris_event_add_string(PolarisEventHandle handle, const char* key, const char* value); int polaris_event_add_int(PolarisEventHandle handle, const char* key, int32_t value); int polaris_event_add_long(PolarisEventHandle handle, const char* key, int64_t value); int polaris_event_add_double(PolarisEventHandle handle, const char* key, double value); int polaris_event_add_bool(PolarisEventHandle handle, const char* key, bool value); /** * [步骤 3] 提交发送 * - Serializes the event and enqueues to AsyncQueue. * - After this call (success or failure), SDK will destroy the handle. * Caller must NOT use handle anymore. * * @param handle 事件句柄 * @param log_path (可选) 附件路径（仅透传，不读文件） * * @return * 0 enqueue success * -EAGAIN queue full -\u003e dropped * -E2BIG payload too large -\u003e dropped * -EINVAL invalid handle / invalid state * -ENOMEM allocation failure */ int polaris_event_commit(PolarisEventHandle handle, const char* log_path); /** * [可选] 取消发送 * - Releases the builder without sending. * * @return * 0 success * -EINVAL invalid handle * -EALREADY already committed * -ECANCELED already canceled */ int polaris_event_cancel(PolarisEventHandle handle); // ============================================================================ // 3. 高级接口 (Raw JSON) // ============================================================================ /** * 直接发送原始 JSON * - SDK will wrap it into the event schema and enqueue. * - Caller thread returns immediately. * * @param event_id 事件 ID * @param process_name 进程名 (可选，NULL 自动) * @param process_ver 版本号 (可选) * @param json_body 合法 JSON 字符串（UTF-8） * @param log_path (可选) 附件路径 * * @return 0 on success; \u003c0 on failure (see return codes above) */ int polaris_report_raw(uint64_t event_id, const char* process_name, const char* process_ver, const char* json_body, const char* log_path); // ============================================================================ // 4. 生命周期管理 (可选) // ============================================================================ /** * 显式反初始化（幂等） * * Strategy A (recommended for low-intrusive): * - Stop worker thread, drop pending events, return 0. * * Strategy B (strict): * - If pending queue not empty, return -EBUSY unless caller sets \"force\". * * v0.2 default: Strategy A. * * @return 0 on success; \u003c0 on failure */ int polaris_deinit(void); #ifdef __cplusplus } #endif #endif // POLARIS_API_H 10. 验证与验收（v0.2 新增） 10.1 功能验收 正常连接：持续上报 1h 无崩溃、无死锁、无内存泄漏 polarisd 重启：SDK 自动重连；重连期间队列按预算堆积，满则 drop 队列满：业务线程 commit 不阻塞，返回 -EAGAIN，drop_count 增长正确 10.2 协议一致性验收 对齐服务端 LSP v1：12B header、小端、msgType=EVENT_REPORT、reqId=0 payload 超限：SDK 返回 -E2BIG，且不会发出非法包 10.3 性能验收 commit/report_raw 平均 \u003c 50us（按典型 payload：1~4KB） 空闲 CPU 占用 ~0（worker 阻塞等待） ","wordCount":"1222","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/others/linux_host_sdk/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/others/>杂记</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>6 min&nbsp;·&nbsp;1222 words</div></header><div class=post-content><h1 id=linux-host-client-sdk-libpolaris_client-技术需求说明书>Linux Host Client SDK (<code>libpolaris_client</code>) 技术需求说明书<a hidden class=anchor aria-hidden=true href=#linux-host-client-sdk-libpolaris_client-技术需求说明书>#</a></h1><p><strong>版本</strong>: <strong>v0.2</strong>
<strong>日期</strong>: <strong>2026-02-10</strong>
<strong>模块</strong>: <code>src/client</code>
<strong>状态</strong>: <strong>待实现 (To Be Implemented)</strong>
<strong>适用范围</strong>: Linux Host 端业务进程（Cluster/IVI/T-Box 等）→ <code>polarisd</code>（UDS IPC）</p><hr><h2 id=订正历史-revision-history>订正历史 (Revision History)<a hidden class=anchor aria-hidden=true href=#订正历史-revision-history>#</a></h2><table><thead><tr><th>版本</th><th style=text-align:right>日期</th><th>订正人</th><th>订正摘要</th></tr></thead><tbody><tr><td>v0.1</td><td style=text-align:right>2026-02-10</td><td>-</td><td>初版：定义 C API + Builder + 异步队列 + UDS 发送模型</td></tr><tr><td><strong>v0.2</strong></td><td style=text-align:right><strong>2026-02-10</strong></td><td>-</td><td><strong>量产化修订</strong>：对齐服务端 LSP 协议（12B Header / LE / msgType / reqId / MAX_PACKET）、明确投递语义（best-effort at-most-once）、补齐错误码与线程模型、完善队列容量/背压/重连退避、强化安全/权限与可观测性、明确 Init/Deinit 幂等与异常边界、修订 params 类型规范（推荐 Object）、补充测试验收要点</td></tr></tbody></table><hr><h2 id=1-概述-overview>1. 概述 (Overview)<a hidden class=anchor aria-hidden=true href=#1-概述-overview>#</a></h2><p><code>libpolaris_client</code> 是一个 C/C++ 动态链接库 (<code>.so</code>)，供 Linux Host 端业务进程链接使用。其核心职责是将业务产生的事件、日志路径、性能数据通过 IPC 高效、稳定地发送给 <code>polarisd</code> 守护进程。</p><h3 id=11-核心设计原则量产标准>1.1 核心设计原则（量产标准）<a hidden class=anchor aria-hidden=true href=#11-核心设计原则量产标准>#</a></h3><ol><li><strong>极低侵入性 (Low Intrusiveness)</strong>
SDK 的异常（内部错误、线程退出、连接失败、队列满）不得导致宿主进程崩溃或长时间阻塞；不得抛出异常穿透 C API。</li><li><strong>业务线程零阻塞 (Non-blocking for callers)</strong>
业务线程调用 <code>commit/report</code> 必须快速返回；不得等待 socket 可写、不得等待重连。</li><li><strong>懒加载且线程安全 (Thread-safe Lazy Init)</strong>
第一次 API 调用触发初始化，且多线程并发只允许初始化一次。</li><li><strong>可控资源与可观测 (Bounded & Observable)</strong>
内存/CPU/FD 使用必须有上限；必须提供 drop/重连等核心指标统计（至少内部计数 + 限频日志）。</li></ol><h3 id=12-投递语义必须写清避免误用>1.2 投递语义（必须写清，避免误用）<a hidden class=anchor aria-hidden=true href=#12-投递语义必须写清避免误用>#</a></h3><ul><li><p>默认语义：<strong>Best-effort, at-most-once</strong></p><ul><li>队列满：丢弃（drop）</li><li>断线：队列缓存到上限，满则丢弃</li><li>不提供“必达/事务/确认”保证（未来如需可基于 <code>CMD_REQ/CMD_RESP + reqId</code> 扩展）</li></ul></li></ul><hr><h2 id=2-架构设计-architecture>2. 架构设计 (Architecture)<a hidden class=anchor aria-hidden=true href=#2-架构设计-architecture>#</a></h2><p>采用 <strong>生产者-消费者</strong> 模型（业务线程生产、后台线程消费），由单例管理全局资源。</p><h3 id=21-核心组件>2.1 核心组件<a hidden class=anchor aria-hidden=true href=#21-核心组件>#</a></h3><ol><li><strong>Facade Layer (C API)</strong>：<code>polaris_api.h</code> 对外接口实现层<ul><li>参数校验、Handle 管理、错误码返回、异常边界保护（catch-all）</li></ul></li><li><strong>ClientManager (Singleton)</strong>：进程内单例<ul><li>Init/Deinit（幂等）</li><li>维护队列、后台线程、Transport</li><li>维护统计指标（drop、重连、发送失败等）</li></ul></li><li><strong>AsyncQueue（有界队列 + 字节预算）</strong><ul><li>建议实现为 <strong>MPSC 队列 + 全局 byte budget</strong>（更易实现变长 payload 的内存上限）</li><li>队列满策略：立即丢弃并返回 <code>-EAGAIN</code></li></ul></li><li><strong>WorkerThread</strong>（单线程即可）<ul><li>从队列取数据 → 通过 Transport 发送</li><li>连接失败时执行退避重连</li><li>无数据时阻塞等待（CV/eventfd/pipe 任一）</li></ul></li><li><strong>Transport (UDS)</strong><ul><li>负责 connect / send（带 MSG_NOSIGNAL）</li><li>负责断线检测与重连</li><li>负责发送阻塞策略（非阻塞 + poll/timeout）</li></ul></li></ol><hr><h2 id=3-功能需求-functional-requirements>3. 功能需求 (Functional Requirements)<a hidden class=anchor aria-hidden=true href=#3-功能需求-functional-requirements>#</a></h2><h3 id=31-句柄与构建器-handle--builder>3.1 句柄与构建器 (Handle & Builder)<a hidden class=anchor aria-hidden=true href=#31-句柄与构建器-handle--builder>#</a></h3><ul><li><strong>Opaque Handle</strong>：<code>PolarisEventHandle</code> 映射到内部 <code>PolarisEventBuilder</code>（C++ 对象）。</li><li><strong>自动填充</strong>（SDK 内部完成）：<ul><li><code>process_name</code> 为空：读取 <code>/proc/self/comm</code>，并 <strong>trim 末尾换行</strong>；注意可能被截断（通常 15/16 字符级别），文档需提示调用方必要时传入更准确的业务进程名。</li><li><code>timestamp_ms</code>：获取当前时间戳（ms）</li><li><code>pid</code>：<code>getpid()</code></li></ul></li><li><strong>JSON 库选择</strong>：<ul><li>推荐与服务端一致：<code>jsoncpp</code>（减少 schema/序列化差异）</li><li>或使用更轻量库（cJSON）但需确保线程安全使用方式（builder 对象私有，无共享全局 state）</li></ul></li></ul><blockquote><p>约束：同一个 handle <strong>不允许</strong>多线程并发修改（builder 常识），但 SDK 对外需明确该约束并提供安全失败策略（见错误码与日志）。</p></blockquote><h3 id=32-异步发送-async-reporting>3.2 异步发送 (Async Reporting)<a hidden class=anchor aria-hidden=true href=#32-异步发送-async-reporting>#</a></h3><ul><li><code>polaris_event_commit</code>：<ul><li>在 commit 阶段完成序列化（形成 LSP Payload 所需 JSON 字符串）</li><li>将序列化结果 push 到 <code>AsyncQueue</code> 后 <strong>立即返回</strong></li><li>commit 后 handle 立即失效（SDK 内部释放）</li></ul></li><li><strong>队列满策略（硬约束）</strong>：<ul><li>立即丢弃并返回 <code>-EAGAIN</code></li><li>丢弃必须计数（drop_count++），并限频日志（例如每 1000 次打印一次 warning）</li></ul></li></ul><h3 id=33-ipc-通信-transport--与服务端严格对齐>3.3 IPC 通信 (Transport) —— <strong>与服务端严格对齐</strong><a hidden class=anchor aria-hidden=true href=#33-ipc-通信-transport--与服务端严格对齐>#</a></h3><h4 id=331-socket>3.3.1 Socket<a hidden class=anchor aria-hidden=true href=#331-socket>#</a></h4><ul><li><code>AF_UNIX</code> + <code>SOCK_STREAM</code></li><li>地址：<code>/run/polaris/polaris_bridge.sock</code>（需可配置：环境变量/配置文件/编译宏三选一）</li><li>SDK <strong>不负责</strong> unlink/chmod（避免误删服务端 socket）；权限不足时返回错误码并限频日志。</li></ul><h4 id=332-协议lsp-v1对齐服务端-lspcodec>3.3.2 协议：LSP v1（对齐服务端 <code>LspCodec</code>）<a hidden class=anchor aria-hidden=true href=#332-协议lsp-v1对齐服务端-lspcodec>#</a></h4><ul><li><strong>Header 总长度：12 bytes</strong></li><li><strong>字节序：Little Endian</strong></li><li>Header 结构：</li></ul><table><thead><tr><th>字段</th><th style=text-align:right>长度</th><th>描述</th></tr></thead><tbody><tr><td>totalLen</td><td style=text-align:right>4</td><td>包总长度（含 Header + Payload）</td></tr><tr><td>msgType</td><td style=text-align:right>2</td><td>消息类型（见下）</td></tr><tr><td>reserved</td><td style=text-align:right>2</td><td>保留字段，必须为 0</td></tr><tr><td>reqId</td><td style=text-align:right>4</td><td>请求 ID（事件上报为 0）</td></tr></tbody></table><ul><li><code>msgType</code>：<ul><li><code>EVENT_REPORT = 0x0001</code></li><li><code>CMD_REQ = 0x0020</code>（可选扩展）</li><li><code>CMD_RESP = 0x0021</code>（可选扩展）</li></ul></li><li><code>MAX_PACKET_SIZE</code>：<strong>2MB（含 header）</strong>，超出直接拒绝并丢弃该事件（返回 <code>-E2BIG</code> 或 <code>-EINVAL</code>，二选一但要写死）</li></ul><h4 id=333-发送模型量产化约束>3.3.3 发送模型（量产化约束）<a hidden class=anchor aria-hidden=true href=#333-发送模型量产化约束>#</a></h4><ul><li>业务线程不发 socket；仅入队。</li><li>WorkerThread 负责发送：<ul><li>推荐：socket 设置非阻塞，使用 <code>poll()</code> 等待可写，设置写超时（例如 50~200ms）</li><li>若遇 <code>EAGAIN</code>：进入 poll 等待（不得 busy loop）</li><li>若遇 <code>EPIPE/ECONNRESET/ENOTCONN</code>：断线 → 进入重连流程</li></ul></li><li><strong>SIGPIPE 防御</strong>：所有 send 必须使用 <code>MSG_NOSIGNAL</code></li></ul><h4 id=334-自动重连退避重试>3.3.4 自动重连（退避重试）<a hidden class=anchor aria-hidden=true href=#334-自动重连退避重试>#</a></h4><ul><li><code>connect()</code> 失败或发送断线：进入重连退避</li><li>推荐参数（写死默认值，可配置）：<ul><li>初始退避：100ms</li><li>指数退避：×2</li><li>最大退避：5s</li><li>加抖动：±20%（避免多进程同步风暴）</li></ul></li><li>重连期间产生事件：按队列容量缓存，满则丢弃（drop）</li></ul><h3 id=34-附件处理-log-attachment>3.4 附件处理 (Log Attachment)<a hidden class=anchor aria-hidden=true href=#34-附件处理-log-attachment>#</a></h3><ul><li><code>log_path</code> 透传给 <code>polarisd</code></li><li>SDK 不读取、不上传文件内容</li><li>SDK 只做轻量校验（可选）：<ul><li>为空允许</li><li>长度上限（防止异常大字符串）</li><li>不做 <code>access()</code> 检查（避免额外 I/O 与权限差异）</li></ul></li></ul><hr><h2 id=4-非功能需求-non-functional-requirements>4. 非功能需求 (Non-Functional Requirements)<a hidden class=anchor aria-hidden=true href=#4-非功能需求-non-functional-requirements>#</a></h2><h3 id=41-稳定性与安全性关键>4.1 稳定性与安全性（关键）<a hidden class=anchor aria-hidden=true href=#41-稳定性与安全性关键>#</a></h3><ol><li><strong>异常边界</strong><ul><li>C API 入口必须 <code>try/catch(...)</code>，禁止异常穿透到宿主进程。</li></ul></li><li><strong>线程安全声明</strong><ul><li>Builder（同 handle）线程不安全：由调用方保证</li><li><code>polaris_event_commit</code> / <code>polaris_report_raw</code>：<strong>线程安全</strong>（MPSC 入队）</li></ul></li><li><strong>Init/Deinit 幂等</strong><ul><li>Init 使用 <code>std::call_once/pthread_once</code> 确保只初始化一次</li><li><code>polaris_deinit()</code> 可重复调用，不崩溃</li><li>Deinit 与并发上报：上报应安全失败并返回错误码（不 crash、不死锁）</li></ul></li><li><strong>资源上限</strong><ul><li>队列必须有上限：<code>max_pending_bytes</code>（默认 4MB，可配置）</li><li>单条 payload 必须有限制（对齐 <code>MAX_PACKET_SIZE</code>）</li></ul></li><li><strong>权限与安全（与服务端策略对齐）</strong><ul><li>若服务端采用 SO_PEERCRED 白名单：文档需声明接入方需运行在允许的 UID/GID 下</li><li>SDK 不主动弱化安全（不 chmod 0666、不 unlink）</li></ul></li></ol><h3 id=42-性能指标可量化验收>4.2 性能指标（可量化验收）<a hidden class=anchor aria-hidden=true href=#42-性能指标可量化验收>#</a></h3><ol><li><code>commit/report_raw</code> 平均耗时 &lt; 50us（仅内存拷贝、序列化、入队）<ul><li>注：序列化成本取决于 params 大小；建议对 payload size 给出推荐上限（如 8KB/16KB）并在超限时拒绝</li></ul></li><li>静态内存开销 &lt; 2MB</li><li>队列堆积最大内存 &lt; 4MB（默认）</li><li>后台线程空闲时必须阻塞等待（CV/事件驱动），CPU 占用接近 0</li></ol><hr><h2 id=5-数据结构定义>5. 数据结构定义<a hidden class=anchor aria-hidden=true href=#5-数据结构定义>#</a></h2><h3 id=51-event-json-schema建议写死>5.1 Event JSON Schema（建议写死）<a hidden class=anchor aria-hidden=true href=#51-event-json-schema建议写死>#</a></h3><p><strong>推荐格式（params 为 Object，量产更稳）</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;eventId&#34;</span>: <span style=color:#ae81ff>1001</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;timestamp&#34;</span>: <span style=color:#ae81ff>1770312345678</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;pid&#34;</span>: <span style=color:#ae81ff>1234</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;processName&#34;</span>: <span style=color:#e6db74>&#34;hmi_app&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;processVer&#34;</span>: <span style=color:#e6db74>&#34;v1.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;params&#34;</span>: { <span style=color:#f92672>&#34;cpu&#34;</span>: <span style=color:#ae81ff>50</span>, <span style=color:#f92672>&#34;mem&#34;</span>: <span style=color:#ae81ff>1024</span> },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;logf&#34;</span>: <span style=color:#e6db74>&#34;/tmp/crash.log&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>兼容说明（可选）：若历史服务端仅支持 params 为字符串，可允许 <code>params</code> 为 stringified JSON，但 v0.2 默认推荐 Object，并在联调阶段完成服务端对齐。</p></blockquote><hr><h2 id=6-错误码规范v02-新增量产必须>6. 错误码规范（v0.2 新增，量产必须）<a hidden class=anchor aria-hidden=true href=#6-错误码规范v02-新增量产必须>#</a></h2><p>所有返回 <code>int</code> 的 API 统一使用如下约定：</p><table><thead><tr><th style=text-align:right>返回值</th><th>含义</th></tr></thead><tbody><tr><td style=text-align:right>0</td><td>成功（已入队）</td></tr><tr><td style=text-align:right>-EINVAL</td><td>参数非法（NULL、空 key、json_body 非法等）</td></tr><tr><td style=text-align:right>-ENOMEM</td><td>内存不足（builder/序列化/入队分配失败）</td></tr><tr><td style=text-align:right>-EAGAIN</td><td>队列满，事件被丢弃（drop）</td></tr><tr><td style=text-align:right>-E2BIG</td><td>单条 payload 超过上限（> MAX_PACKET_SIZE 或 SDK 配置上限）</td></tr><tr><td style=text-align:right>-ENOTCONN</td><td>（可选）不允许离线缓存且当前未连接（若采用该策略）</td></tr></tbody></table><blockquote><p>说明：<code>polaris_event_add_*</code> 仍为 void（保持 v0.1 ABI），但 v0.2 要求内部对错误进行 <strong>计数 + 限频日志</strong>；建议 v0.3 再考虑升级为 <code>int</code> 返回。</p></blockquote><hr><h2 id=7-可观测性-observabilityv02-新增>7. 可观测性 (Observability)（v0.2 新增）<a hidden class=anchor aria-hidden=true href=#7-可观测性-observabilityv02-新增>#</a></h2><p>SDK 内部至少维护以下计数器（原子/无锁）并限频输出日志：</p><ul><li><code>enqueue_count</code></li><li><code>drop_count</code>（队列满/超限）</li><li><code>send_count</code></li><li><code>send_fail_count</code></li><li><code>reconnect_count</code></li><li><code>last_errno</code>（最近一次 socket 错误）</li><li><code>pending_bytes</code>（当前队列占用字节）</li></ul><blockquote><p>可选扩展（不破坏 v0.1 ABI）：新增 <code>polaris_get_stats()</code> API 在 v0.2+ 作为增量接口。</p></blockquote><hr><h2 id=8-接口实现计划保持但补充量产实现约束>8. 接口实现计划（保持，但补充量产实现约束）<a hidden class=anchor aria-hidden=true href=#8-接口实现计划保持但补充量产实现约束>#</a></h2><ol><li><p><code>src/client/PolarisClient.h/cpp</code></p><ul><li>单例、call_once init、队列（MPSC + byte budget）、worker、统计指标</li></ul></li><li><p><code>src/client/PolarisEventBuilder.h/cpp</code></p><ul><li>builder 存储字段与 params object、commit 阶段序列化</li></ul></li><li><p><code>src/client/Transport.h/cpp</code></p><ul><li>UDS 非阻塞、poll 超时、MSG_NOSIGNAL、指数退避重连</li></ul></li><li><p><code>src/client/polaris_api.c</code></p><ul><li>C ABI、参数校验、catch-all、错误码映射、懒加载触发</li></ul></li></ol><hr><h2 id=9-对外接口定义v02-保持-v01-abi补充行为定义>9. 对外接口定义（v0.2 保持 v0.1 ABI，补充行为定义）<a hidden class=anchor aria-hidden=true href=#9-对外接口定义v02-保持-v01-abi补充行为定义>#</a></h2><blockquote><p>下面接口签名保持不变；v0.2 的变化体现在：<strong>错误码规范、线程语义、协议对齐、资源上限与 drop 统计</strong>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Copyright (C) 2024 Voyah Polaris Project
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Polaris Event Reporting SDK (C API)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Thread-safe, Lazy-initialized, Opaque Handle based design.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Semantics (v0.2):
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Best-effort, at-most-once delivery.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Caller thread MUST NOT block on IPC.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - All APIs return 0 on success, negative errno-style value on failure.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef POLARIS_API_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define POLARIS_API_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 0. 返回值规范 (Return Codes)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 0: success
</span></span></span><span style=display:flex><span><span style=color:#75715e>// &lt;0: failure, errno-style
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Recommended common errors:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -EINVAL   invalid args / invalid handle / invalid state
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -ENOMEM   allocation failure
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -E2BIG    payload too large / key-value too large
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -EAGAIN   queue full -&gt; dropped
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -ECANCELED handle already canceled
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -EALREADY  handle already committed / SDK already deinit
</span></span></span><span style=display:flex><span><span style=color:#75715e>// -ENOTCONN (optional) policy disallows offline caching and not connected
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Note: We intentionally do NOT expose internal error strings here.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Logging is rate-limited inside SDK.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef POLARIS_OK
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define POLARIS_OK 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 1. 类型定义 (Opaque Handle)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PolarisEventBuilderInternal</span><span style=color:#f92672>*</span> PolarisEventHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 事件构建流程 (Builder Pattern)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 1] 创建事件构建器
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Lazy init: first successful call triggers SDK initialization.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param event_id       事件 ID (必填, &gt;0)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_name   逻辑进程名 (可选，NULL 则自动读取 /proc/self/comm)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_ver    版本号 (可选，NULL 默认为 &#34;unknown&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param out_handle     [out] 返回 builder handle
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return 0 on success; &lt;0 on failure (errno-style)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_create</span>(<span style=color:#66d9ef>uint64_t</span> event_id,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_name,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_ver,
</span></span><span style=display:flex><span>                         PolarisEventHandle<span style=color:#f92672>*</span> out_handle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 2] 添加 Key-Value 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Builder is NOT thread-safe: same handle must not be mutated concurrently.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - On error, builder remains valid unless error indicates invalid handle/state.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return 0 on success; &lt;0 on failure
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_add_string</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_add_int</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>int32_t</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_add_long</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>int64_t</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_add_double</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>double</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_add_bool</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>bool</span> value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 3] 提交发送
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Serializes the event and enqueues to AsyncQueue.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - After this call (success or failure), SDK will destroy the handle.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *   Caller must NOT use handle anymore.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param handle    事件句柄
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param log_path  (可选) 附件路径（仅透传，不读文件）
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  0        enqueue success
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -EAGAIN   queue full -&gt; dropped
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -E2BIG    payload too large -&gt; dropped
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -EINVAL   invalid handle / invalid state
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -ENOMEM   allocation failure
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_commit</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> log_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [可选] 取消发送
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Releases the builder without sending.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  0          success
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -EINVAL     invalid handle
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -EALREADY   already committed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * -ECANCELED  already canceled
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_cancel</span>(PolarisEventHandle handle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3. 高级接口 (Raw JSON)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 直接发送原始 JSON
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - SDK will wrap it into the event schema and enqueue.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Caller thread returns immediately.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param event_id      事件 ID
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_name  进程名 (可选，NULL 自动)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_ver   版本号 (可选)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param json_body     合法 JSON 字符串（UTF-8）
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param log_path      (可选) 附件路径
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return 0 on success; &lt;0 on failure (see return codes above)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_report_raw</span>(<span style=color:#66d9ef>uint64_t</span> event_id,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_name,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_ver,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> json_body,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> log_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 4. 生命周期管理 (可选)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 显式反初始化（幂等）
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Strategy A (recommended for low-intrusive):
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - Stop worker thread, drop pending events, return 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Strategy B (strict):
</span></span></span><span style=display:flex><span><span style=color:#75715e> * - If pending queue not empty, return -EBUSY unless caller sets &#34;force&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * v0.2 default: Strategy A.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return 0 on success; &lt;0 on failure
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_deinit</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// POLARIS_API_H
</span></span></span></code></pre></div><hr><h2 id=10-验证与验收v02-新增>10. 验证与验收（v0.2 新增）<a hidden class=anchor aria-hidden=true href=#10-验证与验收v02-新增>#</a></h2><h3 id=101-功能验收>10.1 功能验收<a hidden class=anchor aria-hidden=true href=#101-功能验收>#</a></h3><ul><li>正常连接：持续上报 1h 无崩溃、无死锁、无内存泄漏</li><li>polarisd 重启：SDK 自动重连；重连期间队列按预算堆积，满则 drop</li><li>队列满：业务线程 commit 不阻塞，返回 -EAGAIN，drop_count 增长正确</li></ul><h3 id=102-协议一致性验收>10.2 协议一致性验收<a hidden class=anchor aria-hidden=true href=#102-协议一致性验收>#</a></h3><ul><li>对齐服务端 LSP v1：12B header、小端、msgType=EVENT_REPORT、reqId=0</li><li>payload 超限：SDK 返回 -E2BIG，且不会发出非法包</li></ul><h3 id=103-性能验收>10.3 性能验收<a hidden class=anchor aria-hidden=true href=#103-性能验收>#</a></h3><ul><li>commit/report_raw 平均 &lt; 50us（按典型 payload：1~4KB）</li><li>空闲 CPU 占用 ~0（worker 阻塞等待）</li></ul><hr></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>