<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="Linux Host IPC 模块技术需求说明书
版本: v1.1
日期: 2026-02-10
模块: src/transport/ipc
状态: 已冻结 (Ready for Coding)

1. 概述 (Overview)
IPC 模块是 polarisd 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 Unix Domain Socket (SOCK_STREAM)，采用 Epoll Reactor 模型。
v1.1 版本重点增强了 生产环境适应性，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。
核心组件

IpcServer: 负责 Socket 生命周期、连接监听、事件分发 (epoll_wait) 和 线程控制。
ClientSession: 负责单连接的数据缓冲、LSP 协议编解码、以及 EAGAIN 状态下的发送队列管理。


2. 详细功能需求 (Functional Requirements)
2.1 传输层规范 (Transport Layer)


Socket 类型: AF_UNIX (Local Socket) / SOCK_STREAM (TCP-like)。


Socket 路径: /run/polaris/polaris_bridge.sock

理由: 符合 Linux FHS 标准，/run 为 tmpfs (内存文件系统)，重启自动清理，且比 /tmp 更安全。



权限策略:"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/others/linux_host_ipc/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/others/linux_host_ipc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/others/linux_host_ipc/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="Linux Host IPC 模块技术需求说明书 版本: v1.1 日期: 2026-02-10 模块: src/transport/ipc 状态: 已冻结 (Ready for Coding)
1. 概述 (Overview) IPC 模块是 polarisd 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 Unix Domain Socket (SOCK_STREAM)，采用 Epoll Reactor 模型。 v1.1 版本重点增强了 生产环境适应性，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。
核心组件 IpcServer: 负责 Socket 生命周期、连接监听、事件分发 (epoll_wait) 和 线程控制。 ClientSession: 负责单连接的数据缓冲、LSP 协议编解码、以及 EAGAIN 状态下的发送队列管理。 2. 详细功能需求 (Functional Requirements) 2.1 传输层规范 (Transport Layer) Socket 类型: AF_UNIX (Local Socket) / SOCK_STREAM (TCP-like)。
Socket 路径: /run/polaris/polaris_bridge.sock
理由: 符合 Linux FHS 标准，/run 为 tmpfs (内存文件系统)，重启自动清理，且比 /tmp 更安全。 权限策略:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="others"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Linux Host IPC 模块技术需求说明书
版本: v1.1
日期: 2026-02-10
模块: src/transport/ipc
状态: 已冻结 (Ready for Coding)

1. 概述 (Overview)
IPC 模块是 polarisd 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 Unix Domain Socket (SOCK_STREAM)，采用 Epoll Reactor 模型。
v1.1 版本重点增强了 生产环境适应性，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。
核心组件

IpcServer: 负责 Socket 生命周期、连接监听、事件分发 (epoll_wait) 和 线程控制。
ClientSession: 负责单连接的数据缓冲、LSP 协议编解码、以及 EAGAIN 状态下的发送队列管理。


2. 详细功能需求 (Functional Requirements)
2.1 传输层规范 (Transport Layer)


Socket 类型: AF_UNIX (Local Socket) / SOCK_STREAM (TCP-like)。


Socket 路径: /run/polaris/polaris_bridge.sock

理由: 符合 Linux FHS 标准，/run 为 tmpfs (内存文件系统)，重启自动清理，且比 /tmp 更安全。



权限策略:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"杂记","item":"https://ethen-cao.github.io/ethenslab/others/"},{"@type":"ListItem","position":2,"name":"","item":"https://ethen-cao.github.io/ethenslab/others/linux_host_ipc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Linux Host IPC 模块技术需求说明书 版本: v1.1 日期: 2026-02-10 模块: src/transport/ipc 状态: 已冻结 (Ready for Coding)\n1. 概述 (Overview) IPC 模块是 polarisd 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 Unix Domain Socket (SOCK_STREAM)，采用 Epoll Reactor 模型。 v1.1 版本重点增强了 生产环境适应性，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。\n核心组件 IpcServer: 负责 Socket 生命周期、连接监听、事件分发 (epoll_wait) 和 线程控制。 ClientSession: 负责单连接的数据缓冲、LSP 协议编解码、以及 EAGAIN 状态下的发送队列管理。 2. 详细功能需求 (Functional Requirements) 2.1 传输层规范 (Transport Layer) Socket 类型: AF_UNIX (Local Socket) / SOCK_STREAM (TCP-like)。\nSocket 路径: /run/polaris/polaris_bridge.sock\n理由: 符合 Linux FHS 标准，/run 为 tmpfs (内存文件系统)，重启自动清理，且比 /tmp 更安全。 权限策略:\n","keywords":[],"articleBody":"Linux Host IPC 模块技术需求说明书 版本: v1.1 日期: 2026-02-10 模块: src/transport/ipc 状态: 已冻结 (Ready for Coding)\n1. 概述 (Overview) IPC 模块是 polarisd 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 Unix Domain Socket (SOCK_STREAM)，采用 Epoll Reactor 模型。 v1.1 版本重点增强了 生产环境适应性，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。\n核心组件 IpcServer: 负责 Socket 生命周期、连接监听、事件分发 (epoll_wait) 和 线程控制。 ClientSession: 负责单连接的数据缓冲、LSP 协议编解码、以及 EAGAIN 状态下的发送队列管理。 2. 详细功能需求 (Functional Requirements) 2.1 传输层规范 (Transport Layer) Socket 类型: AF_UNIX (Local Socket) / SOCK_STREAM (TCP-like)。\nSocket 路径: /run/polaris/polaris_bridge.sock\n理由: 符合 Linux FHS 标准，/run 为 tmpfs (内存文件系统)，重启自动清理，且比 /tmp 更安全。 权限策略:\n目录权限: /run/polaris/ 权限设为 0755 (Owner: root, Group: root)。 文件权限: Socket 文件权限设为 0666 (rw-rw-rw-)，允许任何用户进程连接（后续可通过 PeerCred 过滤）。 最大连接数: 硬限制 128 (超过此数值 accept 后立即关闭)。\n2.2 生命周期管理 (Lifecycle) 启动清理 (Stale Socket Cleanup):\n在 bind() 之前，必须调用 unlink(SOCKET_PATH)，防止因上次异常退出遗留文件导致 EADDRINUSE 错误。 优雅退出 (Graceful Shutdown):\n引入 eventfd 作为唤醒机制。 stop() 函数向 eventfd 写入 uint64_t (1)，立即唤醒阻塞在 epoll_wait 的线程。 退出时，需遍历所有活跃 Session，关闭 FD 并释放内存。 2.3 协议契约 (Protocol Contract) 编解码: 严格使用 LspCodec (Header 12 Bytes, No Magic)。 最大帧限制: 单个 Frame (Header + Payload) 最大 2MB。超过此大小视为恶意攻击，强制断开连接。 字节序: Little Endian (Host Order on ARM64/x86). 3. 关键非功能需求 (Non-Functional Requirements) 3.1 健壮性与流控 (Robustness \u0026 Flow Control) 发送端流控 (Outbound Handling):\n非阻塞发送: Socket 必须设为 O_NONBLOCK。 EAGAIN 处理: send() 返回 EAGAIN 或 EWOULDBLOCK 时，严禁阻塞等待或丢弃数据。 发送队列: ClientSession 需维护 std::deque","wordCount":"544","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/others/linux_host_ipc/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/others/>杂记</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>3 min&nbsp;·&nbsp;544 words</div></header><div class=post-content><h1 id=linux-host-ipc-模块技术需求说明书>Linux Host IPC 模块技术需求说明书<a hidden class=anchor aria-hidden=true href=#linux-host-ipc-模块技术需求说明书>#</a></h1><p><strong>版本</strong>: v1.1
<strong>日期</strong>: 2026-02-10
<strong>模块</strong>: <code>src/transport/ipc</code>
<strong>状态</strong>: <strong>已冻结 (Ready for Coding)</strong></p><hr><h2 id=1-概述-overview>1. 概述 (Overview)<a hidden class=anchor aria-hidden=true href=#1-概述-overview>#</a></h2><p>IPC 模块是 <code>polarisd</code> 与 Linux 本地业务进程（Client）之间的通信桥梁。它基于 <strong>Unix Domain Socket (SOCK_STREAM)</strong>，采用 <strong>Epoll Reactor</strong> 模型。
v1.1 版本重点增强了 <strong>生产环境适应性</strong>，包括标准路径规范、优雅退出机制、发送流控（Backpressure）以及基础的安全审计能力。</p><h3 id=核心组件>核心组件<a hidden class=anchor aria-hidden=true href=#核心组件>#</a></h3><ol><li><strong>IpcServer</strong>: 负责 Socket 生命周期、连接监听、事件分发 (<code>epoll_wait</code>) 和 线程控制。</li><li><strong>ClientSession</strong>: 负责单连接的数据缓冲、LSP 协议编解码、以及 <code>EAGAIN</code> 状态下的发送队列管理。</li></ol><hr><h2 id=2-详细功能需求-functional-requirements>2. 详细功能需求 (Functional Requirements)<a hidden class=anchor aria-hidden=true href=#2-详细功能需求-functional-requirements>#</a></h2><h3 id=21-传输层规范-transport-layer>2.1 传输层规范 (Transport Layer)<a hidden class=anchor aria-hidden=true href=#21-传输层规范-transport-layer>#</a></h3><ul><li><p><strong>Socket 类型</strong>: <code>AF_UNIX</code> (Local Socket) / <code>SOCK_STREAM</code> (TCP-like)。</p></li><li><p><strong>Socket 路径</strong>: <code>/run/polaris/polaris_bridge.sock</code></p><ul><li><em>理由</em>: 符合 Linux FHS 标准，<code>/run</code> 为 tmpfs (内存文件系统)，重启自动清理，且比 <code>/tmp</code> 更安全。</li></ul></li><li><p><strong>权限策略</strong>:</p><ul><li><strong>目录权限</strong>: <code>/run/polaris/</code> 权限设为 <code>0755</code> (Owner: root, Group: root)。</li><li><strong>文件权限</strong>: Socket 文件权限设为 <code>0666</code> (rw-rw-rw-)，允许任何用户进程连接（后续可通过 PeerCred 过滤）。</li></ul></li><li><p><strong>最大连接数</strong>: 硬限制 <strong>128</strong> (超过此数值 <code>accept</code> 后立即关闭)。</p></li></ul><h3 id=22-生命周期管理-lifecycle>2.2 生命周期管理 (Lifecycle)<a hidden class=anchor aria-hidden=true href=#22-生命周期管理-lifecycle>#</a></h3><ol><li><p><strong>启动清理 (Stale Socket Cleanup)</strong>:</p><ul><li>在 <code>bind()</code> 之前，<strong>必须</strong>调用 <code>unlink(SOCKET_PATH)</code>，防止因上次异常退出遗留文件导致 <code>EADDRINUSE</code> 错误。</li></ul></li><li><p><strong>优雅退出 (Graceful Shutdown)</strong>:</p><ul><li>引入 <strong><code>eventfd</code></strong> 作为唤醒机制。</li><li><code>stop()</code> 函数向 <code>eventfd</code> 写入 uint64_t (1)，立即唤醒阻塞在 <code>epoll_wait</code> 的线程。</li><li>退出时，需遍历所有活跃 Session，关闭 FD 并释放内存。</li></ul></li></ol><h3 id=23-协议契约-protocol-contract>2.3 协议契约 (Protocol Contract)<a hidden class=anchor aria-hidden=true href=#23-协议契约-protocol-contract>#</a></h3><ul><li><strong>编解码</strong>: 严格使用 <code>LspCodec</code> (Header 12 Bytes, No Magic)。</li><li><strong>最大帧限制</strong>: 单个 Frame (Header + Payload) 最大 <strong>2MB</strong>。超过此大小视为恶意攻击，强制断开连接。</li><li><strong>字节序</strong>: Little Endian (Host Order on ARM64/x86).</li></ul><hr><h2 id=3-关键非功能需求-non-functional-requirements>3. 关键非功能需求 (Non-Functional Requirements)<a hidden class=anchor aria-hidden=true href=#3-关键非功能需求-non-functional-requirements>#</a></h2><h3 id=31-健壮性与流控-robustness--flow-control>3.1 健壮性与流控 (Robustness & Flow Control)<a hidden class=anchor aria-hidden=true href=#31-健壮性与流控-robustness--flow-control>#</a></h3><ol><li><p><strong>发送端流控 (Outbound Handling)</strong>:</p><ul><li><strong>非阻塞发送</strong>: Socket 必须设为 <code>O_NONBLOCK</code>。</li><li><strong>EAGAIN 处理</strong>: <code>send()</code> 返回 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code> 时，<strong>严禁</strong>阻塞等待或丢弃数据。</li><li><strong>发送队列</strong>: <code>ClientSession</code> 需维护 <code>std::deque&lt;std::vector&lt;uint8_t>> mOutboundQueue</code>。</li><li><strong>Epoll 联动</strong>: 当队列非空时，向 Epoll 注册 <code>EPOLLOUT</code> 事件；当 Socket 可写时触发回调继续发送。</li></ul></li><li><p><strong>背压策略 (Backpressure)</strong>:</p><ul><li><strong>接收侧</strong>: 当全局 <code>MainEventQueue</code> 满（例如 > 2000 个待处理事件）时，IPC 线程应 <strong>丢弃</strong> 新收到的事件，并记录丢包统计（Rate-limited Log），防止 <code>polarisd</code> OOM。</li></ul></li><li><p><strong>Broken Pipe 防御</strong>:</p><ul><li>发送数据时必须使用 <code>send(fd, buf, len, MSG_NOSIGNAL)</code>，防止客户端突然断开导致 Daemon 收到 <code>SIGPIPE</code> 信号崩溃。</li></ul></li></ol><h3 id=32-安全性-security>3.2 安全性 (Security)<a hidden class=anchor aria-hidden=true href=#32-安全性-security>#</a></h3><ol><li><strong>身份审计 (Peer Credentials)</strong>:<ul><li>在 <code>accept()</code> 成功后，立即调用 <code>getsockopt(fd, SOL_SOCKET, SO_PEERCRED, ...)</code>。</li><li>获取并记录客户端的 <strong>PID (Process ID)</strong>, <strong>UID (User ID)</strong>, <strong>GID (Group ID)</strong>。</li><li><em>v1.1 暂不强制踢除非 root 用户，但必须在 Log 中记录连接者的身份。</em></li></ul></li></ol><h3 id=33-性能-performance>3.3 性能 (Performance)<a hidden class=anchor aria-hidden=true href=#33-性能-performance>#</a></h3><ul><li><strong>内存复用</strong>: 接收缓冲区使用 <code>std::vector</code> 的 <code>reserve/resize</code> 机制，避免频繁 <code>realloc</code>。</li><li><strong>零拷贝</strong>: 尽量减少数据搬运。</li></ul><hr><h2 id=4-接口设计-interface-design>4. 接口设计 (Interface Design)<a hidden class=anchor aria-hidden=true href=#4-接口设计-interface-design>#</a></h2><h3 id=41-clientsession-类设计>4.1 <code>ClientSession</code> 类设计<a hidden class=anchor aria-hidden=true href=#41-clientsession-类设计>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ClientSession</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>enable_shared_from_this<span style=color:#f92672>&lt;</span>ClientSession<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ClientSession(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>int</span> epollFd); <span style=color:#75715e>// 注入 epollFd 以便注册 EPOLLOUT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>ClientSession();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- 事件回调 ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 返回 false 表示需要关闭连接
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>onRead</span>();  <span style=color:#75715e>// 处理 EPOLLIN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>onWrite</span>(); <span style=color:#75715e>// 处理 EPOLLOUT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- 业务接口 ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 发送数据 (自动处理 EAGAIN)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>send</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;&amp;</span> data);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --- 状态查询 ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getFd</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    pid_t <span style=color:#a6e22e>getPeerPid</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    uid_t <span style=color:#a6e22e>getPeerUid</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理 Outbound Queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> enableWriteEvent(<span style=color:#66d9ef>bool</span> enable);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mFd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mEpollFd;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 身份信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ucred</span> mPeerCred; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;</span> mRecvBuffer;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>deque<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>&gt;&gt;</span> mOutboundQueue;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 锁 (可选，如果确认 IpcServer 是单线程 Reactor，则不需要锁)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>mutex mQueueLock; 
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=42-ipcserver-类设计>4.2 <code>IpcServer</code> 类设计<a hidden class=anchor aria-hidden=true href=#42-ipcserver-类设计>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IpcServer</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> start();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>(); <span style=color:#75715e>// 线程安全，可从主线程调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> threadLoop();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleAccept</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleWakeup</span>(); <span style=color:#75715e>// 处理 eventfd
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Socket Setup Helper
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>createServerSocket</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>createEventFd</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mListenFd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mEpollFd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mWakeupFd <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 用于优雅退出
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> mRunning{false};
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> mThread;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>ClientSession<span style=color:#f92672>&gt;&gt;</span> mSessions;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><h2 id=5-数据流向-data-flow>5. 数据流向 (Data Flow)<a hidden class=anchor aria-hidden=true href=#5-数据流向-data-flow>#</a></h2><h3 id=51-上行流程-event-reporting>5.1 上行流程 (Event Reporting)<a hidden class=anchor aria-hidden=true href=#51-上行流程-event-reporting>#</a></h3><ol><li>Client <code>send()</code> -> Kernel Buffer.</li><li><code>epoll_wait</code> 唤醒 -> <code>IpcServer</code> 调用 <code>session->onRead()</code>.</li><li><code>session</code> 读取数据 -> 追加到 <code>mRecvBuffer</code>.</li><li><code>LspCodec::decodeFrame</code> 循环解包.</li><li><code>LspCodec::decodeEvent</code> 反序列化为 <code>PolarisEvent</code>.</li><li><strong>流控检查</strong>: 若 <code>EventQueue</code> 未满 -> <code>Push</code>. 若满 -> <code>Drop</code>.</li></ol><h3 id=52-下行流程-command-response>5.2 下行流程 (Command Response)<a hidden class=anchor aria-hidden=true href=#52-下行流程-command-response>#</a></h3><ol><li>业务线程调用 <code>session->send(data)</code>.</li><li><code>session</code> 尝试直接 <code>write</code>.<ul><li><strong>Case A (Write 全部成功)</strong>: 返回。</li><li><strong>Case B (Write 部分成功/失败 EAGAIN)</strong>:</li></ul></li><li>将剩余数据 Push 到 <code>mOutboundQueue</code>.</li><li>调用 <code>epoll_ctl(MOD)</code> 开启 <code>EPOLLOUT</code> 监听.</li><li><code>epoll_wait</code> 唤醒 (Socket 可写) -> <code>IpcServer</code> 调用 <code>session->onWrite()</code>.</li><li><code>session</code> 继续发送队列中的数据.</li><li>若队列清空 -> 关闭 <code>EPOLLOUT</code> 监听.</li></ol><hr><h2 id=6-异常与错误码>6. 异常与错误码<a hidden class=anchor aria-hidden=true href=#6-异常与错误码>#</a></h2><table><thead><tr><th>错误场景</th><th>处理策略</th><th>日志级别</th></tr></thead><tbody><tr><td><code>accept</code> 返回 <code>EMFILE</code></td><td>进程 FD 耗尽，忽略本次连接，等待释放</td><td>ERROR</td></tr><tr><td><code>read</code> 返回 0</td><td>对端正常关闭 (FIN)，销毁 Session</td><td>INFO</td></tr><tr><td><code>read</code> 返回 <code>ECONNRESET</code></td><td>对端 Crash (RST)，销毁 Session</td><td>WARN</td></tr><tr><td><code>read</code> 返回 <code>EAGAIN</code></td><td>正常现象，退出读循环</td><td>DEBUG</td></tr><tr><td><code>write</code> 返回 <code>EPIPE</code></td><td>Broken Pipe，销毁 Session</td><td>WARN</td></tr><tr><td>Frame Size > 2MB</td><td>协议违规/攻击，立即销毁 Session</td><td>ERROR</td></tr></tbody></table><hr></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>