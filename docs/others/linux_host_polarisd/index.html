<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="Linux Host Polarisd 软件架构设计说明书
版本: v1.0
日期: 2024-02-09
状态: 拟定中

1. 概述 (Overview)
polarisd (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。
1.1 设计目标

高安全性: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。
高可靠性: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。
可扩展性: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。


2. 需求拆解 (Requirements)
2.1 功能需求

事件上报 (Event Forwarding):


接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。
接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。
将上述事件转发给 Android Guest 侧的 polarisd。


指令执行 (Command Execution):


接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。
在 Linux Host 侧执行指令，并将结果返回给 Android。


策略联动 (Strategy Linkage):


支持“事件触发动作”机制（例如：收到 Crash 事件  触发 Log 抓取  填充 Log 路径  发送事件）。

2.2 非功能需求 (技术约束)

线程隔离: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。
调用者安全: libpolaris_client 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。
单向控制: 严禁通过 polarisd 反向控制 Linux 本地业务进程。


3. 软件架构 (Software Architecture)
3.1 架构模式
采用 多线程流水线 (Multi-threaded Pipeline) 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 EventQueue 进行耦合。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/others/linux_host_polarisd/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/others/linux_host_polarisd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/others/linux_host_polarisd/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="Linux Host Polarisd 软件架构设计说明书 版本: v1.0 日期: 2024-02-09 状态: 拟定中
1. 概述 (Overview) polarisd (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。
1.1 设计目标 高安全性: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。 高可靠性: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。 可扩展性: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。 2. 需求拆解 (Requirements) 2.1 功能需求 事件上报 (Event Forwarding): 接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。 接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。 将上述事件转发给 Android Guest 侧的 polarisd。 指令执行 (Command Execution): 接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。 在 Linux Host 侧执行指令，并将结果返回给 Android。 策略联动 (Strategy Linkage): 支持“事件触发动作”机制（例如：收到 Crash 事件 触发 Log 抓取 填充 Log 路径 发送事件）。 2.2 非功能需求 (技术约束) 线程隔离: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。 调用者安全: libpolaris_client 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。 单向控制: 严禁通过 polarisd 反向控制 Linux 本地业务进程。 3. 软件架构 (Software Architecture) 3.1 架构模式 采用 多线程流水线 (Multi-threaded Pipeline) 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 EventQueue 进行耦合。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="others"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Linux Host Polarisd 软件架构设计说明书
版本: v1.0
日期: 2024-02-09
状态: 拟定中

1. 概述 (Overview)
polarisd (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。
1.1 设计目标

高安全性: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。
高可靠性: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。
可扩展性: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。


2. 需求拆解 (Requirements)
2.1 功能需求

事件上报 (Event Forwarding):


接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。
接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。
将上述事件转发给 Android Guest 侧的 polarisd。


指令执行 (Command Execution):


接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。
在 Linux Host 侧执行指令，并将结果返回给 Android。


策略联动 (Strategy Linkage):


支持“事件触发动作”机制（例如：收到 Crash 事件  触发 Log 抓取  填充 Log 路径  发送事件）。

2.2 非功能需求 (技术约束)

线程隔离: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。
调用者安全: libpolaris_client 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。
单向控制: 严禁通过 polarisd 反向控制 Linux 本地业务进程。


3. 软件架构 (Software Architecture)
3.1 架构模式
采用 多线程流水线 (Multi-threaded Pipeline) 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 EventQueue 进行耦合。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"杂记","item":"https://ethen-cao.github.io/ethenslab/others/"},{"@type":"ListItem","position":2,"name":"","item":"https://ethen-cao.github.io/ethenslab/others/linux_host_polarisd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Linux Host Polarisd 软件架构设计说明书 版本: v1.0 日期: 2024-02-09 状态: 拟定中\n1. 概述 (Overview) polarisd (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。\n1.1 设计目标 高安全性: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。 高可靠性: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。 可扩展性: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。 2. 需求拆解 (Requirements) 2.1 功能需求 事件上报 (Event Forwarding): 接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。 接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。 将上述事件转发给 Android Guest 侧的 polarisd。 指令执行 (Command Execution): 接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。 在 Linux Host 侧执行指令，并将结果返回给 Android。 策略联动 (Strategy Linkage): 支持“事件触发动作”机制（例如：收到 Crash 事件 触发 Log 抓取 填充 Log 路径 发送事件）。 2.2 非功能需求 (技术约束) 线程隔离: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。 调用者安全: libpolaris_client 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。 单向控制: 严禁通过 polarisd 反向控制 Linux 本地业务进程。 3. 软件架构 (Software Architecture) 3.1 架构模式 采用 多线程流水线 (Multi-threaded Pipeline) 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 EventQueue 进行耦合。\n","keywords":[],"articleBody":"Linux Host Polarisd 软件架构设计说明书 版本: v1.0 日期: 2024-02-09 状态: 拟定中\n1. 概述 (Overview) polarisd (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。\n1.1 设计目标 高安全性: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。 高可靠性: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。 可扩展性: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。 2. 需求拆解 (Requirements) 2.1 功能需求 事件上报 (Event Forwarding): 接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。 接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。 将上述事件转发给 Android Guest 侧的 polarisd。 指令执行 (Command Execution): 接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。 在 Linux Host 侧执行指令，并将结果返回给 Android。 策略联动 (Strategy Linkage): 支持“事件触发动作”机制（例如：收到 Crash 事件 触发 Log 抓取 填充 Log 路径 发送事件）。 2.2 非功能需求 (技术约束) 线程隔离: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。 调用者安全: libpolaris_client 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。 单向控制: 严禁通过 polarisd 反向控制 Linux 本地业务进程。 3. 软件架构 (Software Architecture) 3.1 架构模式 采用 多线程流水线 (Multi-threaded Pipeline) 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 EventQueue 进行耦合。\n3.2 架构视图 @startuml package \"Client Layer\" { [Linux App / Cluster] --\u003e [libpolaris_client.so] : C API (Non-blocking) } package \"polarisd (Daemon)\" { frame \"Thread 1: Ingress\" { [IpcServer] [SystemMonitor] } frame \"Thread 2: Core Logic\" { component \"\\t\\tPolarisManager\\t\\t\" as PolarisManager queue \"MainEventQueue\" } frame \"Thread 3: Worker\" { [CommandExecutor] [StrategyAction] } frame \"Thread 4: Egress/Gateway\" { [HostVsockServer] } } package \"Android Guest\" { [HostVsockServer] \u003c--\u003e [Android polarisd] : PLP Protocol } ' Data Flow [libpolaris_client.so] --\u003e [IpcServer] : LSP Protocol [IpcServer] --\u003e [MainEventQueue] : Push(Type=IPC_EVENT) [SystemMonitor] --\u003e [MainEventQueue] : Push(Type=MONITOR_EVENT) [MainEventQueue] --\u003e [PolarisManager] : Pop \u0026 Dispatch [PolarisManager] --\u003e [CommandExecutor] : Dispatch Strategy/Cmd [CommandExecutor] --\u003e [MainEventQueue] : Re-entry(Type=STRATEGY_COMPLETE) [PolarisManager] --\u003e [HostVsockServer] : Forward Event/Send cmd resp [HostVsockServer] --\u003e [MainEventQueue] : Push(Type=GUEST_CMD_REQ) @enduml 4. 核心组件详解 (Core Components) 4.1 Client SDK (libpolaris_client) 职责: 提供极其简便的 C 语言接口，屏蔽通信细节。 设计模式: Builder Pattern + Opaque Handle。 特性: Lazy Init: 首次调用时初始化后台发送线程。 Fork Safety: 自动检测 PID 变化，处理子进程中的线程重建。 Fail-Safe: 内部维护环形队列，满则丢弃，绝不阻塞调用者。 4.2 IpcServer (Thread 1) 职责: 监听 Unix Domain Socket (/var/run/polaris_bridge)。 逻辑: 仅负责 accept 和 read。接收数据流，通过 LspCodec 解码为 PolarisEvent，封装入信封后推送到 MainEventQueue。 并发: 独立线程，确保高频 IPC 调用不会被业务逻辑阻塞。 4.3 PolarisManager (Thread 2) 职责: 系统的“大脑”，负责状态机流转和路由分发。 逻辑: 从 MainEventQueue 消费消息。 根据 HostManagerEvent::Type 判断处理路径（查策略表 OR 直接转发）。 维护路由表（Session Router）。 4.4 CommandExecutor (Thread 3) 职责: 系统的“工人”，处理所有耗时、阻塞、涉及文件 I/O 的任务。 逻辑: 维护一个线程池。 执行 Android 发来的命令（Ping, Reboot）。 执行本地联动策略（抓取 Log）。 结果重入: 任务完成后，修改 Event 数据，修改信封类型，重新 Push 到 MainEventQueue。 4.5 HostVsockServer (Thread 4) 职责: 维护与 Android Guest 的 VSOCK 连接 (CID_ANY:9001)。 逻辑: 下行: 将 PolarisEvent 编码为 PLP 协议包发送。 上行: 接收 PLP 包，解码为 CommandRequest 推送队列。 保活: 监听连接断开，处理重连与缓冲区清理。 4.6 SystemMonitor 线程 SystemMonitor代指对协同的监控业务。每个监控需求都是单独的一个线程执行。 5. 关键数据结构 (Key Data Structures) 5.1 纯净载体: PolarisEvent 纯粹的数据传输对象 (DTO)，不包含任何 Host 端内部状态。\nstruct PolarisEvent { uint64_t eventId; uint64_t timestamp; int32_t pid; std::string processName; std::string processVer; std::string params; // JSON String std::string logf; // 附件路径 (可变字段) }; 5.2 状态信封: HostManagerEvent 用于在内部队列中流转的容器，Type 字段充当状态机的状态。\nstruct HostManagerEvent { enum Type { // [Ingress States] TYPE_IPC_EVENT, // 新事件：来自 IPC TYPE_MONITOR_EVENT, // 新事件：来自 Monitor // [Processing States] TYPE_STRATEGY_COMPLETE, // 处理完：来自 Worker (含附件) // [Command States] TYPE_GUEST_CMD_REQ, // 请求：来自 Android TYPE_CMD_EXEC_RESULT // 结果：来自 Worker }; Type type; std::shared_ptr\u003cPolarisEvent\u003e eventData; std::shared_ptr\u003cCommandRequest\u003e cmdRequest; std::shared_ptr\u003cCommandResult\u003e cmdResult; std::weak_ptr\u003cSession\u003e session; // 回包上下文 }; 5.3 CommandRequest 字段名 类型 语义说明 reqId uint32 请求序列号 (用于异步匹配 Response) target enum 执行目标 (LOCAL / HOST) action string 动作指令 (如 capture_log) args JSON 动作参数 timeout uint32 超时时间 (ms) 5.4 CommandResult 用于描述命令执行的最终状态和产物，与 CommandRequest 构成闭环。\n字段名 类型 语义说明 必填 reqId uint32 请求序列号。必须与 CommandRequest.reqId 严格一致，用于回调溯源。 Yes code int32 状态码。0 表示成功，非 0 表示错误码 (如 System Exit Code)。 Yes msg string 可读消息。简短描述 (e.g., “Success”, “Timeout”, “Fork Failed”)。 Yes data JSON 执行产物。具体的返回数据 (e.g., {\"path\": \"/data/trace.pb\"})。 No 6. 对外接口与协议 (Interfaces \u0026 Protocols) 6.1 SDK C API 对外暴露极简接口，隐藏 C++ 实现。\n/* * Copyright (C) 2024 Voyah Polaris Project * * Polaris Event Reporting SDK (C API) * Thread-safe, Lazy-initialized, Opaque Handle based design. */ #ifndef POLARIS_API_H #define POLARIS_API_H #include #include #ifdef __cplusplus extern \"C\" { #endif // ============================================================================ // 1. 类型定义 (Opaque Handle) // ============================================================================ /** * PolarisEventHandle 是一个指向内部 C++ 对象的指针。 * 对于调用者来说，它是不透明的 (void* 或 前置声明结构体)。 * 调用者不应尝试解引用它，也不应自己 free 它。 */ typedef struct PolarisEventBuilderInternal* PolarisEventHandle; // ============================================================================ // 2. 事件构建流程 (Builder Pattern) // ============================================================================ /** * [步骤 1] 创建事件构建器 * * *如果在本次进程生命周期内是第一次调用，此函数会自动触发 SDK 初始化 (启动后台线程)。* * * @param event_id 事件的唯一标识 ID (必填) * @param process_name 逻辑进程名 (可选，传 NULL 则自动读取 /proc/self/comm) * @param process_ver 进程版本号 (可选，传 NULL 则默认为 \"unknown\") * @return 返回不透明句柄。如果内存不足或严重错误，返回 NULL。 */ PolarisEventHandle polaris_event_create(uint64_t event_id, const char* process_name, const char* process_ver); /** * [步骤 2] 添加 Key-Value 数据 * * 类似于 JSON 中的: { \"key\": value } * SDK 内部会自动处理类型转换和 JSON 格式化。 */ void polaris_event_add_string(PolarisEventHandle handle, const char* key, const char* value); void polaris_event_add_int(PolarisEventHandle handle, const char* key, int32_t value); void polaris_event_add_long(PolarisEventHandle handle, const char* key, int64_t value); void polaris_event_add_double(PolarisEventHandle handle, const char* key, double value); void polaris_event_add_bool(PolarisEventHandle handle, const char* key, bool value); /** * [步骤 3] 提交发送 * * 将构建好的事件序列化并放入发送队列。 * ***重要***: 此函数调用后，SDK 内部会自动销毁 handle。 * 调用者在此之后绝对不能再使用该 handle。 * * @param handle 事件句柄 * @param log_path (可选) 需要随事件上传的附件日志路径，无则传 NULL * @return 0: 成功入队; \u003c0: 失败 (如队列满) */ int polaris_event_commit(PolarisEventHandle handle, const char* log_path); /** * [可选] 取消发送 * * 如果在构建过程中决定不发送了，必须调用此函数来释放 handle 资源。 * 类似于 free()。 */ void polaris_event_cancel(PolarisEventHandle handle); // 3. 高级接口 (Raw JSON) // ============================================================================ /** * 直接发送原始 JSON 字符串 * 适用于调用者已经生成了 JSON 数据，或者需要发送复杂的嵌套 JSON 结构的场景。 * 同样支持惰性初始化。 * * @param event_id 事件 ID * @param process_name 进程名 (可选，NULL 为自动) * @param process_ver 版本号 (可选) * @param json_body 合法的 JSON 字符串，例如 \"{\\\"cpu\\\": 90, \\\"detail\\\": {\\\"core\\\": 1}}\" * @param log_path (可选) 附件路径 * @return 0: 成功; \u003c0: 失败 */ int polaris_report_raw(uint64_t event_id, const char* process_name, const char* process_ver, const char* json_body, const char* log_path); // ============================================================================ // 4. 生命周期管理 (可选) // ============================================================================ /** * 显式反初始化 * * 虽然 SDK 会利用静态对象析构自动清理，但在某些严格的内存泄漏检测工具下， * 或者需要确保线程立即退出的场景下，建议在 main 函数退出前显式调用。 */ void polaris_deinit(void); #ifdef __cplusplus } #endif #endif // POLARIS_API_H 6.2 通信协议 6.2.1 LSP v1 (Local Socket Protocol) 用于 linux processes 与 linux host polarisd 通信。\n结构: Header (12B) + Payload (JSON) 字节序: Little Endian 字段 长度 说明 TotalLen 4 Header + Payload 总长 MsgType 2 EVENT_REPORT (0x01), CMD_REQ (0x20), CMD_RESP (0x21) Reserved 2 0 ReqID 4 请求 ID TotalLen (包总长)\n语义: 表示整个数据包的长度，计算公式为 TotalLen = 12 (Header) + Payload Length。 最小有效值: 12 (即 Payload 为空的情况)。 最大限制: 建议限制为 4MB。若收到 TotalLen \u003e 4MB 的包，视为非法攻击或错误，应立即断开连接。 Socket 类型对应的 Framing (分帧) 规则: 由于 Local IPC 可能传输较大的 Log 数据或复杂 JSON，我们采用 SOCK_STREAM (流式套接字)。这意味着数据在传输层是无边界的字节流，接收端必须根据协议头进行分帧。 处理状态机:\nPhase 1: Read Header (Fixed 12 Bytes) 接收端首先尝试从 Socket 读取 12 字节。 如果 read() 返回数据不足 12 字节，需循环读取直到凑齐 12 字节。 校验: 读取后检查 TotalLen。 如果 TotalLen \u003c 12 或 TotalLen \u003e 4MB，视为非法请求，立即关闭 Socket。 Phase 2: Read Payload (Variable Length) 计算 PayloadLen = TotalLen - 12。 如果 PayloadLen == 0，处理结束，进入下一轮 Phase 1。 如果 PayloadLen \u003e 0，循环执行 read()，直到读取的字节数累计达到 PayloadLen。 超时策略: 为了防止恶意客户端发送 Header 后不发 Payload 导致服务端线程挂起，必须设置 SO_RCVTIMEO 或使用 poll/epoll 设置读取超时（建议 3000ms）。超时未读完完整包，直接断开连接。\n6.2.2 PLP v1 (Polaris Link Protocol) 用于 Host 与 Guest 通信。支持全双工控制。\n结构: Header (24B) + Payload (Binary/JSON) 字节序: Little Endian 消息类型 (Type) 值 方向 说明 PLP_HEARTBEAT 0x0001 Bi-dir 心跳 H2G (Host -\u003e Guest) PLP_EVENT_H2G 0x0010 H-\u003eG Host 事件上报 PLP_CMD_RESP_H2G 0x0011 H-\u003eG Host 回复 Android 的请求 PLP_CMD_REQ_H2G 0x0012 H-\u003eG Host 请求 Android 执行 G2H (Guest -\u003e Host) PLP_CMD_REQ_G2H 0x0020 G-\u003eH Android 请求 Host 执行 PLP_CMD_RESP_G2H 0x0021 G-\u003eH Android 回复 Host 的请求 6.2.2.1 Binary Header 结构定义 PLP 采用严格的二进制对齐结构（24 字节），并在 C++ 中使用 packed 属性定义。\n// 6.2.2.1 协议头定义 (C++ Standard Layout) // 确保 Host 与 Android 使用完全相同的头文件定义 #pragma pack(push, 1) // 强制 1 字节对齐，跨编译器通用 struct PlpHeader { uint32_t magic; // 0x504C5253 (\"PLRS\") uint16_t version; // 0x0001 uint16_t header_len; // 0x0018 (24 Bytes) uint32_t payload_len; // Payload 长度 (不含 Header) uint16_t type; // PlpMsgType (e.g., 0x0010 EVENT) uint16_t flags; // Bit 0: IS_JSON, Bit 1: GZIP uint32_t seq_id; // 请求序列号 uint32_t crc32; // Payload CRC32 (IEEE 802.3) }; #pragma pack(pop) // 校验: sizeof(PlpHeader) 必须等于 24 static_assert(sizeof(PlpHeader) == 24, \"PlpHeader size mismatch!\"); 关键字段语义:\nFlags (位掩码):\nBit 0 (IS_JSON): 1 表示 Payload 是 JSON 字符串，0 表示是原始二进制（如 Protobuf 或纯文件流）。 Bit 1 (GZIP): 1 表示 Payload 经过 Gzip 压缩，接收端需先解压。 Bit 2~15: 预留。 SeqID:\n用于双向通信的请求-响应匹配。 发起方（Request）生成 SeqID，响应方（Response）必须回传相同的 SeqID。 对于主动上报的 Event，SeqID 可由发送方自增，用于接收方检测丢包。 CRC32:\n算法: 标准 IEEE 802.3 CRC32。 范围: 仅计算 Payload 部分。Header 本身不参与 CRC 计算（Header 依靠 Magic 校验）。 序列化规范: 对于 PolarisEvent，必须将其字段序列化为 JSON 字符串放入 Payload。 Android 端接收到后，解析 JSON 还原为对象。\n7. 关键时序流程 (Key Sequence Diagrams) 7.1 场景：带策略联动的事件上报 (Crash -\u003e Log -\u003e Send) 此流程展示了 Type 变更 与 队列重入 机制。\n@startuml par IPC -\u003e IPC: LspDecode() -\u003e new PolarisEvent(id=9001) IPC -\u003e MGR: Push(Type=IPC_EVENT) == Phase 2: Dispatch \u0026 Strategy Check == activate MGR MGR -\u003e MGR: Pop() MGR -\u003e MGR: Check Strategy(9001) -\u003e **Need Log** MGR -\u003e WORKER: Dispatch Task (Pass Envelope) deactivate MGR == Phase 3: Execution \u0026 Enrichment == activate WORKER WORKER -\u003e WORKER: perf record -o /data/trace.perf WORKER -\u003e WORKER: Event-\u003elogf = \"/data/trace.perf\" WORKER -\u003e MGR: Re-entry Push(Type=**STRATEGY_COMPLETE**) deactivate WORKER == Phase 4: Final Forwarding == activate MGR MGR -\u003e MGR: Pop() MGR -\u003e MGR: Type is COMPLETE -\u003e **Skip Strategy** MGR -\u003e VSOCK: Forward(Event) deactivate MGR activate VSOCK VSOCK -\u003e VSOCK: PlpEncode() -\u003e write() deactivate VSOCK @enduml 7.2 场景：Android 发送命令给 Host sequenceDiagram participant Android participant Session as GuestSession (Thread 4) participant Queue as MainEventQueue participant Manager as PolarisManager (Thread 2) Android-\u003e\u003eSession: PLP Data (CMD_REQ) activate Session Session-\u003e\u003eSession: read() -\u003e decode() Session-\u003e\u003eQueue: Push(Envelope: GUEST_CMD_REQ) deactivate Session Queue-\u003e\u003eManager: Pop() activate Manager Manager-\u003e\u003eManager: processEvent() Manager-\u003e\u003eManager: Dispatch to Worker... deactivate Manager 7.3 场景：Host 发送事件给 Android sequenceDiagram participant Manager as PolarisManager (Thread 2) participant Server as HostVsockServer participant Session as GuestSession (Thread 4) participant Android activate Manager Manager-\u003e\u003eServer: sendEvent(PolarisEvent) deactivate Manager activate Server Server-\u003e\u003eServer: Lock \u0026 Get Session Server-\u003e\u003eSession: sendRaw(PLP Bytes) deactivate Server activate Session Session-\u003e\u003eSession: Push to OutboundQueue Session-\u003e\u003eSession: Write eventfd (Wakeup Thread 4) deactivate Session Note right of Session: Thread 4 wakes up Session-\u003e\u003eAndroid: write(socket) 8. 构建与部署 (Build \u0026 Deployment) 构建系统: CMake (适配 Yocto do_configure). 依赖管理: jsoncpp: 静态链接至 SDK，动态链接至 Daemon。 libc++: Yocto 默认支持（由 toolchain 决定，工程需在 Yocto layer 中明确选择并验证）。 Systemd 集成: 提供 polarisd.service。 配置 Restart=always。 配置 After=vsock.service。 8.1 目录结构 voyah-cluster/polarisd/ ├── CMakeLists.txt ├── polarisd.service ├── README.md ├── include/ │ └── polaris_api.h # C SDK 接口 ├── src/ │ ├── main.cpp # 守护进程入口 │ │ │ ├── client_sdk/ # SDK 源码 │ │ ├── CMakeLists.txt │ │ └── PolarisClient.cpp │ │ │ ├── message/ # [新增] 消息数据模型 (核心) │ │ ├── PolarisEvent.h # [新增] 纯净业务数据 (DTO) │ │ ├── HostManagerEvent.h # [新增] 状态信封 (Envelope) │ │ ├── CommandRequest.h # [新增] 指令请求结构 │ │ └── CommandResult.h # [新增] 指令结果结构 │ │ │ ├── core/ # 核心逻辑 (Thread 2) │ │ ├── PolarisManager.cpp # 状态机与分发逻辑 │ │ ├── EventQueue.h # 线程安全队列 (存放 HostManagerEvent) │ │ ├── StrategyRegistry.h # [新增] 策略注册表 (ID -\u003e Action 映射) │ │ └── strategy/ │ │ ├── IStrategy.h # [新增] 策略接口基类 │ │ └── LogCaptureStrategy.cpp │ │ │ ├── transport/ # 通信层 (Threads 1 \u0026 4) │ │ ├── Session.h # [新增] 会话基类 (定义 send/close 接口) │ │ ├── ipc/ │ │ │ ├── IpcServer.cpp # UDS Acceptor (Epoll监听) │ │ │ ├── ClientSession.cpp # [新增] 本地客户端会话 (处理 LSP 粘包/缓冲) │ │ │ └── LspCodec.cpp │ │ └── vsock/ │ │ ├── HostVsockServer.cpp # VSOCK Acceptor (持有 GuestSession) │ │ ├── GuestSession.cpp # [新增] Android 会话 (处理 PLP 协议、缓冲、IO) │ │ └── PlpCodec.cpp │ │ │ ├── executor/ # 执行层 (Thread 3) │ │ ├── CommandExecutor.cpp # 线程池实现 │ │ ├── IAction.h # [新增] 执行动作基类 │ │ └── actions/ │ │ ├── PingAction.cpp │ │ └── SystemAction.cpp │ │ │ ├── monitor/ # 监控模块 (Thread 1) │ │ ├── SystemMonitor.cpp │ │ └── QcrosvmMonitor.cpp │ │ │ └── utils/ │ ├── Log.h │ ├── JsonUtils.h │ ├── FileUtils.h │ ├── TimeUtils.h # [新增] 时间戳获取 │ └── SocketUtils.h # [新增] setNonBlocking, createSocket 封装 │ └── tests/ └── ... ","wordCount":"1833","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/others/linux_host_polarisd/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/others/>杂记</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>9 min&nbsp;·&nbsp;1833 words</div></header><div class=post-content><h1 id=linux-host-polarisd-软件架构设计说明书>Linux Host Polarisd 软件架构设计说明书<a hidden class=anchor aria-hidden=true href=#linux-host-polarisd-软件架构设计说明书>#</a></h1><p><strong>版本</strong>: v1.0
<strong>日期</strong>: 2024-02-09
<strong>状态</strong>: 拟定中</p><hr><h2 id=1-概述-overview>1. 概述 (Overview)<a hidden class=anchor aria-hidden=true href=#1-概述-overview>#</a></h2><p><code>polarisd</code> (Linux Host Version) 是运行在 Linux 宿主机上的核心守护进程，充当 Linux 侧应用与 Android 虚拟机（Guest OS）之间的通信网关与策略执行中心。它负责跨系统的事件流转、系统监控以及跨端指令的落地执行。</p><h3 id=11-设计目标>1.1 设计目标<a hidden class=anchor aria-hidden=true href=#11-设计目标>#</a></h3><ul><li><strong>高安全性</strong>: 确保客户端调用非阻塞，确保 Android 端无法反向控制 Linux 关键进程。</li><li><strong>高可靠性</strong>: 采用多线程隔离架构，单一模块阻塞不影响整体吞吐。</li><li><strong>可扩展性</strong>: 支持灵活的策略联动（如 Crash 自动抓取日志）和协议扩展。</li></ul><hr><h2 id=2-需求拆解-requirements>2. 需求拆解 (Requirements)<a hidden class=anchor aria-hidden=true href=#2-需求拆解-requirements>#</a></h2><h3 id=21-功能需求>2.1 功能需求<a hidden class=anchor aria-hidden=true href=#21-功能需求>#</a></h3><ol><li><strong>事件上报 (Event Forwarding)</strong>:</li></ol><ul><li>接收 Linux 本地进程（如 Cluster HMI）通过 SDK 上报的业务事件。</li><li>接收内部 Monitor 监控到的系统事件（如进程崩溃、资源告警）。</li><li>将上述事件转发给 Android Guest 侧的 <code>polarisd</code>。</li></ul><ol start=2><li><strong>指令执行 (Command Execution)</strong>:</li></ol><ul><li>接收 Android Guest 发送的控制指令（如 Ping, CaptureLog）。</li><li>在 Linux Host 侧执行指令，并将结果返回给 Android。</li></ul><ol start=3><li><strong>策略联动 (Strategy Linkage)</strong>:</li></ol><ul><li>支持“事件触发动作”机制（例如：收到 Crash 事件 触发 Log 抓取 填充 Log 路径 发送事件）。</li></ul><h3 id=22-非功能需求-技术约束>2.2 非功能需求 (技术约束)<a hidden class=anchor aria-hidden=true href=#22-非功能需求-技术约束>#</a></h3><ol><li><strong>线程隔离</strong>: IPC 接收、业务分发、指令执行、VSOCK 通信必须运行在独立的线程中，防止死锁。</li><li><strong>调用者安全</strong>: <code>libpolaris_client</code> 必须是非阻塞的，SDK 内部错误不应导致宿主进程崩溃。</li><li><strong>单向控制</strong>: 严禁通过 <code>polarisd</code> 反向控制 Linux 本地业务进程。</li></ol><hr><h2 id=3-软件架构-software-architecture>3. 软件架构 (Software Architecture)<a hidden class=anchor aria-hidden=true href=#3-软件架构-software-architecture>#</a></h2><h3 id=31-架构模式>3.1 架构模式<a hidden class=anchor aria-hidden=true href=#31-架构模式>#</a></h3><p>采用 <strong>多线程流水线 (Multi-threaded Pipeline)</strong> 架构。系统被划分为四个独立的执行域（Execution Domains），通过线程安全的 <code>EventQueue</code> 进行耦合。</p><h3 id=32-架构视图>3.2 架构视图<a hidden class=anchor aria-hidden=true href=#32-架构视图>#</a></h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
package &#34;Client Layer&#34; {
    [Linux App / Cluster] --&gt; [libpolaris_client.so] : C API (Non-blocking)
}

package &#34;polarisd (Daemon)&#34; {
    frame &#34;Thread 1: Ingress&#34; {
        [IpcServer]
        [SystemMonitor]
    }

    frame &#34;Thread 2: Core Logic&#34; {
        component &#34;\t\tPolarisManager\t\t&#34; as PolarisManager
        queue &#34;MainEventQueue&#34;
    }

    frame &#34;Thread 3: Worker&#34; {
        [CommandExecutor]
        [StrategyAction]
    }

    frame &#34;Thread 4: Egress/Gateway&#34; {
        [HostVsockServer]
    }
}

package &#34;Android Guest&#34; {
    [HostVsockServer] &lt;--&gt; [Android polarisd] : PLP Protocol
}

&#39; Data Flow
[libpolaris_client.so] --&gt; [IpcServer] : LSP Protocol
[IpcServer] --&gt; [MainEventQueue] : Push(Type=IPC_EVENT)
[SystemMonitor] --&gt; [MainEventQueue] : Push(Type=MONITOR_EVENT)

[MainEventQueue] --&gt; [PolarisManager] : Pop &amp; Dispatch

[PolarisManager] --&gt; [CommandExecutor] : Dispatch Strategy/Cmd
[CommandExecutor] --&gt; [MainEventQueue] : Re-entry(Type=STRATEGY_COMPLETE)

[PolarisManager] --&gt; [HostVsockServer] : Forward Event/Send cmd resp
[HostVsockServer] --&gt; [MainEventQueue] : Push(Type=GUEST_CMD_REQ)

@enduml
</code></pre><hr><h2 id=4-核心组件详解-core-components>4. 核心组件详解 (Core Components)<a hidden class=anchor aria-hidden=true href=#4-核心组件详解-core-components>#</a></h2><h3 id=41-client-sdk-libpolaris_client>4.1 Client SDK (<code>libpolaris_client</code>)<a hidden class=anchor aria-hidden=true href=#41-client-sdk-libpolaris_client>#</a></h3><ul><li><strong>职责</strong>: 提供极其简便的 C 语言接口，屏蔽通信细节。</li><li><strong>设计模式</strong>: Builder Pattern + Opaque Handle。</li><li><strong>特性</strong>:<ul><li><strong>Lazy Init</strong>: 首次调用时初始化后台发送线程。</li><li><strong>Fork Safety</strong>: 自动检测 PID 变化，处理子进程中的线程重建。</li><li><strong>Fail-Safe</strong>: 内部维护环形队列，满则丢弃，绝不阻塞调用者。</li></ul></li></ul><h3 id=42-ipcserver-thread-1>4.2 IpcServer (Thread 1)<a hidden class=anchor aria-hidden=true href=#42-ipcserver-thread-1>#</a></h3><ul><li><strong>职责</strong>: 监听 Unix Domain Socket (<code>/var/run/polaris_bridge</code>)。</li><li><strong>逻辑</strong>: 仅负责 <code>accept</code> 和 <code>read</code>。接收数据流，通过 <code>LspCodec</code> 解码为 <code>PolarisEvent</code>，封装入信封后推送到 <code>MainEventQueue</code>。</li><li><strong>并发</strong>: 独立线程，确保高频 IPC 调用不会被业务逻辑阻塞。</li></ul><h3 id=43-polarismanager-thread-2>4.3 PolarisManager (Thread 2)<a hidden class=anchor aria-hidden=true href=#43-polarismanager-thread-2>#</a></h3><ul><li><strong>职责</strong>: 系统的“大脑”，负责状态机流转和路由分发。</li><li><strong>逻辑</strong>:<ul><li>从 <code>MainEventQueue</code> 消费消息。</li><li>根据 <code>HostManagerEvent::Type</code> 判断处理路径（查策略表 OR 直接转发）。</li><li>维护路由表（Session Router）。</li></ul></li></ul><h3 id=44-commandexecutor-thread-3>4.4 CommandExecutor (Thread 3)<a hidden class=anchor aria-hidden=true href=#44-commandexecutor-thread-3>#</a></h3><ul><li><strong>职责</strong>: 系统的“工人”，处理所有耗时、阻塞、涉及文件 I/O 的任务。</li><li><strong>逻辑</strong>:<ul><li>维护一个线程池。</li><li>执行 Android 发来的命令（Ping, Reboot）。</li><li>执行本地联动策略（抓取 Log）。</li><li><strong>结果重入</strong>: 任务完成后，修改 Event 数据，修改信封类型，重新 Push 到 <code>MainEventQueue</code>。</li></ul></li></ul><h3 id=45-hostvsockserver-thread-4>4.5 HostVsockServer (Thread 4)<a hidden class=anchor aria-hidden=true href=#45-hostvsockserver-thread-4>#</a></h3><ul><li><strong>职责</strong>: 维护与 Android Guest 的 VSOCK 连接 (<code>CID_ANY:9001</code>)。</li><li><strong>逻辑</strong>:<ul><li><strong>下行</strong>: 将 <code>PolarisEvent</code> 编码为 PLP 协议包发送。</li><li><strong>上行</strong>: 接收 PLP 包，解码为 <code>CommandRequest</code> 推送队列。</li><li><strong>保活</strong>: 监听连接断开，处理重连与缓冲区清理。</li></ul></li></ul><h3 id=46-systemmonitor-线程>4.6 SystemMonitor 线程<a hidden class=anchor aria-hidden=true href=#46-systemmonitor-线程>#</a></h3><ul><li>SystemMonitor代指对协同的监控业务。每个监控需求都是单独的一个线程执行。</li></ul><hr><h2 id=5-关键数据结构-key-data-structures>5. 关键数据结构 (Key Data Structures)<a hidden class=anchor aria-hidden=true href=#5-关键数据结构-key-data-structures>#</a></h2><h3 id=51-纯净载体-polarisevent>5.1 纯净载体: <code>PolarisEvent</code><a hidden class=anchor aria-hidden=true href=#51-纯净载体-polarisevent>#</a></h3><p>纯粹的数据传输对象 (DTO)，不包含任何 Host 端内部状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PolarisEvent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> eventId;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> timestamp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32_t</span> pid;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string processName;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string processVer;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string params;      <span style=color:#75715e>// JSON String
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string logf;        <span style=color:#75715e>// 附件路径 (可变字段)
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=52-状态信封-hostmanagerevent>5.2 状态信封: <code>HostManagerEvent</code><a hidden class=anchor aria-hidden=true href=#52-状态信封-hostmanagerevent>#</a></h3><p>用于在内部队列中流转的容器，<code>Type</code> 字段充当状态机的状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HostManagerEvent</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Type</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [Ingress States]
</span></span></span><span style=display:flex><span>        TYPE_IPC_EVENT,         <span style=color:#75715e>// 新事件：来自 IPC
</span></span></span><span style=display:flex><span>        TYPE_MONITOR_EVENT,     <span style=color:#75715e>// 新事件：来自 Monitor
</span></span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [Processing States]
</span></span></span><span style=display:flex><span>        TYPE_STRATEGY_COMPLETE, <span style=color:#75715e>// 处理完：来自 Worker (含附件)
</span></span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [Command States]
</span></span></span><span style=display:flex><span>        TYPE_GUEST_CMD_REQ,     <span style=color:#75715e>// 请求：来自 Android
</span></span></span><span style=display:flex><span>        TYPE_CMD_EXEC_RESULT    <span style=color:#75715e>// 结果：来自 Worker
</span></span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Type type;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>PolarisEvent<span style=color:#f92672>&gt;</span> eventData;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>CommandRequest<span style=color:#f92672>&gt;</span> cmdRequest;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>CommandResult<span style=color:#f92672>&gt;</span> cmdResult;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>weak_ptr<span style=color:#f92672>&lt;</span>Session<span style=color:#f92672>&gt;</span> session; <span style=color:#75715e>// 回包上下文
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=53-commandrequest>5.3 CommandRequest<a hidden class=anchor aria-hidden=true href=#53-commandrequest>#</a></h3><table><thead><tr><th>字段名</th><th>类型</th><th>语义说明</th></tr></thead><tbody><tr><td><strong>reqId</strong></td><td>uint32</td><td>请求序列号 (用于异步匹配 Response)</td></tr><tr><td><strong>target</strong></td><td>enum</td><td>执行目标 (<code>LOCAL</code> / <code>HOST</code>)</td></tr><tr><td><strong>action</strong></td><td>string</td><td>动作指令 (如 <code>capture_log</code>)</td></tr><tr><td><strong>args</strong></td><td>JSON</td><td>动作参数</td></tr><tr><td><strong>timeout</strong></td><td>uint32</td><td>超时时间 (ms)</td></tr></tbody></table><h3 id=54-commandresult>5.4 CommandResult<a hidden class=anchor aria-hidden=true href=#54-commandresult>#</a></h3><p>用于描述命令执行的最终状态和产物，与 <code>CommandRequest</code> 构成闭环。</p><table><thead><tr><th>字段名</th><th>类型</th><th>语义说明</th><th>必填</th></tr></thead><tbody><tr><td><strong>reqId</strong></td><td>uint32</td><td><strong>请求序列号</strong>。必须与 <code>CommandRequest.reqId</code> 严格一致，用于回调溯源。</td><td>Yes</td></tr><tr><td><strong>code</strong></td><td>int32</td><td><strong>状态码</strong>。<code>0</code> 表示成功，非 <code>0</code> 表示错误码 (如 System Exit Code)。</td><td>Yes</td></tr><tr><td><strong>msg</strong></td><td>string</td><td><strong>可读消息</strong>。简短描述 (e.g., &ldquo;Success&rdquo;, &ldquo;Timeout&rdquo;, &ldquo;Fork Failed&rdquo;)。</td><td>Yes</td></tr><tr><td><strong>data</strong></td><td>JSON</td><td><strong>执行产物</strong>。具体的返回数据 (e.g., <code>{"path": "/data/trace.pb"}</code>)。</td><td>No</td></tr></tbody></table><hr><h2 id=6-对外接口与协议-interfaces--protocols>6. 对外接口与协议 (Interfaces & Protocols)<a hidden class=anchor aria-hidden=true href=#6-对外接口与协议-interfaces--protocols>#</a></h2><h3 id=61-sdk-c-api>6.1 SDK C API<a hidden class=anchor aria-hidden=true href=#61-sdk-c-api>#</a></h3><p>对外暴露极简接口，隐藏 C++ 实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Copyright (C) 2024 Voyah Polaris Project
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Polaris Event Reporting SDK (C API)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Thread-safe, Lazy-initialized, Opaque Handle based design.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef POLARIS_API_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define POLARIS_API_H
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdint.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 1. 类型定义 (Opaque Handle)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * PolarisEventHandle 是一个指向内部 C++ 对象的指针。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 对于调用者来说，它是不透明的 (void* 或 前置声明结构体)。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 调用者不应尝试解引用它，也不应自己 free 它。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> PolarisEventBuilderInternal<span style=color:#f92672>*</span> PolarisEventHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 事件构建流程 (Builder Pattern)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 1] 创建事件构建器
</span></span></span><span style=display:flex><span><span style=color:#75715e> * * *如果在本次进程生命周期内是第一次调用，此函数会自动触发 SDK 初始化 (启动后台线程)。*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param event_id      事件的唯一标识 ID (必填)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_name  逻辑进程名 (可选，传 NULL 则自动读取 /proc/self/comm)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_ver   进程版本号 (可选，传 NULL 则默认为 &#34;unknown&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return              返回不透明句柄。如果内存不足或严重错误，返回 NULL。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>PolarisEventHandle <span style=color:#a6e22e>polaris_event_create</span>(<span style=color:#66d9ef>uint64_t</span> event_id, 
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_name, 
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_ver);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 2] 添加 Key-Value 数据
</span></span></span><span style=display:flex><span><span style=color:#75715e> * * 类似于 JSON 中的: { &#34;key&#34;: value }
</span></span></span><span style=display:flex><span><span style=color:#75715e> * SDK 内部会自动处理类型转换和 JSON 格式化。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_add_string</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_add_int</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>int32_t</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_add_long</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>int64_t</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_add_double</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>double</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_add_bool</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> key, <span style=color:#66d9ef>bool</span> value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [步骤 3] 提交发送
</span></span></span><span style=display:flex><span><span style=color:#75715e> * * 将构建好的事件序列化并放入发送队列。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ***重要***: 此函数调用后，SDK 内部会自动销毁 handle。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 调用者在此之后绝对不能再使用该 handle。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param handle    事件句柄
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param log_path  (可选) 需要随事件上传的附件日志路径，无则传 NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return          0: 成功入队; &lt;0: 失败 (如队列满)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_event_commit</span>(PolarisEventHandle handle, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> log_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * [可选] 取消发送
</span></span></span><span style=display:flex><span><span style=color:#75715e> * * 如果在构建过程中决定不发送了，必须调用此函数来释放 handle 资源。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 类似于 free()。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_event_cancel</span>(PolarisEventHandle handle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 高级接口 (Raw JSON)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 直接发送原始 JSON 字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 适用于调用者已经生成了 JSON 数据，或者需要发送复杂的嵌套 JSON 结构的场景。
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 同样支持惰性初始化。
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param event_id      事件 ID
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_name  进程名 (可选，NULL 为自动)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param process_ver   版本号 (可选)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param json_body     合法的 JSON 字符串，例如 &#34;{\&#34;cpu\&#34;: 90, \&#34;detail\&#34;: {\&#34;core\&#34;: 1}}&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @param log_path      (可选) 附件路径
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @return              0: 成功; &lt;0: 失败
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>polaris_report_raw</span>(<span style=color:#66d9ef>uint64_t</span> event_id, 
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_name, 
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> process_ver,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> json_body,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> log_path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 4. 生命周期管理 (可选)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ============================================================================
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 显式反初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e> * * 虽然 SDK 会利用静态对象析构自动清理，但在某些严格的内存泄漏检测工具下，
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 或者需要确保线程立即退出的场景下，建议在 main 函数退出前显式调用。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>polaris_deinit</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// POLARIS_API_H
</span></span></span></code></pre></div><h3 id=62-通信协议>6.2 通信协议<a hidden class=anchor aria-hidden=true href=#62-通信协议>#</a></h3><h4 id=621-lsp-v1-local-socket-protocol>6.2.1 LSP v1 (Local Socket Protocol)<a hidden class=anchor aria-hidden=true href=#621-lsp-v1-local-socket-protocol>#</a></h4><p>用于 linux processes 与 linux host polarisd 通信。</p><ul><li><strong>结构</strong>: <code>Header (12B) + Payload (JSON)</code></li><li><strong>字节序</strong>: Little Endian</li></ul><table><thead><tr><th>字段</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td><code>TotalLen</code></td><td>4</td><td>Header + Payload 总长</td></tr><tr><td><code>MsgType</code></td><td>2</td><td><code>EVENT_REPORT (0x01)</code>, <code>CMD_REQ (0x20)</code>, <code>CMD_RESP (0x21)</code></td></tr><tr><td><code>Reserved</code></td><td>2</td><td>0</td></tr><tr><td><code>ReqID</code></td><td>4</td><td>请求 ID</td></tr></tbody></table><ul><li><p><strong>TotalLen (包总长)</strong></p><ul><li><strong>语义</strong>: 表示整个数据包的长度，计算公式为 <code>TotalLen = 12 (Header) + Payload Length</code>。</li><li><strong>最小有效值</strong>: 12 (即 Payload 为空的情况)。</li><li><strong>最大限制</strong>: 建议限制为 <strong>4MB</strong>。若收到 <code>TotalLen > 4MB</code> 的包，视为非法攻击或错误，应立即断开连接。</li></ul></li><li><p><strong>Socket 类型对应的 Framing (分帧) 规则</strong>:
由于 Local IPC 可能传输较大的 Log 数据或复杂 JSON，我们采用 SOCK_STREAM (流式套接字)。这意味着数据在传输层是无边界的字节流，接收端必须根据协议头进行分帧。
<strong>处理状态机</strong>:</p><ol><li>Phase 1: Read Header (Fixed 12 Bytes)<ul><li>接收端首先尝试从 Socket 读取 12 字节。</li><li>如果 read() 返回数据不足 12 字节，需循环读取直到凑齐 12 字节。</li><li>校验: 读取后检查 TotalLen。</li><li>如果 TotalLen &lt; 12 或 TotalLen > 4MB，视为非法请求，立即关闭 Socket。</li></ul></li><li>Phase 2: Read Payload (Variable Length)<ul><li>计算 PayloadLen = TotalLen - 12。</li><li>如果 PayloadLen == 0，处理结束，进入下一轮 Phase 1。</li><li>如果 PayloadLen > 0，循环执行 read()，直到读取的字节数累计达到 PayloadLen。</li></ul></li></ol><p><strong>超时策略</strong>:
为了防止恶意客户端发送 Header 后不发 Payload 导致服务端线程挂起，必须设置 SO_RCVTIMEO 或使用 poll/epoll 设置读取超时（建议 3000ms）。超时未读完完整包，直接断开连接。</p></li></ul><h4 id=622-plp-v1-polaris-link-protocol>6.2.2 PLP v1 (Polaris Link Protocol)<a hidden class=anchor aria-hidden=true href=#622-plp-v1-polaris-link-protocol>#</a></h4><p>用于 Host 与 Guest 通信。支持全双工控制。</p><ul><li><strong>结构</strong>: <code>Header (24B) + Payload (Binary/JSON)</code></li><li><strong>字节序</strong>: Little Endian</li></ul><table><thead><tr><th>消息类型 (Type)</th><th>值</th><th>方向</th><th>说明</th></tr></thead><tbody><tr><td><code>PLP_HEARTBEAT</code></td><td>0x0001</td><td>Bi-dir</td><td>心跳</td></tr><tr><td><strong>H2G (Host -> Guest)</strong></td><td></td><td></td><td></td></tr><tr><td><code>PLP_EVENT_H2G</code></td><td>0x0010</td><td>H->G</td><td>Host 事件上报</td></tr><tr><td><code>PLP_CMD_RESP_H2G</code></td><td>0x0011</td><td>H->G</td><td>Host 回复 Android 的请求</td></tr><tr><td><code>PLP_CMD_REQ_H2G</code></td><td>0x0012</td><td>H->G</td><td>Host 请求 Android 执行</td></tr><tr><td><strong>G2H (Guest -> Host)</strong></td><td></td><td></td><td></td></tr><tr><td><code>PLP_CMD_REQ_G2H</code></td><td>0x0020</td><td>G->H</td><td>Android 请求 Host 执行</td></tr><tr><td><code>PLP_CMD_RESP_G2H</code></td><td>0x0021</td><td>G->H</td><td>Android 回复 Host 的请求</td></tr></tbody></table><h5 id=6221-binary-header-结构定义>6.2.2.1 Binary Header 结构定义<a hidden class=anchor aria-hidden=true href=#6221-binary-header-结构定义>#</a></h5><p>PLP 采用严格的二进制对齐结构（24 字节），并在 C++ 中使用 <code>packed</code> 属性定义。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 6.2.2.1 协议头定义 (C++ Standard Layout)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 确保 Host 与 Android 使用完全相同的头文件定义
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma pack(push, 1) </span><span style=color:#75715e>// 强制 1 字节对齐，跨编译器通用
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PlpHeader</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> magic;        <span style=color:#75715e>// 0x504C5253 (&#34;PLRS&#34;)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> version;      <span style=color:#75715e>// 0x0001
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> header_len;   <span style=color:#75715e>// 0x0018 (24 Bytes)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> payload_len;  <span style=color:#75715e>// Payload 长度 (不含 Header)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> type;         <span style=color:#75715e>// PlpMsgType (e.g., 0x0010 EVENT)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> flags;        <span style=color:#75715e>// Bit 0: IS_JSON, Bit 1: GZIP
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> seq_id;       <span style=color:#75715e>// 请求序列号
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> crc32;        <span style=color:#75715e>// Payload CRC32 (IEEE 802.3)
</span></span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma pack(pop)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 校验: sizeof(PlpHeader) 必须等于 24
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>sizeof</span>(PlpHeader) <span style=color:#f92672>==</span> <span style=color:#ae81ff>24</span>, <span style=color:#e6db74>&#34;PlpHeader size mismatch!&#34;</span>);
</span></span></code></pre></div><p><strong>关键字段语义</strong>:</p><ul><li><p><strong>Flags (位掩码)</strong>:</p><ul><li><code>Bit 0 (IS_JSON)</code>: 1 表示 Payload 是 JSON 字符串，0 表示是原始二进制（如 Protobuf 或纯文件流）。</li><li><code>Bit 1 (GZIP)</code>: 1 表示 Payload 经过 Gzip 压缩，接收端需先解压。</li><li><code>Bit 2~15</code>: 预留。</li></ul></li><li><p><strong>SeqID</strong>:</p><ul><li>用于双向通信的请求-响应匹配。</li><li>发起方（Request）生成 SeqID，响应方（Response）必须回传相同的 SeqID。</li><li>对于主动上报的 Event，SeqID 可由发送方自增，用于接收方检测丢包。</li></ul></li><li><p><strong>CRC32</strong>:</p><ul><li>算法: 标准 IEEE 802.3 CRC32。</li><li>范围: <strong>仅计算 Payload 部分</strong>。Header 本身不参与 CRC 计算（Header 依靠 Magic 校验）。</li></ul></li><li><p>序列化规范:
对于 PolarisEvent，必须将其字段序列化为 JSON 字符串放入 Payload。
Android 端接收到后，解析 JSON 还原为对象。</p></li></ul><hr><h2 id=7-关键时序流程-key-sequence-diagrams>7. 关键时序流程 (Key Sequence Diagrams)<a hidden class=anchor aria-hidden=true href=#7-关键时序流程-key-sequence-diagrams>#</a></h2><h3 id=71-场景带策略联动的事件上报-crash---log---send>7.1 场景：带策略联动的事件上报 (Crash -> Log -> Send)<a hidden class=anchor aria-hidden=true href=#71-场景带策略联动的事件上报-crash---log---send>#</a></h3><p>此流程展示了 <strong>Type 变更</strong> 与 <strong>队列重入</strong> 机制。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
par
IPC -&gt; IPC: LspDecode() -&gt; new PolarisEvent(id=9001)
IPC -&gt; MGR: Push(Type=IPC_EVENT)

== Phase 2: Dispatch &amp; Strategy Check ==
activate MGR
MGR -&gt; MGR: Pop()
MGR -&gt; MGR: Check Strategy(9001) -&gt; **Need Log**
MGR -&gt; WORKER: Dispatch Task (Pass Envelope)
deactivate MGR

== Phase 3: Execution &amp; Enrichment ==
activate WORKER
WORKER -&gt; WORKER: perf record -o /data/trace.perf
WORKER -&gt; WORKER: Event-&gt;logf = &#34;/data/trace.perf&#34;
WORKER -&gt; MGR: Re-entry Push(Type=**STRATEGY_COMPLETE**)
deactivate WORKER

== Phase 4: Final Forwarding ==
activate MGR
MGR -&gt; MGR: Pop()
MGR -&gt; MGR: Type is COMPLETE -&gt; **Skip Strategy**
MGR -&gt; VSOCK: Forward(Event)
deactivate MGR

activate VSOCK
VSOCK -&gt; VSOCK: PlpEncode() -&gt; write()
deactivate VSOCK
@enduml
</code></pre><h3 id=72-场景android-发送命令给-host>7.2 场景：Android 发送命令给 Host<a hidden class=anchor aria-hidden=true href=#72-场景android-发送命令给-host>#</a></h3><div class=mermaid>sequenceDiagram
participant Android
participant Session as GuestSession (Thread 4)
participant Queue as MainEventQueue
participant Manager as PolarisManager (Thread 2)
Android->>Session: PLP Data (CMD_REQ)
activate Session
Session->>Session: read() -> decode()
Session->>Queue: Push(Envelope: GUEST_CMD_REQ)
deactivate Session
Queue->>Manager: Pop()
activate Manager
Manager->>Manager: processEvent()
Manager->>Manager: Dispatch to Worker...
deactivate Manager</div><h3 id=73-场景host-发送事件给-android>7.3 场景：Host 发送事件给 Android<a hidden class=anchor aria-hidden=true href=#73-场景host-发送事件给-android>#</a></h3><div class=mermaid>sequenceDiagram
participant Manager as PolarisManager (Thread 2)
participant Server as HostVsockServer
participant Session as GuestSession (Thread 4)
participant Android
activate Manager
Manager->>Server: sendEvent(PolarisEvent)
deactivate Manager
activate Server
Server->>Server: Lock & Get Session
Server->>Session: sendRaw(PLP Bytes)
deactivate Server
activate Session
Session->>Session: Push to OutboundQueue
Session->>Session: Write eventfd (Wakeup Thread 4)
deactivate Session
Note right of Session: Thread 4 wakes up
Session->>Android: write(socket)</div><hr><h2 id=8-构建与部署-build--deployment>8. 构建与部署 (Build & Deployment)<a hidden class=anchor aria-hidden=true href=#8-构建与部署-build--deployment>#</a></h2><ul><li><strong>构建系统</strong>: CMake (适配 Yocto <code>do_configure</code>).</li><li><strong>依赖管理</strong>:<ul><li><code>jsoncpp</code>: 静态链接至 SDK，动态链接至 Daemon。</li><li><code>libc++</code>: Yocto 默认支持（由 toolchain 决定，工程需在 Yocto layer 中明确选择并验证）。</li><li><strong>Systemd 集成</strong>:</li><li>提供 <code>polarisd.service</code>。</li><li>配置 <code>Restart=always</code>。</li><li>配置 <code>After=vsock.service</code>。</li></ul></li></ul><h3 id=81-目录结构>8.1 目录结构<a hidden class=anchor aria-hidden=true href=#81-目录结构>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>voyah-cluster/polarisd/
</span></span><span style=display:flex><span>├── CMakeLists.txt
</span></span><span style=display:flex><span>├── polarisd.service
</span></span><span style=display:flex><span>├── README.md
</span></span><span style=display:flex><span>├── include/
</span></span><span style=display:flex><span>│   └── polaris_api.h               # C SDK 接口
</span></span><span style=display:flex><span>├── src/
</span></span><span style=display:flex><span>│   ├── main.cpp                    # 守护进程入口
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── client_sdk/                 # SDK 源码
</span></span><span style=display:flex><span>│   │   ├── CMakeLists.txt
</span></span><span style=display:flex><span>│   │   └── PolarisClient.cpp
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── message/                    # [新增] 消息数据模型 (核心)
</span></span><span style=display:flex><span>│   │   ├── PolarisEvent.h          # [新增] 纯净业务数据 (DTO)
</span></span><span style=display:flex><span>│   │   ├── HostManagerEvent.h      # [新增] 状态信封 (Envelope)
</span></span><span style=display:flex><span>│   │   ├── CommandRequest.h        # [新增] 指令请求结构
</span></span><span style=display:flex><span>│   │   └── CommandResult.h         # [新增] 指令结果结构
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── core/                       # 核心逻辑 (Thread 2)
</span></span><span style=display:flex><span>│   │   ├── PolarisManager.cpp      # 状态机与分发逻辑
</span></span><span style=display:flex><span>│   │   ├── EventQueue.h            # 线程安全队列 (存放 HostManagerEvent)
</span></span><span style=display:flex><span>│   │   ├── StrategyRegistry.h      # [新增] 策略注册表 (ID -&gt; Action 映射)
</span></span><span style=display:flex><span>│   │   └── strategy/
</span></span><span style=display:flex><span>│   │       ├── IStrategy.h         # [新增] 策略接口基类
</span></span><span style=display:flex><span>│   │       └── LogCaptureStrategy.cpp
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── transport/                  # 通信层 (Threads 1 &amp; 4)
</span></span><span style=display:flex><span>│   │   ├── Session.h               # [新增] 会话基类 (定义 send/close 接口)
</span></span><span style=display:flex><span>│   │   ├── ipc/
</span></span><span style=display:flex><span>│   │   │   ├── IpcServer.cpp       # UDS Acceptor (Epoll监听)
</span></span><span style=display:flex><span>│   │   │   ├── ClientSession.cpp   # [新增] 本地客户端会话 (处理 LSP 粘包/缓冲)
</span></span><span style=display:flex><span>│   │   │   └── LspCodec.cpp
</span></span><span style=display:flex><span>│   │   └── vsock/
</span></span><span style=display:flex><span>│   │       ├── HostVsockServer.cpp # VSOCK Acceptor (持有 GuestSession)
</span></span><span style=display:flex><span>│   │       ├── GuestSession.cpp    # [新增] Android 会话 (处理 PLP 协议、缓冲、IO)
</span></span><span style=display:flex><span>│   │       └── PlpCodec.cpp
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── executor/                   # 执行层 (Thread 3)
</span></span><span style=display:flex><span>│   │   ├── CommandExecutor.cpp     # 线程池实现
</span></span><span style=display:flex><span>│   │   ├── IAction.h               # [新增] 执行动作基类
</span></span><span style=display:flex><span>│   │   └── actions/
</span></span><span style=display:flex><span>│   │       ├── PingAction.cpp
</span></span><span style=display:flex><span>│   │       └── SystemAction.cpp
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   ├── monitor/                    # 监控模块 (Thread 1)
</span></span><span style=display:flex><span>│   │   ├── SystemMonitor.cpp
</span></span><span style=display:flex><span>│   │   └── QcrosvmMonitor.cpp
</span></span><span style=display:flex><span>│   │
</span></span><span style=display:flex><span>│   └── utils/
</span></span><span style=display:flex><span>│       ├── Log.h
</span></span><span style=display:flex><span>│       ├── JsonUtils.h
</span></span><span style=display:flex><span>│       ├── FileUtils.h
</span></span><span style=display:flex><span>│       ├── TimeUtils.h             # [新增] 时间戳获取
</span></span><span style=display:flex><span>│       └── SocketUtils.h           # [新增] setNonBlocking, createSocket 封装
</span></span><span style=display:flex><span>│
</span></span><span style=display:flex><span>└── tests/
</span></span><span style=display:flex><span>    └── ...
</span></span></code></pre></div><hr></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>