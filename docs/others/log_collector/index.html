<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>QNX/Android Rawdump 机制完全原理解析 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。
1. 全系统生命周期与时序总览
此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。
@startuml
!theme plain
skinparam responseMessageBelowArrow true

participant "User / Script" as User
participant "memorydump\n(QNX Daemon)" as MD
participant "Guest Kernel\n(Android)" as Guest
participant "vdev-msm\n(QNX Driver)" as VDEV
participant "SMEM\n(Shared Memory)" as SMEM
participant "Hardware Register\n(Boot MISC / IMEM)" as HW
participant "Firmware\n(XBL / PBL)" as FW
participant "Rawdump Partition\n(Storage)" as Disk
participant "log_collector\n(QNX Daemon)" as LC

== Phase 1: 系统启动与注册 (Registration) ==
activate MD
User -> MD: 启动服务
MD -> SMEM: 初始化 Global TOC (ID 602)
activate SMEM
deactivate MD

group Guest 注册 (Android Boot)
    Guest -> Guest: qcom_minidump_init()
    Guest -> SMEM: 注册 Region (dmesg, stack, etc.)
    Guest -> SMEM: 代理注册 ADSP/CDSP Regions
end

group Host 注册 (QNX Boot)
    User -> MD: 驱动调用 md_ss_register_region()
    MD -> SMEM: 注册 QNX Regions (Audio Heap, etc.)
end

== Phase 2: 模式配置 (Configuration) ==
User -> MD: echo "mini_rawdump" > /dev/pdbg/.../dload_mode
activate MD
MD -> HW: set_wdog_dload_cookie(MINI_RAWDUMP)
note right: 在硬件寄存器中插旗，\n告知固件崩溃后执行 Rawdump
deactivate MD

== Scene A: 在线采集流程 (Online Guest Dump) ==
note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行
Guest -> Guest: Kernel Panic / Watchdog
Guest -> VDEV: 通知 Host (Hypercall / Signal)
activate VDEV
VDEV -> LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP)
activate LC
LC -> SMEM: 读取 Guest Subsystem TOC
LC -> LC: mmap(MAP_PHYS) 映射 Guest 物理内存
LC -> LC: 生成 .bin 文件 (含 Header + Sections)
LC -> Disk: 写入 /var/log/guest_dump.bin (或其他文件路径)
note right of Disk: **OTA 分区安全** (未被覆盖)
LC --> VDEV: 返回成功
deactivate LC
deactivate VDEV

== Scene B: 全系统崩溃流程 (System Crash / Rawdump) ==
note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启
User -> User: System Crash / Watchdog Bite
User -> FW: CPU Reset & Jump to XBL
activate FW

FW -> HW: 读取 Boot Cookie
alt Cookie == MINI_RAWDUMP
    FW -> SMEM: 读取 Global TOC & Region List
    loop 遍历所有注册的 Region
        FW -> Disk: 裸写物理内存数据到 Rawdump 分区
        note right of Disk: **OTA 数据被销毁**
    end
end

FW -> FW: Cold Boot (Reboot OS)
deactivate FW

== Phase 3: 重启后提取 (Extraction) ==
activate LC
LC -> LC: 启动 (main)
LC -> Disk: fopen("/dev/disk/rawdump")
LC -> Disk: 读取 Header & 校验 Signature ("Raw_Dmp!")

alt Header 有效 (Previous Crash Found)
    LC -> Disk: 读取所有 Section 数据
    LC -> LC: 写入 /var/log/sbldump.bin
    LC -> Disk: fwrite(ZERO) 清空分区 Header
    note right: 清除标志防止重复提取
end
deactivate LC

@enduml
2. 核心组件架构详解
整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/others/log_collector/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/others/log_collector/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/others/log_collector/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="QNX/Android Rawdump 机制完全原理解析"><meta property="og:description" content='本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。
1. 全系统生命周期与时序总览 此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。
@startuml !theme plain skinparam responseMessageBelowArrow true participant "User / Script" as User participant "memorydump\n(QNX Daemon)" as MD participant "Guest Kernel\n(Android)" as Guest participant "vdev-msm\n(QNX Driver)" as VDEV participant "SMEM\n(Shared Memory)" as SMEM participant "Hardware Register\n(Boot MISC / IMEM)" as HW participant "Firmware\n(XBL / PBL)" as FW participant "Rawdump Partition\n(Storage)" as Disk participant "log_collector\n(QNX Daemon)" as LC == Phase 1: 系统启动与注册 (Registration) == activate MD User -> MD: 启动服务 MD -> SMEM: 初始化 Global TOC (ID 602) activate SMEM deactivate MD group Guest 注册 (Android Boot) Guest -> Guest: qcom_minidump_init() Guest -> SMEM: 注册 Region (dmesg, stack, etc.) Guest -> SMEM: 代理注册 ADSP/CDSP Regions end group Host 注册 (QNX Boot) User -> MD: 驱动调用 md_ss_register_region() MD -> SMEM: 注册 QNX Regions (Audio Heap, etc.) end == Phase 2: 模式配置 (Configuration) == User -> MD: echo "mini_rawdump" > /dev/pdbg/.../dload_mode activate MD MD -> HW: set_wdog_dload_cookie(MINI_RAWDUMP) note right: 在硬件寄存器中插旗，\n告知固件崩溃后执行 Rawdump deactivate MD == Scene A: 在线采集流程 (Online Guest Dump) == note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行 Guest -> Guest: Kernel Panic / Watchdog Guest -> VDEV: 通知 Host (Hypercall / Signal) activate VDEV VDEV -> LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP) activate LC LC -> SMEM: 读取 Guest Subsystem TOC LC -> LC: mmap(MAP_PHYS) 映射 Guest 物理内存 LC -> LC: 生成 .bin 文件 (含 Header + Sections) LC -> Disk: 写入 /var/log/guest_dump.bin (或其他文件路径) note right of Disk: **OTA 分区安全** (未被覆盖) LC --> VDEV: 返回成功 deactivate LC deactivate VDEV == Scene B: 全系统崩溃流程 (System Crash / Rawdump) == note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启 User -> User: System Crash / Watchdog Bite User -> FW: CPU Reset & Jump to XBL activate FW FW -> HW: 读取 Boot Cookie alt Cookie == MINI_RAWDUMP FW -> SMEM: 读取 Global TOC & Region List loop 遍历所有注册的 Region FW -> Disk: 裸写物理内存数据到 Rawdump 分区 note right of Disk: **OTA 数据被销毁** end end FW -> FW: Cold Boot (Reboot OS) deactivate FW == Phase 3: 重启后提取 (Extraction) == activate LC LC -> LC: 启动 (main) LC -> Disk: fopen("/dev/disk/rawdump") LC -> Disk: 读取 Header & 校验 Signature ("Raw_Dmp!") alt Header 有效 (Previous Crash Found) LC -> Disk: 读取所有 Section 数据 LC -> LC: 写入 /var/log/sbldump.bin LC -> Disk: fwrite(ZERO) 清空分区 Header note right: 清除标志防止重复提取 end deactivate LC @enduml 2. 核心组件架构详解 整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="others"><meta property="article:published_time" content="2025-08-28T16:25:03+08:00"><meta property="article:modified_time" content="2025-08-28T16:25:03+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="QNX/Android Rawdump 机制完全原理解析"><meta name=twitter:description content='本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。
1. 全系统生命周期与时序总览
此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。
@startuml
!theme plain
skinparam responseMessageBelowArrow true

participant "User / Script" as User
participant "memorydump\n(QNX Daemon)" as MD
participant "Guest Kernel\n(Android)" as Guest
participant "vdev-msm\n(QNX Driver)" as VDEV
participant "SMEM\n(Shared Memory)" as SMEM
participant "Hardware Register\n(Boot MISC / IMEM)" as HW
participant "Firmware\n(XBL / PBL)" as FW
participant "Rawdump Partition\n(Storage)" as Disk
participant "log_collector\n(QNX Daemon)" as LC

== Phase 1: 系统启动与注册 (Registration) ==
activate MD
User -> MD: 启动服务
MD -> SMEM: 初始化 Global TOC (ID 602)
activate SMEM
deactivate MD

group Guest 注册 (Android Boot)
    Guest -> Guest: qcom_minidump_init()
    Guest -> SMEM: 注册 Region (dmesg, stack, etc.)
    Guest -> SMEM: 代理注册 ADSP/CDSP Regions
end

group Host 注册 (QNX Boot)
    User -> MD: 驱动调用 md_ss_register_region()
    MD -> SMEM: 注册 QNX Regions (Audio Heap, etc.)
end

== Phase 2: 模式配置 (Configuration) ==
User -> MD: echo "mini_rawdump" > /dev/pdbg/.../dload_mode
activate MD
MD -> HW: set_wdog_dload_cookie(MINI_RAWDUMP)
note right: 在硬件寄存器中插旗，\n告知固件崩溃后执行 Rawdump
deactivate MD

== Scene A: 在线采集流程 (Online Guest Dump) ==
note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行
Guest -> Guest: Kernel Panic / Watchdog
Guest -> VDEV: 通知 Host (Hypercall / Signal)
activate VDEV
VDEV -> LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP)
activate LC
LC -> SMEM: 读取 Guest Subsystem TOC
LC -> LC: mmap(MAP_PHYS) 映射 Guest 物理内存
LC -> LC: 生成 .bin 文件 (含 Header + Sections)
LC -> Disk: 写入 /var/log/guest_dump.bin (或其他文件路径)
note right of Disk: **OTA 分区安全** (未被覆盖)
LC --> VDEV: 返回成功
deactivate LC
deactivate VDEV

== Scene B: 全系统崩溃流程 (System Crash / Rawdump) ==
note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启
User -> User: System Crash / Watchdog Bite
User -> FW: CPU Reset & Jump to XBL
activate FW

FW -> HW: 读取 Boot Cookie
alt Cookie == MINI_RAWDUMP
    FW -> SMEM: 读取 Global TOC & Region List
    loop 遍历所有注册的 Region
        FW -> Disk: 裸写物理内存数据到 Rawdump 分区
        note right of Disk: **OTA 数据被销毁**
    end
end

FW -> FW: Cold Boot (Reboot OS)
deactivate FW

== Phase 3: 重启后提取 (Extraction) ==
activate LC
LC -> LC: 启动 (main)
LC -> Disk: fopen("/dev/disk/rawdump")
LC -> Disk: 读取 Header & 校验 Signature ("Raw_Dmp!")

alt Header 有效 (Previous Crash Found)
    LC -> Disk: 读取所有 Section 数据
    LC -> LC: 写入 /var/log/sbldump.bin
    LC -> Disk: fwrite(ZERO) 清空分区 Header
    note right: 清除标志防止重复提取
end
deactivate LC

@enduml
2. 核心组件架构详解
整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"杂记","item":"https://ethen-cao.github.io/ethenslab/others/"},{"@type":"ListItem","position":2,"name":"QNX/Android Rawdump 机制完全原理解析","item":"https://ethen-cao.github.io/ethenslab/others/log_collector/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"QNX/Android Rawdump 机制完全原理解析","name":"QNX\/Android Rawdump 机制完全原理解析","description":"本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。\n1. 全系统生命周期与时序总览 此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。\n@startuml !theme plain skinparam responseMessageBelowArrow true participant \u0026#34;User / Script\u0026#34; as User participant \u0026#34;memorydump\\n(QNX Daemon)\u0026#34; as MD participant \u0026#34;Guest Kernel\\n(Android)\u0026#34; as Guest participant \u0026#34;vdev-msm\\n(QNX Driver)\u0026#34; as VDEV participant \u0026#34;SMEM\\n(Shared Memory)\u0026#34; as SMEM participant \u0026#34;Hardware Register\\n(Boot MISC / IMEM)\u0026#34; as HW participant \u0026#34;Firmware\\n(XBL / PBL)\u0026#34; as FW participant \u0026#34;Rawdump Partition\\n(Storage)\u0026#34; as Disk participant \u0026#34;log_collector\\n(QNX Daemon)\u0026#34; as LC == Phase 1: 系统启动与注册 (Registration) == activate MD User -\u0026gt; MD: 启动服务 MD -\u0026gt; SMEM: 初始化 Global TOC (ID 602) activate SMEM deactivate MD group Guest 注册 (Android Boot) Guest -\u0026gt; Guest: qcom_minidump_init() Guest -\u0026gt; SMEM: 注册 Region (dmesg, stack, etc.) Guest -\u0026gt; SMEM: 代理注册 ADSP/CDSP Regions end group Host 注册 (QNX Boot) User -\u0026gt; MD: 驱动调用 md_ss_register_region() MD -\u0026gt; SMEM: 注册 QNX Regions (Audio Heap, etc.) end == Phase 2: 模式配置 (Configuration) == User -\u0026gt; MD: echo \u0026#34;mini_rawdump\u0026#34; \u0026gt; /dev/pdbg/.../dload_mode activate MD MD -\u0026gt; HW: set_wdog_dload_cookie(MINI_RAWDUMP) note right: 在硬件寄存器中插旗，\\n告知固件崩溃后执行 Rawdump deactivate MD == Scene A: 在线采集流程 (Online Guest Dump) == note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行 Guest -\u0026gt; Guest: Kernel Panic / Watchdog Guest -\u0026gt; VDEV: 通知 Host (Hypercall / Signal) activate VDEV VDEV -\u0026gt; LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP) activate LC LC -\u0026gt; SMEM: 读取 Guest Subsystem TOC LC -\u0026gt; LC: mmap(MAP_PHYS) 映射 Guest 物理内存 LC -\u0026gt; LC: 生成 .bin 文件 (含 Header + Sections) LC -\u0026gt; Disk: 写入 /var/log/guest_dump.bin (或其他文件路径) note right of Disk: **OTA 分区安全** (未被覆盖) LC --\u0026gt; VDEV: 返回成功 deactivate LC deactivate VDEV == Scene B: 全系统崩溃流程 (System Crash / Rawdump) == note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启 User -\u0026gt; User: System Crash / Watchdog Bite User -\u0026gt; FW: CPU Reset \u0026amp; Jump to XBL activate FW FW -\u0026gt; HW: 读取 Boot Cookie alt Cookie == MINI_RAWDUMP FW -\u0026gt; SMEM: 读取 Global TOC \u0026amp; Region List loop 遍历所有注册的 Region FW -\u0026gt; Disk: 裸写物理内存数据到 Rawdump 分区 note right of Disk: **OTA 数据被销毁** end end FW -\u0026gt; FW: Cold Boot (Reboot OS) deactivate FW == Phase 3: 重启后提取 (Extraction) == activate LC LC -\u0026gt; LC: 启动 (main) LC -\u0026gt; Disk: fopen(\u0026#34;/dev/disk/rawdump\u0026#34;) LC -\u0026gt; Disk: 读取 Header \u0026amp; 校验 Signature (\u0026#34;Raw_Dmp!\u0026#34;) alt Header 有效 (Previous Crash Found) LC -\u0026gt; Disk: 读取所有 Section 数据 LC -\u0026gt; LC: 写入 /var/log/sbldump.bin LC -\u0026gt; Disk: fwrite(ZERO) 清空分区 Header note right: 清除标志防止重复提取 end deactivate LC @enduml 2. 核心组件架构详解 整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。\n","keywords":[],"articleBody":"本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。\n1. 全系统生命周期与时序总览 此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。\n@startuml !theme plain skinparam responseMessageBelowArrow true participant \"User / Script\" as User participant \"memorydump\\n(QNX Daemon)\" as MD participant \"Guest Kernel\\n(Android)\" as Guest participant \"vdev-msm\\n(QNX Driver)\" as VDEV participant \"SMEM\\n(Shared Memory)\" as SMEM participant \"Hardware Register\\n(Boot MISC / IMEM)\" as HW participant \"Firmware\\n(XBL / PBL)\" as FW participant \"Rawdump Partition\\n(Storage)\" as Disk participant \"log_collector\\n(QNX Daemon)\" as LC == Phase 1: 系统启动与注册 (Registration) == activate MD User -\u003e MD: 启动服务 MD -\u003e SMEM: 初始化 Global TOC (ID 602) activate SMEM deactivate MD group Guest 注册 (Android Boot) Guest -\u003e Guest: qcom_minidump_init() Guest -\u003e SMEM: 注册 Region (dmesg, stack, etc.) Guest -\u003e SMEM: 代理注册 ADSP/CDSP Regions end group Host 注册 (QNX Boot) User -\u003e MD: 驱动调用 md_ss_register_region() MD -\u003e SMEM: 注册 QNX Regions (Audio Heap, etc.) end == Phase 2: 模式配置 (Configuration) == User -\u003e MD: echo \"mini_rawdump\" \u003e /dev/pdbg/.../dload_mode activate MD MD -\u003e HW: set_wdog_dload_cookie(MINI_RAWDUMP) note right: 在硬件寄存器中插旗，\\n告知固件崩溃后执行 Rawdump deactivate MD == Scene A: 在线采集流程 (Online Guest Dump) == note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行 Guest -\u003e Guest: Kernel Panic / Watchdog Guest -\u003e VDEV: 通知 Host (Hypercall / Signal) activate VDEV VDEV -\u003e LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP) activate LC LC -\u003e SMEM: 读取 Guest Subsystem TOC LC -\u003e LC: mmap(MAP_PHYS) 映射 Guest 物理内存 LC -\u003e LC: 生成 .bin 文件 (含 Header + Sections) LC -\u003e Disk: 写入 /var/log/guest_dump.bin (或其他文件路径) note right of Disk: **OTA 分区安全** (未被覆盖) LC --\u003e VDEV: 返回成功 deactivate LC deactivate VDEV == Scene B: 全系统崩溃流程 (System Crash / Rawdump) == note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启 User -\u003e User: System Crash / Watchdog Bite User -\u003e FW: CPU Reset \u0026 Jump to XBL activate FW FW -\u003e HW: 读取 Boot Cookie alt Cookie == MINI_RAWDUMP FW -\u003e SMEM: 读取 Global TOC \u0026 Region List loop 遍历所有注册的 Region FW -\u003e Disk: 裸写物理内存数据到 Rawdump 分区 note right of Disk: **OTA 数据被销毁** end end FW -\u003e FW: Cold Boot (Reboot OS) deactivate FW == Phase 3: 重启后提取 (Extraction) == activate LC LC -\u003e LC: 启动 (main) LC -\u003e Disk: fopen(\"/dev/disk/rawdump\") LC -\u003e Disk: 读取 Header \u0026 校验 Signature (\"Raw_Dmp!\") alt Header 有效 (Previous Crash Found) LC -\u003e Disk: 读取所有 Section 数据 LC -\u003e LC: 写入 /var/log/sbldump.bin LC -\u003e Disk: fwrite(ZERO) 清空分区 Header note right: 清除标志防止重复提取 end deactivate LC @enduml 2. 核心组件架构详解 整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。\n组件名称 运行环境 核心源码 职责与作用 SMEM (Shared Memory) Hardware smem_type.h 数据中心\n存储 ID 为 602 的 Global TOC。它是所有子系统注册内存区域（Region）的共享账本，XBL 和 log_collector 都依据此表工作。 memorydump QNX Host ss_minidump_main.c Host 侧登记处\n负责维护 Host 侧的 SMEM 表，提供接口供 QNX 驱动注册内存。同时负责向硬件寄存器写入 Magic Cookie (MINI_RAWDUMP)。 vdev-msm QNX Host vdev-msm.c Guest 吹哨人\n监听 Android 虚拟机的看门狗状态。当 Guest Panic 时，它负责触发在线采集流程 (DCMD_COLLECT_GUEST_MINIDUMP)。 log_collector QNX Host log_collect_resmgr.c 搬运工\n1. 在线模式：响应 vdev-msm 请求，通过 mmap 读取 Guest 内存并存为文件。\n2. 离线模式：系统重启后，检查 Rawdump 分区头，提取 XBL 写入的数据。 XBL Firmware Bootloader XBLRamDump 离线执行者\n仅在全系统重启（System Crash）时工作。它无视文件系统，直接将物理内存“裸写”到 Rawdump 分区。 3. 存储架构：OTA 分区复用机制 系统采用了 Rawdump 与 OTA 分区复用 的策略。\n物理层：QNX 侧存在一个约 10GB 的物理分区 /dev/disk/rawdump。 透传层：通过 vdev-virtio-blk 将该物理分区透传给 Android 虚拟机。 Android 侧：被重命名为 /dev/block/by-name/ota。 冲突与共存： 正常运行：Android 挂载为 ext4 文件系统，用于存储 OTA 升级包。 Guest Crash：log_collector 写入普通文件，OTA 数据安全。 System Crash：XBL 固件直接覆盖写入，OTA 文件系统被销毁。 4. 关键路径决策分析 系统在崩溃时会根据情况进入两条不同的路径，这也是排查“OTA 损坏”或“Log 丢失”问题的关键依据。\n路径 A：Guest VM Crash (在线采集) 特征：QNX 不重启，仅 Android 重启。 流程：vdev-msm -\u003e log_collector -\u003e mmap -\u003e 写文件 (/var/log/guest_dump.bin)。 结果：速度快，保留 OTA 包。 路径 B：System Crash (离线转储) 特征：整机黑屏重启，XBL 介入。 流程：硬件看门狗复位 -\u003e XBL -\u003e 读取 SMEM -\u003e 覆盖 Rawdump 分区。 结果：速度慢，销毁 OTA 包。 5. Android 侧的避让策略 (init.mount_ota.sh) 为了处理路径 B 带来的分区污染，Android 启动脚本实现了以下逻辑：\n触发：sys.boot_completed=1（开机完成后）。 检测：dd 读取分区头，检查是否存在 Raw_Dmp!。 避让：如果发现签名，脚本会循环等待（Time-wait），给 QNX log_collector 提取数据留出时间。 格式化：提取完成或等待超时后，强制格式化分区，恢复 OTA 功能。 ","wordCount":"565","inLanguage":"en","datePublished":"2025-08-28T16:25:03+08:00","dateModified":"2025-08-28T16:25:03+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/others/log_collector/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/others/>杂记</a></div><h1 class="post-title entry-hint-parent">QNX/Android Rawdump 机制完全原理解析</h1><div class=post-meta><span title='2025-08-28 16:25:03 +0800 CST'>August 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words</div></header><div class=post-content><p>本文档基于系统源码（QNX/Android/Bootloader）及实际配置分析，详细阐述了智能座舱系统中的内存转储（Crash Dump）机制。</p><h2 id=1-全系统生命周期与时序总览>1. 全系统生命周期与时序总览<a hidden class=anchor aria-hidden=true href=#1-全系统生命周期与时序总览>#</a></h2><p>此图描述了从系统启动注册、模式配置，到发生崩溃（分两种场景），最后到重启提取的完整闭环流程。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
skinparam responseMessageBelowArrow true

participant &#34;User / Script&#34; as User
participant &#34;memorydump\n(QNX Daemon)&#34; as MD
participant &#34;Guest Kernel\n(Android)&#34; as Guest
participant &#34;vdev-msm\n(QNX Driver)&#34; as VDEV
participant &#34;SMEM\n(Shared Memory)&#34; as SMEM
participant &#34;Hardware Register\n(Boot MISC / IMEM)&#34; as HW
participant &#34;Firmware\n(XBL / PBL)&#34; as FW
participant &#34;Rawdump Partition\n(Storage)&#34; as Disk
participant &#34;log_collector\n(QNX Daemon)&#34; as LC

== Phase 1: 系统启动与注册 (Registration) ==
activate MD
User -&gt; MD: 启动服务
MD -&gt; SMEM: 初始化 Global TOC (ID 602)
activate SMEM
deactivate MD

group Guest 注册 (Android Boot)
    Guest -&gt; Guest: qcom_minidump_init()
    Guest -&gt; SMEM: 注册 Region (dmesg, stack, etc.)
    Guest -&gt; SMEM: 代理注册 ADSP/CDSP Regions
end

group Host 注册 (QNX Boot)
    User -&gt; MD: 驱动调用 md_ss_register_region()
    MD -&gt; SMEM: 注册 QNX Regions (Audio Heap, etc.)
end

== Phase 2: 模式配置 (Configuration) ==
User -&gt; MD: echo &#34;mini_rawdump&#34; &gt; /dev/pdbg/.../dload_mode
activate MD
MD -&gt; HW: set_wdog_dload_cookie(MINI_RAWDUMP)
note right: 在硬件寄存器中插旗，\n告知固件崩溃后执行 Rawdump
deactivate MD

== Scene A: 在线采集流程 (Online Guest Dump) ==
note over Guest, LC: 场景：仅 Guest VM 崩溃，Host 正常运行
Guest -&gt; Guest: Kernel Panic / Watchdog
Guest -&gt; VDEV: 通知 Host (Hypercall / Signal)
activate VDEV
VDEV -&gt; LC: devctl(DCMD_COLLECT_GUEST_MINIDUMP)
activate LC
LC -&gt; SMEM: 读取 Guest Subsystem TOC
LC -&gt; LC: mmap(MAP_PHYS) 映射 Guest 物理内存
LC -&gt; LC: 生成 .bin 文件 (含 Header + Sections)
LC -&gt; Disk: 写入 /var/log/guest_dump.bin (或其他文件路径)
note right of Disk: **OTA 分区安全** (未被覆盖)
LC --&gt; VDEV: 返回成功
deactivate LC
deactivate VDEV

== Scene B: 全系统崩溃流程 (System Crash / Rawdump) ==
note over User, Disk: 场景：Host 崩溃或 Watchdog 触发全系统重启
User -&gt; User: System Crash / Watchdog Bite
User -&gt; FW: CPU Reset &amp; Jump to XBL
activate FW

FW -&gt; HW: 读取 Boot Cookie
alt Cookie == MINI_RAWDUMP
    FW -&gt; SMEM: 读取 Global TOC &amp; Region List
    loop 遍历所有注册的 Region
        FW -&gt; Disk: 裸写物理内存数据到 Rawdump 分区
        note right of Disk: **OTA 数据被销毁**
    end
end

FW -&gt; FW: Cold Boot (Reboot OS)
deactivate FW

== Phase 3: 重启后提取 (Extraction) ==
activate LC
LC -&gt; LC: 启动 (main)
LC -&gt; Disk: fopen(&#34;/dev/disk/rawdump&#34;)
LC -&gt; Disk: 读取 Header &amp; 校验 Signature (&#34;Raw_Dmp!&#34;)

alt Header 有效 (Previous Crash Found)
    LC -&gt; Disk: 读取所有 Section 数据
    LC -&gt; LC: 写入 /var/log/sbldump.bin
    LC -&gt; Disk: fwrite(ZERO) 清空分区 Header
    note right: 清除标志防止重复提取
end
deactivate LC

@enduml
</code></pre><h2 id=2-核心组件架构详解>2. 核心组件架构详解<a hidden class=anchor aria-hidden=true href=#2-核心组件架构详解>#</a></h2><p>整个 Rawdump 机制跨越了 Bootloader、Host OS (QNX)、Guest OS (Android) 和 硬件层。</p><table><thead><tr><th>组件名称</th><th>运行环境</th><th>核心源码</th><th>职责与作用</th></tr></thead><tbody><tr><td><strong>SMEM (Shared Memory)</strong></td><td>Hardware</td><td><code>smem_type.h</code></td><td><strong>数据中心</strong><br>存储 ID 为 <code>602</code> 的 Global TOC。它是所有子系统注册内存区域（Region）的共享账本，XBL 和 log_collector 都依据此表工作。</td></tr><tr><td><strong><code>memorydump</code></strong></td><td>QNX Host</td><td><code>ss_minidump_main.c</code></td><td><strong>Host 侧登记处</strong><br>负责维护 Host 侧的 SMEM 表，提供接口供 QNX 驱动注册内存。同时负责向硬件寄存器写入 Magic Cookie (<code>MINI_RAWDUMP</code>)。</td></tr><tr><td><strong><code>vdev-msm</code></strong></td><td>QNX Host</td><td><code>vdev-msm.c</code></td><td><strong>Guest 吹哨人</strong><br>监听 Android 虚拟机的看门狗状态。当 Guest Panic 时，它负责触发在线采集流程 (<code>DCMD_COLLECT_GUEST_MINIDUMP</code>)。</td></tr><tr><td><strong><code>log_collector</code></strong></td><td>QNX Host</td><td><code>log_collect_resmgr.c</code></td><td><strong>搬运工</strong><br>1. <strong>在线模式</strong>：响应 <code>vdev-msm</code> 请求，通过 <code>mmap</code> 读取 Guest 内存并存为文件。<br>2. <strong>离线模式</strong>：系统重启后，检查 Rawdump 分区头，提取 XBL 写入的数据。</td></tr><tr><td><strong>XBL Firmware</strong></td><td>Bootloader</td><td><code>XBLRamDump</code></td><td><strong>离线执行者</strong><br>仅在<strong>全系统重启</strong>（System Crash）时工作。它无视文件系统，直接将物理内存“裸写”到 Rawdump 分区。</td></tr></tbody></table><hr><h2 id=3-存储架构ota-分区复用机制>3. 存储架构：OTA 分区复用机制<a hidden class=anchor aria-hidden=true href=#3-存储架构ota-分区复用机制>#</a></h2><p>系统采用了 <strong>Rawdump 与 OTA 分区复用</strong> 的策略。</p><ul><li><strong>物理层</strong>：QNX 侧存在一个约 <strong>10GB</strong> 的物理分区 <code>/dev/disk/rawdump</code>。</li><li><strong>透传层</strong>：通过 <code>vdev-virtio-blk</code> 将该物理分区透传给 Android 虚拟机。</li><li><strong>Android 侧</strong>：被重命名为 <code>/dev/block/by-name/ota</code>。</li><li><strong>冲突与共存</strong>：</li><li><strong>正常运行</strong>：Android 挂载为 <code>ext4</code> 文件系统，用于存储 OTA 升级包。</li><li><strong>Guest Crash</strong>：<code>log_collector</code> 写入普通文件，<strong>OTA 数据安全</strong>。</li><li><strong>System Crash</strong>：XBL 固件直接覆盖写入，<strong>OTA 文件系统被销毁</strong>。</li></ul><hr><h2 id=4-关键路径决策分析>4. 关键路径决策分析<a hidden class=anchor aria-hidden=true href=#4-关键路径决策分析>#</a></h2><p>系统在崩溃时会根据情况进入两条不同的路径，这也是排查“OTA 损坏”或“Log 丢失”问题的关键依据。</p><h3 id=路径-aguest-vm-crash-在线采集>路径 A：Guest VM Crash (在线采集)<a hidden class=anchor aria-hidden=true href=#路径-aguest-vm-crash-在线采集>#</a></h3><ul><li><strong>特征</strong>：QNX 不重启，仅 Android 重启。</li><li><strong>流程</strong>：<code>vdev-msm</code> -> <code>log_collector</code> -> <code>mmap</code> -> 写文件 (<code>/var/log/guest_dump.bin</code>)。</li><li><strong>结果</strong>：速度快，保留 OTA 包。</li></ul><h3 id=路径-bsystem-crash-离线转储>路径 B：System Crash (离线转储)<a hidden class=anchor aria-hidden=true href=#路径-bsystem-crash-离线转储>#</a></h3><ul><li><strong>特征</strong>：整机黑屏重启，XBL 介入。</li><li><strong>流程</strong>：硬件看门狗复位 -> XBL -> 读取 SMEM -> <strong>覆盖 Rawdump 分区</strong>。</li><li><strong>结果</strong>：速度慢，<strong>销毁 OTA 包</strong>。</li></ul><hr><h2 id=5-android-侧的避让策略-initmount_otash>5. Android 侧的避让策略 (<code>init.mount_ota.sh</code>)<a hidden class=anchor aria-hidden=true href=#5-android-侧的避让策略-initmount_otash>#</a></h2><p>为了处理路径 B 带来的分区污染，Android 启动脚本实现了以下逻辑：</p><ol><li><strong>触发</strong>：<code>sys.boot_completed=1</code>（开机完成后）。</li><li><strong>检测</strong>：<code>dd</code> 读取分区头，检查是否存在 <code>Raw_Dmp!</code>。</li><li><strong>避让</strong>：如果发现签名，脚本会循环等待（Time-wait），给 QNX <code>log_collector</code> 提取数据留出时间。</li><li><strong>格式化</strong>：提取完成或等待超时后，强制格式化分区，恢复 OTA 功能。</li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>