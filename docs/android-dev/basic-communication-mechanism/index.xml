<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础通信 on Ethen 的实验室</title>
    <link>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/</link>
    <description>Recent content in 基础通信 on Ethen 的实验室</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 28 Aug 2025 14:30:02 +0800</lastBuildDate>
    <atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Binder</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/binder/</link>
      <pubDate>Thu, 28 Aug 2025 14:30:02 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/binder/</guid>
      <description>&lt;h2 id=&#34;同步通信&#34;&gt;同步通信&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ethen-cao.github.io/ethenslab/images/binder-sync.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;异步通信&#34;&gt;异步通信&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ethen-cao.github.io/ethenslab/images/binder-async.png&#34; alt=&#34;&#34;&gt;)&lt;/p&gt;&#xA;&lt;h2 id=&#34;内存管理&#34;&gt;内存管理&lt;/h2&gt;&#xA;&lt;p&gt;好的。遵照您的要求，以下是对该问题的严肃且精准的完整回答。&lt;/p&gt;&#xA;&lt;h3 id=&#34;binder-驱动的通信内存管理机制&#34;&gt;&lt;strong&gt;Binder 驱动的通信内存管理机制&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Binder 驱动的内存管理是一套内核层面的复杂机制，其核心目标是在进程间高效、安全地传输数据，并实现“一次拷贝”原则。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第一部分binder-通信内存的总体管理机制&#34;&gt;&lt;strong&gt;第一部分：Binder 通信内存的总体管理机制&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;该机制主要分为三个阶段：虚拟内存区的建立、事务缓冲区的分配与映射、以及事务缓冲区的释放。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1.1 进程虚拟内存区的建立&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;当一个用户进程首次打开 &lt;code&gt;/dev/binder&lt;/code&gt; 设备并对其执行 &lt;code&gt;mmap()&lt;/code&gt; 系统调用时，Binder 驱动会执行 &lt;code&gt;binder_mmap()&lt;/code&gt; 内核函数。此函数的主要工作包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为该进程在内核中创建一个 &lt;code&gt;binder_proc&lt;/code&gt; 结构体实例，用于追踪其所有 Binder 相关状态。&lt;/li&gt;&#xA;&lt;li&gt;在该进程的虚拟地址空间中，分配并初始化一块指定大小（由 &lt;code&gt;BINDER_VM_SIZE&lt;/code&gt; 决定，通常为 1MB）的虚拟内存区域（Virtual Memory Area, VMA）。&lt;/li&gt;&#xA;&lt;li&gt;将这个 VMA 与进程的 &lt;code&gt;binder_proc&lt;/code&gt; 结构体关联。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;此阶段的关键在于，&lt;strong&gt;仅分配了虚拟地址空间，并未分配实际的物理内存&lt;/strong&gt;。这块 VMA 的作用是为未来接收 Binder 数据提供一个预先确定的目标地址范围。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1.2 事务缓冲区的分配与映射&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;当一个进程（Client）通过 &lt;code&gt;ioctl(BINDER_WRITE_READ)&lt;/code&gt; 发起一次事务（Transaction）时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配内核缓冲区&lt;/strong&gt;：Binder 驱动的 &lt;code&gt;binder_thread_write()&lt;/code&gt; 函数会调用 &lt;code&gt;binder_alloc_buf()&lt;/code&gt;，根据事务数据的大小，从内核的通用物理内存池（如 &lt;code&gt;vmalloc&lt;/code&gt; 或 slab 分配器）中分配一个 &lt;code&gt;binder_buffer&lt;/code&gt; 内核对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据拷贝（一次拷贝）&lt;/strong&gt;：驱动调用 &lt;code&gt;copy_from_user()&lt;/code&gt;，将数据从 Client 进程的用户空间地址，拷贝到上一步分配的内核 &lt;code&gt;binder_buffer&lt;/code&gt; 中。这是整个跨进程通信中唯一的一次数据内容拷贝。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;地址空间映射&lt;/strong&gt;：驱动识别出目标进程（Server）后，并不会再次拷贝数据。它会执行一个核心操作：&lt;strong&gt;修改 Server 进程的内核页表&lt;/strong&gt;，将承载着数据的 &lt;code&gt;binder_buffer&lt;/code&gt; 的物理内存页，直接映射到 Server 进程在 1.1 阶段建立的 VMA 中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据投递&lt;/strong&gt;：驱动将映射后的缓冲区在 Server 进程中的虚拟地址，连同事务命令（如 &lt;code&gt;BR_TRANSACTION&lt;/code&gt; 或 &lt;code&gt;BR_ONEWAY&lt;/code&gt;），一同投递给 Server 中等待的 Binder 线程。Server 线程可以直接访问该地址，如同访问进程内内存一样。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;1.3 事务缓冲区的释放&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
