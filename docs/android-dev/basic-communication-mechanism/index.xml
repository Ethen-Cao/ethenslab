<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>基础通信 on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/</link><description>Recent content in 基础通信 on Ethen 的实验室</description><generator>Hugo -- 0.155.3</generator><language>en</language><lastBuildDate>Thu, 28 Aug 2025 14:30:02 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/index.xml" rel="self" type="application/rss+xml"/><item><title>Android Binder 通信模型与内存管理机制详解</title><link>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/binder/</link><pubDate>Thu, 28 Aug 2025 14:30:02 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/binder/</guid><description>&lt;p&gt;Binder 是 Android 系统中进程间通信（IPC）的基石。不同于 Linux 传统的管道、Socket 或共享内存，Binder 提供了一种基于 C/S 架构、支持对象传输且内存高效的通信机制。&lt;/p&gt;
&lt;p&gt;本文档将深入剖析 Binder 的同步/异步通信模型、线程调度策略以及内核层的内存管理机制。&lt;/p&gt;
&lt;h2 id="1-通信模型概述"&gt;1. 通信模型概述&lt;/h2&gt;
&lt;p&gt;Binder 驱动通过 &lt;code&gt;ioctl&lt;/code&gt; 系统调用与用户空间交互。根据事务标志位（Flags），通信模式主要分为两类。&lt;/p&gt;
&lt;h3 id="11-同步通信-synchronous"&gt;1.1 同步通信 (Synchronous)&lt;/h3&gt;
&lt;p&gt;这是 Binder 的默认通信模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流程&lt;/strong&gt;：Client 发起调用后，其线程会被挂起（Blocked），进入等待状态。Binder 驱动唤醒 Server 端线程处理请求。Server 处理完毕并将结果写入驱动后，驱动唤醒 Client 线程，Client 获取返回值继续执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强一致性&lt;/strong&gt;：Client 确切知道 Server 何时处理完毕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级继承&lt;/strong&gt;：为防止优先级反转，驱动会将 Client 线程的优先级临时“借”给 Server 线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源限制&lt;/strong&gt;：受限于调用栈深度和线程池大小，过多的同步链调用可能导致死锁或 watchdog 超时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="同步通信线程调度与优先级继承"&gt;同步通信线程调度与优先级继承&lt;/h4&gt;
&lt;p&gt;在同步通信（Synchronous IPC）中，Client 端发起请求后会进入阻塞状态（Blocked），直到 Server 端返回结果。Binder 驱动在此过程中扮演了“调度员”的角色，不仅负责数据的传递，还负责协调双方线程的执行状态和优先级。&lt;/p&gt;
&lt;h5 id="核心机制"&gt;核心机制&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;阻塞等待&lt;/strong&gt;：Client 线程调用 &lt;code&gt;ioctl&lt;/code&gt; 发送事务后，会在内核中休眠，等待 Server 的回复（Reply）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级继承&lt;/strong&gt;：如果 Client 的优先级高于 Server 线程，Binder 驱动会将 Server 线程的优先级临时提升至与 Client 一致，以避免“优先级反转”问题。当 Server 处理完请求后，恢复原优先级。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程栈管理&lt;/strong&gt;：Binder 驱动维护了 &lt;code&gt;transaction_stack&lt;/code&gt;，用于追踪跨进程调用的嵌套关系（如 A-&amp;gt;B-&amp;gt;C），确保回复能正确层层返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id="同步通信时序图"&gt;同步通信时序图&lt;/h5&gt;
&lt;p&gt;下图展示了一个完整的同步调用闭环：Client 发送请求 -&amp;gt; Server 被唤醒处理 -&amp;gt; Server 返回结果 -&amp;gt; Client 被唤醒。&lt;/p&gt;</description></item></channel></rss>