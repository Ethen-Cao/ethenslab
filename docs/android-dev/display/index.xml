<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Display Manager on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/</link><description>Recent content in Display Manager on Ethen 的实验室</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Mon, 29 Sep 2025 10:22:54 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/display/index.xml" rel="self" type="application/rss+xml"/><item><title>Android SurfaceFlinger RenderEngine 深度详解</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/renderengine/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/renderengine/</guid><description>&lt;p&gt;RenderEngine 是 SurfaceFlinger 的渲染后端核心，负责将各个图层（Layer）的内容利用 GPU 合成到一帧缓冲区中。在现代 Android 版本中，它基于 &lt;strong&gt;Skia&lt;/strong&gt; 图形库构建，实现了高度的模块化、多后端支持（GLES/Vulkan）以及异步多线程渲染。&lt;/p&gt;
&lt;h2 id="1-架构概览-architecture-overview"&gt;1. 架构概览 (Architecture Overview)&lt;/h2&gt;
&lt;p&gt;RenderEngine 采用了 &lt;strong&gt;分层架构&lt;/strong&gt; 与 &lt;strong&gt;装饰器模式&lt;/strong&gt; 的设计。&lt;/p&gt;
&lt;h3 id="11-核心组件架构图"&gt;1.1 核心组件架构图&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme cerulean
hide empty members
skinparam linetype ortho
skinparam nodesep 60
skinparam ranksep 60
&amp;#39; ==========================================
&amp;#39; 1. 接口与装饰器层
&amp;#39; ==========================================
package &amp;#34;Interface &amp;amp; Decorator&amp;#34; {
abstract class RenderEngine {
+ {static} create() : unique_ptr&amp;lt;RenderEngine&amp;gt;
+ {abstract} drawLayers()
+ {abstract} mapExternalTextureBuffer()
}
class RenderEngineThreaded {
- mRenderEngine : unique_ptr&amp;lt;RenderEngine&amp;gt;
- mThread : std::thread
- mFunctionCalls : queue&amp;lt;function&amp;gt;
+ drawLayers() : &amp;#34;非阻塞提交&amp;#34;
}
note right of RenderEngineThreaded
&amp;lt;b&amp;gt;线程装饰器&amp;lt;/b&amp;gt;
将渲染调用跨线程
分发到后台工作线程
end note
}
&amp;#39; ==========================================
&amp;#39; 2. 核心逻辑层 (Skia Implementation)
&amp;#39; ==========================================
package &amp;#34;Core Implementation (Skia)&amp;#34; {
abstract class SkiaRenderEngine {
# mTextureCache : TextureCache
# mCaptureCache : CaptureCache
+ drawLayers() : &amp;#34;通用 Skia 绘制逻辑&amp;#34;
# drawLayersInternal()
}
note right of SkiaRenderEngine
&amp;lt;b&amp;gt;业务逻辑核心&amp;lt;/b&amp;gt;
负责将 LayerSettings
翻译为 Skia Canvas 指令
end note
}
&amp;#39; ==========================================
&amp;#39; 3. 后端驱动层 (Backends)
&amp;#39; ==========================================
package &amp;#34;Backend Drivers&amp;#34; {
class SkiaGLRenderEngine {
- mEGLDisplay : EGLDisplay
- mEGLContext : EGLContext
+ create()
--
(Ganesh GL Backend)
}
class GaneshVkRenderEngine {
- mInstance : VkInstance
- mDevice : VkDevice
+ create()
--
(Ganesh Vulkan Backend)
}
class GraphiteVkRenderEngine {
--
(Graphite Vulkan Backend)
}
}
&amp;#39; 关系连线
RenderEngine &amp;lt;|-- RenderEngineThreaded
RenderEngine &amp;lt;|-- SkiaRenderEngine
SkiaRenderEngine &amp;lt;|-- SkiaGLRenderEngine
SkiaRenderEngine &amp;lt;|-- GaneshVkRenderEngine
SkiaRenderEngine &amp;lt;|-- GraphiteVkRenderEngine
RenderEngineThreaded o-- RenderEngine : 包装实际实现 (Impl)
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="12-关键组件工作机制"&gt;1.2 关键组件工作机制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;RenderEngine&lt;/code&gt; (Interface)&lt;/strong&gt;:&lt;/p&gt;</description></item><item><title>Android SurfaceFlinger 深度解析</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/</guid><description>&lt;p&gt;SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。&lt;/p&gt;
&lt;h2 id="1-display-创建过程"&gt;1. Display 创建过程&lt;/h2&gt;
&lt;p&gt;在 SurfaceFlinger 中，&lt;code&gt;Display&lt;/code&gt; 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。&lt;/p&gt;
&lt;h3 id="11-核心流程时序解析"&gt;1.1 核心流程时序解析&lt;/h3&gt;
&lt;p&gt;下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。&lt;/p&gt;
&lt;div class="mermaid"&gt;sequenceDiagram
autonumber
%% 定义参与者
participant HWC as HWC/Kernel
participant DisplayManagerService as DisplayManagerService
participant SF as SurfaceFlinger(MainThread)
participant CE as CompositionEngine
participant BQ as BufferQueue
participant VDS as VirtualDisplaySurface
participant FBS as FramebufferSurface
participant DD as DisplayDevice
participant Scheduler as Scheduler
box "触发源 (Triggers)" #f9f9f9
participant HWC
participant DisplayManagerService
end
box "SurfaceFlinger" #e1f5fe
participant SF
participant Scheduler
participant DD
participant CE
participant BQ
participant VDS
participant FBS
end
%% === 第一阶段：触发 ===
rect rgb(255, 240, 240)
note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
alt 物理屏幕插入 (Hotplug)
HWC -&gt;&gt; SF: onHotplugReceived(displayId, connected=true)
SF -&gt;&gt; SF: update mCurrentState (add Display)
SF -&gt;&gt; SF: setTransactionFlags(eDisplayTransactionNeeded)
else 虚拟屏幕请求 (Virtual)
DisplayManagerService -&gt;&gt; SF: createDisplay(name, secure)
SF -&gt;&gt; SF: update mCurrentState (add Display)
SF -&gt;&gt; SF: setTransactionFlags(eDisplayTransactionNeeded)
end
end
%% === 第二阶段：主循环处理 ===
SF -&gt;&gt; SF: onMessageInvalidate() -&gt; handleMessageTransaction()
SF -&gt;&gt; SF: processDisplayChangesLocked()
note right of SF: 发现 mCurrentState 有新 token&lt;br/&gt;而 mDrawingState 没有
%% === 第三阶段：核心工厂方法 ===
rect rgb(255, 250, 230)
note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
SF -&gt;&gt; SF: processDisplayAdded(token, state)
%% 1. 创建 CE Display
SF -&gt;&gt; CE: createDisplay(args)
activate CE
CE --&gt;&gt; SF: return compositionDisplay
deactivate CE
%% 2. 创建 Buffer 管道
SF -&gt;&gt; BQ: createBufferQueue()
BQ --&gt;&gt; SF: return (producer, consumer)
%% 3. 创建 Surface (分叉逻辑)
note right of SF: 阶段 3: 注册与激活
alt 物理屏幕
SF -&gt;&gt; Scheduler: registerDisplay(physicalId, refreshRateSelector)
end
SF -&gt;&gt; SF: mDisplays.add(token, displayDevice)
opt 如果是物理屏幕
SF -&gt;&gt; HWC: setPowerMode(ON)
SF -&gt;&gt; SF: onActiveDisplayChangedLocked (如果是主屏)
end
end
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;技术实现细节：&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>DisplayManagerService设计</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/</guid><description>&lt;h2 id="logicaldisplay的创建过程"&gt;LogicalDisplay的创建过程&lt;/h2&gt;
&lt;p&gt;这个时序图展示了从底层物理屏幕发现到上层窗口管理容器创建的完整链路。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/android-13-LogicalDisplay-creating-sequence.png" alt="" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化阶段&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 启动，在 &lt;code&gt;onStart&lt;/code&gt; 方法中发送 &lt;code&gt;MSG_REGISTER_DEFAULT_DISPLAY_ADAPTERS&lt;/code&gt; 消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 的 Handler 处理该消息，调用 &lt;code&gt;registerDefaultDisplayAdapters&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;registerDefaultDisplayAdapters&lt;/code&gt; 中，创建 &lt;code&gt;LocalDisplayAdapter&lt;/code&gt; 实例并注册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LocalDisplayAdapter 发现设备&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LocalDisplayAdapter&lt;/code&gt; 初始化时会从 &lt;code&gt;SurfaceControl&lt;/code&gt; 获取物理屏幕信息（通过 &lt;code&gt;SurfaceControlProxy&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;发现物理屏幕后，创建 &lt;code&gt;LocalDisplayDevice&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;sendDisplayDeviceEventLocked&lt;/code&gt; 发送 &lt;code&gt;DISPLAY_DEVICE_EVENT_ADDED&lt;/code&gt; 事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DisplayDeviceRepository 处理事件&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DisplayAdapter&lt;/code&gt; 将事件发送给 &lt;code&gt;DisplayDeviceRepository&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayDeviceRepository&lt;/code&gt; 将 &lt;code&gt;LocalDisplayDevice&lt;/code&gt; 添加到列表，并通知监听者，即 &lt;code&gt;LogicalDisplayMapper&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LogicalDisplayMapper 创建 LogicalDisplay&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LogicalDisplayMapper&lt;/code&gt; 收到 &lt;code&gt;DISPLAY_DEVICE_EVENT_ADDED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果是默认屏幕，先进行初始化配置。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;createNewLogicalDisplayLocked&lt;/code&gt; 创建 &lt;code&gt;LogicalDisplay&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;applyLayoutLocked&lt;/code&gt; 来根据设备状态配置布局。&lt;/li&gt;
&lt;li&gt;最后调用 &lt;code&gt;updateLogicalDisplaysLocked&lt;/code&gt; 来更新整个系统的显示状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通知系统和 WMS&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;updateLogicalDisplaysLocked&lt;/code&gt; 中，&lt;code&gt;LogicalDisplayMapper&lt;/code&gt; 通知 &lt;code&gt;DisplayManagerService&lt;/code&gt; (通过 &lt;code&gt;Listener&lt;/code&gt;) &lt;code&gt;LOGICAL_DISPLAY_EVENT_ADDED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 收到事件，调用 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 发送 &lt;code&gt;DisplayManagerGlobal.EVENT_DISPLAY_ADDED&lt;/code&gt; 到 Handler。&lt;/li&gt;
&lt;li&gt;Handler 处理消息，调用 &lt;code&gt;deliverDisplayEvent&lt;/code&gt; 通知所有注册的 &lt;code&gt;IDisplayManagerCallback&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键点&lt;/strong&gt;: &lt;code&gt;WindowManagerService&lt;/code&gt; 在初始化时通过 &lt;code&gt;DisplayManagerInternal&lt;/code&gt; 获取了 &lt;code&gt;DisplayManager&lt;/code&gt; 的回调或直接监听。但在代码中，WMS 实际上是通过 &lt;code&gt;DisplayManagerInternal.registerDisplayTransactionListener&lt;/code&gt; 或直接轮询/监听来感知的。&lt;/li&gt;
&lt;li&gt;更具体的路径是：&lt;code&gt;DisplayManagerService&lt;/code&gt; 在 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt; 中会配置显示属性，并最终触发 &lt;code&gt;DisplayTransactionListener&lt;/code&gt; 或发送广播。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;WindowManagerService&lt;/code&gt; 中，通常通过 &lt;code&gt;DisplayManager&lt;/code&gt; 的回调 &lt;code&gt;onDisplayAdded&lt;/code&gt; 感知，然后调用 &lt;code&gt;mRoot.createDisplayContent&lt;/code&gt;。在提供的代码中，&lt;code&gt;DisplayManagerService&lt;/code&gt; 拥有 &lt;code&gt;mDisplayTransactionListeners&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 的 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt; 会调用 &lt;code&gt;sendDisplayEventLocked&lt;/code&gt;，进而触发回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;补充：&lt;code&gt;WindowManagerService&lt;/code&gt; 如何创建 &lt;code&gt;DisplayContent&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;</description></item><item><title>HWC简介</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/composor/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/composor/</guid><description>&lt;p&gt;HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;服务启动与依赖注入&lt;/strong&gt;：&lt;code&gt;service.cpp&lt;/code&gt; 启动进程，创建 AIDL 服务实体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDM 环境初始化&lt;/strong&gt;：&lt;code&gt;ConcurrencyMgr&lt;/code&gt; 初始化，加载 Core 层和硬件信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Display 对象构建&lt;/strong&gt;：&lt;code&gt;DisplayBuilder&lt;/code&gt; 根据硬件信息创建具体的 &lt;code&gt;DisplayBuiltIn&lt;/code&gt; 和 &lt;code&gt;HWPeripheralDRM&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="qualcomm-hwc-启动与-display-创建全流程"&gt;Qualcomm HWC 启动与 Display 创建全流程&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme plain
skinparam MaxMessageSize 200
skinparam participantPadding 10
skinparam boxPadding 10
skinparam defaultFontName Monospaced
autonumber &amp;#34;&amp;lt;b&amp;gt;[Boot-0]&amp;lt;/b&amp;gt;&amp;#34;
title HWC Service Startup &amp;amp; Display Creation Sequence (Final Fix)
box &amp;#34;Service Process Entry&amp;#34; #White
participant &amp;#34;Main (service.cpp)&amp;#34; as Main
participant &amp;#34;AidlComposer\n(BnComposer)&amp;#34; as AC
end box
box &amp;#34;SDM Client Layer&amp;#34; #LightYellow
participant &amp;#34;SDMInterfaceFactory&amp;#34; as Factory
participant &amp;#34;ConcurrencyMgr&amp;#34; as CM
participant &amp;#34;SDMDisplayBuilder&amp;#34; as Builder
end box
box &amp;#34;SDM Core Layer&amp;#34; #LightGreen
participant &amp;#34;CoreInterface&amp;#34; as CoreStatic
participant &amp;#34;CoreImpl&amp;#34; as Core
participant &amp;#34;DisplayBuiltIn&amp;#34; as DBI
participant &amp;#34;DPUMultiCore\n(Mux)&amp;#34; as Mux
end box
box &amp;#34;Device Abstraction Layer (DAL)&amp;#34; #LightGray
participant &amp;#34;HWInfoInterface&amp;#34; as HWInfo
participant &amp;#34;HWInterface\n(Factory)&amp;#34; as HWFactory
participant &amp;#34;HWPeripheralDRM&amp;#34; as HW
end box
== 阶段 1: 服务启动与接口绑定 ==
Main -&amp;gt; Main: setpriority / sched_setscheduler
create AC
Main -&amp;gt; AC: **new AidlComposer()**
activate AC
&amp;#39; 1.1 创建核心管理对象 ConcurrencyMgr
AC -&amp;gt; Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ...
activate Factory
Factory -&amp;gt; CM: **GetInstance()** (Singleton)
activate CM
CM --&amp;gt; Factory: instance
deactivate CM
Factory --&amp;gt; AC: shared_ptr&amp;lt;ConcurrencyMgr&amp;gt;
deactivate Factory
&amp;#39; 1.2 初始化 ConcurrencyMgr
AC -&amp;gt; CM: **Init(buffer_allocator, ...)**
activate CM
== 阶段 2: SDM 核心环境初始化 ==
CM -&amp;gt; CM: InitSubModules()
&amp;#39; 2.1 创建 CoreImpl
CM -&amp;gt; CoreStatic: **CreateCore(...)**
activate CoreStatic
create Core
CoreStatic -&amp;gt; Core: new CoreImpl(...)
Core -&amp;gt; Core: Init()
&amp;#39; 2.2 加载硬件信息 (DRM Capability)
Core -&amp;gt; HWInfo: Create(&amp;amp;hw_info_intf)
activate HWInfo
HWInfo -&amp;gt; HWInfo: Open DRM / Get Caps
HWInfo --&amp;gt; Core: Success
deactivate HWInfo
Core --&amp;gt; CoreStatic: Success
CoreStatic --&amp;gt; CM: core_intf_
deactivate CoreStatic
&amp;#39; 2.3 创建 Builder
create Builder
CM -&amp;gt; Builder: new SDMDisplayBuilder(core_intf_, ...)
CM -&amp;gt; Builder: Init()
== 阶段 3: 创建主显示设备 (Primary Display) ==
CM -&amp;gt; CM: CreatePrimaryDisplay()
CM -&amp;gt; Builder: **CreatePrimaryDisplay()**
activate Builder
&amp;#39; 3.1 查询连接状态
Builder -&amp;gt; Core: GetDisplaysStatus()
Core -&amp;gt; HWInfo: GetDisplaysStatus()
HWInfo --&amp;gt; Core: HWDisplaysInfo (is_connected=true, type=BuiltIn)
Core --&amp;gt; Builder: HWDisplaysInfo
&amp;#39; 3.2 发现 Primary BuiltIn Display，开始构建
create DBI
Builder -&amp;gt; DBI: **Create(...)**
activate DBI
DBI -&amp;gt; DBI: Init()
&amp;#39; 3.3 创建 DPU Mux (处理多核/Split)
&amp;#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息
create Mux
DBI -&amp;gt; Mux: **DPUCoreFactory::Create(...)**
activate Mux
Mux -&amp;gt; Mux: Init()
&amp;#39; 3.4 创建底层 HW Interface
loop For Each DPU Core
Mux -&amp;gt; HWFactory: **HWInterface::Create(type=kBuiltIn)**
activate HWFactory
create HW
HWFactory -&amp;gt; HW: **new HWPeripheralDRM(...)**
activate HW
HWFactory -&amp;gt; HW: Init()
&amp;#39; 3.5 HW 初始化 (DRM Session)
HW -&amp;gt; HW: HWDeviceDRM::Init() (Register Display)
HW -&amp;gt; HW: PopulateHWPanelInfo() (Read Max Brightness)
HW --&amp;gt; HWFactory: Success
deactivate HW
HWFactory --&amp;gt; Mux: HWInterface*
deactivate HWFactory
end
Mux --&amp;gt; DBI: Success
deactivate Mux
DBI --&amp;gt; Builder: Display*
deactivate DBI
&amp;#39; 3.6 注册回 ConcurrencyMgr
Builder -&amp;gt; CM: SetDisplayByClientId(Primary, DBI*)
note right of CM: sdm_display_[0] = DBI
Builder --&amp;gt; CM: Success
deactivate Builder
CM --&amp;gt; AC: Success
deactivate CM
AC --&amp;gt; Main: Created
deactivate AC
Main -&amp;gt; Main: AServiceManager_addService(AidlComposer)
note right of Main: 服务就绪，等待 SurfaceFlinger 连接
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="关键步骤解析"&gt;关键步骤解析&lt;/h3&gt;
&lt;h4 id="1-唯一入口servicecpp"&gt;1. 唯一入口：&lt;code&gt;service.cpp&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 &lt;code&gt;AidlComposer&lt;/code&gt;。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。&lt;/p&gt;</description></item><item><title/><link>https://ethen-cao.github.io/ethenslab/android-dev/display/hwc_setbrightness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/hwc_setbrightness/</guid><description>&lt;div class="mermaid"&gt;graph TD
!theme plain
%% --- 定义样式 ---
classDef appLayer fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
classDef bufferLayer fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;
classDef sfLayer fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;
classDef halLayer fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;
classDef hwLayer fill:#eeeeee,stroke:#616161,stroke-width:2px;
classDef decisionNode fill:#ffccbc,stroke:#bf360c,stroke-width:2px,stroke-dasharray: 5 5;
%% --- 1. 应用层 (Producers) ---
subgraph AppLayer [应用层 (Producers)]
direction LR
App[App / Game]
SysUI[SystemUI / Launcher]
end
class App,SysUI appLayer;
%% --- 2. Buffer 传输层 ---
subgraph BufferLayer [Buffer 传输机制]
BQ[BufferQueue&lt;br/&gt;(Producer/Consumer)]
Gralloc[Gralloc&lt;br/&gt;(显存分配)]
end
class BQ,Gralloc bufferLayer;
%% --- 3. SurfaceFlinger 核心层 ---
subgraph SF_Core [SurfaceFlinger Native Process]
direction TB
Scheduler[Scheduler / VsyncModulator&lt;br/&gt;(心跳控制)]
SF_Main[SurfaceFlinger Main Thread&lt;br/&gt;(事务处理 &amp; 锁定图层)]
subgraph CE [CompositionEngine (合成引擎)]
Output[Output (Display)]
Planner[Planner / LayerStack]
Strategy[&lt;b&gt;chooseCompositionStrategy&lt;/b&gt;&lt;br/&gt;(决策中心)]
end
RE[RenderEngine&lt;br/&gt;(SkiaGL / SkiaVK / Graphite)]
end
class Scheduler,SF_Main,Output,Planner,RE sfLayer;
class Strategy decisionNode;
%% --- 4. HAL 硬件抽象层 ---
subgraph HAL [硬件抽象层 (HAL)]
HWC[HWComposer HAL&lt;br/&gt;(DRM/KMS)]
GPUDriver[GPU Driver&lt;br/&gt;(OpenGL/Vulkan)]
end
class HWC,GPUDriver halLayer;
%% --- 5. 硬件层 ---
subgraph Hardware [硬件层]
GPU_HW[GPU 硬件]
DPU_HW[DPU / Display Controller]
Panel[屏幕面板]
end
class GPU_HW,DPU_HW,Panel hwLayer;
%% --- 连接关系 ---
%% 生产阶段
App --&gt;|1. QueueBuffer| BQ
SysUI --&gt;|1. QueueBuffer| BQ
BQ -.-&gt;|指向| Gralloc
%% 触发阶段
Display_Vsync(硬件 Vsync) -.-&gt; Scheduler
Scheduler --&gt;|2. OnFrameSignal| SF_Main
%% 逻辑处理
SF_Main --&gt;|3. AcquireBuffer| BQ
SF_Main --&gt;|4. 调用| CE
CE --&gt;|5. prepareFrame| Output
Output --&gt; Planner
Planner --&gt; Strategy
%% 核心决策交互 (谈判)
Strategy --&gt;|6. ValidateDisplay (能处理吗?)| HWC
HWC --&gt;|7. 返回合成类型 (Client/Device)| Strategy
%% 执行路径 A: GPU 合成 (Client Composition)
Strategy --"8a. 需要 GPU 合成 (Client)"--&gt; RE
RE --&gt;|9. DrawLayers (Skia)| GPUDriver
GPUDriver --&gt; GPU_HW
GPU_HW --&gt;|10. 输出合成后的 Buffer| BQ_Target[Framebuffer Target]
BQ_Target --&gt; HWC
%% 执行路径 B: 硬件合成 (Device Composition)
Strategy --"8b. 纯硬件合成 (Device Overlay)"--&gt; HWC
%% 最终提交
HWC --&gt;|11. PresentDisplay (Atomic Commit)| DPU_HW
DPU_HW --&gt;|12. 扫描输出| Panel
&lt;/div&gt;&lt;h3 id="亮度调节失败引发surfaceflinger合成策略选择失败的时序图"&gt;亮度调节失败引发SurfaceFlinger合成策略选择失败的时序图&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme plain
&amp;#39; skinparam MaxMessageSize 300
skinparam participantPadding 10
skinparam boxPadding 10
skinparam defaultFontName Monospaced
autonumber &amp;#34;&amp;lt;b&amp;gt;[0]&amp;lt;/b&amp;gt;&amp;#34;
title 亮度设置失败导致合成策略中止的全链路时序图
box &amp;#34;SurfaceFlinger 进程&amp;#34; #lightgreen
participant &amp;#34;CompositionEngine&amp;#34; as CE
participant &amp;#34;HWComposer&amp;#34; as SF_HWC
participant &amp;#34;AidlComposer\n(HAL Client)&amp;#34; as Client
participant &amp;#34;ComposerClientWriter&amp;#34; as Writer
end box
box &amp;#34;HWC Service 进程 (Guest OS)&amp;#34; #LightGray
participant &amp;#34;AidlComposerClient\n(CommandEngine)&amp;#34; as Server
participant &amp;#34;ConcurrencyMgr\n(SettingsIntf)&amp;#34; as CM
participant &amp;#34;DisplayBuiltIn\n(SDM Logic)&amp;#34; as DBI
participant &amp;#34;DPUMultiCore\n(Mux)&amp;#34; as Mux
participant &amp;#34;HWPeripheralDRM\n(DAL)&amp;#34; as HW
end box
box &amp;#34;Kernel / FileSystem&amp;#34; #MistyRose
participant &amp;#34;/sys/class/backlight&amp;#34; as Sysfs
end box
== 阶段 0: 指令积压 (Client Side Batching) ==
note right of CE: SurfaceFlinger 在之前的逻辑中\n调用了 setDisplayBrightness
CE -&amp;gt; SF_HWC: setDisplayBrightness(...)
SF_HWC -&amp;gt; Client: setDisplayBrightness(...)
Client -&amp;gt; Writer: 写入指令到 Command Queue
note right of Writer: 此时 Command Index 0 缓存了:\n1. OP: SetBrightness\n(尚未发送)
== 阶段 1: 触发策略选择 (Frame Start) ==
CE -&amp;gt; CE: **chooseCompositionStrategy()**
CE -&amp;gt; SF_HWC: getDeviceCompositionChanges()
SF_HWC -&amp;gt; SF_HWC: check canSkipValidate (True)
SF_HWC -&amp;gt; Client: presentOrValidateDisplay()
note right of Writer: 将 Validate 指令追加到 Command Queue (Index 0)\n现在 Index 0 包含: [SetBrightness, PresentOrValidate]
Client -&amp;gt; Server: **executeCommands()** (Binder IPC)
activate Server
== 阶段 2: 服务端执行 (The Root Cause) ==
Server -&amp;gt; Server: 解析 Command Queue\n初始化 mCommandIndex = 0
group #MistyRose HWC 服务端循环 [处理 Index 0]
&amp;#39; --- 步骤 A: 亮度设置 ---
note right of Server: **步骤 A: 优先执行亮度设置**
Server -&amp;gt; CM: SetDisplayBrightness(level)
CM -&amp;gt; DBI: SetPanelBrightness(brightness)
note right of DBI: 转换 float 为 int level
DBI -&amp;gt; Mux: SetPanelBrightness(level)
Mux -&amp;gt; HW: SetPanelBrightness(level)
activate HW
HW -&amp;gt; HW: 检查 enable_brightness_drm_prop
note right of HW: 属性未开启(false)，走 Sysfs 路径
HW -&amp;gt; Sysfs: open(&amp;#34;.../panel0-backlight/brightness&amp;#34;)
Sysfs --&amp;gt; HW: &amp;lt;color:red&amp;gt;❌ 失败 (ENOENT / No such file)&amp;lt;/color&amp;gt;
note right of HW
**故障点**: 虚拟化环境中 Guest OS
看不到物理背光节点
end note
HW --&amp;gt; Mux: 返回 kErrorFileDescriptor
deactivate HW
Mux --&amp;gt; DBI: 返回 Error
DBI --&amp;gt; CM: 返回 Error
CM --&amp;gt; Server: 返回 Error (kErrorBadConfig)
Server -&amp;gt; Server: writeError(Index=0, BadConfig)
note right of Server: &amp;lt;font color=red&amp;gt;&amp;lt;b&amp;gt;[Log 1] W SDM : executeSetDisplayBrightness...&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;\n记录错误，但**不中断**循环
&amp;#39; --- 步骤 B: 验证 ---
note right of Server: **步骤 B: 执行合成验证**
Server -&amp;gt; CM: CommitOrPrepare(...)
activate CM
CM --&amp;gt; Server: &amp;lt;font color=green&amp;gt;✅ 成功 (kErrorNone)&amp;lt;/font&amp;gt;
deactivate CM
Server -&amp;gt; Server: setPresentOrValidateResult(Validated)
end
Server --&amp;gt; Client: 返回 Binder Status OK\n数据包包含:\n1. ErrorList: [{Index:0, Err:BadConfig}]\n2. ResultList: [{Index:0, Validated}]
deactivate Server
== 阶段 3: 客户端误判 (The Misjudgment) ==
Client -&amp;gt; Client: 解析返回数据
group 客户端判决逻辑 [AidlComposer::execute]
Client -&amp;gt; Client: 检查 Index 0
note right of Client
**&amp;lt;color:red&amp;gt;致命误判逻辑&amp;lt;/color&amp;gt;**:
1. 发现 Index 0 有 Error (实际源自亮度)
2. 发现 Index 0 包含 Validate 指令
3. **判定: 整个 Validate 失败**
end note
Client --&amp;gt; SF_HWC: 返回 **Error::BAD_CONFIG**
end
== 阶段 4: 策略中止 (Abort) ==
SF_HWC -&amp;gt; SF_HWC: RETURN_IF_HWC_ERROR_FOR(...)
note right of SF_HWC: &amp;lt;font color=red&amp;gt;&amp;lt;b&amp;gt;[Log 2] E HWComposer : getDeviceCompositionChanges... failed...&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;
SF_HWC --&amp;gt; CE: 返回 **UNKNOWN_ERROR** (-2147483648)
CE -&amp;gt; CE: if (result != NO_ERROR)
note right of CE: &amp;lt;font color=red&amp;gt;&amp;lt;b&amp;gt;[Log 3] E CompositionEngine : chooseCompositionStrategy failed...&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;
CE -&amp;gt; CE: return false
note right of CE: **放弃当前帧合成**\n(SurfaceFlinger 丢弃这一帧)
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id="详细说明为什么会失败"&gt;详细说明：为什么会失败&lt;/h3&gt;
&lt;h4 id="1-根本原因-root-cause"&gt;1. 根本原因 (Root Cause)&lt;/h4&gt;
&lt;p&gt;故障发生在 &lt;strong&gt;阶段 2&lt;/strong&gt; 的底层 &lt;code&gt;HWPeripheralDRM&lt;/code&gt; 中。&lt;/p&gt;</description></item></channel></rss>