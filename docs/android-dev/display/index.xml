<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Display Manager on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/</link><description>Recent content in Display Manager on Ethen 的实验室</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Mon, 29 Sep 2025 10:22:54 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/display/index.xml" rel="self" type="application/rss+xml"/><item><title>DisplayManagerService设计</title><link>https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/</guid><description>&lt;h2 id="logicaldisplay的创建过程"&gt;LogicalDisplay的创建过程&lt;/h2&gt;
&lt;p&gt;这个时序图展示了从底层物理屏幕发现到上层窗口管理容器创建的完整链路。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/android-13-LogicalDisplay-creating-sequence.png" alt="" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初始化阶段&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 启动，在 &lt;code&gt;onStart&lt;/code&gt; 方法中发送 &lt;code&gt;MSG_REGISTER_DEFAULT_DISPLAY_ADAPTERS&lt;/code&gt; 消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 的 Handler 处理该消息，调用 &lt;code&gt;registerDefaultDisplayAdapters&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;registerDefaultDisplayAdapters&lt;/code&gt; 中，创建 &lt;code&gt;LocalDisplayAdapter&lt;/code&gt; 实例并注册。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LocalDisplayAdapter 发现设备&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LocalDisplayAdapter&lt;/code&gt; 初始化时会从 &lt;code&gt;SurfaceControl&lt;/code&gt; 获取物理屏幕信息（通过 &lt;code&gt;SurfaceControlProxy&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;发现物理屏幕后，创建 &lt;code&gt;LocalDisplayDevice&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;sendDisplayDeviceEventLocked&lt;/code&gt; 发送 &lt;code&gt;DISPLAY_DEVICE_EVENT_ADDED&lt;/code&gt; 事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DisplayDeviceRepository 处理事件&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DisplayAdapter&lt;/code&gt; 将事件发送给 &lt;code&gt;DisplayDeviceRepository&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayDeviceRepository&lt;/code&gt; 将 &lt;code&gt;LocalDisplayDevice&lt;/code&gt; 添加到列表，并通知监听者，即 &lt;code&gt;LogicalDisplayMapper&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LogicalDisplayMapper 创建 LogicalDisplay&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LogicalDisplayMapper&lt;/code&gt; 收到 &lt;code&gt;DISPLAY_DEVICE_EVENT_ADDED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果是默认屏幕，先进行初始化配置。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;createNewLogicalDisplayLocked&lt;/code&gt; 创建 &lt;code&gt;LogicalDisplay&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;applyLayoutLocked&lt;/code&gt; 来根据设备状态配置布局。&lt;/li&gt;
&lt;li&gt;最后调用 &lt;code&gt;updateLogicalDisplaysLocked&lt;/code&gt; 来更新整个系统的显示状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通知系统和 WMS&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;updateLogicalDisplaysLocked&lt;/code&gt; 中，&lt;code&gt;LogicalDisplayMapper&lt;/code&gt; 通知 &lt;code&gt;DisplayManagerService&lt;/code&gt; (通过 &lt;code&gt;Listener&lt;/code&gt;) &lt;code&gt;LOGICAL_DISPLAY_EVENT_ADDED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 收到事件，调用 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 发送 &lt;code&gt;DisplayManagerGlobal.EVENT_DISPLAY_ADDED&lt;/code&gt; 到 Handler。&lt;/li&gt;
&lt;li&gt;Handler 处理消息，调用 &lt;code&gt;deliverDisplayEvent&lt;/code&gt; 通知所有注册的 &lt;code&gt;IDisplayManagerCallback&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键点&lt;/strong&gt;: &lt;code&gt;WindowManagerService&lt;/code&gt; 在初始化时通过 &lt;code&gt;DisplayManagerInternal&lt;/code&gt; 获取了 &lt;code&gt;DisplayManager&lt;/code&gt; 的回调或直接监听。但在代码中，WMS 实际上是通过 &lt;code&gt;DisplayManagerInternal.registerDisplayTransactionListener&lt;/code&gt; 或直接轮询/监听来感知的。&lt;/li&gt;
&lt;li&gt;更具体的路径是：&lt;code&gt;DisplayManagerService&lt;/code&gt; 在 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt; 中会配置显示属性，并最终触发 &lt;code&gt;DisplayTransactionListener&lt;/code&gt; 或发送广播。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;WindowManagerService&lt;/code&gt; 中，通常通过 &lt;code&gt;DisplayManager&lt;/code&gt; 的回调 &lt;code&gt;onDisplayAdded&lt;/code&gt; 感知，然后调用 &lt;code&gt;mRoot.createDisplayContent&lt;/code&gt;。在提供的代码中，&lt;code&gt;DisplayManagerService&lt;/code&gt; 拥有 &lt;code&gt;mDisplayTransactionListeners&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayManagerService&lt;/code&gt; 的 &lt;code&gt;handleLogicalDisplayAddedLocked&lt;/code&gt; 会调用 &lt;code&gt;sendDisplayEventLocked&lt;/code&gt;，进而触发回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;补充：&lt;code&gt;WindowManagerService&lt;/code&gt; 如何创建 &lt;code&gt;DisplayContent&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>