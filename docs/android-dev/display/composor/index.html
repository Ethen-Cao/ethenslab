<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HWC简介 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：

服务启动与依赖注入：service.cpp 启动进程，创建 AIDL 服务实体。
SDM 环境初始化：ConcurrencyMgr 初始化，加载 Core 层和硬件信息。
Display 对象构建：DisplayBuilder 根据硬件信息创建具体的 DisplayBuiltIn 和 HWPeripheralDRM。

Qualcomm HWC 启动与 Display 创建全流程

  @startuml
!theme plain
skinparam MaxMessageSize 200
skinparam participantPadding 10
skinparam boxPadding 10
skinparam defaultFontName Monospaced
autonumber "<b>[Boot-0]</b>"

title HWC Service Startup & Display Creation Sequence (Final Fix)

box "Service Process Entry" #White
    participant "Main (service.cpp)" as Main
    participant "AidlComposer\n(BnComposer)" as AC
end box

box "SDM Client Layer" #LightYellow
    participant "SDMInterfaceFactory" as Factory
    participant "ConcurrencyMgr" as CM
    participant "SDMDisplayBuilder" as Builder
end box

box "SDM Core Layer" #LightGreen
    participant "CoreInterface" as CoreStatic
    participant "CoreImpl" as Core
    participant "DisplayBuiltIn" as DBI
    participant "DPUMultiCore\n(Mux)" as Mux
end box

box "Device Abstraction Layer (DAL)" #LightGray
    participant "HWInfoInterface" as HWInfo
    participant "HWInterface\n(Factory)" as HWFactory
    participant "HWPeripheralDRM" as HW
end box

== 阶段 1: 服务启动与接口绑定 ==
Main -> Main: setpriority / sched_setscheduler
create AC
Main -> AC: **new AidlComposer()**
activate AC

    &#39; 1.1 创建核心管理对象 ConcurrencyMgr
    AC -> Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ...
    activate Factory
    Factory -> CM: **GetInstance()** (Singleton)
    activate CM
    CM --> Factory: instance
    deactivate CM
    Factory --> AC: shared_ptr<ConcurrencyMgr>
    deactivate Factory

    &#39; 1.2 初始化 ConcurrencyMgr
    AC -> CM: **Init(buffer_allocator, ...)**
    activate CM

== 阶段 2: SDM 核心环境初始化 ==
        CM -> CM: InitSubModules()
        
        &#39; 2.1 创建 CoreImpl
        CM -> CoreStatic: **CreateCore(...)**
        activate CoreStatic
        create Core
        CoreStatic -> Core: new CoreImpl(...)
        Core -> Core: Init()
        
        &#39; 2.2 加载硬件信息 (DRM Capability)
        Core -> HWInfo: Create(&amp;hw_info_intf)
        activate HWInfo
        HWInfo -> HWInfo: Open DRM / Get Caps
        HWInfo --> Core: Success
        deactivate HWInfo
        
        Core --> CoreStatic: Success
        CoreStatic --> CM: core_intf_
        deactivate CoreStatic

        &#39; 2.3 创建 Builder
        create Builder
        CM -> Builder: new SDMDisplayBuilder(core_intf_, ...)
        CM -> Builder: Init()

== 阶段 3: 创建主显示设备 (Primary Display) ==
        CM -> CM: CreatePrimaryDisplay()
        CM -> Builder: **CreatePrimaryDisplay()**
        activate Builder
        
        &#39; 3.1 查询连接状态
        Builder -> Core: GetDisplaysStatus()
        Core -> HWInfo: GetDisplaysStatus()
        HWInfo --> Core: HWDisplaysInfo (is_connected=true, type=BuiltIn)
        Core --> Builder: HWDisplaysInfo
        
        &#39; 3.2 发现 Primary BuiltIn Display，开始构建
        create DBI
        Builder -> DBI: **Create(...)**
        activate DBI
        
        DBI -> DBI: Init()
        
            &#39; 3.3 创建 DPU Mux (处理多核/Split)
            &#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息
            create Mux
            DBI -> Mux: **DPUCoreFactory::Create(...)**
            activate Mux
            
            Mux -> Mux: Init()
            
                &#39; 3.4 创建底层 HW Interface
                loop For Each DPU Core
                    Mux -> HWFactory: **HWInterface::Create(type=kBuiltIn)**
                    activate HWFactory
                    
                    create HW
                    HWFactory -> HW: **new HWPeripheralDRM(...)**
                    activate HW
                    HWFactory -> HW: Init()
                    
                    &#39; 3.5 HW 初始化 (DRM Session)
                    HW -> HW: HWDeviceDRM::Init() (Register Display)
                    HW -> HW: PopulateHWPanelInfo() (Read Max Brightness)
                    
                    HW --> HWFactory: Success
                    deactivate HW
                    
                    HWFactory --> Mux: HWInterface*
                    deactivate HWFactory
                end
            
            Mux --> DBI: Success
            deactivate Mux
            
        DBI --> Builder: Display*
        deactivate DBI
        
        &#39; 3.6 注册回 ConcurrencyMgr
        Builder -> CM: SetDisplayByClientId(Primary, DBI*)
        note right of CM: sdm_display_[0] = DBI
        
        Builder --> CM: Success
        deactivate Builder
        
    CM --> AC: Success
    deactivate CM

AC --> Main: Created
deactivate AC

Main -> Main: AServiceManager_addService(AidlComposer)
note right of Main: 服务就绪，等待 SurfaceFlinger 连接

@enduml
关键步骤解析
1. 唯一入口：service.cpp
这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 AidlComposer。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/display/composor/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/display/composor/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/display/composor/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="HWC简介"><meta property="og:description" content='HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：
服务启动与依赖注入：service.cpp 启动进程，创建 AIDL 服务实体。 SDM 环境初始化：ConcurrencyMgr 初始化，加载 Core 层和硬件信息。 Display 对象构建：DisplayBuilder 根据硬件信息创建具体的 DisplayBuiltIn 和 HWPeripheralDRM。 Qualcomm HWC 启动与 Display 创建全流程 @startuml !theme plain skinparam MaxMessageSize 200 skinparam participantPadding 10 skinparam boxPadding 10 skinparam defaultFontName Monospaced autonumber "<b>[Boot-0]</b>" title HWC Service Startup & Display Creation Sequence (Final Fix) box "Service Process Entry" #White participant "Main (service.cpp)" as Main participant "AidlComposer\n(BnComposer)" as AC end box box "SDM Client Layer" #LightYellow participant "SDMInterfaceFactory" as Factory participant "ConcurrencyMgr" as CM participant "SDMDisplayBuilder" as Builder end box box "SDM Core Layer" #LightGreen participant "CoreInterface" as CoreStatic participant "CoreImpl" as Core participant "DisplayBuiltIn" as DBI participant "DPUMultiCore\n(Mux)" as Mux end box box "Device Abstraction Layer (DAL)" #LightGray participant "HWInfoInterface" as HWInfo participant "HWInterface\n(Factory)" as HWFactory participant "HWPeripheralDRM" as HW end box == 阶段 1: 服务启动与接口绑定 == Main -> Main: setpriority / sched_setscheduler create AC Main -> AC: **new AidlComposer()** activate AC &#39; 1.1 创建核心管理对象 ConcurrencyMgr AC -> Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ... activate Factory Factory -> CM: **GetInstance()** (Singleton) activate CM CM --> Factory: instance deactivate CM Factory --> AC: shared_ptr<ConcurrencyMgr> deactivate Factory &#39; 1.2 初始化 ConcurrencyMgr AC -> CM: **Init(buffer_allocator, ...)** activate CM == 阶段 2: SDM 核心环境初始化 == CM -> CM: InitSubModules() &#39; 2.1 创建 CoreImpl CM -> CoreStatic: **CreateCore(...)** activate CoreStatic create Core CoreStatic -> Core: new CoreImpl(...) Core -> Core: Init() &#39; 2.2 加载硬件信息 (DRM Capability) Core -> HWInfo: Create(&amp;hw_info_intf) activate HWInfo HWInfo -> HWInfo: Open DRM / Get Caps HWInfo --> Core: Success deactivate HWInfo Core --> CoreStatic: Success CoreStatic --> CM: core_intf_ deactivate CoreStatic &#39; 2.3 创建 Builder create Builder CM -> Builder: new SDMDisplayBuilder(core_intf_, ...) CM -> Builder: Init() == 阶段 3: 创建主显示设备 (Primary Display) == CM -> CM: CreatePrimaryDisplay() CM -> Builder: **CreatePrimaryDisplay()** activate Builder &#39; 3.1 查询连接状态 Builder -> Core: GetDisplaysStatus() Core -> HWInfo: GetDisplaysStatus() HWInfo --> Core: HWDisplaysInfo (is_connected=true, type=BuiltIn) Core --> Builder: HWDisplaysInfo &#39; 3.2 发现 Primary BuiltIn Display，开始构建 create DBI Builder -> DBI: **Create(...)** activate DBI DBI -> DBI: Init() &#39; 3.3 创建 DPU Mux (处理多核/Split) &#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息 create Mux DBI -> Mux: **DPUCoreFactory::Create(...)** activate Mux Mux -> Mux: Init() &#39; 3.4 创建底层 HW Interface loop For Each DPU Core Mux -> HWFactory: **HWInterface::Create(type=kBuiltIn)** activate HWFactory create HW HWFactory -> HW: **new HWPeripheralDRM(...)** activate HW HWFactory -> HW: Init() &#39; 3.5 HW 初始化 (DRM Session) HW -> HW: HWDeviceDRM::Init() (Register Display) HW -> HW: PopulateHWPanelInfo() (Read Max Brightness) HW --> HWFactory: Success deactivate HW HWFactory --> Mux: HWInterface* deactivate HWFactory end Mux --> DBI: Success deactivate Mux DBI --> Builder: Display* deactivate DBI &#39; 3.6 注册回 ConcurrencyMgr Builder -> CM: SetDisplayByClientId(Primary, DBI*) note right of CM: sdm_display_[0] = DBI Builder --> CM: Success deactivate Builder CM --> AC: Success deactivate CM AC --> Main: Created deactivate AC Main -> Main: AServiceManager_addService(AidlComposer) note right of Main: 服务就绪，等待 SurfaceFlinger 连接 @enduml 关键步骤解析 1. 唯一入口：service.cpp 这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 AidlComposer。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T10:22:54+08:00"><meta property="article:modified_time" content="2025-09-29T10:22:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="HWC简介"><meta name=twitter:description content='HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：

服务启动与依赖注入：service.cpp 启动进程，创建 AIDL 服务实体。
SDM 环境初始化：ConcurrencyMgr 初始化，加载 Core 层和硬件信息。
Display 对象构建：DisplayBuilder 根据硬件信息创建具体的 DisplayBuiltIn 和 HWPeripheralDRM。

Qualcomm HWC 启动与 Display 创建全流程

  @startuml
!theme plain
skinparam MaxMessageSize 200
skinparam participantPadding 10
skinparam boxPadding 10
skinparam defaultFontName Monospaced
autonumber "<b>[Boot-0]</b>"

title HWC Service Startup & Display Creation Sequence (Final Fix)

box "Service Process Entry" #White
    participant "Main (service.cpp)" as Main
    participant "AidlComposer\n(BnComposer)" as AC
end box

box "SDM Client Layer" #LightYellow
    participant "SDMInterfaceFactory" as Factory
    participant "ConcurrencyMgr" as CM
    participant "SDMDisplayBuilder" as Builder
end box

box "SDM Core Layer" #LightGreen
    participant "CoreInterface" as CoreStatic
    participant "CoreImpl" as Core
    participant "DisplayBuiltIn" as DBI
    participant "DPUMultiCore\n(Mux)" as Mux
end box

box "Device Abstraction Layer (DAL)" #LightGray
    participant "HWInfoInterface" as HWInfo
    participant "HWInterface\n(Factory)" as HWFactory
    participant "HWPeripheralDRM" as HW
end box

== 阶段 1: 服务启动与接口绑定 ==
Main -> Main: setpriority / sched_setscheduler
create AC
Main -> AC: **new AidlComposer()**
activate AC

    &#39; 1.1 创建核心管理对象 ConcurrencyMgr
    AC -> Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ...
    activate Factory
    Factory -> CM: **GetInstance()** (Singleton)
    activate CM
    CM --> Factory: instance
    deactivate CM
    Factory --> AC: shared_ptr<ConcurrencyMgr>
    deactivate Factory

    &#39; 1.2 初始化 ConcurrencyMgr
    AC -> CM: **Init(buffer_allocator, ...)**
    activate CM

== 阶段 2: SDM 核心环境初始化 ==
        CM -> CM: InitSubModules()
        
        &#39; 2.1 创建 CoreImpl
        CM -> CoreStatic: **CreateCore(...)**
        activate CoreStatic
        create Core
        CoreStatic -> Core: new CoreImpl(...)
        Core -> Core: Init()
        
        &#39; 2.2 加载硬件信息 (DRM Capability)
        Core -> HWInfo: Create(&amp;hw_info_intf)
        activate HWInfo
        HWInfo -> HWInfo: Open DRM / Get Caps
        HWInfo --> Core: Success
        deactivate HWInfo
        
        Core --> CoreStatic: Success
        CoreStatic --> CM: core_intf_
        deactivate CoreStatic

        &#39; 2.3 创建 Builder
        create Builder
        CM -> Builder: new SDMDisplayBuilder(core_intf_, ...)
        CM -> Builder: Init()

== 阶段 3: 创建主显示设备 (Primary Display) ==
        CM -> CM: CreatePrimaryDisplay()
        CM -> Builder: **CreatePrimaryDisplay()**
        activate Builder
        
        &#39; 3.1 查询连接状态
        Builder -> Core: GetDisplaysStatus()
        Core -> HWInfo: GetDisplaysStatus()
        HWInfo --> Core: HWDisplaysInfo (is_connected=true, type=BuiltIn)
        Core --> Builder: HWDisplaysInfo
        
        &#39; 3.2 发现 Primary BuiltIn Display，开始构建
        create DBI
        Builder -> DBI: **Create(...)**
        activate DBI
        
        DBI -> DBI: Init()
        
            &#39; 3.3 创建 DPU Mux (处理多核/Split)
            &#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息
            create Mux
            DBI -> Mux: **DPUCoreFactory::Create(...)**
            activate Mux
            
            Mux -> Mux: Init()
            
                &#39; 3.4 创建底层 HW Interface
                loop For Each DPU Core
                    Mux -> HWFactory: **HWInterface::Create(type=kBuiltIn)**
                    activate HWFactory
                    
                    create HW
                    HWFactory -> HW: **new HWPeripheralDRM(...)**
                    activate HW
                    HWFactory -> HW: Init()
                    
                    &#39; 3.5 HW 初始化 (DRM Session)
                    HW -> HW: HWDeviceDRM::Init() (Register Display)
                    HW -> HW: PopulateHWPanelInfo() (Read Max Brightness)
                    
                    HW --> HWFactory: Success
                    deactivate HW
                    
                    HWFactory --> Mux: HWInterface*
                    deactivate HWFactory
                end
            
            Mux --> DBI: Success
            deactivate Mux
            
        DBI --> Builder: Display*
        deactivate DBI
        
        &#39; 3.6 注册回 ConcurrencyMgr
        Builder -> CM: SetDisplayByClientId(Primary, DBI*)
        note right of CM: sdm_display_[0] = DBI
        
        Builder --> CM: Success
        deactivate Builder
        
    CM --> AC: Success
    deactivate CM

AC --> Main: Created
deactivate AC

Main -> Main: AServiceManager_addService(AidlComposer)
note right of Main: 服务就绪，等待 SurfaceFlinger 连接

@enduml
关键步骤解析
1. 唯一入口：service.cpp
这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 AidlComposer。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"Display Manager","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/"},{"@type":"ListItem","position":3,"name":"HWC简介","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/composor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HWC简介","name":"HWC简介","description":"HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：\n服务启动与依赖注入：service.cpp 启动进程，创建 AIDL 服务实体。 SDM 环境初始化：ConcurrencyMgr 初始化，加载 Core 层和硬件信息。 Display 对象构建：DisplayBuilder 根据硬件信息创建具体的 DisplayBuiltIn 和 HWPeripheralDRM。 Qualcomm HWC 启动与 Display 创建全流程 @startuml !theme plain skinparam MaxMessageSize 200 skinparam participantPadding 10 skinparam boxPadding 10 skinparam defaultFontName Monospaced autonumber \u0026#34;\u0026lt;b\u0026gt;[Boot-0]\u0026lt;/b\u0026gt;\u0026#34; title HWC Service Startup \u0026amp; Display Creation Sequence (Final Fix) box \u0026#34;Service Process Entry\u0026#34; #White participant \u0026#34;Main (service.cpp)\u0026#34; as Main participant \u0026#34;AidlComposer\\n(BnComposer)\u0026#34; as AC end box box \u0026#34;SDM Client Layer\u0026#34; #LightYellow participant \u0026#34;SDMInterfaceFactory\u0026#34; as Factory participant \u0026#34;ConcurrencyMgr\u0026#34; as CM participant \u0026#34;SDMDisplayBuilder\u0026#34; as Builder end box box \u0026#34;SDM Core Layer\u0026#34; #LightGreen participant \u0026#34;CoreInterface\u0026#34; as CoreStatic participant \u0026#34;CoreImpl\u0026#34; as Core participant \u0026#34;DisplayBuiltIn\u0026#34; as DBI participant \u0026#34;DPUMultiCore\\n(Mux)\u0026#34; as Mux end box box \u0026#34;Device Abstraction Layer (DAL)\u0026#34; #LightGray participant \u0026#34;HWInfoInterface\u0026#34; as HWInfo participant \u0026#34;HWInterface\\n(Factory)\u0026#34; as HWFactory participant \u0026#34;HWPeripheralDRM\u0026#34; as HW end box == 阶段 1: 服务启动与接口绑定 == Main -\u0026gt; Main: setpriority / sched_setscheduler create AC Main -\u0026gt; AC: **new AidlComposer()** activate AC \u0026#39; 1.1 创建核心管理对象 ConcurrencyMgr AC -\u0026gt; Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ... activate Factory Factory -\u0026gt; CM: **GetInstance()** (Singleton) activate CM CM --\u0026gt; Factory: instance deactivate CM Factory --\u0026gt; AC: shared_ptr\u0026lt;ConcurrencyMgr\u0026gt; deactivate Factory \u0026#39; 1.2 初始化 ConcurrencyMgr AC -\u0026gt; CM: **Init(buffer_allocator, ...)** activate CM == 阶段 2: SDM 核心环境初始化 == CM -\u0026gt; CM: InitSubModules() \u0026#39; 2.1 创建 CoreImpl CM -\u0026gt; CoreStatic: **CreateCore(...)** activate CoreStatic create Core CoreStatic -\u0026gt; Core: new CoreImpl(...) Core -\u0026gt; Core: Init() \u0026#39; 2.2 加载硬件信息 (DRM Capability) Core -\u0026gt; HWInfo: Create(\u0026amp;hw_info_intf) activate HWInfo HWInfo -\u0026gt; HWInfo: Open DRM / Get Caps HWInfo --\u0026gt; Core: Success deactivate HWInfo Core --\u0026gt; CoreStatic: Success CoreStatic --\u0026gt; CM: core_intf_ deactivate CoreStatic \u0026#39; 2.3 创建 Builder create Builder CM -\u0026gt; Builder: new SDMDisplayBuilder(core_intf_, ...) CM -\u0026gt; Builder: Init() == 阶段 3: 创建主显示设备 (Primary Display) == CM -\u0026gt; CM: CreatePrimaryDisplay() CM -\u0026gt; Builder: **CreatePrimaryDisplay()** activate Builder \u0026#39; 3.1 查询连接状态 Builder -\u0026gt; Core: GetDisplaysStatus() Core -\u0026gt; HWInfo: GetDisplaysStatus() HWInfo --\u0026gt; Core: HWDisplaysInfo (is_connected=true, type=BuiltIn) Core --\u0026gt; Builder: HWDisplaysInfo \u0026#39; 3.2 发现 Primary BuiltIn Display，开始构建 create DBI Builder -\u0026gt; DBI: **Create(...)** activate DBI DBI -\u0026gt; DBI: Init() \u0026#39; 3.3 创建 DPU Mux (处理多核/Split) \u0026#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息 create Mux DBI -\u0026gt; Mux: **DPUCoreFactory::Create(...)** activate Mux Mux -\u0026gt; Mux: Init() \u0026#39; 3.4 创建底层 HW Interface loop For Each DPU Core Mux -\u0026gt; HWFactory: **HWInterface::Create(type=kBuiltIn)** activate HWFactory create HW HWFactory -\u0026gt; HW: **new HWPeripheralDRM(...)** activate HW HWFactory -\u0026gt; HW: Init() \u0026#39; 3.5 HW 初始化 (DRM Session) HW -\u0026gt; HW: HWDeviceDRM::Init() (Register Display) HW -\u0026gt; HW: PopulateHWPanelInfo() (Read Max Brightness) HW --\u0026gt; HWFactory: Success deactivate HW HWFactory --\u0026gt; Mux: HWInterface* deactivate HWFactory end Mux --\u0026gt; DBI: Success deactivate Mux DBI --\u0026gt; Builder: Display* deactivate DBI \u0026#39; 3.6 注册回 ConcurrencyMgr Builder -\u0026gt; CM: SetDisplayByClientId(Primary, DBI*) note right of CM: sdm_display_[0] = DBI Builder --\u0026gt; CM: Success deactivate Builder CM --\u0026gt; AC: Success deactivate CM AC --\u0026gt; Main: Created deactivate AC Main -\u0026gt; Main: AServiceManager_addService(AidlComposer) note right of Main: 服务就绪，等待 SurfaceFlinger 连接 @enduml 关键步骤解析 1. 唯一入口：service.cpp 这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 AidlComposer。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。\n","keywords":[],"articleBody":"HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：\n服务启动与依赖注入：service.cpp 启动进程，创建 AIDL 服务实体。 SDM 环境初始化：ConcurrencyMgr 初始化，加载 Core 层和硬件信息。 Display 对象构建：DisplayBuilder 根据硬件信息创建具体的 DisplayBuiltIn 和 HWPeripheralDRM。 Qualcomm HWC 启动与 Display 创建全流程 @startuml !theme plain skinparam MaxMessageSize 200 skinparam participantPadding 10 skinparam boxPadding 10 skinparam defaultFontName Monospaced autonumber \"[Boot-0]\" title HWC Service Startup \u0026 Display Creation Sequence (Final Fix) box \"Service Process Entry\" #White participant \"Main (service.cpp)\" as Main participant \"AidlComposer\\n(BnComposer)\" as AC end box box \"SDM Client Layer\" #LightYellow participant \"SDMInterfaceFactory\" as Factory participant \"ConcurrencyMgr\" as CM participant \"SDMDisplayBuilder\" as Builder end box box \"SDM Core Layer\" #LightGreen participant \"CoreInterface\" as CoreStatic participant \"CoreImpl\" as Core participant \"DisplayBuiltIn\" as DBI participant \"DPUMultiCore\\n(Mux)\" as Mux end box box \"Device Abstraction Layer (DAL)\" #LightGray participant \"HWInfoInterface\" as HWInfo participant \"HWInterface\\n(Factory)\" as HWFactory participant \"HWPeripheralDRM\" as HW end box == 阶段 1: 服务启动与接口绑定 == Main -\u003e Main: setpriority / sched_setscheduler create AC Main -\u003e AC: **new AidlComposer()** activate AC ' 1.1 创建核心管理对象 ConcurrencyMgr AC -\u003e Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ... activate Factory Factory -\u003e CM: **GetInstance()** (Singleton) activate CM CM --\u003e Factory: instance deactivate CM Factory --\u003e AC: shared_ptr deactivate Factory ' 1.2 初始化 ConcurrencyMgr AC -\u003e CM: **Init(buffer_allocator, ...)** activate CM == 阶段 2: SDM 核心环境初始化 == CM -\u003e CM: InitSubModules() ' 2.1 创建 CoreImpl CM -\u003e CoreStatic: **CreateCore(...)** activate CoreStatic create Core CoreStatic -\u003e Core: new CoreImpl(...) Core -\u003e Core: Init() ' 2.2 加载硬件信息 (DRM Capability) Core -\u003e HWInfo: Create(\u0026hw_info_intf) activate HWInfo HWInfo -\u003e HWInfo: Open DRM / Get Caps HWInfo --\u003e Core: Success deactivate HWInfo Core --\u003e CoreStatic: Success CoreStatic --\u003e CM: core_intf_ deactivate CoreStatic ' 2.3 创建 Builder create Builder CM -\u003e Builder: new SDMDisplayBuilder(core_intf_, ...) CM -\u003e Builder: Init() == 阶段 3: 创建主显示设备 (Primary Display) == CM -\u003e CM: CreatePrimaryDisplay() CM -\u003e Builder: **CreatePrimaryDisplay()** activate Builder ' 3.1 查询连接状态 Builder -\u003e Core: GetDisplaysStatus() Core -\u003e HWInfo: GetDisplaysStatus() HWInfo --\u003e Core: HWDisplaysInfo (is_connected=true, type=BuiltIn) Core --\u003e Builder: HWDisplaysInfo ' 3.2 发现 Primary BuiltIn Display，开始构建 create DBI Builder -\u003e DBI: **Create(...)** activate DBI DBI -\u003e DBI: Init() ' 3.3 创建 DPU Mux (处理多核/Split) ' [修复点] create Mux 必须紧邻发送给 Mux 的消息 create Mux DBI -\u003e Mux: **DPUCoreFactory::Create(...)** activate Mux Mux -\u003e Mux: Init() ' 3.4 创建底层 HW Interface loop For Each DPU Core Mux -\u003e HWFactory: **HWInterface::Create(type=kBuiltIn)** activate HWFactory create HW HWFactory -\u003e HW: **new HWPeripheralDRM(...)** activate HW HWFactory -\u003e HW: Init() ' 3.5 HW 初始化 (DRM Session) HW -\u003e HW: HWDeviceDRM::Init() (Register Display) HW -\u003e HW: PopulateHWPanelInfo() (Read Max Brightness) HW --\u003e HWFactory: Success deactivate HW HWFactory --\u003e Mux: HWInterface* deactivate HWFactory end Mux --\u003e DBI: Success deactivate Mux DBI --\u003e Builder: Display* deactivate DBI ' 3.6 注册回 ConcurrencyMgr Builder -\u003e CM: SetDisplayByClientId(Primary, DBI*) note right of CM: sdm_display_[0] = DBI Builder --\u003e CM: Success deactivate Builder CM --\u003e AC: Success deactivate CM AC --\u003e Main: Created deactivate AC Main -\u003e Main: AServiceManager_addService(AidlComposer) note right of Main: 服务就绪，等待 SurfaceFlinger 连接 @enduml 关键步骤解析 1. 唯一入口：service.cpp 这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 AidlComposer。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。\n2. 隐藏的单例：ConcurrencyMgr AidlComposer 在构造时通过 SDMInterfaceFactory 获取了一堆接口（LifeCycle, Settings 等）。 关键点：这些接口的实现者全是同一个对象——ConcurrencyMgr。它是 SDM Client 层的“上帝对象”，如果不初始化它，整个显示系统就不会启动。\n3. 硬件扫描：HWInfoInterface 在创建任何 Display 对象之前，SDM 必须先知道底层有什么。 CoreImpl 初始化时会调用 HWInfoInterface 去扫描 DRM 节点（/dev/dri/card0），获取连接器列表、面板信息（是否有内屏、是否支持 HDR 等）。\n4. 工厂流水线：DisplayBuilder -\u003e DisplayBuiltIn -\u003e HWPeripheralDRM 这是对象创建的核心链条：\nBuilder: 拿到硬件列表，发现有一个主屏（Primary），于是决定造一个 DisplayBuiltIn。 Logic (BuiltIn): DisplayBuiltIn 初始化时，发现可能需要控制多个 DPU 核心（例如左右分屏），于是创建 DPUMultiCore。 Hardware (DAL): DPUMultiCore 最终请求创建一个硬件接口。因为类型是 kBuiltIn，工厂方法（hw_interface.cpp）毫不犹豫地创建了 HWPeripheralDRM。 5. 最终状态 当 service.cpp 执行到 addService 时：\n内存中已经存在了 HWPeripheralDRM 实例。 该实例已经尝试读取了 /sys/class/backlight/...（在 PopulateHWPanelInfo 阶段）。 如果是在虚拟化环境且没有适配，此时 brightness_base_path_ 可能已经包含了错误的路径，或者 max brightness 为 0，为后续的 BadConfig 埋下了伏笔。 ","wordCount":"558","inLanguage":"en","datePublished":"2025-09-29T10:22:54+08:00","dateModified":"2025-09-29T10:22:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/display/composor/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/display/>Display Manager</a></div><h1 class="post-title entry-hint-parent">HWC简介</h1><div class=post-meta><span title='2025-09-29 10:22:54 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;558 words</div></header><div class=post-content><p>HWC 服务启动到底层 Display 对象创建完成的完整时序,这个过程主要分为三个阶段：</p><ol><li><strong>服务启动与依赖注入</strong>：<code>service.cpp</code> 启动进程，创建 AIDL 服务实体。</li><li><strong>SDM 环境初始化</strong>：<code>ConcurrencyMgr</code> 初始化，加载 Core 层和硬件信息。</li><li><strong>Display 对象构建</strong>：<code>DisplayBuilder</code> 根据硬件信息创建具体的 <code>DisplayBuiltIn</code> 和 <code>HWPeripheralDRM</code>。</li></ol><h3 id=qualcomm-hwc-启动与-display-创建全流程>Qualcomm HWC 启动与 Display 创建全流程<a hidden class=anchor aria-hidden=true href=#qualcomm-hwc-启动与-display-创建全流程>#</a></h3><pre class=plantuml-container hidden>
  <code class=language-plantuml>@startuml
!theme plain
skinparam MaxMessageSize 200
skinparam participantPadding 10
skinparam boxPadding 10
skinparam defaultFontName Monospaced
autonumber &#34;&lt;b&gt;[Boot-0]&lt;/b&gt;&#34;

title HWC Service Startup &amp; Display Creation Sequence (Final Fix)

box &#34;Service Process Entry&#34; #White
    participant &#34;Main (service.cpp)&#34; as Main
    participant &#34;AidlComposer\n(BnComposer)&#34; as AC
end box

box &#34;SDM Client Layer&#34; #LightYellow
    participant &#34;SDMInterfaceFactory&#34; as Factory
    participant &#34;ConcurrencyMgr&#34; as CM
    participant &#34;SDMDisplayBuilder&#34; as Builder
end box

box &#34;SDM Core Layer&#34; #LightGreen
    participant &#34;CoreInterface&#34; as CoreStatic
    participant &#34;CoreImpl&#34; as Core
    participant &#34;DisplayBuiltIn&#34; as DBI
    participant &#34;DPUMultiCore\n(Mux)&#34; as Mux
end box

box &#34;Device Abstraction Layer (DAL)&#34; #LightGray
    participant &#34;HWInfoInterface&#34; as HWInfo
    participant &#34;HWInterface\n(Factory)&#34; as HWFactory
    participant &#34;HWPeripheralDRM&#34; as HW
end box

== 阶段 1: 服务启动与接口绑定 ==
Main -&gt; Main: setpriority / sched_setscheduler
create AC
Main -&gt; AC: **new AidlComposer()**
activate AC

    &#39; 1.1 创建核心管理对象 ConcurrencyMgr
    AC -&gt; Factory: CreateLifeCycleIntf() / CreateSettingsIntf() ...
    activate Factory
    Factory -&gt; CM: **GetInstance()** (Singleton)
    activate CM
    CM --&gt; Factory: instance
    deactivate CM
    Factory --&gt; AC: shared_ptr&lt;ConcurrencyMgr&gt;
    deactivate Factory

    &#39; 1.2 初始化 ConcurrencyMgr
    AC -&gt; CM: **Init(buffer_allocator, ...)**
    activate CM

== 阶段 2: SDM 核心环境初始化 ==
        CM -&gt; CM: InitSubModules()
        
        &#39; 2.1 创建 CoreImpl
        CM -&gt; CoreStatic: **CreateCore(...)**
        activate CoreStatic
        create Core
        CoreStatic -&gt; Core: new CoreImpl(...)
        Core -&gt; Core: Init()
        
        &#39; 2.2 加载硬件信息 (DRM Capability)
        Core -&gt; HWInfo: Create(&amp;hw_info_intf)
        activate HWInfo
        HWInfo -&gt; HWInfo: Open DRM / Get Caps
        HWInfo --&gt; Core: Success
        deactivate HWInfo
        
        Core --&gt; CoreStatic: Success
        CoreStatic --&gt; CM: core_intf_
        deactivate CoreStatic

        &#39; 2.3 创建 Builder
        create Builder
        CM -&gt; Builder: new SDMDisplayBuilder(core_intf_, ...)
        CM -&gt; Builder: Init()

== 阶段 3: 创建主显示设备 (Primary Display) ==
        CM -&gt; CM: CreatePrimaryDisplay()
        CM -&gt; Builder: **CreatePrimaryDisplay()**
        activate Builder
        
        &#39; 3.1 查询连接状态
        Builder -&gt; Core: GetDisplaysStatus()
        Core -&gt; HWInfo: GetDisplaysStatus()
        HWInfo --&gt; Core: HWDisplaysInfo (is_connected=true, type=BuiltIn)
        Core --&gt; Builder: HWDisplaysInfo
        
        &#39; 3.2 发现 Primary BuiltIn Display，开始构建
        create DBI
        Builder -&gt; DBI: **Create(...)**
        activate DBI
        
        DBI -&gt; DBI: Init()
        
            &#39; 3.3 创建 DPU Mux (处理多核/Split)
            &#39; [修复点] create Mux 必须紧邻发送给 Mux 的消息
            create Mux
            DBI -&gt; Mux: **DPUCoreFactory::Create(...)**
            activate Mux
            
            Mux -&gt; Mux: Init()
            
                &#39; 3.4 创建底层 HW Interface
                loop For Each DPU Core
                    Mux -&gt; HWFactory: **HWInterface::Create(type=kBuiltIn)**
                    activate HWFactory
                    
                    create HW
                    HWFactory -&gt; HW: **new HWPeripheralDRM(...)**
                    activate HW
                    HWFactory -&gt; HW: Init()
                    
                    &#39; 3.5 HW 初始化 (DRM Session)
                    HW -&gt; HW: HWDeviceDRM::Init() (Register Display)
                    HW -&gt; HW: PopulateHWPanelInfo() (Read Max Brightness)
                    
                    HW --&gt; HWFactory: Success
                    deactivate HW
                    
                    HWFactory --&gt; Mux: HWInterface*
                    deactivate HWFactory
                end
            
            Mux --&gt; DBI: Success
            deactivate Mux
            
        DBI --&gt; Builder: Display*
        deactivate DBI
        
        &#39; 3.6 注册回 ConcurrencyMgr
        Builder -&gt; CM: SetDisplayByClientId(Primary, DBI*)
        note right of CM: sdm_display_[0] = DBI
        
        Builder --&gt; CM: Success
        deactivate Builder
        
    CM --&gt; AC: Success
    deactivate CM

AC --&gt; Main: Created
deactivate AC

Main -&gt; Main: AServiceManager_addService(AidlComposer)
note right of Main: 服务就绪，等待 SurfaceFlinger 连接

@enduml</code>
</pre><h3 id=关键步骤解析>关键步骤解析<a hidden class=anchor aria-hidden=true href=#关键步骤解析>#</a></h3><h4 id=1-唯一入口servicecpp>1. 唯一入口：<code>service.cpp</code><a hidden class=anchor aria-hidden=true href=#1-唯一入口servicecpp>#</a></h4><p>这是 HWC 进程的起点。它并没有直接去操作硬件，而是先创建了 <code>AidlComposer</code>。这符合 Android VINTF 架构，将 AIDL 接口作为服务的门面。</p><h4 id=2-隐藏的单例concurrencymgr>2. 隐藏的单例：<code>ConcurrencyMgr</code><a hidden class=anchor aria-hidden=true href=#2-隐藏的单例concurrencymgr>#</a></h4><p><code>AidlComposer</code> 在构造时通过 <code>SDMInterfaceFactory</code> 获取了一堆接口（<code>LifeCycle</code>, <code>Settings</code> 等）。
<strong>关键点</strong>：这些接口的实现者全是同一个对象——<strong><code>ConcurrencyMgr</code></strong>。它是 SDM Client 层的“上帝对象”，如果不初始化它，整个显示系统就不会启动。</p><h4 id=3-硬件扫描hwinfointerface>3. 硬件扫描：<code>HWInfoInterface</code><a hidden class=anchor aria-hidden=true href=#3-硬件扫描hwinfointerface>#</a></h4><p>在创建任何 Display 对象之前，SDM 必须先知道底层有什么。
<code>CoreImpl</code> 初始化时会调用 <code>HWInfoInterface</code> 去扫描 DRM 节点（<code>/dev/dri/card0</code>），获取连接器列表、面板信息（是否有内屏、是否支持 HDR 等）。</p><h4 id=4-工厂流水线displaybuilder---displaybuiltin---hwperipheraldrm>4. 工厂流水线：<code>DisplayBuilder</code> -> <code>DisplayBuiltIn</code> -> <code>HWPeripheralDRM</code><a hidden class=anchor aria-hidden=true href=#4-工厂流水线displaybuilder---displaybuiltin---hwperipheraldrm>#</a></h4><p>这是对象创建的核心链条：</p><ul><li><strong>Builder</strong>: 拿到硬件列表，发现有一个主屏（Primary），于是决定造一个 <code>DisplayBuiltIn</code>。</li><li><strong>Logic (BuiltIn)</strong>: <code>DisplayBuiltIn</code> 初始化时，发现可能需要控制多个 DPU 核心（例如左右分屏），于是创建 <code>DPUMultiCore</code>。</li><li><strong>Hardware (DAL)</strong>: <code>DPUMultiCore</code> 最终请求创建一个硬件接口。因为类型是 <code>kBuiltIn</code>，工厂方法（<code>hw_interface.cpp</code>）毫不犹豫地创建了 <strong><code>HWPeripheralDRM</code></strong>。</li></ul><h4 id=5-最终状态>5. 最终状态<a hidden class=anchor aria-hidden=true href=#5-最终状态>#</a></h4><p>当 <code>service.cpp</code> 执行到 <code>addService</code> 时：</p><ul><li>内存中已经存在了 <code>HWPeripheralDRM</code> 实例。</li><li>该实例已经尝试读取了 <code>/sys/class/backlight/...</code>（在 <code>PopulateHWPanelInfo</code> 阶段）。</li><li>如果是在虚拟化环境且没有适配，此时 <code>brightness_base_path_</code> 可能已经包含了错误的路径，或者 max brightness 为 0，为后续的 <code>BadConfig</code> 埋下了伏笔。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/><span class=title>« Prev</span><br><span>DisplayManagerService设计</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/><span class=title>Next »</span><br><span>Insets animation flow</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>