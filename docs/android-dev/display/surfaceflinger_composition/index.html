<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android SurfaceFlinger 深度解析 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。
1. Display 创建过程
在 SurfaceFlinger 中，Display 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。
1.1 核心流程时序解析
下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。
sequenceDiagram
    autonumber
    
    %% 定义参与者
    participant HWC as HWC/Kernel
    participant DisplayManagerService as DisplayManagerService
    participant SF as SurfaceFlinger(MainThread)
    participant CE as CompositionEngine
    participant BQ as BufferQueue
    participant VDS as VirtualDisplaySurface
    participant FBS as FramebufferSurface
    participant DD as DisplayDevice
    participant Scheduler as Scheduler

    box "触发源 (Triggers)" #f9f9f9
        participant HWC
        participant DisplayManagerService
    end

    box "SurfaceFlinger" #e1f5fe
        participant SF
        participant Scheduler
        participant DD



        participant CE
        participant BQ
        participant VDS
        participant FBS
    end

    %% === 第一阶段：触发 ===
    rect rgb(255, 240, 240)
    note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
    
    alt 物理屏幕插入 (Hotplug)
        HWC ->> SF: onHotplugReceived(displayId, connected=true)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    else 虚拟屏幕请求 (Virtual)
        DisplayManagerService ->> SF: createDisplay(name, secure)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    end
    end

    %% === 第二阶段：主循环处理 ===
    SF ->> SF: onMessageInvalidate() -> handleMessageTransaction()
    SF ->> SF: processDisplayChangesLocked()
    note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有

    %% === 第三阶段：核心工厂方法 ===
    rect rgb(255, 250, 230)
    note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
    SF ->> SF: processDisplayAdded(token, state)

    %% 1. 创建 CE Display
    SF ->> CE: createDisplay(args)
    activate CE
    CE -->> SF: return compositionDisplay
    deactivate CE

    %% 2. 创建 Buffer 管道
    SF ->> BQ: createBufferQueue()
    BQ -->> SF: return (producer, consumer)

    %% 3. 创建 Surface (分叉逻辑)
    note right of SF: 阶段 3: 注册与激活
    
    alt 物理屏幕
        SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector)
    end

    SF ->> SF: mDisplays.add(token, displayDevice)
    
    opt 如果是物理屏幕
        SF ->> HWC: setPowerMode(ON)
        SF ->> SF: onActiveDisplayChangedLocked (如果是主屏)
    end
    end
技术实现细节：'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Android SurfaceFlinger 深度解析"><meta property="og:description" content='SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。
1. Display 创建过程 在 SurfaceFlinger 中，Display 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。
1.1 核心流程时序解析 下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。
sequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box "触发源 (Triggers)" #f9f9f9 participant HWC participant DisplayManagerService end box "SurfaceFlinger" #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC ->> SF: onHotplugReceived(displayId, connected=true) SF ->> SF: update mCurrentState (add Display) SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService ->> SF: createDisplay(name, secure) SF ->> SF: update mCurrentState (add Display) SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF ->> SF: onMessageInvalidate() -> handleMessageTransaction() SF ->> SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF ->> SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF ->> CE: createDisplay(args) activate CE CE -->> SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF ->> BQ: createBufferQueue() BQ -->> SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF ->> SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF ->> HWC: setPowerMode(ON) SF ->> SF: onActiveDisplayChangedLocked (如果是主屏) end end 技术实现细节：'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T10:22:54+08:00"><meta property="article:modified_time" content="2025-09-29T10:22:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android SurfaceFlinger 深度解析"><meta name=twitter:description content='SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。
1. Display 创建过程
在 SurfaceFlinger 中，Display 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。
1.1 核心流程时序解析
下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。
sequenceDiagram
    autonumber
    
    %% 定义参与者
    participant HWC as HWC/Kernel
    participant DisplayManagerService as DisplayManagerService
    participant SF as SurfaceFlinger(MainThread)
    participant CE as CompositionEngine
    participant BQ as BufferQueue
    participant VDS as VirtualDisplaySurface
    participant FBS as FramebufferSurface
    participant DD as DisplayDevice
    participant Scheduler as Scheduler

    box "触发源 (Triggers)" #f9f9f9
        participant HWC
        participant DisplayManagerService
    end

    box "SurfaceFlinger" #e1f5fe
        participant SF
        participant Scheduler
        participant DD



        participant CE
        participant BQ
        participant VDS
        participant FBS
    end

    %% === 第一阶段：触发 ===
    rect rgb(255, 240, 240)
    note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
    
    alt 物理屏幕插入 (Hotplug)
        HWC ->> SF: onHotplugReceived(displayId, connected=true)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    else 虚拟屏幕请求 (Virtual)
        DisplayManagerService ->> SF: createDisplay(name, secure)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    end
    end

    %% === 第二阶段：主循环处理 ===
    SF ->> SF: onMessageInvalidate() -> handleMessageTransaction()
    SF ->> SF: processDisplayChangesLocked()
    note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有

    %% === 第三阶段：核心工厂方法 ===
    rect rgb(255, 250, 230)
    note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
    SF ->> SF: processDisplayAdded(token, state)

    %% 1. 创建 CE Display
    SF ->> CE: createDisplay(args)
    activate CE
    CE -->> SF: return compositionDisplay
    deactivate CE

    %% 2. 创建 Buffer 管道
    SF ->> BQ: createBufferQueue()
    BQ -->> SF: return (producer, consumer)

    %% 3. 创建 Surface (分叉逻辑)
    note right of SF: 阶段 3: 注册与激活
    
    alt 物理屏幕
        SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector)
    end

    SF ->> SF: mDisplays.add(token, displayDevice)
    
    opt 如果是物理屏幕
        SF ->> HWC: setPowerMode(ON)
        SF ->> SF: onActiveDisplayChangedLocked (如果是主屏)
    end
    end
技术实现细节：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"Display Manager","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/"},{"@type":"ListItem","position":3,"name":"Android SurfaceFlinger 深度解析","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android SurfaceFlinger 深度解析","name":"Android SurfaceFlinger 深度解析","description":"SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。\n1. Display 创建过程 在 SurfaceFlinger 中，Display 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。\n1.1 核心流程时序解析 下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。\nsequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box \"触发源 (Triggers)\" #f9f9f9 participant HWC participant DisplayManagerService end box \"SurfaceFlinger\" #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC -\u003e\u003e SF: onHotplugReceived(displayId, connected=true) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService -\u003e\u003e SF: createDisplay(name, secure) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF -\u003e\u003e SF: onMessageInvalidate() -\u003e handleMessageTransaction() SF -\u003e\u003e SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF -\u003e\u003e SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF -\u003e\u003e CE: createDisplay(args) activate CE CE --\u003e\u003e SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF -\u003e\u003e BQ: createBufferQueue() BQ --\u003e\u003e SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF -\u003e\u003e Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF -\u003e\u003e SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF -\u003e\u003e HWC: setPowerMode(ON) SF -\u003e\u003e SF: onActiveDisplayChangedLocked (如果是主屏) end end 技术实现细节：\n","keywords":[],"articleBody":"SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。\n1. Display 创建过程 在 SurfaceFlinger 中，Display 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。\n1.1 核心流程时序解析 下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。\nsequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box \"触发源 (Triggers)\" #f9f9f9 participant HWC participant DisplayManagerService end box \"SurfaceFlinger\" #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC -\u003e\u003e SF: onHotplugReceived(displayId, connected=true) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService -\u003e\u003e SF: createDisplay(name, secure) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF -\u003e\u003e SF: onMessageInvalidate() -\u003e handleMessageTransaction() SF -\u003e\u003e SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF -\u003e\u003e SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF -\u003e\u003e CE: createDisplay(args) activate CE CE --\u003e\u003e SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF -\u003e\u003e BQ: createBufferQueue() BQ --\u003e\u003e SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF -\u003e\u003e Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF -\u003e\u003e SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF -\u003e\u003e HWC: setPowerMode(ON) SF -\u003e\u003e SF: onActiveDisplayChangedLocked (如果是主屏) end end 技术实现细节：\n事件触发与状态标记： 物理屏幕：HWComposer 收到内核的 Hotplug 事件，回调 onHotplugReceived。SF 将新的 Display 信息添加到 mCurrentState.displays 中，并调用 setTransactionFlags(eDisplayTransactionNeeded)，请求在主线程下一次遍历时处理。 虚拟屏幕：DisplayManagerService 通过 Binder 调用 createDisplay，同样更新 mCurrentState 并设置标志位。 状态提交与差异比对： SF 主线程在 handleMessageTransaction 中调用 processDisplayChangesLocked。 逻辑核心在于比对 mCurrentState（最新状态）与 mDrawingState（上一帧绘制状态）。若发现 mCurrentState 中存在新的 Display Token，则判定为新增屏幕，调用 processDisplayAdded。 核心对象构建 (processDisplayAdded)： CompositionEngine::Display：调用 getCompositionEngine().createDisplay 创建合成引擎侧的 Display 抽象，用于管理 OutputLayer 和合成状态。\nBufferQueue：创建图形缓冲区队列，用于 SF 的 GPU 合成结果输出。\nDisplayDevice：根据屏幕类型创建具体的设备抽象。\n物理屏幕：创建 FramebufferSurface 作为 BufferQueue 的消费者，直接对接 HWC。\n虚拟屏幕：创建 VirtualDisplaySurface，通常对接媒体编解码器或 WiFi Display。\nScheduler 注册：如果是物理屏幕，将其注册到 Scheduler，以便该屏幕能接收 VSYNC 信号并参与刷新率策略决策。\n2. Layer 管理与渲染架构 Layer 是 SurfaceFlinger 进行图形管理和合成的基本单元。现代 Android 架构中，Layer 的设计强调了状态的隔离与流水线处理。\n2.1 Layer 核心架构类图 下图展示了 SurfaceFlinger 核心对象、CompositionEngine 以及硬件层之间的静态关系，明确了 Layer 在不同模块中的形态。\n@startuml !theme plain hide empty members skinparam linetype ortho skinparam nodesep 60 skinparam ranksep 60 ' ========================================== ' SurfaceFlinger 域 ' ========================================== package \"SurfaceFlinger Core\" { class SurfaceFlinger { - mLayers : List","wordCount":"3549","inLanguage":"en","datePublished":"2025-09-29T10:22:54+08:00","dateModified":"2025-09-29T10:22:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/display/>Display Manager</a></div><h1 class="post-title entry-hint-parent">Android SurfaceFlinger 深度解析</h1><div class=post-meta><span title='2025-09-29 10:22:54 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3549 words</div></header><div class=post-content><p>SurfaceFlinger 是 Android 图形栈的核心系统服务，负责全系统的图形合成与显示管理。本文基于 Android 源码，深入剖析其从 Display 创建、Layer 状态管理、合成策略决策到 RenderEngine 渲染执行及 HWC 提交的完整技术链路。</p><h2 id=1-display-创建过程>1. Display 创建过程<a hidden class=anchor aria-hidden=true href=#1-display-创建过程>#</a></h2><p>在 SurfaceFlinger 中，<code>Display</code> 是物理屏幕（由 HWC 管理）或虚拟屏幕（由系统服务请求创建）的抽象实体。Display 的创建是一个异步且多阶段的过程，涉及内核事件响应、状态机更新及渲染资源的初始化。</p><h3 id=11-核心流程时序解析>1.1 核心流程时序解析<a hidden class=anchor aria-hidden=true href=#11-核心流程时序解析>#</a></h3><p>下图展示了从触发源（硬件热插拔或服务请求）到 SurfaceFlinger 内部对象初始化的完整调用时序。</p><div class=mermaid>sequenceDiagram
autonumber
%% 定义参与者
participant HWC as HWC/Kernel
participant DisplayManagerService as DisplayManagerService
participant SF as SurfaceFlinger(MainThread)
participant CE as CompositionEngine
participant BQ as BufferQueue
participant VDS as VirtualDisplaySurface
participant FBS as FramebufferSurface
participant DD as DisplayDevice
participant Scheduler as Scheduler
box "触发源 (Triggers)" #f9f9f9
participant HWC
participant DisplayManagerService
end
box "SurfaceFlinger" #e1f5fe
participant SF
participant Scheduler
participant DD
participant CE
participant BQ
participant VDS
participant FBS
end
%% === 第一阶段：触发 ===
rect rgb(255, 240, 240)
note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
alt 物理屏幕插入 (Hotplug)
HWC ->> SF: onHotplugReceived(displayId, connected=true)
SF ->> SF: update mCurrentState (add Display)
SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
else 虚拟屏幕请求 (Virtual)
DisplayManagerService ->> SF: createDisplay(name, secure)
SF ->> SF: update mCurrentState (add Display)
SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
end
end
%% === 第二阶段：主循环处理 ===
SF ->> SF: onMessageInvalidate() -> handleMessageTransaction()
SF ->> SF: processDisplayChangesLocked()
note right of SF: 发现 mCurrentState 有新 token<br>而 mDrawingState 没有
%% === 第三阶段：核心工厂方法 ===
rect rgb(255, 250, 230)
note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
SF ->> SF: processDisplayAdded(token, state)
%% 1. 创建 CE Display
SF ->> CE: createDisplay(args)
activate CE
CE -->> SF: return compositionDisplay
deactivate CE
%% 2. 创建 Buffer 管道
SF ->> BQ: createBufferQueue()
BQ -->> SF: return (producer, consumer)
%% 3. 创建 Surface (分叉逻辑)
note right of SF: 阶段 3: 注册与激活
alt 物理屏幕
SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector)
end
SF ->> SF: mDisplays.add(token, displayDevice)
opt 如果是物理屏幕
SF ->> HWC: setPowerMode(ON)
SF ->> SF: onActiveDisplayChangedLocked (如果是主屏)
end
end</div><p><strong>技术实现细节：</strong></p><ol><li><strong>事件触发与状态标记</strong>：</li></ol><ul><li><strong>物理屏幕</strong>：<code>HWComposer</code> 收到内核的 Hotplug 事件，回调 <code>onHotplugReceived</code>。SF 将新的 Display 信息添加到 <code>mCurrentState.displays</code> 中，并调用 <code>setTransactionFlags(eDisplayTransactionNeeded)</code>，请求在主线程下一次遍历时处理。</li><li><strong>虚拟屏幕</strong>：<code>DisplayManagerService</code> 通过 Binder 调用 <code>createDisplay</code>，同样更新 <code>mCurrentState</code> 并设置标志位。</li></ul><ol start=2><li><strong>状态提交与差异比对</strong>：</li></ol><ul><li>SF 主线程在 <code>handleMessageTransaction</code> 中调用 <code>processDisplayChangesLocked</code>。</li><li>逻辑核心在于比对 <code>mCurrentState</code>（最新状态）与 <code>mDrawingState</code>（上一帧绘制状态）。若发现 <code>mCurrentState</code> 中存在新的 Display Token，则判定为新增屏幕，调用 <code>processDisplayAdded</code>。</li></ul><ol start=3><li><strong>核心对象构建 (<code>processDisplayAdded</code>)</strong>：</li></ol><ul><li><p><strong>CompositionEngine::Display</strong>：调用 <code>getCompositionEngine().createDisplay</code> 创建合成引擎侧的 Display 抽象，用于管理 OutputLayer 和合成状态。</p></li><li><p><strong>BufferQueue</strong>：创建图形缓冲区队列，用于 SF 的 GPU 合成结果输出。</p></li><li><p><strong>DisplayDevice</strong>：根据屏幕类型创建具体的设备抽象。</p></li><li><p><strong>物理屏幕</strong>：创建 <code>FramebufferSurface</code> 作为 BufferQueue 的消费者，直接对接 HWC。</p></li><li><p><strong>虚拟屏幕</strong>：创建 <code>VirtualDisplaySurface</code>，通常对接媒体编解码器或 WiFi Display。</p></li><li><p><strong>Scheduler 注册</strong>：如果是物理屏幕，将其注册到 Scheduler，以便该屏幕能接收 VSYNC 信号并参与刷新率策略决策。</p></li></ul><hr><h2 id=2-layer-管理与渲染架构>2. Layer 管理与渲染架构<a hidden class=anchor aria-hidden=true href=#2-layer-管理与渲染架构>#</a></h2><p>Layer 是 SurfaceFlinger 进行图形管理和合成的基本单元。现代 Android 架构中，Layer 的设计强调了状态的隔离与流水线处理。</p><h3 id=21-layer-核心架构类图>2.1 Layer 核心架构类图<a hidden class=anchor aria-hidden=true href=#21-layer-核心架构类图>#</a></h3><p>下图展示了 SurfaceFlinger 核心对象、CompositionEngine 以及硬件层之间的静态关系，明确了 Layer 在不同模块中的形态。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide empty members
skinparam linetype ortho
skinparam nodesep 60
skinparam ranksep 60

&#39; ==========================================
&#39; SurfaceFlinger 域
&#39; ==========================================
package &#34;SurfaceFlinger Core&#34; {
    class SurfaceFlinger {
        - mLayers : List&lt;sp&lt;Layer&gt;&gt;
        + createBufferStateLayer()
    }

    class Layer {
        - mDrawingState : State
        - mBufferInfo : BufferInfo
        - mLayerFEs : vector&lt;pair&lt;TraversalPath, sp&lt;LayerFE&gt;&gt;&gt;
        + setBuffer()
        + latchBufferImpl()
        + getCompositionEngineLayerFE()
    }

    class &#34;Layer::State&#34; as LayerState {
        + buffer : shared_ptr&lt;ExternalTexture&gt;
        + geometry : Rect/FloatRect
        + dataspace : Dataspace
    }
}

&#39; ==========================================
&#39; CompositionEngine 域
&#39; ==========================================
package &#34;CompositionEngine&#34; {
    
    &#39; 接口定义
    interface LayerFE {
        + prepareClientComposition()
        + onPreComposition()
        + getCompositionState()
    }

    &#39; 具体实现 (通常是 Layer 的内部类或者独立类，这里根据提供的 LayerFE.cpp 是独立类)
    class &#34;LayerFE (Impl)&#34; as LayerFEImpl {
        - mSnapshot : LayerFECompositionState
        - mExternalTexture : shared_ptr&lt;ExternalTexture&gt;
        + prepareBufferStateClientComposition()
        + prepareShadowClientComposition()
    }

    class Output {
        - mOutputLayers : List&lt;OutputLayer&gt;
        + collectVisibleLayers()
        + updateCompositionState()
    }

    class OutputLayer {
        - mLayerFE : sp&lt;LayerFE&gt;
        - mState : OutputLayerCompositionState
        - mHwc : optional&lt;HWC2::Layer&gt;
        + updateCompositionState()
        + writeStateToHWC()
        + getOutput()
    }

    struct LayerSettings {
        + source : PixelSource
        + geometry : Geometry
        + alpha : float
        + bufferId : uint64_t
    }
}

package &#34;RenderEngine Layer&#34; {
    struct &#34;LayerSettings&#34; as RELayerSettings
    class RenderEngine {
        + drawLayers(std::vector&lt;const LayerSettings*&gt;&amp; layers)
    }

    RenderEngine --&gt; RELayerSettings:use
}

package &#34;Hardware&#34; {
    class &#34;HWC2::Layer&#34; as HwcLayer
}

&#39; ==========================================
&#39; 关系连线
&#39; ==========================================

&#39; SF 管理 Layer
SurfaceFlinger &#34;1&#34; o-- &#34;*&#34; Layer : 管理

&#39; Layer 组合 State
Layer *-- LayerState

&#39; Layer 创建并持有 LayerFE
Layer *-- LayerFE : 创建 &amp; 持有\n(1:N, 对应不同遍历路径)
LayerFE &lt;|-- LayerFEImpl : 实现

&#39; Output 管理 OutputLayer
Output &#34;1&#34; *-- &#34;*&#34; OutputLayer : 拥有 (按显示屏)

&#39; OutputLayer 关联 LayerFE
OutputLayer --&gt; LayerFE : 引用 (获取数据)

&#39; OutputLayer 关联 HWC Layer
OutputLayer --&gt; HwcLayer : 包装硬件层

&#39; LayerFE 生成 LayerSettings
LayerFEImpl ..&gt; LayerSettings : 生成 (prepareClientComposition)
LayerSettings --|&gt; RELayerSettings : 继承/兼容

@enduml
</code></pre><p><strong>组件职责与实现：</strong></p><ol><li><strong><code>Layer</code> (SurfaceFlinger)</strong>：</li></ol><ul><li><strong>BufferState 管理</strong>：实现了 BufferStateLayer 模式。通过 <code>setBuffer</code> 接收应用提交的 BufferData，更新 <code>mDrawingState</code>。</li><li><strong>Latch 机制</strong>：在 VSYNC 到达时，<code>latchBufferImpl</code> 将 <code>mDrawingState</code> 中的 Buffer 和属性移动到 <code>mBufferInfo</code>，确立当前帧的显示内容。</li><li><strong>LayerFE 工厂</strong>：负责创建并持有 <code>LayerFE</code> 实例，建立与 CompositionEngine 的连接。</li></ul><ol start=2><li><strong><code>LayerFE</code> (Front End)</strong>：</li></ol><ul><li><strong>快照隔离</strong>：LayerFE 充当 Layer 的快照代理。当 <code>latchBuffer</code> 发生时，Layer 的状态被复制到 LayerFE 的 <code>LayerFECompositionState</code> (<code>mSnapshot</code>) 中。</li><li><strong>并发安全</strong>：CompositionEngine 在合成过程中只读取 LayerFE 的快照数据，从而允许 SF 主线程在不阻塞合成的情况下处理下一帧的 Layer 属性更新。</li></ul><ol start=3><li><strong><code>OutputLayer</code> (CompositionEngine)</strong>：</li></ol><ul><li><strong>Output 关联</strong>：一个 Layer 可能显示在多个屏幕上（如镜像）。<code>OutputLayer</code> 将 <code>LayerFE</code> 的数据映射到具体的 <code>Display</code> 坐标系中，计算裁剪、投影和 Z-Order。</li><li><strong>HWC 桥接</strong>：持有 <code>HWC2::Layer</code> 指针，负责将图层属性写入硬件合成器。</li></ul><hr><h2 id=3-display-图像合成流程>3. Display 图像合成流程<a hidden class=anchor aria-hidden=true href=#3-display-图像合成流程>#</a></h2><p>图像合成是将所有 OutputLayer 的内容按照 Z-Order 叠加并输出到显示缓冲区的过程。该过程是一个由 VSYNC 驱动的闭环。</p><h3 id=31-数据流与合成路径选择>3.1 数据流与合成路径选择<a hidden class=anchor aria-hidden=true href=#31-数据流与合成路径选择>#</a></h3><p>下图展示了 Buffer 从 App 生产到最终显示的物理流转路径，以及基于 RenderEngine 和 HWC 的分流机制。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme cerulean
hide empty members
skinparam linetype ortho
skinparam nodesep 60
skinparam ranksep 50

&#39; ==========================================
&#39; 1. App Layer System (新增部分：生产端)
&#39; ==========================================
package &#34;App Layer System&#34; {
    package &#34;App BufferQueue&#34; &lt;&lt;Rectangle&gt;&gt; {
        interface &#34;IGBP (App)&#34; as AppIGBP
        class &#34;BufferQueue (App)&#34; as AppBQ
        interface &#34;IGBC (Layer)&#34; as AppIGBC
    }

    &#39; App 生产流程
    AppIGBP -down-o AppBQ: App 写入
    AppBQ o-down- AppIGBC: Layer 读取

}

&#39; ==========================================
&#39; 2. SurfaceFlinger (总管)
&#39; ==========================================
package &#34;SurfaceFlinger Core&#34; {
    class SurfaceFlinger {
        - mLayers : List&lt;sp&lt;Layer&gt;&gt;
        - mDisplays : Map
        + handleMessageInvalidate()
    }

    class DisplayDevice {
        - mCompositionDisplay
        - mDisplaySurface
    }

    class Layer {
        - mDrawingState : State
        - mBufferInfo : BufferInfo
        + setBuffer() : &#34;接收 Buffer (BufferState 模式)&#34;
        + latchBufferImpl() : &#34;锁定最新 Buffer&#34;
        + getBuffer() : &#34;获取 GraphicBuffer&#34;
    }    
}

AppIGBC -right-&gt; Layer : 消费
&#39; SF 管理 Layer 和 Display
SurfaceFlinger -down-&gt; Layer : 遍历 Layer
SurfaceFlinger -down-&gt; DisplayDevice : 管理 Display

&#39; ==========================================
&#39; 3. CompositionEngine (逻辑核心 &amp; 决策)
&#39; ==========================================
package &#34;CompositionEngine&#34; {
    abstract class Output {
        - mRenderSurface
        - mOutputLayers : List&lt;OutputLayer&gt;
        + composeSurfaces()
    }

    class &#34;\tOutputLayer\t\t\t\t\t&#34; as OutputLayer {
        - mLayerFE : LayerFE
        + writeStateToHWC()
    }

    class Display {
        &#39; 逻辑对象
    }

    class RenderSurface {
        - mNativeWindow
        - mDisplaySurface
        + queueBuffer()
    }
    
    class RenderEngine {
        + drawLayers()
    }

    interface DisplaySurface {
        + advanceFrame()
    }
}

&#39; CE 内部关系
DisplayDevice -down-&gt; Display : 持有
Display -down-|&gt; Output
Output &#34;1&#34; *-down- &#34;*&#34; OutputLayer : 包含
Output &#34;1&#34; *-down- &#34;1&#34; RenderSurface : 拥有

&#39; OutputLayer 关联具体的 Layer 数据
OutputLayer .left.&gt; Layer : 引用 Layer 数据

&#39; ==========================================
&#39; 4. 关键分支：渲染路径选择
&#39; ==========================================

&#39; 路径 A: GPU 合成 (RenderEngine 读取 Layer Buffer)
RenderEngine .up.&gt; Layer : Path A: 读取 Layer Buffer (纹理)
Output .right.&gt; RenderEngine #purple : 指挥绘图
RenderEngine .down.&gt; RenderSurface#purple : 绘制结果 (Target)


&#39; ==========================================
&#39; 5. 实现层 &amp; 基础设施
&#39; ==========================================
package &#34;Display Hardware&#34; {
    class &#34;\t\t\tFramebufferSurface\t\t&#34; as FramebufferSurface{
        + advanceFrame()
        + setClientTarget()
    }
    
    interface &#34;\t\tANativeWindow\t\t&#34; as SFNativeWindow {
        + queueBuffer()
        + queueBuffer()
    }

    &#39; ==========================================
    &#39; 6. SF BufferQueue (输出端)
    &#39; ==========================================
    package &#34;Display BufferQueue&#34; &lt;&lt;Rectangle&gt;&gt; {
        interface &#34;IGBP&#34; as SFIGBP
        class &#34;BufferQueue&#34; as SFBQ
        interface &#34;IGBC&#34; as SFIGBC
    }

}

package &#34;HWC Abstraction&#34; {
    class &#34;\t\t\t\tHWComposer\t\t\t\t\t\t&#34; as HWComposer{
        + setLayerBuffer()
        + setClientTarget()
    }
}

&#39; RenderSurface 的分发
DisplayDevice -right-&gt; DisplaySurface : 持有管道
RenderSurface -right-&gt; DisplaySurface : 控制流
RenderSurface -down-&gt; SFNativeWindow#purple : 数据流

&#39; FramebufferSurface 实现
FramebufferSurface .up.|&gt; DisplaySurface
FramebufferSurface -down-&gt; HWComposer#purple : 提交合成后的ClientTarget
&#39; 路径 B: HWC 合成 (直接透传 Layer Buffer)
OutputLayer ..&gt; HWComposer #red : Path B: setLayerBuffer(直接送给硬件)


SFNativeWindow -down-&gt; SFIGBP
SFIGBP --o SFBQ
SFBQ o-- SFIGBC
SFIGBC --&gt; FramebufferSurface

@enduml
</code></pre><p><strong>技术路径详解：</strong></p><ol><li><strong>路径 A：GPU 合成 (Client Composition)</strong>（紫色路径）</li></ol><ul><li><strong>触发条件</strong>：HWC 无法处理的 Layer（如超出图层数量限制、不支持的混合模式、复杂的圆角/模糊特效）。</li><li><strong>输入</strong>：<code>Output</code> 将这些 Layer 标记为 <code>Client</code>，提取其 Buffer 句柄作为<strong>纹理</strong>。</li><li><strong>处理</strong>：<code>RenderEngine</code> 使用 OpenGL/Skia 对纹理进行采样和片段着色。</li><li><strong>输出</strong>：渲染结果写入 <code>RenderSurface</code> 申请的 <code>GraphicBuffer</code>。该 Buffer 入队后，由 <code>FramebufferSurface</code> 消费，并作为 <strong>ClientTarget</strong> 提交给 HWC。</li></ul><ol start=2><li><strong>路径 B：HWC 合成 (Device Composition)</strong>（红色路径）</li></ol><ul><li><strong>触发条件</strong>：标准的 Overlay 图层，硬件直接支持。</li><li><strong>处理</strong>：<code>OutputLayer</code> 通过 <code>writeStateToHWC</code>，将 Layer 的 Buffer 句柄、屏幕坐标、裁切区域直接配置给 <code>HWComposer</code>。</li><li><strong>输出</strong>：无中间 Buffer 生成。显示控制器（Display Controller）在扫描输出时，利用 DMA 直接读取 App 的 Buffer 内存进行叠加。</li></ul><h3 id=32-完整的合成时序>3.2 完整的合成时序<a hidden class=anchor aria-hidden=true href=#32-完整的合成时序>#</a></h3><p>整个合成周期分为调度、锁定、策略决策、执行与上屏四个阶段。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide footbox
skinparam linetype ortho
skinparam sequenceMessageAlign center
autonumber

&#39; ==========================================
&#39; 参与者定义
&#39; ==========================================

box &#34;Scheduling &amp; Logic&#34; #f9f9f9
    participant &#34;MessageQueue\n(VSYNC)&#34; as MQ
    participant &#34;SurfaceFlinger&#34; as SF
    participant &#34;Layer&#34; as Layer
end box

box &#34;Composition Engine&#34; #e1f5fe
    participant &#34;Output\n(Display)&#34; as Output
    participant &#34;LayerFE\n(Snapshot)&#34; as LayerFE
    participant &#34;OutputLayer&#34; as OutLayer
    participant &#34;RenderSurface&#34; as RS
end box

box &#34;Render Hardware&#34; #e8f5e9
    participant &#34;RenderEngine\n(GPU)&#34; as RE
    participant &#34;FramebufferSurface&#34; as FBS
end box

box &#34;Hardware Composer&#34; #fff3e0
    participant &#34;HWComposer\n(HAL)&#34; as HWC
end box

&#39; ==========================================
&#39; Phase 1: 调度与锁定 (Heartbeat &amp; Latch)
&#39; ==========================================
== Phase 1: VSYNC Trigger &amp; Data Latching ==

MQ -&gt;&gt; SF: onMessageInvalidate() \n(VSYNC Arrives)
activate SF

SF -&gt;&gt; SF: handleMessageTransaction()\n处理 Layer 属性变化
SF -&gt;&gt; SF: handleMessageInvalidate()

loop 遍历所有 Layer
    SF -&gt;&gt; Layer: latchBuffer()
    activate Layer
    note right of Layer: 锁定当前帧的 Buffer\n更新 mBufferInfo
    
    Layer -&gt;&gt; LayerFE: updateSnapshot()
    activate LayerFE
    note right of LayerFE: 固化 Buffer 句柄\n隔离主线程
    deactivate LayerFE
    deactivate Layer
end

&#39; ==========================================
&#39; Phase 2: 收集与策略协商 (Strategy)
&#39; ==========================================
== Phase 2: Visibility &amp; Strategy Choice ==

SF -&gt;&gt; Output: composeSurfaces()
activate Output

&#39; 1. 收集可见层
Output -&gt;&gt; Output: collectVisibleLayers()
note right of Output: 计算可见性、裁剪、Z-Order\n创建 OutputLayer 列表

&#39; 2. 更新合成状态
Output -&gt;&gt; OutLayer: updateCompositionState()
activate OutLayer
OutLayer -&gt;&gt; LayerFE: getCompositionState()
LayerFE --&gt;&gt; OutLayer: return Snapshot (Geometry, Buffer)
deactivate OutLayer

&#39; 3. 询问 HWC (Validate)
Output -&gt;&gt; Output: prepareFrame() (策略协商)
Output -&gt;&gt; HWC: validateDisplay()
note right of HWC
    HWC 检查每个 Layer 的属性。
    返回它&lt;b&gt;不能&lt;/b&gt;处理的 Layer 列表。
end note
HWC --&gt;&gt; Output: ChangedCompositionTypes (Fallback to GPU)

Output -&gt;&gt; OutLayer: applyCompositionType()
note right of OutLayer
    根据 HWC 的反馈，标记每个 Layer 是
    &lt;color:red&gt;&lt;b&gt;DEVICE (HWC)&lt;/b&gt;&lt;/color&gt; 还是 &lt;color:blue&gt;&lt;b&gt;CLIENT (GPU)&lt;/b&gt;&lt;/color&gt;
end note

&#39; ==========================================
&#39; Phase 3: 执行合成 (Execution)
&#39; ==========================================
== Phase 3: Composition Execution ==

&#39; --- 分支 B: GPU 合成 (Client Composition) ---
group Client Composition (GPU Rendering)
    Output -&gt;&gt; Output: generateClientCompositionRequests()
    
    loop 遍历标记为 CLIENT 的 OutputLayer
        Output -&gt;&gt; LayerFE: prepareClientComposition()
        activate LayerFE
        note right of LayerFE: 封装 LayerSettings\n包含 ExternalTexture(Buffer)
        LayerFE --&gt;&gt; Output: LayerSettings
        deactivate LayerFE
    end

    Output -&gt;&gt; RS: dequeueBuffer()
    RS --&gt;&gt; Output: 目标 Buffer (Render Target)

    Output -&gt;&gt; RE: drawLayers(LayerSettings[], TargetBuffer)
    activate RE
    note right of RE
        GPU Shader 运行：
        采样 Layer Buffer (纹理)
        混合写入 Target Buffer
    end note
    RE --&gt;&gt; Output: 绘制完成 (Fence)
    deactivate RE

    Output -&gt;&gt; RS: queueBuffer(TargetBuffer)
    activate RS
    
    &#39; 关键连接点：RenderSurface 通知 FramebufferSurface
    RS -&gt;&gt; FBS: advanceFrame()
    activate FBS
    note right of FBS: 从 BufferQueue 获取\nGPU 画好的 Buffer
    
    FBS -&gt;&gt; HWC: setClientTarget(TargetBuffer)
    note right of HWC
        HWC 接收 GPU 合成结果
        作为背景层或混合层
    end note
    deactivate FBS
    deactivate RS
end

&#39; --- 分支 A: HWC 合成 (Device Composition) ---
group Device Composition (Overlay)
    loop 遍历标记为 DEVICE 的 OutputLayer
        Output -&gt;&gt; OutLayer: writeStateToHWC()
        activate OutLayer
        OutLayer -&gt;&gt; LayerFE: getBuffer()
        OutLayer -&gt;&gt; HWC: setLayerBuffer(Slot, BufferHandle, Fence)
        note right of HWC
            &lt;color:red&gt;&lt;b&gt;透传模式&lt;/b&gt;&lt;/color&gt;
            HWC 直接持有 Layer 的 Buffer 句柄
        end note
        deactivate OutLayer
    end
end

&#39; ==========================================
&#39; Phase 4: 最终上屏 (Present)
&#39; ==========================================
== Phase 4: Final Present ==

Output -&gt;&gt; HWC: presentDisplay()
activate HWC
note right of HWC
    硬件刷新屏幕：
    读取 ClientTarget (GPU结果)
    + 读取 Overlay Layers (透传结果)
end note
HWC --&gt;&gt; Output: PresentFence
deactivate HWC

Output -&gt;&gt; Output: onFrameCommitted()
deactivate Output
deactivate SF

@enduml
</code></pre><hr><h2 id=4-深入-renderenginegpu-合成详解>4. 深入 RenderEngine：GPU 合成详解<a hidden class=anchor aria-hidden=true href=#4-深入-renderenginegpu-合成详解>#</a></h2><p>RenderEngine 是 SurfaceFlinger 的渲染后端，负责执行所有 Client Composition 任务。它屏蔽了底层 OpenGL ES / Vulkan 的 API 差异，提供面向图层的绘制接口。</p><h3 id=41-renderengine-架构概览>4.1 RenderEngine 架构概览<a hidden class=anchor aria-hidden=true href=#41-renderengine-架构概览>#</a></h3><p>RenderEngine 采用了分层与装饰器模式设计，包含接口定义、线程模型、逻辑实现与后端驱动。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide empty members
skinparam linetype ortho
skinparam nodesep 80
skinparam ranksep 150

&#39; ==========================================
&#39; 接口与基类
&#39; ==========================================
package &#34;Interface Layer&#34; {
    abstract class RenderEngine {
        + {static} create() : unique_ptr&lt;RenderEngine&gt;
        + {abstract} drawLayers()
        + {abstract} mapExternalTextureBuffer()
    }

    class RenderEngineThreaded {
        - mRenderEngine : unique_ptr&lt;RenderEngine&gt;
        - mThread : thread
        + drawLayers() : &#34;推入任务队列&#34;
    }
}

&#39; ==========================================
&#39; 核心实现层 (Skia Base)
&#39; ==========================================
package &#34;Skia Implementation Layer&#34; {
    abstract class &#34;SkiaRenderEngine\t\t\t\t\t\t\t\t\t\t\t\t\t&#34; as SkiaRenderEngine {
        # mTextureCache : TextureCache
        # mCaptureCache : CaptureCache
        + drawLayers() : &#34;通用 Skia 绘制逻辑&#34;
        # drawLayersInternal()
    }
}

&#39; ==========================================
&#39; 后端具体实现 (Backends)
&#39; ==========================================
package &#34;Backend Layer&#34; {
    class SkiaGLRenderEngine {
        - mEGLDisplay : EGLDisplay
        - mEGLContext : EGLContext
        + create()
        --
        (Ganesh GL Backend)
    }

    class GaneshVkRenderEngine {
        - mInstance : VkInstance
        - mDevice : VkDevice
        + create()
        --
        (Ganesh Vulkan Backend)
    }

    class GraphiteVkRenderEngine {
        + create()
        --
        (Graphite Vulkan Backend)
    }
}

&#39; ==========================================
&#39; 数据对象
&#39; ==========================================
package &#34;Data Objects&#34; {
    class ExternalTexture {
        - mBuffer : sp&lt;GraphicBuffer&gt;
        + getBuffer()
    }
    
    struct LayerSettings {
        + geometry
        + source
        + alpha
    }
}

&#39; ==========================================
&#39; 关系连线
&#39; ==========================================

&#39; 继承关系
RenderEngine &lt;|-- RenderEngineThreaded
RenderEngine &lt;|-- SkiaRenderEngine
SkiaRenderEngine &lt;|-- SkiaGLRenderEngine
SkiaRenderEngine &lt;|-- GaneshVkRenderEngine
SkiaRenderEngine &lt;|-- GraphiteVkRenderEngine

&#39; 组合关系 (Decorator Pattern)
RenderEngineThreaded o-- RenderEngine : 包装实际引擎

&#39; 依赖关系
RenderEngine ..&gt; ExternalTexture : 管理
RenderEngine ..&gt; LayerSettings : 消费


@enduml
</code></pre><p><strong>关键组件实现原理：</strong></p><ul><li><strong>RenderEngineThreaded (Threading)</strong>：这是一个装饰器类，用于实现<strong>单线程异步渲染</strong>。它内部维护一个命令队列（<code>mFunctionCalls</code>）和一个后台工作线程（<code>mThread</code>）。当外部调用 <code>drawLayers</code> 时，它将调用参数封装为 Lambda 表达式推入队列，并立即返回 <code>std::future</code>。这确保了 SurfaceFlinger 主线程不会被耗时的 GPU 提交（<code>flush/submit</code>）操作阻塞。</li><li><strong>SkiaRenderEngine (Core Logic)</strong>：这是业务逻辑的核心。它负责将 SurfaceFlinger 的 <code>LayerSettings</code>（包含几何、特效、Buffer）翻译成 Skia 的 <code>SkCanvas</code> 绘图指令。例如，它将 <code>LayerSettings.geometry.positionTransform</code> 转换为 <code>canvas->concat(matrix)</code>，将圆角参数转换为 <code>canvas->drawRRect()</code>。</li><li><strong>SkiaGLRenderEngine (GL Backend)</strong>：负责管理 EGL 上下文。在初始化时，它创建 EGLDisplay 和 EGLContext，并将原生的 GL 环境封装成 Skia 的 <code>GrDirectContext</code>，注入到 <code>SkiaRenderEngine</code> 中，使其具备操作 GPU 的能力。</li></ul><h3 id=42-物理数据流与内存视图>4.2 物理数据流与内存视图<a hidden class=anchor aria-hidden=true href=#42-物理数据流与内存视图>#</a></h3><p>在 RenderEngine 的合成过程中，数据并未发生拷贝，而是以句柄（Handle）形式在进程间和模块间流转。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide empty members
skinparam linetype ortho
skinparam nodesep 100
skinparam ranksep 120

package &#34;Physical RAM (Shared Memory)&#34; {
    class &#34;App Buffer Memory\t\t\t\t\t\t&#34; as SharedMemApp {
        &lt;color:red&gt;&lt;b&gt;[ 像素数据 R,G,B,A... ]&lt;/b&gt;&lt;/color&gt;
        (由 App GPU 写入)
    }
    
    class &#34;\tSF Output Memory\t\t\t\t&#34; as SharedMemSF {
        &lt;color:blue&gt;&lt;b&gt;[ 合成后的像素数据 ]&lt;/b&gt;&lt;/color&gt;
        (由 SF GPU 写入)
    }
}

package &#34;App Process&#34; {
    class &#34;App BufferQueue&#34; as AppBQ
    AppBQ -down-&gt; SharedMemApp : 1. 持有句柄\n(Producer)
}

package &#34;SurfaceFlinger Process&#34; {
    class &#34;\t\tLayer\t\t&#34; as Layer
    class &#34;RenderEngine&#34; as RE
    class &#34;FramebufferSurface&#34; as FBS
    
    Layer -down-&gt; SharedMemApp : 2. 接收句柄\n(Consumer/Wrapper)
    
    RE -down-&gt; SharedMemApp : 3. 绑定为&lt;b&gt;纹理(Texture)&lt;/b&gt;\n(Input Source)
    RE -down-&gt; SharedMemSF : 4. 绑定为&lt;b&gt;渲染目标(Target)&lt;/b&gt;\n(Output Destination)
    
    FBS -down-&gt; SharedMemSF : 5. 持有句柄\n(Consumer)
}

package &#34;HWC / Display Hardware&#34; {
    class &#34;Display Controller&#34; as HWC
    HWC -up-&gt; SharedMemSF : 6. 读取显示\n(Scanout)
}

note left of SharedMemApp
    &lt;b&gt;核心真相：&lt;/b&gt;
    数据一直躺在 RAM 里。
    跨进程传递的只是指向
    这块 RAM 的文件描述符 (fd)。
end note

@enduml
</code></pre><h3 id=43-逻辑工作流draw-call-视图>4.3 逻辑工作流：Draw Call 视图<a hidden class=anchor aria-hidden=true href=#43-逻辑工作流draw-call-视图>#</a></h3><p>RenderEngine 将物理 Buffer 抽象为纹理，将合成过程转化为一次标准的 GPU 渲染流程。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide empty members
skinparam linetype ortho
skinparam nodesep 80
skinparam ranksep 120

package &#34;Inputs: Layers (Textures)&#34; {
    class &#34;Layer A\n(Texture 1)&#34; as TexA
    class &#34;Layer B\n(Texture 2)&#34; as TexB
    class &#34;Layer C\n(Texture 3)&#34; as TexC
}

package &#34;RenderEngine (The GPU Worker)&#34; {
    class &#34;\t\tShader / Pipeline\t\t\t\t\t&#34; as Shader {
        &lt;b&gt;Step 1: Sampling (采样)&lt;/b&gt;
        读取纹理坐标 (u,v) 处的颜色
        ====
        &lt;b&gt;Step 2: Math (运算)&lt;/b&gt;
        Color = A*alpha + B*(1-alpha)
        处理圆角、阴影、模糊
    }
}

package &#34;Output: FramebufferSurface&#34; {
    class &#34;ClientTarget Buffer\n(Render Target)&#34; as OutBuf {
        &lt;color:blue&gt;&lt;b&gt;[ 最终图像 ]&lt;/b&gt;&lt;/color&gt;
        格式: RGBA_8888 / FP16
    }
}

&#39; 流程连线
TexA -down-&gt; Shader : Read (Sample)
TexB -down-&gt; Shader : Read (Sample)
TexC -down-&gt; Shader : Read (Sample)

Shader -down-&gt; OutBuf : Write (Render)

note bottom of Shader
    &lt;b&gt;drawLayers() 的本质：&lt;/b&gt;
    1. Bind Textures (Layer Buffers)
    2. Bind Framebuffer (Target Buffer)
    3. DrawCall (运行 Shader 合成像素)
end note

@enduml
</code></pre><p><strong>实现细节：</strong></p><ol><li><strong>绑定输入</strong>：<code>SkiaRenderEngine::mapExternalTextureBuffer</code> 将 Layer 的 Buffer 映射为 <code>SkiaBackendTexture</code>。</li><li><strong>绑定输出</strong>：将 FramebufferSurface 提供的 Buffer 封装为 <code>SkSurface</code>，作为渲染画布。</li><li><strong>指令生成</strong>：根据 <code>LayerSettings</code>，通过 <code>SkCanvas</code> 发出 <code>drawImageRect</code> 等指令。</li><li><strong>Shader 执行</strong>：<code>flushAndSubmit</code> 触发 Skia 将高级指令转换为 GL/VK 命令流，GPU 运行 Shader 执行像素混合和特效计算。</li></ol><h3 id=44-renderengine-异步调用时序>4.4 RenderEngine 异步调用时序<a hidden class=anchor aria-hidden=true href=#44-renderengine-异步调用时序>#</a></h3><p>下图展示了 <code>RenderEngineThreaded</code> 如何通过任务队列实现异步渲染。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide footbox
skinparam sequenceMessageAlign center

participant &#34;SurfaceFlinger\n(Output)&#34; as SF
participant &#34;RenderEngine\n(Threaded)&#34; as Threaded
participant &#34;Task Queue&#34; as Queue
participant &#34;Worker Thread&#34; as Worker
participant &#34;SkiaGLRenderEngine\n(GLES Backend)&#34; as GLImpl
participant &#34;Skia\n(Library)&#34; as Skia

== 1. 提交绘制任务 ==

SF -&gt;&gt; Threaded: drawLayers(layers, buffer, fence)
activate Threaded
note right of Threaded
    非阻塞调用
    仅打包任务
end note

Threaded -&gt;&gt; Queue: push(Task)
Threaded --&gt;&gt; SF: Future&lt;Fence&gt;
deactivate Threaded

== 2. 异步执行 ==

Worker -&gt;&gt; Queue: wait &amp; pop()
activate Worker

Worker -&gt;&gt; GLImpl: drawLayers(layers, buffer)
activate GLImpl

&#39; 准备画布
GLImpl -&gt;&gt; GLImpl: mapBuffer(buffer) -&gt; SkSurface
GLImpl -&gt;&gt; Skia: getCanvas()

&#39; 遍历图层
loop For each Layer
    GLImpl -&gt;&gt; GLImpl: setupMatrix &amp; Clip
    
    alt is Texture Layer
        GLImpl -&gt;&gt; Skia: canvas-&gt;drawImageRect(image, paint)
    else is Solid Color
        GLImpl -&gt;&gt; Skia: canvas-&gt;drawRect(rect, paint)
    end
    
    opt has Shadow/Blur
        GLImpl -&gt;&gt; Skia: SkShadowUtils::DrawShadow / Paint.setImageFilter
    end
end

&#39; 提交
GLImpl -&gt;&gt; Skia: context-&gt;flushAndSubmit()
activate Skia
Skia --&gt;&gt; GLImpl: Submit
deactivate Skia

GLImpl -&gt;&gt; GLImpl: createFence()
GLImpl --&gt;&gt; Worker: DrawFence
deactivate GLImpl

&#39; 完成
Worker -&gt;&gt; SF: Future.set(DrawFence)
deactivate Worker

@enduml
</code></pre><hr><h2 id=5-scheduler-与-vsync-调度>5. Scheduler 与 VSYNC 调度<a hidden class=anchor aria-hidden=true href=#5-scheduler-与-vsync-调度>#</a></h2><p>Scheduler 是 SurfaceFlinger 的时间基准控制中心，负责生成 VSYNC 信号、分发事件以及根据系统状态动态调整刷新率。</p><h3 id=51-scheduler-核心架构>5.1 Scheduler 核心架构<a hidden class=anchor aria-hidden=true href=#51-scheduler-核心架构>#</a></h3><p>Scheduler 位于 HWC 硬件信号与上层逻辑之间，起到解耦和策略控制的作用。</p><div class=mermaid>graph TD
%% 外部输入
subgraph Inputs [输入信号]
HWC_Vsync[HWC VSYNC 信号]
Touch[Input 触摸事件]
Layers[Layer 更新频率]
Power[电源/热状态]
end
%% Scheduler 核心
subgraph Scheduler_Core [Scheduler]
direction TB
VsyncModulator[VsyncModulator<br>相位控制]
LayerHistory[LayerHistory<br>FPS检测]
Policy[RefreshRate Policy<br>策略决策]
subgraph Timers [状态机定时器]
IdleTimer[Idle Timer]
TouchTimer[Touch Timer]
end
Pacesetter[Pacesetter Logic<br>多屏领跑机制]
end
%% 输出分发
subgraph EventThreads [VSYNC 分发]
AppET[EventThread App<br>Cycle::Render]
SfET[EventThread SF<br>Cycle::LastComposite]
end
%% 最终输出
subgraph Outputs [输出动作]
Choreographer[App Choreographer]
SF_Main[SF Main Thread]
HWC_Config[HWC Config/Mode<br>切帧率]
end
%% 连线
HWC_Vsync --> Scheduler_Core
Touch --> TouchTimer
Layers --> LayerHistory
Scheduler_Core --> AppET
Scheduler_Core --> SfET
AppET --> Choreographer
SfET --> SF_Main
Policy --> HWC_Config</div><p><strong>关键组件机制：</strong></p><ul><li><strong>VsyncModulator</strong>：根据系统负载动态调整 App VSYNC 和 SF VSYNC 的相位偏移（Offset）。例如，当系统掉帧时，减小偏移量以给予 CPU/GPU 更多处理时间。</li><li><strong>LayerHistory</strong>：记录每个 Layer 的提交时间戳，计算其平均帧率。这是内容自适应刷新率（Content Detection）的基础。</li><li><strong>Pacesetter</strong>：在多屏设备中，选定一个主屏作为时间基准，其他屏幕的 VSYNC 基于主屏时钟进行偏移生成，防止节奏混乱。</li></ul><h3 id=52-智能刷新率决策流程>5.2 智能刷新率决策流程<a hidden class=anchor aria-hidden=true href=#52-智能刷新率决策流程>#</a></h3><p><strong>场景一：触摸升频 (Touch Boost)</strong>
为了保证交互的跟手性，当 Input 系统检测到触摸时，Scheduler 会强制将屏幕刷新率提升至最高。</p><div class=mermaid>sequenceDiagram
participant Touch as InputSystem
participant Sched as Scheduler
participant Timer as TouchTimer
participant Policy as PolicyLogic
participant HWC as HWC
Touch->>Sched: onTouchHint()
Sched->>Timer: reset()
Timer-->>Policy: Callback(TimerState::Reset)
rect rgb(230, 240, 255)
Note right of Policy: 策略判定：进入 Touch 状态
Policy->>Policy: Current Mode = 120Hz (Max)
end
Policy->>HWC: setActiveConfig(120Hz)
HWC-->>Sched: VSYNC (120Hz)</div><p><strong>场景二：内容帧率匹配 (Content Detection)</strong>
当播放 30fps 视频时，<code>LayerHistory</code> 检测到 Buffer 提交间隔稳定在 33ms，Scheduler 会选择 60Hz 或 30Hz 的显示模式以避免画面抖动（Judder）。</p><div class=mermaid>sequenceDiagram
participant App as VideoApp
participant LH as LayerHistory
participant Sched as Scheduler
participant HWC
loop 播放视频 (30fps)
App->>Sched: queueBuffer (T1)
App->>Sched: queueBuffer (T2)
Sched->>LH: record(LayerID, PresentTime)
end
LH->>LH: 分析: 平均间隔 33ms -> 30fps
LH-->>Sched: Summary: Vote for 30Hz/60Hz
Sched->>Sched: chooseDisplayModes()
Note right of Sched: 最佳匹配: 60Hz (30的倍数)
Sched->>HWC: setActiveConfig(60Hz)</div><hr><h2 id=6-hwcomposer-硬件抽象与通信>6. HWComposer 硬件抽象与通信<a hidden class=anchor aria-hidden=true href=#6-hwcomposer-硬件抽象与通信>#</a></h2><p>HWComposer (HWC) 是 SurfaceFlinger 与底层显示驱动交互的 AIDL 接口。为了减少 Binder IPC 通信的开销，HWC 引入了复杂的命令缓冲机制。</p><h3 id=61-hwcomposer-架构设计>6.1 HWComposer 架构设计<a hidden class=anchor aria-hidden=true href=#61-hwcomposer-架构设计>#</a></h3><p>下图展示了 HWComposer 的层级结构，从顶层的单例管理到底层 AIDL 接口的代理。</p><div class=mermaid>classDiagram
direction TD
%% ==========================================
%% 1. Top Level: HWComposer
%% ==========================================
class HWComposer {
- mDisplayData : map~HalDisplayId, DisplayData~
+ getDeviceCompositionChanges() : void
}
class DisplayData {
- port : int
- hwcDisplay : unique_ptr~HWC2::Display~
}
%% ==========================================
%% 2. Abstraction Layer (HWC2)
%% ==========================================
%% 使用 ID["Label"] 语法处理特殊字符
class HWC2_Display["HWC2::Display"] {
<<interface>>
}
class HWC2_impl_Display["HWC2::impl::Display"] {
- mComposer : Hwc2::Composer&
+ presentOrValidate() : void
}
class Hwc2_Composer["Hwc2::Composer"] {
<<interface>>
}
%% ==========================================
%% 3. Implementation Layer (AIDL)
%% ==========================================
class AidlComposer["Hwc2::AidlComposer"] {
- mAidlComposer
- mAidlComposerClient
- mAidlComposerCallback
+ executeCommands() : void
+ presentOrValidateDisplay() : void
}
%% ==========================================
%% 4. Command Processing (Writer/Reader)
%% ==========================================
class ComposerClientWriter {
- mDisplayCommand : optional~DisplayCommand~
- mLayerCommand : optional~LayerCommand~
- mCommands : vector~DisplayCommand~
- mDisplay : int
+ presentOrValidateDisplay() : void
+ setDisplayBrightness() : void
}
class ComposerClientReader {
- mErrors : vector~CommandError~
- mReturnData : map~int64_t, ReturnData~
+ parse(results) : void
}
%% ==========================================
%% 5. AIDL Interfaces (Bottom Leaves)
%% ==========================================
class AidlComposerInterface {
<<aidlinterface>>
}
class AidlComposerClient {
<<aidlinterface>>
+ executeCommands() : void
}
class AidlComposerCallbackWrapper {
<<callback>>
}
%% ==========================================
%% Relationships
%% ==========================================
%% 1. HWComposer holds DisplayData
HWComposer *-- DisplayData
%% 2. DisplayData holds HWC2::Display
DisplayData *-- HWC2_Display
%% 3. HWC2::impl::Display implements HWC2::Display
HWC2_Display <|-- HWC2_impl_Display
%% 4. impl::Display uses Composer
HWC2_impl_Display --> Hwc2_Composer
%% 5. AidlComposer implements Composer
Hwc2_Composer <|-- AidlComposer
%% 6. AidlComposer Aggregates Writer & Reader (Key to command buffer)
AidlComposer o-- ComposerClientWriter : Map<displayid>
AidlComposer o-- ComposerClientReader : Map<displayid>
%% 7. AidlComposer holds AIDL Proxies
AidlComposer --> AidlComposerInterface : - mAidlComposer
AidlComposer --> AidlComposerClient : - mAidlComposerClient
AidlComposer --> AidlComposerCallbackWrapper : - mAidlComposerCallback</div><h3 id=62-命令批处理机制-batching>6.2 命令批处理机制 (Batching)<a hidden class=anchor aria-hidden=true href=#62-命令批处理机制-batching>#</a></h3><p><code>AidlComposer</code> 并不直接发起 IPC 调用。它维护了每个 Display 对应的 <code>ComposerClientWriter</code>。当 SurfaceFlinger 调用 <code>setLayerBuffer</code> 或 <code>setLayerColor</code> 等接口时，这些操作被序列化为 AIDL 定义的结构体（<code>DisplayCommand</code>）并缓存在 <code>mCommands</code> 内存缓冲区中。</p><div class=mermaid>classDiagram
direction TB
%% ==========================================
%% 核心控制器
%% ==========================================
class AidlComposer {
- mAidlComposerClient : IComposerClient
- mWriters : Map~DisplayId, ComposerClientWriter~
- mReaders : Map~DisplayId, ComposerClientReader~
+ setLayerBuffer()
+ execute()
+ presentDisplay()
}
%% ==========================================
%% 写入侧 (Client -> Service)
%% ==========================================
class ComposerClientWriter {
- mDisplay : int64_t
- mCommands : vector~DisplayCommand~
- mDisplayCommand : optional~DisplayCommand~
- mLayerCommand : optional~LayerCommand~
+ setLayerBuffer()
+ setLayerColor()
+ takePendingCommands() : vector~DisplayCommand~
}
note for ComposerClientWriter "<b>职责：命令缓冲</b><br>将函数调用转换为AIDL结构体<br>并缓存在 mCommands 中，不发生IPC"
%% ==========================================
%% 读取侧 (Service -> Client)
%% ==========================================
class ComposerClientReader {
- mReturnData : Map~DisplayId, ReturnData~
+ parse(vector~CommandResultPayload~)
+ takePresentFence()
+ takeReleaseFences()
}
note for ComposerClientReader "<b>职责：结果解析</b><br>解析 IPC 返回的 Payload<br>按类型存入 mReturnData 供查询"
class CommandResultPayload {
<<aidl union>>
+ presentFence
+ releaseFences
+ error
}
class ReturnData {
+ presentFence : ScopedFileDescriptor
+ releasedLayers : vector
}
class DisplayCommand {
<<aidl struct>>
+ layers : vector~LayerCommand~
+ clientTarget : ClientTarget
}
%% ==========================================
%% IPC 接口
%% ==========================================
class IComposerClient {
<<aidl interface>>
+ executeCommands(commands, out results)
}
%% ==========================================
%% 关系连线
%% ==========================================
%% 组合关系
AidlComposer "1" *-- "*" ComposerClientWriter : 拥有 (按Display管理)
AidlComposer "1" *-- "*" ComposerClientReader : 拥有 (按Display管理)
AidlComposer ..> IComposerClient : 代理调用 (Binder IPC)
%% 数据流向：写
ComposerClientWriter ..> DisplayCommand : 生成并缓存
DisplayCommand ..> IComposerClient : 作为参数发送
%% 数据流向：读
IComposerClient ..> CommandResultPayload : 返回结果
CommandResultPayload ..> ComposerClientReader : 输入解析
ComposerClientReader *-- ReturnData : 内部存储解析结果</div><h3 id=63-hwc-交互时序>6.3 HWC 交互时序<a hidden class=anchor aria-hidden=true href=#63-hwc-交互时序>#</a></h3><p>只有当调用 <code>execute()</code> 或 <code>presentOrValidateDisplay()</code> 时，<code>AidlComposer</code> 才会将缓冲区中的所有命令打包，通过 <code>IComposerClient::executeCommands</code> 发起一次 Binder 调用，并将返回结果交给 <code>ComposerClientReader</code> 解析。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide footbox
autonumber

participant &#34;HWComposer&#34; as Caller
participant &#34;AidlComposer&#34; as Aidl
participant &#34;ComposerClientWriter&#34; as Writer
participant &#34;IComposerClient (Binder)&#34; as Binder
participant &#34;ComposerClientReader&#34; as Reader

note over Caller, Writer: 阶段 1: 命令积攒 (Buffering)\n此处不发生 IPC，仅内存操作

Caller -&gt; Aidl: setLayerBuffer(display, layer, buffer...)
activate Aidl
Aidl -&gt; Aidl: getWriter(display)
Aidl -&gt; Writer: setLayerBuffer(..., buffer)
activate Writer
Writer -&gt; Writer: getLayerCommand()
Writer -&gt; Writer: 填充 Buffer 数据到 mLayerCommand
deactivate Writer
deactivate Aidl

Caller -&gt; Aidl: setLayerColor(display, layer, color...)
activate Aidl
Aidl -&gt; Writer: setLayerColor(..., color)
deactivate Aidl

note over Caller, Reader: 阶段 2: 批量提交与解析 (Execution &amp; Parsing)

Caller -&gt; Aidl: execute(display) / presentDisplay
activate Aidl

Aidl -&gt; Writer: takePendingCommands()
activate Writer
Writer -&gt; Writer: flushLayerCommand()
Writer -&gt; Writer: flushDisplayCommand()
Writer --&gt; Aidl: vector&lt;DisplayCommand&gt; cmds
deactivate Writer

note right of Writer: mCommands 被清空\ncmds 被移动到 AidlComposer

Aidl -&gt; Binder: executeCommands(cmds)
activate Binder
note right of Binder: 跨进程传输\nHardware Composer 处理命令
Binder --&gt; Aidl: vector&lt;CommandResultPayload&gt; results
deactivate Binder

Aidl -&gt; Reader: parse(results)
activate Reader
loop 遍历 results
    Reader -&gt; Reader: 根据 Tag (Fence/Error/etc)\n分类存入 mReturnData
end
deactivate Reader

Aidl -&gt; Reader: takeErrors()
activate Reader
Reader --&gt; Aidl: errors
deactivate Reader

opt 如果 Caller 需要 PresentFence
    Aidl -&gt; Reader: takePresentFence(display)
    activate Reader
    Reader --&gt; Aidl: ScopedFileDescriptor
    deactivate Reader
end

Aidl --&gt; Caller: Error::NONE
deactivate Aidl

@enduml
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/display/renderengine/><span class=title>« Prev</span><br><span>Android SurfaceFlinger RenderEngine 深度详解</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/display/displaymanagerservice/><span class=title>Next »</span><br><span>DisplayManagerService设计</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>