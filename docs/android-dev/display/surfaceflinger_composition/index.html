<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="Display创建过程
sequenceDiagram
    autonumber
    
    %% 定义参与者
    participant HWC as HWC/Kernel
    participant DisplayManagerService as DisplayManagerService
    participant SF as SurfaceFlinger(MainThread)
    participant CE as CompositionEngine
    participant BQ as BufferQueue
    participant VDS as VirtualDisplaySurface
    participant FBS as FramebufferSurface
    participant DD as DisplayDevice
    participant Scheduler as Scheduler

    box &#34;触发源 (Triggers)&#34; #f9f9f9
        participant HWC
        participant DisplayManagerService
    end

    box &#34;SurfaceFlinger&#34; #e1f5fe
        participant SF
        participant Scheduler
        participant DD



        participant CE
        participant BQ
        participant VDS
        participant FBS
    end

    %% === 第一阶段：触发 ===
    rect rgb(255, 240, 240)
    note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
    
    alt 物理屏幕插入 (Hotplug)
        HWC ->> SF: onHotplugReceived(displayId, connected=true)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    else 虚拟屏幕请求 (Virtual)
        DisplayManagerService ->> SF: createDisplay(name, secure)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    end
    end

    %% === 第二阶段：主循环处理 ===
    SF ->> SF: onMessageInvalidate() -> handleMessageTransaction()
    SF ->> SF: processDisplayChangesLocked()
    note right of SF: 发现 mCurrentState 有新 token<br/>而 mDrawingState 没有

    %% === 第三阶段：核心工厂方法 ===
    rect rgb(255, 250, 230)
    note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
    SF ->> SF: processDisplayAdded(token, state)

    %% 1. 创建 CE Display
    SF ->> CE: createDisplay(args)
    activate CE
    CE -->> SF: return compositionDisplay
    deactivate CE

    %% 2. 创建 Buffer 管道
    SF ->> BQ: createBufferQueue()
    BQ -->> SF: return (producer, consumer)

    %% 3. 创建 Surface (分叉逻辑)
    alt 是虚拟屏幕 (Virtual)
        SF ->> VDS: new VirtualDisplaySurface(bqProducer, ...)
        VDS -->> SF: return displaySurface
    else 是物理屏幕 (Physical)
        SF ->> FBS: new FramebufferSurface(hwc, displayId, consumer, ...)
        FBS -->> SF: return displaySurface
    end

    %% 4. 创建 DisplayDevice 对象
    SF ->> SF: setupNewDisplayDeviceInternal(...)
    SF ->> DD: new DisplayDevice(compositionDisplay, displaySurface, ...)
    activate DD
    DD -->> SF: return displayDevice
    deactivate DD
    end

    %% === 第四阶段：注册与激活 ===
    rect rgb(240, 255, 240)
    note right of SF: 阶段 3: 注册与激活
    
    alt 物理屏幕
        SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector)
    end

    SF ->> SF: mDisplays.add(token, displayDevice)
    
    opt 如果是物理屏幕
        SF ->> HWC: setPowerMode(ON)
        SF ->> SF: onActiveDisplayChangedLocked (如果是主屏)
    end
    end
Display的管理
@startuml
!theme plain
hide empty members
' 强制使用直角线，避免曲线
skinparam linetype ortho
' 增加节点间距，防止挤在一起
skinparam nodesep 80
skinparam ranksep 60

' ==========================================
' 核心类定义
' ==========================================

class SurfaceFlinger {
    - mDisplays
    + processDisplayAdded()
}

class DisplayDevice {
    - mCompositionDisplay
    - mDisplaySurface
}

class Display {
    ' 逻辑对象
}

abstract class Output {
    - mRenderSurface
    + composeSurfaces()
}

class RenderSurface {
    - mNativeWindow
    - mDisplaySurface
    + queueBuffer()
}
note left of RenderSurface
    <b>[双面胶]</b>
    左手: 数据流 (NativeWindow)
    右手: 控制流 (DisplaySurface)
end note

class RenderEngine {
    + drawLayers()
}

interface DisplaySurface {
    + advanceFrame()
}

class FramebufferSurface {
    + advanceFrame()
    + setClientTarget()
}

interface &#34;\t\tANativeWindow\t\t&#34; as ANativeWindow{
    + queueBuffer()
}

class HWComposer {
    + setClientTarget()
}

' ==========================================
' 底层 BufferQueue 定义 (使用 together 强制在一起)
' ==========================================
package &#34;BufferQueue System&#34; <<Rectangle>> {
    interface IGraphicBufferProducer
    class BufferQueue
    interface IGraphicBufferConsumer
}

' ==========================================
' 关系连线 (精心设计的布局方向)
' ==========================================

' 1. 顶层管理
SurfaceFlinger -down-> DisplayDevice : 管理

' 2. DisplayDevice 分流 (关键布局点)
' 向下连接逻辑，向右连接管道，把图撑开
DisplayDevice -down-> Display : 持有逻辑\n(CompositionEngine)
DisplayDevice -right-> DisplaySurface : 持有

' 3. 左侧：逻辑合成链路 (Vertical)
Display -down-|> Output
Output -down-> RenderSurface : 拥有
Output .left.> RenderEngine : 指挥绘图
RenderEngine .right.> RenderSurface : 绘制目标

' 4. RenderSurface 的分发 (关键枢纽)
' 向右连接控制流
RenderSurface -right-> DisplaySurface : 1.控制流\n(advanceFrame)
' 向下连接数据流
RenderSurface -down-> ANativeWindow : 2.数据流\n(queueBuffer)

' 5. 右侧：实现层 (Vertical)
FramebufferSurface .up.|> DisplaySurface : 实现
FramebufferSurface .up.|> ANativeWindow : 提供后端
FramebufferSurface -right-> HWComposer : 提交\n(setClientTarget)

' 6. 底部：BufferQueue 闭环
ANativeWindow -down-> IGraphicBufferProducer : 封装
IGraphicBufferProducer -right-o BufferQueue : 写入
BufferQueue o-right- IGraphicBufferConsumer : 读取
IGraphicBufferConsumer -up-> FramebufferSurface : 消费

' 7. 布局辅助 (水平对齐)
' 强制 RenderSurface 和 DisplaySurface 在同一水平线上
RenderSurface -[hidden]right- DisplaySurface

@enduml
总结数据流向"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="Display创建过程 sequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box &#34;触发源 (Triggers)&#34; #f9f9f9 participant HWC participant DisplayManagerService end box &#34;SurfaceFlinger&#34; #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC ->> SF: onHotplugReceived(displayId, connected=true) SF ->> SF: update mCurrentState (add Display) SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService ->> SF: createDisplay(name, secure) SF ->> SF: update mCurrentState (add Display) SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF ->> SF: onMessageInvalidate() -> handleMessageTransaction() SF ->> SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token<br/>而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF ->> SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF ->> CE: createDisplay(args) activate CE CE -->> SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF ->> BQ: createBufferQueue() BQ -->> SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) alt 是虚拟屏幕 (Virtual) SF ->> VDS: new VirtualDisplaySurface(bqProducer, ...) VDS -->> SF: return displaySurface else 是物理屏幕 (Physical) SF ->> FBS: new FramebufferSurface(hwc, displayId, consumer, ...) FBS -->> SF: return displaySurface end %% 4. 创建 DisplayDevice 对象 SF ->> SF: setupNewDisplayDeviceInternal(...) SF ->> DD: new DisplayDevice(compositionDisplay, displaySurface, ...) activate DD DD -->> SF: return displayDevice deactivate DD end %% === 第四阶段：注册与激活 === rect rgb(240, 255, 240) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF ->> SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF ->> HWC: setPowerMode(ON) SF ->> SF: onActiveDisplayChangedLocked (如果是主屏) end end Display的管理 @startuml !theme plain hide empty members ' 强制使用直角线，避免曲线 skinparam linetype ortho ' 增加节点间距，防止挤在一起 skinparam nodesep 80 skinparam ranksep 60 ' ========================================== ' 核心类定义 ' ========================================== class SurfaceFlinger { - mDisplays + processDisplayAdded() } class DisplayDevice { - mCompositionDisplay - mDisplaySurface } class Display { ' 逻辑对象 } abstract class Output { - mRenderSurface + composeSurfaces() } class RenderSurface { - mNativeWindow - mDisplaySurface + queueBuffer() } note left of RenderSurface <b>[双面胶]</b> 左手: 数据流 (NativeWindow) 右手: 控制流 (DisplaySurface) end note class RenderEngine { + drawLayers() } interface DisplaySurface { + advanceFrame() } class FramebufferSurface { + advanceFrame() + setClientTarget() } interface &#34;\t\tANativeWindow\t\t&#34; as ANativeWindow{ + queueBuffer() } class HWComposer { + setClientTarget() } ' ========================================== ' 底层 BufferQueue 定义 (使用 together 强制在一起) ' ========================================== package &#34;BufferQueue System&#34; <<Rectangle>> { interface IGraphicBufferProducer class BufferQueue interface IGraphicBufferConsumer } ' ========================================== ' 关系连线 (精心设计的布局方向) ' ========================================== ' 1. 顶层管理 SurfaceFlinger -down-> DisplayDevice : 管理 ' 2. DisplayDevice 分流 (关键布局点) ' 向下连接逻辑，向右连接管道，把图撑开 DisplayDevice -down-> Display : 持有逻辑\n(CompositionEngine) DisplayDevice -right-> DisplaySurface : 持有 ' 3. 左侧：逻辑合成链路 (Vertical) Display -down-|> Output Output -down-> RenderSurface : 拥有 Output .left.> RenderEngine : 指挥绘图 RenderEngine .right.> RenderSurface : 绘制目标 ' 4. RenderSurface 的分发 (关键枢纽) ' 向右连接控制流 RenderSurface -right-> DisplaySurface : 1.控制流\n(advanceFrame) ' 向下连接数据流 RenderSurface -down-> ANativeWindow : 2.数据流\n(queueBuffer) ' 5. 右侧：实现层 (Vertical) FramebufferSurface .up.|> DisplaySurface : 实现 FramebufferSurface .up.|> ANativeWindow : 提供后端 FramebufferSurface -right-> HWComposer : 提交\n(setClientTarget) ' 6. 底部：BufferQueue 闭环 ANativeWindow -down-> IGraphicBufferProducer : 封装 IGraphicBufferProducer -right-o BufferQueue : 写入 BufferQueue o-right- IGraphicBufferConsumer : 读取 IGraphicBufferConsumer -up-> FramebufferSurface : 消费 ' 7. 布局辅助 (水平对齐) ' 强制 RenderSurface 和 DisplaySurface 在同一水平线上 RenderSurface -[hidden]right- DisplaySurface @enduml 总结数据流向"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Display创建过程
sequenceDiagram
    autonumber
    
    %% 定义参与者
    participant HWC as HWC/Kernel
    participant DisplayManagerService as DisplayManagerService
    participant SF as SurfaceFlinger(MainThread)
    participant CE as CompositionEngine
    participant BQ as BufferQueue
    participant VDS as VirtualDisplaySurface
    participant FBS as FramebufferSurface
    participant DD as DisplayDevice
    participant Scheduler as Scheduler

    box &#34;触发源 (Triggers)&#34; #f9f9f9
        participant HWC
        participant DisplayManagerService
    end

    box &#34;SurfaceFlinger&#34; #e1f5fe
        participant SF
        participant Scheduler
        participant DD



        participant CE
        participant BQ
        participant VDS
        participant FBS
    end

    %% === 第一阶段：触发 ===
    rect rgb(255, 240, 240)
    note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
    
    alt 物理屏幕插入 (Hotplug)
        HWC ->> SF: onHotplugReceived(displayId, connected=true)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    else 虚拟屏幕请求 (Virtual)
        DisplayManagerService ->> SF: createDisplay(name, secure)
        SF ->> SF: update mCurrentState (add Display)
        SF ->> SF: setTransactionFlags(eDisplayTransactionNeeded)
    end
    end

    %% === 第二阶段：主循环处理 ===
    SF ->> SF: onMessageInvalidate() -> handleMessageTransaction()
    SF ->> SF: processDisplayChangesLocked()
    note right of SF: 发现 mCurrentState 有新 token<br/>而 mDrawingState 没有

    %% === 第三阶段：核心工厂方法 ===
    rect rgb(255, 250, 230)
    note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
    SF ->> SF: processDisplayAdded(token, state)

    %% 1. 创建 CE Display
    SF ->> CE: createDisplay(args)
    activate CE
    CE -->> SF: return compositionDisplay
    deactivate CE

    %% 2. 创建 Buffer 管道
    SF ->> BQ: createBufferQueue()
    BQ -->> SF: return (producer, consumer)

    %% 3. 创建 Surface (分叉逻辑)
    alt 是虚拟屏幕 (Virtual)
        SF ->> VDS: new VirtualDisplaySurface(bqProducer, ...)
        VDS -->> SF: return displaySurface
    else 是物理屏幕 (Physical)
        SF ->> FBS: new FramebufferSurface(hwc, displayId, consumer, ...)
        FBS -->> SF: return displaySurface
    end

    %% 4. 创建 DisplayDevice 对象
    SF ->> SF: setupNewDisplayDeviceInternal(...)
    SF ->> DD: new DisplayDevice(compositionDisplay, displaySurface, ...)
    activate DD
    DD -->> SF: return displayDevice
    deactivate DD
    end

    %% === 第四阶段：注册与激活 ===
    rect rgb(240, 255, 240)
    note right of SF: 阶段 3: 注册与激活
    
    alt 物理屏幕
        SF ->> Scheduler: registerDisplay(physicalId, refreshRateSelector)
    end

    SF ->> SF: mDisplays.add(token, displayDevice)
    
    opt 如果是物理屏幕
        SF ->> HWC: setPowerMode(ON)
        SF ->> SF: onActiveDisplayChangedLocked (如果是主屏)
    end
    end
Display的管理
@startuml
!theme plain
hide empty members
' 强制使用直角线，避免曲线
skinparam linetype ortho
' 增加节点间距，防止挤在一起
skinparam nodesep 80
skinparam ranksep 60

' ==========================================
' 核心类定义
' ==========================================

class SurfaceFlinger {
    - mDisplays
    + processDisplayAdded()
}

class DisplayDevice {
    - mCompositionDisplay
    - mDisplaySurface
}

class Display {
    ' 逻辑对象
}

abstract class Output {
    - mRenderSurface
    + composeSurfaces()
}

class RenderSurface {
    - mNativeWindow
    - mDisplaySurface
    + queueBuffer()
}
note left of RenderSurface
    <b>[双面胶]</b>
    左手: 数据流 (NativeWindow)
    右手: 控制流 (DisplaySurface)
end note

class RenderEngine {
    + drawLayers()
}

interface DisplaySurface {
    + advanceFrame()
}

class FramebufferSurface {
    + advanceFrame()
    + setClientTarget()
}

interface &#34;\t\tANativeWindow\t\t&#34; as ANativeWindow{
    + queueBuffer()
}

class HWComposer {
    + setClientTarget()
}

' ==========================================
' 底层 BufferQueue 定义 (使用 together 强制在一起)
' ==========================================
package &#34;BufferQueue System&#34; <<Rectangle>> {
    interface IGraphicBufferProducer
    class BufferQueue
    interface IGraphicBufferConsumer
}

' ==========================================
' 关系连线 (精心设计的布局方向)
' ==========================================

' 1. 顶层管理
SurfaceFlinger -down-> DisplayDevice : 管理

' 2. DisplayDevice 分流 (关键布局点)
' 向下连接逻辑，向右连接管道，把图撑开
DisplayDevice -down-> Display : 持有逻辑\n(CompositionEngine)
DisplayDevice -right-> DisplaySurface : 持有

' 3. 左侧：逻辑合成链路 (Vertical)
Display -down-|> Output
Output -down-> RenderSurface : 拥有
Output .left.> RenderEngine : 指挥绘图
RenderEngine .right.> RenderSurface : 绘制目标

' 4. RenderSurface 的分发 (关键枢纽)
' 向右连接控制流
RenderSurface -right-> DisplaySurface : 1.控制流\n(advanceFrame)
' 向下连接数据流
RenderSurface -down-> ANativeWindow : 2.数据流\n(queueBuffer)

' 5. 右侧：实现层 (Vertical)
FramebufferSurface .up.|> DisplaySurface : 实现
FramebufferSurface .up.|> ANativeWindow : 提供后端
FramebufferSurface -right-> HWComposer : 提交\n(setClientTarget)

' 6. 底部：BufferQueue 闭环
ANativeWindow -down-> IGraphicBufferProducer : 封装
IGraphicBufferProducer -right-o BufferQueue : 写入
BufferQueue o-right- IGraphicBufferConsumer : 读取
IGraphicBufferConsumer -up-> FramebufferSurface : 消费

' 7. 布局辅助 (水平对齐)
' 强制 RenderSurface 和 DisplaySurface 在同一水平线上
RenderSurface -[hidden]right- DisplaySurface

@enduml
总结数据流向"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"Display Manager","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/"},{"@type":"ListItem","position":3,"name":"","item":"https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Display创建过程 sequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box \u0026#34;触发源 (Triggers)\u0026#34; #f9f9f9 participant HWC participant DisplayManagerService end box \u0026#34;SurfaceFlinger\u0026#34; #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC -\u0026gt;\u0026gt; SF: onHotplugReceived(displayId, connected=true) SF -\u0026gt;\u0026gt; SF: update mCurrentState (add Display) SF -\u0026gt;\u0026gt; SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService -\u0026gt;\u0026gt; SF: createDisplay(name, secure) SF -\u0026gt;\u0026gt; SF: update mCurrentState (add Display) SF -\u0026gt;\u0026gt; SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF -\u0026gt;\u0026gt; SF: onMessageInvalidate() -\u0026gt; handleMessageTransaction() SF -\u0026gt;\u0026gt; SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token\u0026lt;br/\u0026gt;而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF -\u0026gt;\u0026gt; SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF -\u0026gt;\u0026gt; CE: createDisplay(args) activate CE CE --\u0026gt;\u0026gt; SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF -\u0026gt;\u0026gt; BQ: createBufferQueue() BQ --\u0026gt;\u0026gt; SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) alt 是虚拟屏幕 (Virtual) SF -\u0026gt;\u0026gt; VDS: new VirtualDisplaySurface(bqProducer, ...) VDS --\u0026gt;\u0026gt; SF: return displaySurface else 是物理屏幕 (Physical) SF -\u0026gt;\u0026gt; FBS: new FramebufferSurface(hwc, displayId, consumer, ...) FBS --\u0026gt;\u0026gt; SF: return displaySurface end %% 4. 创建 DisplayDevice 对象 SF -\u0026gt;\u0026gt; SF: setupNewDisplayDeviceInternal(...) SF -\u0026gt;\u0026gt; DD: new DisplayDevice(compositionDisplay, displaySurface, ...) activate DD DD --\u0026gt;\u0026gt; SF: return displayDevice deactivate DD end %% === 第四阶段：注册与激活 === rect rgb(240, 255, 240) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF -\u0026gt;\u0026gt; Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF -\u0026gt;\u0026gt; SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF -\u0026gt;\u0026gt; HWC: setPowerMode(ON) SF -\u0026gt;\u0026gt; SF: onActiveDisplayChangedLocked (如果是主屏) end end Display的管理 @startuml !theme plain hide empty members \u0026#39; 强制使用直角线，避免曲线 skinparam linetype ortho \u0026#39; 增加节点间距，防止挤在一起 skinparam nodesep 80 skinparam ranksep 60 \u0026#39; ========================================== \u0026#39; 核心类定义 \u0026#39; ========================================== class SurfaceFlinger { - mDisplays + processDisplayAdded() } class DisplayDevice { - mCompositionDisplay - mDisplaySurface } class Display { \u0026#39; 逻辑对象 } abstract class Output { - mRenderSurface + composeSurfaces() } class RenderSurface { - mNativeWindow - mDisplaySurface + queueBuffer() } note left of RenderSurface \u0026lt;b\u0026gt;[双面胶]\u0026lt;/b\u0026gt; 左手: 数据流 (NativeWindow) 右手: 控制流 (DisplaySurface) end note class RenderEngine { + drawLayers() } interface DisplaySurface { + advanceFrame() } class FramebufferSurface { + advanceFrame() + setClientTarget() } interface \u0026#34;\\t\\tANativeWindow\\t\\t\u0026#34; as ANativeWindow{ + queueBuffer() } class HWComposer { + setClientTarget() } \u0026#39; ========================================== \u0026#39; 底层 BufferQueue 定义 (使用 together 强制在一起) \u0026#39; ========================================== package \u0026#34;BufferQueue System\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt; { interface IGraphicBufferProducer class BufferQueue interface IGraphicBufferConsumer } \u0026#39; ========================================== \u0026#39; 关系连线 (精心设计的布局方向) \u0026#39; ========================================== \u0026#39; 1. 顶层管理 SurfaceFlinger -down-\u0026gt; DisplayDevice : 管理 \u0026#39; 2. DisplayDevice 分流 (关键布局点) \u0026#39; 向下连接逻辑，向右连接管道，把图撑开 DisplayDevice -down-\u0026gt; Display : 持有逻辑\\n(CompositionEngine) DisplayDevice -right-\u0026gt; DisplaySurface : 持有 \u0026#39; 3. 左侧：逻辑合成链路 (Vertical) Display -down-|\u0026gt; Output Output -down-\u0026gt; RenderSurface : 拥有 Output .left.\u0026gt; RenderEngine : 指挥绘图 RenderEngine .right.\u0026gt; RenderSurface : 绘制目标 \u0026#39; 4. RenderSurface 的分发 (关键枢纽) \u0026#39; 向右连接控制流 RenderSurface -right-\u0026gt; DisplaySurface : 1.控制流\\n(advanceFrame) \u0026#39; 向下连接数据流 RenderSurface -down-\u0026gt; ANativeWindow : 2.数据流\\n(queueBuffer) \u0026#39; 5. 右侧：实现层 (Vertical) FramebufferSurface .up.|\u0026gt; DisplaySurface : 实现 FramebufferSurface .up.|\u0026gt; ANativeWindow : 提供后端 FramebufferSurface -right-\u0026gt; HWComposer : 提交\\n(setClientTarget) \u0026#39; 6. 底部：BufferQueue 闭环 ANativeWindow -down-\u0026gt; IGraphicBufferProducer : 封装 IGraphicBufferProducer -right-o BufferQueue : 写入 BufferQueue o-right- IGraphicBufferConsumer : 读取 IGraphicBufferConsumer -up-\u0026gt; FramebufferSurface : 消费 \u0026#39; 7. 布局辅助 (水平对齐) \u0026#39; 强制 RenderSurface 和 DisplaySurface 在同一水平线上 RenderSurface -[hidden]right- DisplaySurface @enduml 总结数据流向\n","keywords":[],"articleBody":"Display创建过程 sequenceDiagram autonumber %% 定义参与者 participant HWC as HWC/Kernel participant DisplayManagerService as DisplayManagerService participant SF as SurfaceFlinger(MainThread) participant CE as CompositionEngine participant BQ as BufferQueue participant VDS as VirtualDisplaySurface participant FBS as FramebufferSurface participant DD as DisplayDevice participant Scheduler as Scheduler box \"触发源 (Triggers)\" #f9f9f9 participant HWC participant DisplayManagerService end box \"SurfaceFlinger\" #e1f5fe participant SF participant Scheduler participant DD participant CE participant BQ participant VDS participant FBS end %% === 第一阶段：触发 === rect rgb(255, 240, 240) note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟) alt 物理屏幕插入 (Hotplug) HWC -\u003e\u003e SF: onHotplugReceived(displayId, connected=true) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) else 虚拟屏幕请求 (Virtual) DisplayManagerService -\u003e\u003e SF: createDisplay(name, secure) SF -\u003e\u003e SF: update mCurrentState (add Display) SF -\u003e\u003e SF: setTransactionFlags(eDisplayTransactionNeeded) end end %% === 第二阶段：主循环处理 === SF -\u003e\u003e SF: onMessageInvalidate() -\u003e handleMessageTransaction() SF -\u003e\u003e SF: processDisplayChangesLocked() note right of SF: 发现 mCurrentState 有新 token而 mDrawingState 没有 %% === 第三阶段：核心工厂方法 === rect rgb(255, 250, 230) note right of SF: 阶段 2: 核心工厂 (processDisplayAdded) SF -\u003e\u003e SF: processDisplayAdded(token, state) %% 1. 创建 CE Display SF -\u003e\u003e CE: createDisplay(args) activate CE CE --\u003e\u003e SF: return compositionDisplay deactivate CE %% 2. 创建 Buffer 管道 SF -\u003e\u003e BQ: createBufferQueue() BQ --\u003e\u003e SF: return (producer, consumer) %% 3. 创建 Surface (分叉逻辑) alt 是虚拟屏幕 (Virtual) SF -\u003e\u003e VDS: new VirtualDisplaySurface(bqProducer, ...) VDS --\u003e\u003e SF: return displaySurface else 是物理屏幕 (Physical) SF -\u003e\u003e FBS: new FramebufferSurface(hwc, displayId, consumer, ...) FBS --\u003e\u003e SF: return displaySurface end %% 4. 创建 DisplayDevice 对象 SF -\u003e\u003e SF: setupNewDisplayDeviceInternal(...) SF -\u003e\u003e DD: new DisplayDevice(compositionDisplay, displaySurface, ...) activate DD DD --\u003e\u003e SF: return displayDevice deactivate DD end %% === 第四阶段：注册与激活 === rect rgb(240, 255, 240) note right of SF: 阶段 3: 注册与激活 alt 物理屏幕 SF -\u003e\u003e Scheduler: registerDisplay(physicalId, refreshRateSelector) end SF -\u003e\u003e SF: mDisplays.add(token, displayDevice) opt 如果是物理屏幕 SF -\u003e\u003e HWC: setPowerMode(ON) SF -\u003e\u003e SF: onActiveDisplayChangedLocked (如果是主屏) end end Display的管理 @startuml !theme plain hide empty members ' 强制使用直角线，避免曲线 skinparam linetype ortho ' 增加节点间距，防止挤在一起 skinparam nodesep 80 skinparam ranksep 60 ' ========================================== ' 核心类定义 ' ========================================== class SurfaceFlinger { - mDisplays + processDisplayAdded() } class DisplayDevice { - mCompositionDisplay - mDisplaySurface } class Display { ' 逻辑对象 } abstract class Output { - mRenderSurface + composeSurfaces() } class RenderSurface { - mNativeWindow - mDisplaySurface + queueBuffer() } note left of RenderSurface [双面胶] 左手: 数据流 (NativeWindow) 右手: 控制流 (DisplaySurface) end note class RenderEngine { + drawLayers() } interface DisplaySurface { + advanceFrame() } class FramebufferSurface { + advanceFrame() + setClientTarget() } interface \"\\t\\tANativeWindow\\t\\t\" as ANativeWindow{ + queueBuffer() } class HWComposer { + setClientTarget() } ' ========================================== ' 底层 BufferQueue 定义 (使用 together 强制在一起) ' ========================================== package \"BufferQueue System\" \u003c\u003e { interface IGraphicBufferProducer class BufferQueue interface IGraphicBufferConsumer } ' ========================================== ' 关系连线 (精心设计的布局方向) ' ========================================== ' 1. 顶层管理 SurfaceFlinger -down-\u003e DisplayDevice : 管理 ' 2. DisplayDevice 分流 (关键布局点) ' 向下连接逻辑，向右连接管道，把图撑开 DisplayDevice -down-\u003e Display : 持有逻辑\\n(CompositionEngine) DisplayDevice -right-\u003e DisplaySurface : 持有 ' 3. 左侧：逻辑合成链路 (Vertical) Display -down-|\u003e Output Output -down-\u003e RenderSurface : 拥有 Output .left.\u003e RenderEngine : 指挥绘图 RenderEngine .right.\u003e RenderSurface : 绘制目标 ' 4. RenderSurface 的分发 (关键枢纽) ' 向右连接控制流 RenderSurface -right-\u003e DisplaySurface : 1.控制流\\n(advanceFrame) ' 向下连接数据流 RenderSurface -down-\u003e ANativeWindow : 2.数据流\\n(queueBuffer) ' 5. 右侧：实现层 (Vertical) FramebufferSurface .up.|\u003e DisplaySurface : 实现 FramebufferSurface .up.|\u003e ANativeWindow : 提供后端 FramebufferSurface -right-\u003e HWComposer : 提交\\n(setClientTarget) ' 6. 底部：BufferQueue 闭环 ANativeWindow -down-\u003e IGraphicBufferProducer : 封装 IGraphicBufferProducer -right-o BufferQueue : 写入 BufferQueue o-right- IGraphicBufferConsumer : 读取 IGraphicBufferConsumer -up-\u003e FramebufferSurface : 消费 ' 7. 布局辅助 (水平对齐) ' 强制 RenderSurface 和 DisplaySurface 在同一水平线上 RenderSurface -[hidden]right- DisplaySurface @enduml 总结数据流向\n[RenderEngine] | (绘制 GPU 合成部分) v [IGraphicBufferProducer] --\u003e [BufferQueue] --\u003e [IGraphicBufferConsumer] | v [FramebufferSurface] | (setClientTarget) v [HWComposer] --\u003e [物理屏幕] Scheduler Scheduler 是 SurfaceFlinger 的核心组件，充当图形渲染系统的**“指挥家”和“节拍器”**。它的主要职责是管理系统的时间基准（Timing）和刷新率策略。\n它负责解决两个核心问题：\nWhen to draw (时机)：生成和分发 VSYNC 信号，驱动 App 渲染和 SF 合成。 How fast to draw (频率)：根据内容、交互和热状态，动态调整显示屏的刷新率（60Hz, 90Hz, 120Hz 等），以平衡流畅度与功耗。 核心架构图 (Architecture) Scheduler 处于 HWC（硬件层）与 App/SF（逻辑层）的中间，负责协调上下游。\ngraph TD %% 外部输入 subgraph Inputs [输入信号] HWC_Vsync[HWC VSYNC 信号] Touch[Input 触摸事件] Layers[Layer 更新频率] Power[电源/热状态] end %% Scheduler 核心 subgraph Scheduler_Core [Scheduler] direction TB VsyncModulator[VsyncModulator相位控制] LayerHistory[LayerHistoryFPS检测] Policy[RefreshRate Policy策略决策] subgraph Timers [状态机定时器] IdleTimer[Idle Timer] TouchTimer[Touch Timer] end Pacesetter[Pacesetter Logic多屏领跑机制] end %% 输出分发 subgraph EventThreads [VSYNC 分发] AppET[EventThread AppCycle::Render] SfET[EventThread SFCycle::LastComposite] end %% 最终输出 subgraph Outputs [输出动作] Choreographer[App Choreographer] SF_Main[SF Main Thread] HWC_Config[HWC Config/Mode切帧率] end %% 连线 HWC_Vsync --\u003e Scheduler_Core Touch --\u003e TouchTimer Layers --\u003e LayerHistory Scheduler_Core --\u003e AppET Scheduler_Core --\u003e SfET AppET --\u003e Choreographer SfET --\u003e SF_Main Policy --\u003e HWC_Config IGraphicBufferProducer --o BufferQueue : \"写入\" BufferQueue o-- IGraphicBufferConsumer : \"读取\" FramebufferSurface \u003c-- IGraphicBufferConsumer : \"消费\" class HWComposer { + setClientTarget() } FramebufferSurface ..\u003e HWComposer : \"提交\" 核心机制详解 VSYNC 信号分发 Scheduler 并不直接把硬件 VSYNC 发送给所有人，而是通过 EventThread 进行解耦和分发。\n硬件同步 (resyncToHardwareVsync): Scheduler 监听 HWC 的硬件 VSYNC，并利用内部模型计算出精确的“软件 VSYNC”时间点。这允许系统在必要时关闭硬件 VSYNC 以省电（由软件定时器模拟）。 双路分发: Cycle::Render (App VSYNC): 发送给 App 的 Choreographer。包含一定的相位偏移 (Phase Offset)，让 App 在屏幕刷新之前的一段时间开始画图。 Cycle::LastComposite (SF VSYNC): 发送给 SurfaceFlinger 主线程。通常晚于 App VSYNC，用于收集 App 画好的 Buffer 进行合成。 智能刷新率决策 (Refresh Rate Selection) Scheduler 维护了一套复杂的策略状态机，决定当前最佳的 Display Mode。\n触发源 机制类 行为逻辑 内容侦测 LayerHistory 记录每个 Layer 的提交时间戳，计算 FPS。\n例如：检测到视频播放 (24/30fps)，可能调整屏幕为 60Hz 或 120Hz 以匹配倍数；检测到游戏 (High FPS)，推高刷新率。 用户交互 TouchTimer 当检测到触摸事件时，强制 Boost 到最高刷新率（如 120Hz），保证跟手性。触摸停止一段时间后回落。 屏幕空闲 IdleTimer 当屏幕一段时间没有 Layer 更新时，降低刷新率（如 60Hz 或更低）以省电。 系统限制 Thermal/Power 当系统过热或开启省电模式时，强制限制最高刷新率。 多屏领跑机制 (Pacesetter) 在多屏设备中，为了防止不同刷新率的屏幕导致 VSYNC 混乱，Scheduler 引入了 Pacesetter (领跑者) 概念。\nPacesetter: 选定一个主屏幕（通常是获焦的屏幕）。Scheduler 的主 VSYNC 节拍由该屏幕决定。 Followers: 其他屏幕作为跟随者。它们的合成时机是根据 Pacesetter 的时间轴计算出来的偏移量。 代码体现: promotePacesetterDisplay, registerDisplayInternal. 驱动合成循环 (Frame Orchestration) Scheduler 不仅负责发信号，还通过回调驱动每一帧的实际工作流程。\n核心函数: onFrameSignal(ICompositor\u0026 compositor, ...)\nvoid Scheduler::onFrameSignal(...) { // 1. 准备阶段：计算预期时间 beginFrameArgs = ...; // 2. 通知各 Display 的 Targeter 准备 (Layer 更新) pacesetter-\u003etargeterPtr-\u003ebeginFrame(...); // 3. 提交事务 (Commit) // 处理 WindowManager 的事务，Layer 属性变化等 compositor.commit(...); // 4. 执行合成 (Composite) // 通知 RenderEngine 进行绘图，或者通知 HWC 准备 Flip compositor.composite(...); // 5. 收尾 targeter-\u003eendFrame(...); } 关键类说明 (Glossary) Scheduler: 门面类，统筹全局。 VsyncSchedule: 管理特定显示屏的 VSYNC 时间表和分发器 (Dispatch)。 VsyncModulator: 动态调节 VSYNC 的相位偏移 (Phase Offsets)。例如在 App 频繁掉帧时，可能会调整偏移量给 App 更多的时间。 LayerHistory: 历史记录器。它知道哪些 Layer 是“活跃”的，以及它们的平均帧率。 EventThread: 一个独立的线程，通过 BitTube (Socket) 将 VSYNC 信号发送给跨进程的客户端 (App)。 FrameTargeter: 负责计算每一帧的目标渲染时间点。 工作流时序 (Sequence Diagrams) 5.1 触摸升频流程 (Touch Boost) sequenceDiagram participant Touch as InputSystem participant Sched as Scheduler participant Timer as TouchTimer participant Policy as PolicyLogic participant HWC as HWC Touch-\u003e\u003eSched: onTouchHint() Sched-\u003e\u003eTimer: reset() Timer--\u003e\u003ePolicy: Callback(TimerState::Reset) rect rgb(230, 240, 255) Note right of Policy: 策略判定：进入 Touch 状态 Policy-\u003e\u003ePolicy: Current Mode = 120Hz (Max) end Policy-\u003e\u003eHWC: setActiveConfig(120Hz) HWC--\u003e\u003eSched: VSYNC (120Hz) 帧率检测与切换 (Content Detection) sequenceDiagram participant App as VideoApp participant LH as LayerHistory participant Sched as Scheduler participant HWC loop 播放视频 (30fps) App-\u003e\u003eSched: queueBuffer (T1) App-\u003e\u003eSched: queueBuffer (T2) Sched-\u003e\u003eLH: record(LayerID, PresentTime) end LH-\u003e\u003eLH: 分析: 平均间隔 33ms -\u003e 30fps LH--\u003e\u003eSched: Summary: Vote for 30Hz/60Hz Sched-\u003e\u003eSched: chooseDisplayModes() Note right of Sched: 最佳匹配: 60Hz (30的倍数) Sched-\u003e\u003eHWC: setActiveConfig(60Hz) 常见调试命令 在终端中可以使用 dumpsys 查看 Scheduler 的内部状态：\n# 查看 SurfaceFlinger 完整信息 (包含 Scheduler) adb shell dumpsys SurfaceFlinger # 仅查看 Scheduler 部分 (依赖实现) adb shell dumpsys SurfaceFlinger --section Scheduler # 关键输出解读: # Pacesetter Display: 当前领跑的屏幕 ID # LayerHistory: 各个 Layer 的检测帧率 # VsyncSchedule: 当前 Vsync 的周期和偏移量 ","wordCount":"1086","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/display/surfaceflinger_composition/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/display/>Display Manager</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>6 min&nbsp;·&nbsp;1086 words</div></header><div class=post-content><h2 id=display创建过程>Display创建过程<a hidden class=anchor aria-hidden=true href=#display创建过程>#</a></h2><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    autonumber
    
    %% 定义参与者
    participant HWC as HWC/Kernel
    participant DisplayManagerService as DisplayManagerService
    participant SF as SurfaceFlinger(MainThread)
    participant CE as CompositionEngine
    participant BQ as BufferQueue
    participant VDS as VirtualDisplaySurface
    participant FBS as FramebufferSurface
    participant DD as DisplayDevice
    participant Scheduler as Scheduler

    box &#34;触发源 (Triggers)&#34; #f9f9f9
        participant HWC
        participant DisplayManagerService
    end

    box &#34;SurfaceFlinger&#34; #e1f5fe
        participant SF
        participant Scheduler
        participant DD



        participant CE
        participant BQ
        participant VDS
        participant FBS
    end

    %% === 第一阶段：触发 ===
    rect rgb(255, 240, 240)
    note right of SF: 阶段 1: 触发创建 (物理 vs 虚拟)
    
    alt 物理屏幕插入 (Hotplug)
        HWC -&gt;&gt; SF: onHotplugReceived(displayId, connected=true)
        SF -&gt;&gt; SF: update mCurrentState (add Display)
        SF -&gt;&gt; SF: setTransactionFlags(eDisplayTransactionNeeded)
    else 虚拟屏幕请求 (Virtual)
        DisplayManagerService -&gt;&gt; SF: createDisplay(name, secure)
        SF -&gt;&gt; SF: update mCurrentState (add Display)
        SF -&gt;&gt; SF: setTransactionFlags(eDisplayTransactionNeeded)
    end
    end

    %% === 第二阶段：主循环处理 ===
    SF -&gt;&gt; SF: onMessageInvalidate() -&gt; handleMessageTransaction()
    SF -&gt;&gt; SF: processDisplayChangesLocked()
    note right of SF: 发现 mCurrentState 有新 token&lt;br/&gt;而 mDrawingState 没有

    %% === 第三阶段：核心工厂方法 ===
    rect rgb(255, 250, 230)
    note right of SF: 阶段 2: 核心工厂 (processDisplayAdded)
    SF -&gt;&gt; SF: processDisplayAdded(token, state)

    %% 1. 创建 CE Display
    SF -&gt;&gt; CE: createDisplay(args)
    activate CE
    CE --&gt;&gt; SF: return compositionDisplay
    deactivate CE

    %% 2. 创建 Buffer 管道
    SF -&gt;&gt; BQ: createBufferQueue()
    BQ --&gt;&gt; SF: return (producer, consumer)

    %% 3. 创建 Surface (分叉逻辑)
    alt 是虚拟屏幕 (Virtual)
        SF -&gt;&gt; VDS: new VirtualDisplaySurface(bqProducer, ...)
        VDS --&gt;&gt; SF: return displaySurface
    else 是物理屏幕 (Physical)
        SF -&gt;&gt; FBS: new FramebufferSurface(hwc, displayId, consumer, ...)
        FBS --&gt;&gt; SF: return displaySurface
    end

    %% 4. 创建 DisplayDevice 对象
    SF -&gt;&gt; SF: setupNewDisplayDeviceInternal(...)
    SF -&gt;&gt; DD: new DisplayDevice(compositionDisplay, displaySurface, ...)
    activate DD
    DD --&gt;&gt; SF: return displayDevice
    deactivate DD
    end

    %% === 第四阶段：注册与激活 ===
    rect rgb(240, 255, 240)
    note right of SF: 阶段 3: 注册与激活
    
    alt 物理屏幕
        SF -&gt;&gt; Scheduler: registerDisplay(physicalId, refreshRateSelector)
    end

    SF -&gt;&gt; SF: mDisplays.add(token, displayDevice)
    
    opt 如果是物理屏幕
        SF -&gt;&gt; HWC: setPowerMode(ON)
        SF -&gt;&gt; SF: onActiveDisplayChangedLocked (如果是主屏)
    end
    end
</code></pre><h2 id=display的管理>Display的管理<a hidden class=anchor aria-hidden=true href=#display的管理>#</a></h2><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
hide empty members
&#39; 强制使用直角线，避免曲线
skinparam linetype ortho
&#39; 增加节点间距，防止挤在一起
skinparam nodesep 80
skinparam ranksep 60

&#39; ==========================================
&#39; 核心类定义
&#39; ==========================================

class SurfaceFlinger {
    - mDisplays
    + processDisplayAdded()
}

class DisplayDevice {
    - mCompositionDisplay
    - mDisplaySurface
}

class Display {
    &#39; 逻辑对象
}

abstract class Output {
    - mRenderSurface
    + composeSurfaces()
}

class RenderSurface {
    - mNativeWindow
    - mDisplaySurface
    + queueBuffer()
}
note left of RenderSurface
    &lt;b&gt;[双面胶]&lt;/b&gt;
    左手: 数据流 (NativeWindow)
    右手: 控制流 (DisplaySurface)
end note

class RenderEngine {
    + drawLayers()
}

interface DisplaySurface {
    + advanceFrame()
}

class FramebufferSurface {
    + advanceFrame()
    + setClientTarget()
}

interface &#34;\t\tANativeWindow\t\t&#34; as ANativeWindow{
    + queueBuffer()
}

class HWComposer {
    + setClientTarget()
}

&#39; ==========================================
&#39; 底层 BufferQueue 定义 (使用 together 强制在一起)
&#39; ==========================================
package &#34;BufferQueue System&#34; &lt;&lt;Rectangle&gt;&gt; {
    interface IGraphicBufferProducer
    class BufferQueue
    interface IGraphicBufferConsumer
}

&#39; ==========================================
&#39; 关系连线 (精心设计的布局方向)
&#39; ==========================================

&#39; 1. 顶层管理
SurfaceFlinger -down-&gt; DisplayDevice : 管理

&#39; 2. DisplayDevice 分流 (关键布局点)
&#39; 向下连接逻辑，向右连接管道，把图撑开
DisplayDevice -down-&gt; Display : 持有逻辑\n(CompositionEngine)
DisplayDevice -right-&gt; DisplaySurface : 持有

&#39; 3. 左侧：逻辑合成链路 (Vertical)
Display -down-|&gt; Output
Output -down-&gt; RenderSurface : 拥有
Output .left.&gt; RenderEngine : 指挥绘图
RenderEngine .right.&gt; RenderSurface : 绘制目标

&#39; 4. RenderSurface 的分发 (关键枢纽)
&#39; 向右连接控制流
RenderSurface -right-&gt; DisplaySurface : 1.控制流\n(advanceFrame)
&#39; 向下连接数据流
RenderSurface -down-&gt; ANativeWindow : 2.数据流\n(queueBuffer)

&#39; 5. 右侧：实现层 (Vertical)
FramebufferSurface .up.|&gt; DisplaySurface : 实现
FramebufferSurface .up.|&gt; ANativeWindow : 提供后端
FramebufferSurface -right-&gt; HWComposer : 提交\n(setClientTarget)

&#39; 6. 底部：BufferQueue 闭环
ANativeWindow -down-&gt; IGraphicBufferProducer : 封装
IGraphicBufferProducer -right-o BufferQueue : 写入
BufferQueue o-right- IGraphicBufferConsumer : 读取
IGraphicBufferConsumer -up-&gt; FramebufferSurface : 消费

&#39; 7. 布局辅助 (水平对齐)
&#39; 强制 RenderSurface 和 DisplaySurface 在同一水平线上
RenderSurface -[hidden]right- DisplaySurface

@enduml
</code></pre><p>总结数据流向</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>[RenderEngine] 
</span></span><span style=display:flex><span>      | (绘制 GPU 合成部分)
</span></span><span style=display:flex><span>      v
</span></span><span style=display:flex><span>[IGraphicBufferProducer] --&gt; [BufferQueue] --&gt; [IGraphicBufferConsumer]
</span></span><span style=display:flex><span>                                                      |
</span></span><span style=display:flex><span>                                                      v
</span></span><span style=display:flex><span>                                             [FramebufferSurface]
</span></span><span style=display:flex><span>                                                      | (setClientTarget)
</span></span><span style=display:flex><span>                                                      v
</span></span><span style=display:flex><span>                                                [HWComposer] --&gt; [物理屏幕]
</span></span></code></pre></div><hr><h2 id=scheduler>Scheduler<a hidden class=anchor aria-hidden=true href=#scheduler>#</a></h2><p><strong>Scheduler</strong> 是 SurfaceFlinger 的核心组件，充当图形渲染系统的**“指挥家”<strong>和</strong>“节拍器”**。它的主要职责是管理系统的时间基准（Timing）和刷新率策略。</p><p>它负责解决两个核心问题：</p><ol><li><strong>When to draw (时机)</strong>：生成和分发 VSYNC 信号，驱动 App 渲染和 SF 合成。</li><li><strong>How fast to draw (频率)</strong>：根据内容、交互和热状态，动态调整显示屏的刷新率（60Hz, 90Hz, 120Hz 等），以平衡流畅度与功耗。</li></ol><h3 id=核心架构图-architecture>核心架构图 (Architecture)<a hidden class=anchor aria-hidden=true href=#核心架构图-architecture>#</a></h3><p>Scheduler 处于 HWC（硬件层）与 App/SF（逻辑层）的中间，负责协调上下游。</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TD
    %% 外部输入
    subgraph Inputs [输入信号]
        HWC_Vsync[HWC VSYNC 信号]
        Touch[Input 触摸事件]
        Layers[Layer 更新频率]
        Power[电源/热状态]
    end

    %% Scheduler 核心
    subgraph Scheduler_Core [Scheduler]
        direction TB
        
        VsyncModulator[VsyncModulator&lt;br/&gt;相位控制]
        LayerHistory[LayerHistory&lt;br/&gt;FPS检测]
        Policy[RefreshRate Policy&lt;br/&gt;策略决策]
        
        subgraph Timers [状态机定时器]
            IdleTimer[Idle Timer]
            TouchTimer[Touch Timer]
        end
        
        Pacesetter[Pacesetter Logic&lt;br/&gt;多屏领跑机制]
    end

    %% 输出分发
    subgraph EventThreads [VSYNC 分发]
        AppET[EventThread App&lt;br/&gt;Cycle::Render]
        SfET[EventThread SF&lt;br/&gt;Cycle::LastComposite]
    end

    %% 最终输出
    subgraph Outputs [输出动作]
        Choreographer[App Choreographer]
        SF_Main[SF Main Thread]
        HWC_Config[HWC Config/Mode&lt;br/&gt;切帧率]
    end

    %% 连线
    HWC_Vsync --&gt; Scheduler_Core
    Touch --&gt; TouchTimer
    Layers --&gt; LayerHistory
    
    Scheduler_Core --&gt; AppET
    Scheduler_Core --&gt; SfET
    
    AppET --&gt; Choreographer
    SfET --&gt; SF_Main
    
    Policy --&gt; HWC_Config
</code></pre><pre><code>IGraphicBufferProducer --o BufferQueue : &quot;写入&quot;
BufferQueue o-- IGraphicBufferConsumer : &quot;读取&quot;


FramebufferSurface &lt;-- IGraphicBufferConsumer : &quot;消费&quot;

class HWComposer {
    + setClientTarget()
}
FramebufferSurface ..&gt; HWComposer : &quot;提交&quot;
</code></pre><h3 id=核心机制详解>核心机制详解<a hidden class=anchor aria-hidden=true href=#核心机制详解>#</a></h3><h4 id=vsync-信号分发>VSYNC 信号分发<a hidden class=anchor aria-hidden=true href=#vsync-信号分发>#</a></h4><p>Scheduler 并不直接把硬件 VSYNC 发送给所有人，而是通过 <strong><code>EventThread</code></strong> 进行解耦和分发。</p><ul><li><strong>硬件同步 (<code>resyncToHardwareVsync</code>)</strong>: Scheduler 监听 HWC 的硬件 VSYNC，并利用内部模型计算出精确的“软件 VSYNC”时间点。这允许系统在必要时关闭硬件 VSYNC 以省电（由软件定时器模拟）。</li><li><strong>双路分发</strong>:<ul><li><strong><code>Cycle::Render</code> (App VSYNC)</strong>: 发送给 App 的 <code>Choreographer</code>。包含一定的<strong>相位偏移 (Phase Offset)</strong>，让 App 在屏幕刷新之前的一段时间开始画图。</li><li><strong><code>Cycle::LastComposite</code> (SF VSYNC)</strong>: 发送给 SurfaceFlinger 主线程。通常晚于 App VSYNC，用于收集 App 画好的 Buffer 进行合成。</li></ul></li></ul><h4 id=智能刷新率决策-refresh-rate-selection>智能刷新率决策 (Refresh Rate Selection)<a hidden class=anchor aria-hidden=true href=#智能刷新率决策-refresh-rate-selection>#</a></h4><p>Scheduler 维护了一套复杂的策略状态机，决定当前最佳的 Display Mode。</p><table><thead><tr><th>触发源</th><th>机制类</th><th>行为逻辑</th></tr></thead><tbody><tr><td><strong>内容侦测</strong></td><td><code>LayerHistory</code></td><td>记录每个 Layer 的提交时间戳，计算 FPS。<br>例如：检测到视频播放 (24/30fps)，可能调整屏幕为 60Hz 或 120Hz 以匹配倍数；检测到游戏 (High FPS)，推高刷新率。</td></tr><tr><td><strong>用户交互</strong></td><td><code>TouchTimer</code></td><td>当检测到触摸事件时，<strong>强制 Boost</strong> 到最高刷新率（如 120Hz），保证跟手性。触摸停止一段时间后回落。</td></tr><tr><td><strong>屏幕空闲</strong></td><td><code>IdleTimer</code></td><td>当屏幕一段时间没有 Layer 更新时，降低刷新率（如 60Hz 或更低）以省电。</td></tr><tr><td><strong>系统限制</strong></td><td><code>Thermal/Power</code></td><td>当系统过热或开启省电模式时，强制限制最高刷新率。</td></tr></tbody></table><h4 id=多屏领跑机制-pacesetter>多屏领跑机制 (Pacesetter)<a hidden class=anchor aria-hidden=true href=#多屏领跑机制-pacesetter>#</a></h4><p>在多屏设备中，为了防止不同刷新率的屏幕导致 VSYNC 混乱，Scheduler 引入了 <strong>Pacesetter (领跑者)</strong> 概念。</p><ul><li><strong>Pacesetter</strong>: 选定一个主屏幕（通常是获焦的屏幕）。Scheduler 的主 VSYNC 节拍由该屏幕决定。</li><li><strong>Followers</strong>: 其他屏幕作为跟随者。它们的合成时机是根据 Pacesetter 的时间轴计算出来的偏移量。</li><li><strong>代码体现</strong>: <code>promotePacesetterDisplay</code>, <code>registerDisplayInternal</code>.</li></ul><h4 id=驱动合成循环-frame-orchestration>驱动合成循环 (Frame Orchestration)<a hidden class=anchor aria-hidden=true href=#驱动合成循环-frame-orchestration>#</a></h4><p>Scheduler 不仅负责发信号，还通过回调驱动每一帧的实际工作流程。</p><p><strong>核心函数</strong>: <code>onFrameSignal(ICompositor& compositor, ...)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Scheduler<span style=color:#f92672>::</span>onFrameSignal(...) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 准备阶段：计算预期时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    beginFrameArgs <span style=color:#f92672>=</span> ...;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 通知各 Display 的 Targeter 准备 (Layer 更新)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pacesetter<span style=color:#f92672>-&gt;</span>targeterPtr<span style=color:#f92672>-&gt;</span>beginFrame(...);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 提交事务 (Commit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 处理 WindowManager 的事务，Layer 属性变化等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    compositor.commit(...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 执行合成 (Composite)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 通知 RenderEngine 进行绘图，或者通知 HWC 准备 Flip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    compositor.composite(...);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 收尾
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    targeter<span style=color:#f92672>-&gt;</span>endFrame(...);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=关键类说明-glossary>关键类说明 (Glossary)<a hidden class=anchor aria-hidden=true href=#关键类说明-glossary>#</a></h3><ul><li><strong><code>Scheduler</code></strong>: 门面类，统筹全局。</li><li><strong><code>VsyncSchedule</code></strong>: 管理特定显示屏的 VSYNC 时间表和分发器 (<code>Dispatch</code>)。</li><li><strong><code>VsyncModulator</code></strong>: 动态调节 VSYNC 的相位偏移 (Phase Offsets)。例如在 App 频繁掉帧时，可能会调整偏移量给 App 更多的时间。</li><li><strong><code>LayerHistory</code></strong>: 历史记录器。它知道哪些 Layer 是“活跃”的，以及它们的平均帧率。</li><li><strong><code>EventThread</code></strong>: 一个独立的线程，通过 <code>BitTube</code> (Socket) 将 VSYNC 信号发送给跨进程的客户端 (App)。</li><li><strong><code>FrameTargeter</code></strong>: 负责计算每一帧的目标渲染时间点。</li></ul><h3 id=工作流时序-sequence-diagrams>工作流时序 (Sequence Diagrams)<a hidden class=anchor aria-hidden=true href=#工作流时序-sequence-diagrams>#</a></h3><h4 id=51-触摸升频流程-touch-boost>5.1 触摸升频流程 (Touch Boost)<a hidden class=anchor aria-hidden=true href=#51-触摸升频流程-touch-boost>#</a></h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant Touch as InputSystem
    participant Sched as Scheduler
    participant Timer as TouchTimer
    participant Policy as PolicyLogic
    participant HWC as HWC

    Touch-&gt;&gt;Sched: onTouchHint()
    Sched-&gt;&gt;Timer: reset()
    Timer--&gt;&gt;Policy: Callback(TimerState::Reset)
    
    rect rgb(230, 240, 255)
    Note right of Policy: 策略判定：进入 Touch 状态
    Policy-&gt;&gt;Policy: Current Mode = 120Hz (Max)
    end
    
    Policy-&gt;&gt;HWC: setActiveConfig(120Hz)
    HWC--&gt;&gt;Sched: VSYNC (120Hz)
</code></pre><h4 id=帧率检测与切换-content-detection>帧率检测与切换 (Content Detection)<a hidden class=anchor aria-hidden=true href=#帧率检测与切换-content-detection>#</a></h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant App as VideoApp
    participant LH as LayerHistory
    participant Sched as Scheduler
    participant HWC

    loop 播放视频 (30fps)
        App-&gt;&gt;Sched: queueBuffer (T1)
        App-&gt;&gt;Sched: queueBuffer (T2)
        Sched-&gt;&gt;LH: record(LayerID, PresentTime)
    end

    LH-&gt;&gt;LH: 分析: 平均间隔 33ms -&gt; 30fps
    LH--&gt;&gt;Sched: Summary: Vote for 30Hz/60Hz

    Sched-&gt;&gt;Sched: chooseDisplayModes()
    Note right of Sched: 最佳匹配: 60Hz (30的倍数)
    
    Sched-&gt;&gt;HWC: setActiveConfig(60Hz)
</code></pre><hr><h3 id=常见调试命令>常见调试命令<a hidden class=anchor aria-hidden=true href=#常见调试命令>#</a></h3><p>在终端中可以使用 dumpsys 查看 Scheduler 的内部状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 查看 SurfaceFlinger 完整信息 (包含 Scheduler)</span>
</span></span><span style=display:flex><span>adb shell dumpsys SurfaceFlinger
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 仅查看 Scheduler 部分 (依赖实现)</span>
</span></span><span style=display:flex><span>adb shell dumpsys SurfaceFlinger --section Scheduler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 关键输出解读:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Pacesetter Display: 当前领跑的屏幕 ID</span>
</span></span><span style=display:flex><span><span style=color:#75715e># LayerHistory: 各个 Layer 的检测帧率</span>
</span></span><span style=display:flex><span><span style=color:#75715e># VsyncSchedule: 当前 Vsync 的周期和偏移量</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/display/hwc_setbrightness/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perf_stability_solution/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>