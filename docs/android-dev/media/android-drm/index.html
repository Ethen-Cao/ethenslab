<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Android DRM 框架 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="Widevine Overview

这张图是 Widevine DRM（数字版权管理）视频播放流程 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：

1. 内容准备与分发

Source Media（原始媒体内容）
这是未经加密的音视频源文件。
Shaka Packager（打包器）
将原始媒体文件进行 加密和分片，并打包成 DASH Presentation（自适应流媒体格式）。
DASH Presentation
是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。
CDN（内容分发网络）
DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。


2. 授权与密钥服务

License Service（许可证服务）
管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。
License Proxy
充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。


3. 设备安全与密钥保护

OEM（设备制造商）
在设备中实现 OEMCrypto HAL，并提供硬件安全环境（TEE、Secure OS）。
设备出厂时会存有 Lockbox（Keyboxes），这是设备的安全身份凭证。
Keysith (Provisioning)
用于设备首次激活时的 设备认证与密钥配置，保证终端能安全接收 DRM 密钥。


4. 终端播放流程


Media Player
播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。
播放器检测到内容加密后，会通过 CDM（Content Decryption Module） 请求解密。


CDM
内容解密模块，负责：">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.8d92b99258d2a8aea36dee98116af3631ad91e255aef20c2caa81c9459a68fd8.css" integrity="sha256-jZK5kljSqK6jbe6YEWrzYxrZHiVa7yDCyqgclFmmj9g=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="Android DRM 框架">
  <meta property="og:description" content="Widevine Overview 这张图是 Widevine DRM（数字版权管理）视频播放流程 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：
1. 内容准备与分发 Source Media（原始媒体内容） 这是未经加密的音视频源文件。 Shaka Packager（打包器） 将原始媒体文件进行 加密和分片，并打包成 DASH Presentation（自适应流媒体格式）。 DASH Presentation 是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。 CDN（内容分发网络） DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。 2. 授权与密钥服务 License Service（许可证服务） 管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。 License Proxy 充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。 3. 设备安全与密钥保护 OEM（设备制造商） 在设备中实现 OEMCrypto HAL，并提供硬件安全环境（TEE、Secure OS）。 设备出厂时会存有 Lockbox（Keyboxes），这是设备的安全身份凭证。 Keysith (Provisioning) 用于设备首次激活时的 设备认证与密钥配置，保证终端能安全接收 DRM 密钥。 4. 终端播放流程 Media Player 播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。 播放器检测到内容加密后，会通过 CDM（Content Decryption Module） 请求解密。
CDM 内容解密模块，负责：">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="android-dev">
    <meta property="article:published_time" content="2025-08-08T11:36:11+08:00">
    <meta property="article:modified_time" content="2025-08-08T11:36:11+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android DRM 框架">
<meta name="twitter:description" content="Widevine Overview

这张图是 Widevine DRM（数字版权管理）视频播放流程 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：

1. 内容准备与分发

Source Media（原始媒体内容）
这是未经加密的音视频源文件。
Shaka Packager（打包器）
将原始媒体文件进行 加密和分片，并打包成 DASH Presentation（自适应流媒体格式）。
DASH Presentation
是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。
CDN（内容分发网络）
DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。


2. 授权与密钥服务

License Service（许可证服务）
管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。
License Proxy
充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。


3. 设备安全与密钥保护

OEM（设备制造商）
在设备中实现 OEMCrypto HAL，并提供硬件安全环境（TEE、Secure OS）。
设备出厂时会存有 Lockbox（Keyboxes），这是设备的安全身份凭证。
Keysith (Provisioning)
用于设备首次激活时的 设备认证与密钥配置，保证终端能安全接收 DRM 密钥。


4. 终端播放流程


Media Player
播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。
播放器检测到内容加密后，会通过 CDM（Content Decryption Module） 请求解密。


CDM
内容解密模块，负责：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Android系统开发",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Android Media技术文档",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/media/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Android DRM 框架",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android DRM 框架",
  "name": "Android DRM 框架",
  "description": "Widevine Overview 这张图是 Widevine DRM（数字版权管理）视频播放流程 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：\n1. 内容准备与分发 Source Media（原始媒体内容） 这是未经加密的音视频源文件。 Shaka Packager（打包器） 将原始媒体文件进行 加密和分片，并打包成 DASH Presentation（自适应流媒体格式）。 DASH Presentation 是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。 CDN（内容分发网络） DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。 2. 授权与密钥服务 License Service（许可证服务） 管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。 License Proxy 充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。 3. 设备安全与密钥保护 OEM（设备制造商） 在设备中实现 OEMCrypto HAL，并提供硬件安全环境（TEE、Secure OS）。 设备出厂时会存有 Lockbox（Keyboxes），这是设备的安全身份凭证。 Keysith (Provisioning) 用于设备首次激活时的 设备认证与密钥配置，保证终端能安全接收 DRM 密钥。 4. 终端播放流程 Media Player 播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。 播放器检测到内容加密后，会通过 CDM（Content Decryption Module） 请求解密。\nCDM 内容解密模块，负责：\n",
  "keywords": [
    
  ],
  "articleBody": "Widevine Overview 这张图是 Widevine DRM（数字版权管理）视频播放流程 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：\n1. 内容准备与分发 Source Media（原始媒体内容） 这是未经加密的音视频源文件。 Shaka Packager（打包器） 将原始媒体文件进行 加密和分片，并打包成 DASH Presentation（自适应流媒体格式）。 DASH Presentation 是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。 CDN（内容分发网络） DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。 2. 授权与密钥服务 License Service（许可证服务） 管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。 License Proxy 充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。 3. 设备安全与密钥保护 OEM（设备制造商） 在设备中实现 OEMCrypto HAL，并提供硬件安全环境（TEE、Secure OS）。 设备出厂时会存有 Lockbox（Keyboxes），这是设备的安全身份凭证。 Keysith (Provisioning) 用于设备首次激活时的 设备认证与密钥配置，保证终端能安全接收 DRM 密钥。 4. 终端播放流程 Media Player 播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。 播放器检测到内容加密后，会通过 CDM（Content Decryption Module） 请求解密。\nCDM 内容解密模块，负责：\n与 License Proxy/Service 通信，请求播放许可证（License）。 将密钥请求交给 OEMCrypto HAL。 OEMCrypto HAL 硬件安全层，负责实际的 密钥解密与内容解密（在 TEE/Secure OS 内运行）。 它确保明文内容不会暴露在非安全环境中。\nMedia Output 最终的解密音视频流送入播放器渲染输出。 如果是安全视频（L1 模式），输出会经过 安全视频路径（SVP），防止被截取。\n5. 数据流向说明（图中箭头颜色） 灰色箭头（Provisioning 流程） 设备向 Keysmith 请求认证信息，保证设备被授权。 红色箭头（打包流程） 从 Source Media 到 Shaka Packager 的加密打包。 绿色箭头（内容分发） DASH 文件和加密分片从 CDN 到播放器，再到 CDM。 蓝色箭头（License 流程） 播放器通过 License Proxy 与 License Service 交互，获取解密所需的许可证。 黄色箭头（硬件安全路径） OEMCrypto HAL 在硬件安全环境下处理密钥，解密后交给 Media Output。 6. 整体理解 这张图展示了 加密媒体内容如何通过 DRM 保护，从内容提供方到最终设备播放的安全链路。 关键点：\n内容在服务端被 加密，在客户端通过 许可证服务获取密钥。 密钥始终在安全硬件环境中处理，避免泄露。 播放过程保证了 端到端的安全性，符合电影公司/流媒体平台对版权保护的要求。 Widevine L1 DRM 播放流程解读 下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。\n阶段1：设备首次注册 / 公钥上报 App 初始化 DRM\n应用调用 MediaDrm，系统初始化 DRM 会话。 TEE 生成设备密钥对\n设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。 私钥仅存在于 TEE 内部，绝不导出。 设备证书生成\nTEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。 上传设备证书\nApp 将证书发送给 License Server。 License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。 阶段2：许可证请求与 Content Key 加密 生成许可证请求\nApp 调用 getLicenseRequest(Content ID)。 TEE 使用设备私钥对请求进行签名，保证请求合法性。 发送许可证请求\nApp 将签名请求发送给 License Server。 许可证生成\nLicense Server 验证签名。 使用设备公钥加密 Content Key，并生成许可证响应。 加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥) 许可证下发\nApp 收到加密许可证，通过 provideProvisionResponse() 交给 MediaDrm/TEE。 TEE 内部解密许可证\nTEE 使用设备私钥解密，取出 Content Key。 当设备收到加密的许可证后，CDM 会将其传递给 TEE。在 TEE 内部： TEE 直接使用唯一的设备私钥来解密整个许可证，从而直接得到明文的内容密钥。 内容密钥 = RSA_Decrypt(加密后的许可证, 设备私钥) 返回一个 会话句柄 给 MediaDrm，而不是返回明文 Content Key。 阶段3：视频解密与 Secure Path 渲染 MediaCrypto 初始化\nApp 创建 MediaCrypto 实例，绑定 Content Key 会话。 视频解码配置\nApp 配置 MediaCodec，准备播放加密视频流。 播放循环\n(21) App 将加密视频片段交给 MediaCrypto。\n(22) MediaCrypto 把加密数据传给 TEE。\n(23) TEE 使用 Content Key 解密。\n(24) 解密后的帧不会返回 App，而是直接传递到 SecureDecoder（安全硬件解码器）。\n关键点： 解密后数据通过 Secure Buffer / Secure Path，不会暴露到普通内存或应用层。 (25) SecureDecoder 渲染视频帧到屏幕。\n安全关键点总结 设备私钥 (Device Private Key) 永远存储在 TEE 内部，避免泄露。 Content Key 只在 TEE 内部解密，并通过会话句柄访问，App 永远看不到明文密钥。 解密视频帧 通过 Secure Buffer 直接进入 SecureDecoder，保证数据不会泄露到应用层或系统内存。 Secure Path 渲染 确保视频帧只能显示，不能被截屏、拷贝或录制。 Widevine L1 生产预置流程 概述 Widevine L1 的生产预置流程是设备从出厂到获得正式身份认证的一系列安全操作，用于保证 设备私钥不泄露，并让设备能够获得 Google 签名的合法证书，参与 Widevine DRM 的内容解密。整个流程由 OEM 工厂和 Google 云端签名服务共同完成，但 OEM 不持有 Google 的根私钥。\n阶段 1：密钥对生成（Key Pair Generation） OEM 启动预置流程：生产线上的工厂 PC 启动预置程序，准备对新出厂设备进行 Widevine L1 初始化。 运行预置工具：工厂 PC 调用专用预置工具（FactoryTool），与设备芯片内部的 TEE 交互。 TEE 生成设备密钥对：芯片内部的可信执行环境（TEE）生成唯一的 Device Key Pair，其中 私钥永远不会导出，公钥将用于后续申请证书。 安全存储私钥：Device Private Key 被写入 TEE 的安全存储区域（如 Fuse / Keybox / RPMB），确保不可被外部访问。 导出公钥：TEE 将 Device Public Key 提供给预置工具，用于生成证书签名请求（CSR）。 安全亮点：私钥永不离开 TEE，保证设备身份的安全基础。\n阶段 2：证书签名请求（CSR） 生成 CSR：FactoryTool 将设备公钥与唯一的 Device ID 组合成证书签名请求（CSR）。\nCSR 遵循标准 PKI 规范，用于申请数字签名证书。 发送 CSR 至 Google 云端签名服务：CSR 通过加密通道（如专线、VPN 或 HTTPS）上传到 Google 的 Widevine CA 系统。\nGoogle 会先验证 CSR 请求来源是否来自授权 OEM 或工厂。 安全亮点：CSR 通过安全通道传输，保证在传输过程中不被篡改或窃取。\n阶段 3：签名与证书返回 Google 签名 CSR：Google 的证书签名服务使用 Root Private Key 对 CSR 进行数字签名，生成 设备证书（Device Certificate）。 返回签名证书：签名后的设备证书通过加密通道返回给工厂的预置工具。 安全亮点：OEM 不持有 Google 根私钥，签名操作完全在 Google 云端完成，保证了证书的权威性和不可伪造性。\n阶段 4：证书注入与激活 注入设备证书：FactoryTool 将签名证书写入 DeviceTEE 内部，通过 TEE 提供的安全接口完成注入。 TEE 验证签名：设备启动时或注入时，TEE 使用 Google Root Public Key 验证证书签名是否合法。 永久存储证书：签名验证通过后，设备证书被存储在 TEE 的安全存储区域，与私钥共同形成完整身份体系。 返回成功状态：TEE 向 FactoryTool 返回注入成功的状态，表示设备已成为 Widevine L1 合法设备。 签名验证失败（异常情况）：若验证失败，TEE 返回错误状态，流程中止，防止非法设备获得证书。 记录流程结果：FactoryPC 对整个流程进行记录和日志保存，以便追踪和质量管理。 安全亮点：\n设备证书和私钥都存储在 TEE 内，外部软件无法访问。 只有经过 Google 签名的设备证书才能被设备接受并激活 Widevine L1。 整个流程保证了生产阶段的设备身份和密钥管理安全。 总结 设备私钥永不外露，保证了 DRM 内容密钥解密的安全根基。 CSR 安全传输 + Google 云端签名，保证了设备公钥和身份的可信性。 TEE 验证与安全存储，确保只有合法设备才能获得 Widevine L1 认证。 OEM 仅扮演代理角色，负责安全地生成密钥和传递 CSR，签名权威仍在 Google。 Widevine 远程密钥预置 (RKP) 流程 1. RKP 简介 远程密钥预置（Remote Key Provisioning, RKP）是 Widevine L1 认证设备的一种现代密钥安装方法。与传统的工厂预置（Factory Provisioning）模式不同，RKP 允许设备在离开生产线后，于首次使用时，通过安全的网络连接动态地从 Google 服务器获取其唯一的设备密钥。\n这种模式的优势在于：\n简化生产线流程：无需在工厂进行耗时且复杂的密钥烧录操作。 更高的安全性：密钥仅在需要时才生成和安装，减少了生产和运输过程中的安全风险。 设备可更新性：密钥管理和证书可以在设备生命周期内进行远程更新和管理。 2. 关键组件 设备制造商 (OEM)：负责设备的硬件生产和软件集成。 Google RKP 服务：一个安全的云端服务，负责为设备生成和签名密钥。 高通/SoC 厂商：提供支持 RKP 的 TEE（可信执行环境）和相关的库（如 liboemcrypto.so）。 终端设备：待预置的设备，包含 TEE 硬件。 RKP 专用工具：Google 提供给 OEM 的工具，用于在工厂或开发阶段与设备通信，并协助密钥注册。 3. RKP 工作流程 整个 RKP 流程可以分为两个主要阶段：工厂注册和远程激活。\n阶段一：工厂端注册（一次性操作） 这个阶段通常在 OEM 的工厂或开发环境中完成，目的是将设备的基本信息和公钥安全地注册到谷歌的云端服务。\n设备准备：设备出厂时，其 TEE 内已预置了支持 RKP 的基础固件，但没有设备密钥。 证书签名请求 (CSR) 提取：OEM 使用 Google 提供的专用工具（如 rkp_factory_extraction_tool），通过 USB 或其他安全连接与设备通信。该工具指示设备的 TEE 生成一个临时的密钥对，并用其私钥对一个 CSR 进行签名。 CSR 上传：工具将该 CSR 上传到 Google 的 RKP 服务。 Google 签名：RKP 服务验证 CSR 的合法性，并用其根私钥对 CSR 进行签名，生成一个临时的设备证书。这个证书将用于后续远程激活时验证设备的身份。 阶段二：远程密钥获取与激活（首次使用） 这个阶段在设备首次连接到互联网时自动触发，通常在 App 尝试播放受保护内容时由 MediaDrm 框架启动。\n设备密钥生成：设备的 TEE 安全地生成一个永久的、唯一的设备密钥对。 密钥请求：设备将这个永久密钥对的公钥，以及在工厂端获得的临时证书，一起发送给 Google RKP 服务。 密钥签名：RKP 服务验证请求，并用其根私钥对设备的永久公钥进行签名，生成最终的、不可更改的设备证书。 设备激活：设备下载并验证这个签名的设备证书。一旦验证通过，设备密钥即被激活，并可以用于后续的许可证请求。 4. RKP 流程 PlantUML 时序图 传统的工厂预置私钥方式（Factory-Provisioned Keys） 在Android早期版本（如Android 11及之前）的密钥认证（Key Attestation）机制中，采用的是工厂预置私钥的方式。具体过程如下：\n密钥生成与预置：OEM（原始设备制造商）或ODM（原始设计制造商）在工厂环境中生成密钥对（公钥和私钥）。私钥直接注入（provisioned）到设备的TEE（Trusted Execution Environment，可信执行环境）中。 风险与问题：这要求在工厂处理敏感的私钥秘密，增加了供应链泄露的风险（如工厂员工或供应链环节的潜在泄露）。一旦私钥泄露，整个批次的设备可能受影响，且难以恢复。同时，密钥是静态的，不易轮换，隐私保护较弱（例如，多个应用可能共享同一密钥，导致追踪风险）。 使用流程：设备出厂后，应用请求认证时，直接使用预置的私钥生成凭证链，无需在线请求新证书。但证书链较短，且根信任基于RSA。 这种方式确实在“第一步”（工厂阶段）就预置了私钥，这也是其主要安全隐患所在。\nRKP（远程密钥预置）与传统的区别 RKP是Google从Android 12开始引入的可选机制，并在Android 13中强制要求（针对新设备），旨在取代传统的工厂预置私钥方式，提高安全性和隐私。RKP的核心是不预置私钥，而是由设备自行生成并保护私钥，只在工厂提取公钥。\n密钥生成：密钥对（公钥和私钥）由设备TEE自行生成。私钥从生成起就永不离开TEE的安全环境，确保零暴露。 工厂流程（第一步）：OEM在工厂启动设备公钥提取。设备TEE生成唯一的硬件绑定密钥对。只提取公钥（DK_PUB），上传到Google服务器存储。私钥不导出、不预置。 远程配置流程（设备端）：设备开箱联网后，应用触发请求，TEE生成CSR（凭证签名请求），用私钥签名后发送到Google服务器。服务器验证公钥匹配后，签名并返回短期证书链（有效期最长两个月）。证书定期轮换。 安全/隐私优势： 供应链安全：消除工厂处理私钥的风险，减少泄露可能。 隐私提升：每个应用获得不同的认证密钥，证书短期有效，服务器分段设计（验证公钥的服务器不接触认证密钥），防止设备追踪。 可恢复性：如果设备软件被入侵，Google可停止向其提供新证书，而不影响整个生态。 技术改进：证书链更长，根信任从RSA转向ECDSA，支持更安全的密钥轮换。 总之，传统的工厂预置确实在第一步预置私钥，但RKP避免了这一点，转而使用设备生成+公钥提取的方式。这大大降低了风险，并已成为Android生态的标准。\n流程对比：Widevine L1 预置 vs. RKP 认证 这两种流程服务于不同的核心目标，并且在工作流程、安全性及 OEM 责任方面存在根本差异。\n特性比较 传统 Widevine L1 生产预置 (Keybox) 远程密钥预置 (RKP for Attestation) 核心目标 DRM 内容保护，确保加密的影音内容只能在授权设备上播放。 设备完整性认证 (Attestation)，向 App (如银行、支付) 证明设备处于安全、未被篡改的状态 。 密钥配置地点 工厂生产线 。密钥在设备出厂前已完全烧录。 用户端 (In-the-field) 。设备在首次连接网络时，通过 OTA 远程获取密钥凭证 。 工厂流程 注入私钥 。将包含完整密钥对 (公钥+私钥) 的 keybox.xml 文件安全地烧录到每台设备中。 提取公钥 。仅从每台设备中提取其唯一的、非敏感的公钥 (DK_PUB)。 关键交付物 一台包含永久性 Widevine 设备密钥的、已完全配置的设备。 一台「已准备好」进行远程配置的设备，其公钥已在 Google 云端注册 。 密钥/凭证类型 永久性、长生命周期的设备密钥。一旦泄漏，影响是永久的 。 短期、可再生的认证凭证 (例如，有效期仅两个月)。 安全性 较高风险。OEM 必须处理并保护高度敏感的私钥材料，存在工厂或供应链泄漏的风险 。 极高安全性。OEM 在工厂完全不接触任何私钥，私钥从未离开过设备的 TEE 。 灵活性与可恢复性 低。密钥一旦泄漏或被撤销，设备将永久失去信任 ，通常需要硬件召回 (RMA) 。 高。如果出现漏洞，Google 只需停止为有问题的设备签发新的短期凭证，即可有效控制风险，无需撤销永久密钥 。 OEM 责任 责任重大。需要建立和维护昂贵且复杂的安全生产环境，以保护私钥材料的安全 。 责任较轻。只需负责提取和上传非敏感的公钥 ，大大降低了安全管理的复杂度和成本。 ",
  "wordCount" : "703",
  "inLanguage": "en",
  "datePublished": "2025-08-08T11:36:11+08:00",
  "dateModified": "2025-08-08T11:36:11+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/qnx/" title="QNX开发">
                    <span>QNX开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/android-dev/">Android系统开发</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/android-dev/media/">Android Media技术文档</a></div>
    <h1 class="post-title entry-hint-parent">
      Android DRM 框架
    </h1>
    <div class="post-meta"><span title='2025-08-08 11:36:11 +0800 CST'>August 8, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;703 words

</div>
  </header> 
  <div class="post-content"><h2 id="widevine-overview">Widevine Overview<a hidden class="anchor" aria-hidden="true" href="#widevine-overview">#</a></h2>
<p><img loading="lazy" src="/ethenslab/images/Widevine_architect.png"></p>
<p>这张图是 <strong>Widevine DRM（数字版权管理）视频播放流程</strong> 的整体架构图，展示了从内容打包、分发到终端设备解密播放的完整链路。分步骤解读：</p>
<hr>
<h3 id="1-内容准备与分发">1. <strong>内容准备与分发</strong><a hidden class="anchor" aria-hidden="true" href="#1-内容准备与分发">#</a></h3>
<ul>
<li><strong>Source Media（原始媒体内容）</strong>
这是未经加密的音视频源文件。</li>
<li><strong>Shaka Packager（打包器）</strong>
将原始媒体文件进行 <strong>加密和分片</strong>，并打包成 <strong>DASH Presentation（自适应流媒体格式）</strong>。</li>
<li><strong>DASH Presentation</strong>
是最终的媒体描述文件（如 MPD），里面包含分片信息、码率信息和加密标记。</li>
<li><strong>CDN（内容分发网络）</strong>
DASH 文件和加密后的媒体分片会被放到 CDN 上，供终端播放器请求。</li>
</ul>
<hr>
<h3 id="2-授权与密钥服务">2. <strong>授权与密钥服务</strong><a hidden class="anchor" aria-hidden="true" href="#2-授权与密钥服务">#</a></h3>
<ul>
<li><strong>License Service（许可证服务）</strong>
管理内容密钥（KID、CEK），并根据终端请求签发播放许可证（License）。</li>
<li><strong>License Proxy</strong>
充当中间层，接收终端的 License 请求并转发给 License Service，再把结果返回给终端。</li>
</ul>
<hr>
<h3 id="3-设备安全与密钥保护">3. <strong>设备安全与密钥保护</strong><a hidden class="anchor" aria-hidden="true" href="#3-设备安全与密钥保护">#</a></h3>
<ul>
<li><strong>OEM（设备制造商）</strong>
在设备中实现 <strong>OEMCrypto HAL</strong>，并提供硬件安全环境（TEE、Secure OS）。
设备出厂时会存有 <strong>Lockbox（Keyboxes）</strong>，这是设备的安全身份凭证。</li>
<li><strong>Keysith (Provisioning)</strong>
用于设备首次激活时的 <strong>设备认证与密钥配置</strong>，保证终端能安全接收 DRM 密钥。</li>
</ul>
<hr>
<h3 id="4-终端播放流程">4. <strong>终端播放流程</strong><a hidden class="anchor" aria-hidden="true" href="#4-终端播放流程">#</a></h3>
<ul>
<li>
<p><strong>Media Player</strong>
播放器解析 DASH MPD，从 CDN 拉取加密的媒体分片。
播放器检测到内容加密后，会通过 <strong>CDM（Content Decryption Module）</strong> 请求解密。</p>
</li>
<li>
<p><strong>CDM</strong>
内容解密模块，负责：</p>
<ul>
<li>与 License Proxy/Service 通信，请求播放许可证（License）。</li>
<li>将密钥请求交给 <strong>OEMCrypto HAL</strong>。</li>
</ul>
</li>
<li>
<p><strong>OEMCrypto HAL</strong>
硬件安全层，负责实际的 <strong>密钥解密与内容解密</strong>（在 TEE/Secure OS 内运行）。
它确保明文内容不会暴露在非安全环境中。</p>
</li>
<li>
<p><strong>Media Output</strong>
最终的解密音视频流送入播放器渲染输出。
如果是安全视频（L1 模式），输出会经过 <strong>安全视频路径（SVP）</strong>，防止被截取。</p>
</li>
</ul>
<hr>
<h3 id="5-数据流向说明图中箭头颜色">5. <strong>数据流向说明（图中箭头颜色）</strong><a hidden class="anchor" aria-hidden="true" href="#5-数据流向说明图中箭头颜色">#</a></h3>
<ul>
<li><strong>灰色箭头（Provisioning 流程）</strong>
设备向 Keysmith 请求认证信息，保证设备被授权。</li>
<li><strong>红色箭头（打包流程）</strong>
从 Source Media 到 Shaka Packager 的加密打包。</li>
<li><strong>绿色箭头（内容分发）</strong>
DASH 文件和加密分片从 CDN 到播放器，再到 CDM。</li>
<li><strong>蓝色箭头（License 流程）</strong>
播放器通过 License Proxy 与 License Service 交互，获取解密所需的许可证。</li>
<li><strong>黄色箭头（硬件安全路径）</strong>
OEMCrypto HAL 在硬件安全环境下处理密钥，解密后交给 Media Output。</li>
</ul>
<hr>
<h3 id="6-整体理解">6. <strong>整体理解</strong><a hidden class="anchor" aria-hidden="true" href="#6-整体理解">#</a></h3>
<p>这张图展示了 <strong>加密媒体内容如何通过 DRM 保护，从内容提供方到最终设备播放的安全链路</strong>。
关键点：</p>
<ul>
<li>内容在服务端被 <strong>加密</strong>，在客户端通过 <strong>许可证服务</strong>获取密钥。</li>
<li>密钥始终在安全硬件环境中处理，避免泄露。</li>
<li>播放过程保证了 <strong>端到端的安全性</strong>，符合电影公司/流媒体平台对版权保护的要求。</li>
</ul>
<hr>
<h2 id="widevine-l1-drm-播放流程解读">Widevine L1 DRM 播放流程解读<a hidden class="anchor" aria-hidden="true" href="#widevine-l1-drm-播放流程解读">#</a></h2>
<p>下面的时序图展示了 <strong>Android 平台 Widevine L1 DRM</strong> 的核心工作原理，涵盖了 <strong>设备注册、许可证获取、视频解密与安全渲染</strong> 三个阶段，并特别标注了 <strong>安全关键点（Secure Path）</strong>。</p>
<p><img loading="lazy" src="/ethenslab/images/drm-contentkey.png"></p>
<hr>
<h3 id="阶段1设备首次注册--公钥上报">阶段1：设备首次注册 / 公钥上报<a hidden class="anchor" aria-hidden="true" href="#阶段1设备首次注册--公钥上报">#</a></h3>
<ol>
<li>
<p><strong>App 初始化 DRM</strong></p>
<ul>
<li>应用调用 <code>MediaDrm</code>，系统初始化 DRM 会话。</li>
</ul>
</li>
<li>
<p><strong>TEE 生成设备密钥对</strong></p>
<ul>
<li>设备在 TEE 内部生成 <strong>Device Key Pair</strong>（公钥/私钥）。</li>
<li><strong>私钥仅存在于 TEE 内部，绝不导出</strong>。</li>
</ul>
</li>
<li>
<p><strong>设备证书生成</strong></p>
<ul>
<li>TEE 通过 <code>generateProvisioningRequest()</code> 生成设备证书，包含设备公钥和签名。</li>
</ul>
</li>
<li>
<p><strong>上传设备证书</strong></p>
<ul>
<li>App 将证书发送给 License Server。</li>
<li>License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="阶段2许可证请求与-content-key-加密">阶段2：许可证请求与 Content Key 加密<a hidden class="anchor" aria-hidden="true" href="#阶段2许可证请求与-content-key-加密">#</a></h3>
<ol start="5">
<li>
<p><strong>生成许可证请求</strong></p>
<ul>
<li>App 调用 <code>getLicenseRequest(Content ID)</code>。</li>
<li>TEE 使用设备私钥对请求进行签名，保证请求合法性。</li>
</ul>
</li>
<li>
<p><strong>发送许可证请求</strong></p>
<ul>
<li>App 将签名请求发送给 License Server。</li>
</ul>
</li>
<li>
<p><strong>许可证生成</strong></p>
<ul>
<li>License Server 验证签名。</li>
<li>使用设备公钥加密 Content Key，并生成许可证响应。</li>
<li>加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥)</li>
</ul>
</li>
<li>
<p><strong>许可证下发</strong></p>
<ul>
<li>App 收到加密许可证，通过 <code>provideProvisionResponse()</code> 交给 MediaDrm/TEE。</li>
</ul>
</li>
<li>
<p><strong>TEE 内部解密许可证</strong></p>
<ul>
<li>TEE 使用设备私钥解密，取出 Content Key。
当设备收到加密的许可证后，CDM 会将其传递给 TEE。在 TEE 内部：
TEE 直接使用唯一的设备私钥来解密整个许可证，从而直接得到明文的内容密钥。
内容密钥 = RSA_Decrypt(加密后的许可证, 设备私钥)</li>
<li>返回一个 <strong>会话句柄</strong> 给 MediaDrm，而不是返回明文 Content Key。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="阶段3视频解密与-secure-path-渲染">阶段3：视频解密与 Secure Path 渲染<a hidden class="anchor" aria-hidden="true" href="#阶段3视频解密与-secure-path-渲染">#</a></h3>
<ol start="10">
<li>
<p><strong>MediaCrypto 初始化</strong></p>
<ul>
<li>App 创建 <code>MediaCrypto</code> 实例，绑定 Content Key 会话。</li>
</ul>
</li>
<li>
<p><strong>视频解码配置</strong></p>
<ul>
<li>App 配置 <code>MediaCodec</code>，准备播放加密视频流。</li>
</ul>
</li>
<li>
<p><strong>播放循环</strong></p>
<ul>
<li>
<p><strong>(21)</strong> App 将加密视频片段交给 <code>MediaCrypto</code>。</p>
</li>
<li>
<p><strong>(22)</strong> <code>MediaCrypto</code> 把加密数据传给 TEE。</p>
</li>
<li>
<p><strong>(23)</strong> TEE 使用 Content Key 解密。</p>
</li>
<li>
<p><strong>(24)</strong> 解密后的帧不会返回 App，而是直接传递到 <strong>SecureDecoder</strong>（安全硬件解码器）。</p>
<ul>
<li><strong>关键点：</strong> 解密后数据通过 <strong>Secure Buffer / Secure Path</strong>，不会暴露到普通内存或应用层。</li>
</ul>
</li>
<li>
<p><strong>(25)</strong> SecureDecoder 渲染视频帧到屏幕。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="安全关键点总结">安全关键点总结<a hidden class="anchor" aria-hidden="true" href="#安全关键点总结">#</a></h3>
<ul>
<li><strong>设备私钥 (Device Private Key)</strong> 永远存储在 TEE 内部，避免泄露。</li>
<li><strong>Content Key</strong> 只在 TEE 内部解密，并通过会话句柄访问，App 永远看不到明文密钥。</li>
<li><strong>解密视频帧</strong> 通过 <strong>Secure Buffer</strong> 直接进入 SecureDecoder，保证数据不会泄露到应用层或系统内存。</li>
<li><strong>Secure Path 渲染</strong> 确保视频帧只能显示，不能被截屏、拷贝或录制。</li>
</ul>
<hr>
<h2 id="widevine-l1-生产预置流程">Widevine L1 生产预置流程<a hidden class="anchor" aria-hidden="true" href="#widevine-l1-生产预置流程">#</a></h2>
<h3 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h3>
<p>Widevine L1 的生产预置流程是设备从出厂到获得正式身份认证的一系列安全操作，用于保证 <strong>设备私钥不泄露</strong>，并让设备能够获得 <strong>Google 签名的合法证书</strong>，参与 Widevine DRM 的内容解密。整个流程由 OEM 工厂和 Google 云端签名服务共同完成，但 OEM 不持有 Google 的根私钥。</p>
<hr>
<h3 id="阶段-1密钥对生成key-pair-generation">阶段 1：密钥对生成（Key Pair Generation）<a hidden class="anchor" aria-hidden="true" href="#阶段-1密钥对生成key-pair-generation">#</a></h3>
<ol>
<li><strong>OEM 启动预置流程</strong>：生产线上的工厂 PC 启动预置程序，准备对新出厂设备进行 Widevine L1 初始化。</li>
<li><strong>运行预置工具</strong>：工厂 PC 调用专用预置工具（FactoryTool），与设备芯片内部的 TEE 交互。</li>
<li><strong>TEE 生成设备密钥对</strong>：芯片内部的可信执行环境（TEE）生成唯一的 Device Key Pair，其中 <strong>私钥永远不会导出</strong>，公钥将用于后续申请证书。</li>
<li><strong>安全存储私钥</strong>：Device Private Key 被写入 TEE 的安全存储区域（如 Fuse / Keybox / RPMB），确保不可被外部访问。</li>
<li><strong>导出公钥</strong>：TEE 将 Device Public Key 提供给预置工具，用于生成证书签名请求（CSR）。</li>
</ol>
<p><strong>安全亮点</strong>：私钥永不离开 TEE，保证设备身份的安全基础。</p>
<hr>
<h3 id="阶段-2证书签名请求csr">阶段 2：证书签名请求（CSR）<a hidden class="anchor" aria-hidden="true" href="#阶段-2证书签名请求csr">#</a></h3>
<ol start="6">
<li>
<p><strong>生成 CSR</strong>：FactoryTool 将设备公钥与唯一的 Device ID 组合成证书签名请求（CSR）。</p>
<ul>
<li>CSR 遵循标准 PKI 规范，用于申请数字签名证书。</li>
</ul>
</li>
<li>
<p><strong>发送 CSR 至 Google 云端签名服务</strong>：CSR 通过加密通道（如专线、VPN 或 HTTPS）上传到 Google 的 Widevine CA 系统。</p>
<ul>
<li>Google 会先验证 CSR 请求来源是否来自授权 OEM 或工厂。</li>
</ul>
</li>
</ol>
<p><strong>安全亮点</strong>：CSR 通过安全通道传输，保证在传输过程中不被篡改或窃取。</p>
<hr>
<h3 id="阶段-3签名与证书返回">阶段 3：签名与证书返回<a hidden class="anchor" aria-hidden="true" href="#阶段-3签名与证书返回">#</a></h3>
<ol start="8">
<li><strong>Google 签名 CSR</strong>：Google 的证书签名服务使用 Root Private Key 对 CSR 进行数字签名，生成 <strong>设备证书（Device Certificate）</strong>。</li>
<li><strong>返回签名证书</strong>：签名后的设备证书通过加密通道返回给工厂的预置工具。</li>
</ol>
<p><strong>安全亮点</strong>：OEM 不持有 Google 根私钥，签名操作完全在 Google 云端完成，保证了证书的权威性和不可伪造性。</p>
<hr>
<h3 id="阶段-4证书注入与激活">阶段 4：证书注入与激活<a hidden class="anchor" aria-hidden="true" href="#阶段-4证书注入与激活">#</a></h3>
<ol start="10">
<li><strong>注入设备证书</strong>：FactoryTool 将签名证书写入 DeviceTEE 内部，通过 TEE 提供的安全接口完成注入。</li>
<li><strong>TEE 验证签名</strong>：设备启动时或注入时，TEE 使用 Google Root Public Key 验证证书签名是否合法。</li>
<li><strong>永久存储证书</strong>：签名验证通过后，设备证书被存储在 TEE 的安全存储区域，与私钥共同形成完整身份体系。</li>
<li><strong>返回成功状态</strong>：TEE 向 FactoryTool 返回注入成功的状态，表示设备已成为 Widevine L1 合法设备。</li>
<li><strong>签名验证失败</strong>（异常情况）：若验证失败，TEE 返回错误状态，流程中止，防止非法设备获得证书。</li>
<li><strong>记录流程结果</strong>：FactoryPC 对整个流程进行记录和日志保存，以便追踪和质量管理。</li>
</ol>
<p><strong>安全亮点</strong>：</p>
<ul>
<li>设备证书和私钥都存储在 TEE 内，外部软件无法访问。</li>
<li>只有经过 Google 签名的设备证书才能被设备接受并激活 Widevine L1。</li>
<li>整个流程保证了生产阶段的设备身份和密钥管理安全。</li>
</ul>
<hr>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<ol>
<li><strong>设备私钥永不外露</strong>，保证了 DRM 内容密钥解密的安全根基。</li>
<li><strong>CSR 安全传输 + Google 云端签名</strong>，保证了设备公钥和身份的可信性。</li>
<li><strong>TEE 验证与安全存储</strong>，确保只有合法设备才能获得 Widevine L1 认证。</li>
<li>OEM 仅扮演代理角色，负责安全地生成密钥和传递 CSR，签名权威仍在 Google。</li>
</ol>
<hr>
<p><img loading="lazy" src="/ethenslab/images/drm-keyprovision.png"></p>
<h2 id="widevine-远程密钥预置-rkp-流程">Widevine 远程密钥预置 (RKP) 流程<a hidden class="anchor" aria-hidden="true" href="#widevine-远程密钥预置-rkp-流程">#</a></h2>
<h3 id="1-rkp-简介"><strong>1. RKP 简介</strong><a hidden class="anchor" aria-hidden="true" href="#1-rkp-简介">#</a></h3>
<p>远程密钥预置（Remote Key Provisioning, RKP）是 Widevine L1 认证设备的一种现代密钥安装方法。与传统的<strong>工厂预置（Factory Provisioning）模式不同，RKP 允许设备在离开生产线后，于首次使用</strong>时，通过安全的网络连接动态地从 Google 服务器获取其唯一的设备密钥。</p>
<p>这种模式的优势在于：</p>
<ul>
<li><strong>简化生产线流程</strong>：无需在工厂进行耗时且复杂的密钥烧录操作。</li>
<li><strong>更高的安全性</strong>：密钥仅在需要时才生成和安装，减少了生产和运输过程中的安全风险。</li>
<li><strong>设备可更新性</strong>：密钥管理和证书可以在设备生命周期内进行远程更新和管理。</li>
</ul>
<h3 id="2-关键组件"><strong>2. 关键组件</strong><a hidden class="anchor" aria-hidden="true" href="#2-关键组件">#</a></h3>
<ul>
<li><strong>设备制造商 (OEM)</strong>：负责设备的硬件生产和软件集成。</li>
<li><strong>Google RKP 服务</strong>：一个安全的云端服务，负责为设备生成和签名密钥。</li>
<li><strong>高通/SoC 厂商</strong>：提供支持 RKP 的 TEE（可信执行环境）和相关的库（如 <code>liboemcrypto.so</code>）。</li>
<li><strong>终端设备</strong>：待预置的设备，包含 TEE 硬件。</li>
<li><strong>RKP 专用工具</strong>：Google 提供给 OEM 的工具，用于在工厂或开发阶段与设备通信，并协助密钥注册。</li>
</ul>
<h3 id="3-rkp-工作流程"><strong>3. RKP 工作流程</strong><a hidden class="anchor" aria-hidden="true" href="#3-rkp-工作流程">#</a></h3>
<p>整个 RKP 流程可以分为两个主要阶段：<strong>工厂注册</strong>和<strong>远程激活</strong>。</p>
<h4 id="阶段一工厂端注册一次性操作"><strong>阶段一：工厂端注册（一次性操作）</strong><a hidden class="anchor" aria-hidden="true" href="#阶段一工厂端注册一次性操作">#</a></h4>
<p>这个阶段通常在 OEM 的工厂或开发环境中完成，目的是将设备的基本信息和公钥安全地注册到谷歌的云端服务。</p>
<ol>
<li><strong>设备准备</strong>：设备出厂时，其 TEE 内已预置了支持 RKP 的基础固件，但<strong>没有</strong>设备密钥。</li>
<li><strong>证书签名请求 (CSR) 提取</strong>：OEM 使用 Google 提供的专用工具（如 <code>rkp_factory_extraction_tool</code>），通过 USB 或其他安全连接与设备通信。该工具指示设备的 TEE 生成一个临时的密钥对，并用其私钥对一个 CSR 进行签名。</li>
<li><strong>CSR 上传</strong>：工具将该 CSR 上传到 Google 的 RKP 服务。</li>
<li><strong>Google 签名</strong>：RKP 服务验证 CSR 的合法性，并用其<strong>根私钥</strong>对 CSR 进行签名，生成一个<strong>临时的设备证书</strong>。这个证书将用于后续远程激活时验证设备的身份。</li>
</ol>
<h4 id="阶段二远程密钥获取与激活首次使用"><strong>阶段二：远程密钥获取与激活（首次使用）</strong><a hidden class="anchor" aria-hidden="true" href="#阶段二远程密钥获取与激活首次使用">#</a></h4>
<p>这个阶段在设备首次连接到互联网时自动触发，通常在 App 尝试播放受保护内容时由 <code>MediaDrm</code> 框架启动。</p>
<ol>
<li><strong>设备密钥生成</strong>：设备的 TEE 安全地生成一个<strong>永久的</strong>、唯一的设备密钥对。</li>
<li><strong>密钥请求</strong>：设备将这个永久密钥对的<strong>公钥</strong>，以及在工厂端获得的临时证书，一起发送给 Google RKP 服务。</li>
<li><strong>密钥签名</strong>：RKP 服务验证请求，并用其<strong>根私钥</strong>对设备的永久公钥进行签名，生成最终的、不可更改的<strong>设备证书</strong>。</li>
<li><strong>设备激活</strong>：设备下载并验证这个签名的设备证书。一旦验证通过，设备密钥即被激活，并可以用于后续的许可证请求。</li>
</ol>
<hr>
<h4 id="4-rkp-流程-plantuml-时序图"><strong>4. RKP 流程 PlantUML 时序图</strong><a hidden class="anchor" aria-hidden="true" href="#4-rkp-流程-plantuml-时序图">#</a></h4>
<p><img loading="lazy" src="/ethenslab/images/drm-rkp.png"></p>
<p>传统的工厂预置私钥方式（Factory-Provisioned Keys）
在Android早期版本（如Android 11及之前）的密钥认证（Key Attestation）机制中，采用的是工厂预置私钥的方式。具体过程如下：</p>
<ul>
<li>密钥生成与预置：OEM（原始设备制造商）或ODM（原始设计制造商）在工厂环境中生成密钥对（公钥和私钥）。私钥直接注入（provisioned）到设备的TEE（Trusted Execution Environment，可信执行环境）中。</li>
<li>风险与问题：这要求在工厂处理敏感的私钥秘密，增加了供应链泄露的风险（如工厂员工或供应链环节的潜在泄露）。一旦私钥泄露，整个批次的设备可能受影响，且难以恢复。同时，密钥是静态的，不易轮换，隐私保护较弱（例如，多个应用可能共享同一密钥，导致追踪风险）。</li>
<li>使用流程：设备出厂后，应用请求认证时，直接使用预置的私钥生成凭证链，无需在线请求新证书。但证书链较短，且根信任基于RSA。</li>
</ul>
<p>这种方式确实在“第一步”（工厂阶段）就预置了私钥，这也是其主要安全隐患所在。</p>
<p><strong>RKP（远程密钥预置）与传统的区别</strong>
RKP是Google从Android 12开始引入的可选机制，并在Android 13中强制要求（针对新设备），旨在取代传统的工厂预置私钥方式，提高安全性和隐私。RKP的核心是不预置私钥，而是由设备自行生成并保护私钥，只在工厂提取公钥。</p>
<ul>
<li>密钥生成：密钥对（公钥和私钥）由设备TEE自行生成。私钥从生成起就永不离开TEE的安全环境，确保零暴露。</li>
<li>工厂流程（第一步）：OEM在工厂启动设备公钥提取。设备TEE生成唯一的硬件绑定密钥对。只提取公钥（DK_PUB），上传到Google服务器存储。私钥不导出、不预置。</li>
<li>远程配置流程（设备端）：设备开箱联网后，应用触发请求，TEE生成CSR（凭证签名请求），用私钥签名后发送到Google服务器。服务器验证公钥匹配后，签名并返回短期证书链（有效期最长两个月）。证书定期轮换。
安全/隐私优势：</li>
<li>供应链安全：消除工厂处理私钥的风险，减少泄露可能。</li>
<li>隐私提升：每个应用获得不同的认证密钥，证书短期有效，服务器分段设计（验证公钥的服务器不接触认证密钥），防止设备追踪。</li>
<li>可恢复性：如果设备软件被入侵，Google可停止向其提供新证书，而不影响整个生态。</li>
<li>技术改进：证书链更长，根信任从RSA转向ECDSA，支持更安全的密钥轮换。</li>
</ul>
<p>总之，传统的工厂预置确实在第一步预置私钥，但RKP避免了这一点，转而使用设备生成+公钥提取的方式。这大大降低了风险，并已成为Android生态的标准。</p>
<h5 id="流程对比widevine-l1-预置-vs-rkp-认证">流程对比：Widevine L1 预置 vs. RKP 认证<a hidden class="anchor" aria-hidden="true" href="#流程对比widevine-l1-预置-vs-rkp-认证">#</a></h5>
<p>这两种流程服务于不同的核心目标，并且在工作流程、安全性及 OEM 责任方面存在根本差异。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性比较</th>
          <th style="text-align: left"><strong>传统 Widevine L1 生产预置 (Keybox)</strong></th>
          <th style="text-align: left"><strong>远程密钥预置 (RKP for Attestation)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>核心目标</strong></td>
          <td style="text-align: left">DRM 内容保护，确保加密的影音内容只能在授权设备上播放。</td>
          <td style="text-align: left">设备完整性认证 (Attestation)，向 App (如银行、支付) 证明设备处于安全、未被篡改的状态 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>密钥配置地点</strong></td>
          <td style="text-align: left"><strong>工厂生产线</strong> 。密钥在设备出厂前已完全烧录。</td>
          <td style="text-align: left"><strong>用户端 (In-the-field)</strong> 。设备在首次连接网络时，通过 OTA 远程获取密钥凭证 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>工厂流程</strong></td>
          <td style="text-align: left"><strong>注入私钥</strong>  。将包含完整密钥对 (公钥+私钥) 的 <code>keybox.xml</code> 文件安全地烧录到每台设备中。</td>
          <td style="text-align: left"><strong>提取公钥</strong> 。仅从每台设备中提取其唯一的、非敏感的公钥 (DK_PUB)。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>关键交付物</strong></td>
          <td style="text-align: left">一台包含<strong>永久性</strong> Widevine 设备密钥的、已完全配置的设备。</td>
          <td style="text-align: left">一台「已准备好」进行远程配置的设备，其公钥已在 Google 云端注册 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>密钥/凭证类型</strong></td>
          <td style="text-align: left"><strong>永久性、长生命周期的设备密钥</strong>。一旦泄漏，影响是永久的 。</td>
          <td style="text-align: left"><strong>短期、可再生的认证凭证</strong> (例如，有效期仅两个月)。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>安全性</strong></td>
          <td style="text-align: left"><strong>较高风险</strong>。OEM 必须处理并保护高度敏感的私钥材料，存在工厂或供应链泄漏的风险 。</td>
          <td style="text-align: left"><strong>极高安全性</strong>。OEM 在工厂完全不接触任何私钥，私钥从未离开过设备的 TEE 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>灵活性与可恢复性</strong></td>
          <td style="text-align: left"><strong>低</strong>。密钥一旦泄漏或被撤销，设备将永久失去信任 ，通常需要硬件召回 (RMA) 。</td>
          <td style="text-align: left"><strong>高</strong>。如果出现漏洞，Google 只需停止为有问题的设备签发新的短期凭证，即可有效控制风险，无需撤销永久密钥 。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>OEM 责任</strong></td>
          <td style="text-align: left"><strong>责任重大</strong>。需要建立和维护昂贵且复杂的安全生产环境，以保护私钥材料的安全 。</td>
          <td style="text-align: left"><strong>责任较轻</strong>。只需负责提取和上传非敏感的公钥 ，大大降低了安全管理的复杂度和成本。</td>
      </tr>
  </tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://ethen-cao.github.io/ethenslab/android-dev/resource/android-theme/">
    <span class="title">Next »</span>
    <br>
    <span>Android Theme</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
