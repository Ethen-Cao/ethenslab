<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Android DRM 框架 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="Widevine L1 DRM 播放流程解读
下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。

阶段1：设备首次注册 / 公钥上报


App 初始化 DRM

应用调用 MediaDrm，系统初始化 DRM 会话。



TEE 生成设备密钥对

设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。
私钥仅存在于 TEE 内部，绝不导出。



设备证书生成

TEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。



上传设备证书

App 将证书发送给 License Server。
License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。




阶段2：许可证请求与 Content Key 加密


生成许可证请求

App 调用 getLicenseRequest(Content ID)。
TEE 使用设备私钥对请求进行签名，保证请求合法性。



发送许可证请求

App 将签名请求发送给 License Server。



许可证生成

License Server 验证签名。
使用设备公钥加密 Content Key，并生成许可证响应。
加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥)



许可证下发">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.8d92b99258d2a8aea36dee98116af3631ad91e255aef20c2caa81c9459a68fd8.css" integrity="sha256-jZK5kljSqK6jbe6YEWrzYxrZHiVa7yDCyqgclFmmj9g=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="Android DRM 框架">
  <meta property="og:description" content="Widevine L1 DRM 播放流程解读 下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。
阶段1：设备首次注册 / 公钥上报 App 初始化 DRM
应用调用 MediaDrm，系统初始化 DRM 会话。 TEE 生成设备密钥对
设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。 私钥仅存在于 TEE 内部，绝不导出。 设备证书生成
TEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。 上传设备证书
App 将证书发送给 License Server。 License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。 阶段2：许可证请求与 Content Key 加密 生成许可证请求
App 调用 getLicenseRequest(Content ID)。 TEE 使用设备私钥对请求进行签名，保证请求合法性。 发送许可证请求
App 将签名请求发送给 License Server。 许可证生成
License Server 验证签名。 使用设备公钥加密 Content Key，并生成许可证响应。 加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥) 许可证下发">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="android-dev">
    <meta property="article:published_time" content="2025-08-08T11:36:11+08:00">
    <meta property="article:modified_time" content="2025-08-08T11:36:11+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android DRM 框架">
<meta name="twitter:description" content="Widevine L1 DRM 播放流程解读
下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。

阶段1：设备首次注册 / 公钥上报


App 初始化 DRM

应用调用 MediaDrm，系统初始化 DRM 会话。



TEE 生成设备密钥对

设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。
私钥仅存在于 TEE 内部，绝不导出。



设备证书生成

TEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。



上传设备证书

App 将证书发送给 License Server。
License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。




阶段2：许可证请求与 Content Key 加密


生成许可证请求

App 调用 getLicenseRequest(Content ID)。
TEE 使用设备私钥对请求进行签名，保证请求合法性。



发送许可证请求

App 将签名请求发送给 License Server。



许可证生成

License Server 验证签名。
使用设备公钥加密 Content Key，并生成许可证响应。
加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥)



许可证下发">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Android系统开发",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Android DRM 框架",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android DRM 框架",
  "name": "Android DRM 框架",
  "description": "Widevine L1 DRM 播放流程解读 下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。\n阶段1：设备首次注册 / 公钥上报 App 初始化 DRM\n应用调用 MediaDrm，系统初始化 DRM 会话。 TEE 生成设备密钥对\n设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。 私钥仅存在于 TEE 内部，绝不导出。 设备证书生成\nTEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。 上传设备证书\nApp 将证书发送给 License Server。 License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。 阶段2：许可证请求与 Content Key 加密 生成许可证请求\nApp 调用 getLicenseRequest(Content ID)。 TEE 使用设备私钥对请求进行签名，保证请求合法性。 发送许可证请求\nApp 将签名请求发送给 License Server。 许可证生成\nLicense Server 验证签名。 使用设备公钥加密 Content Key，并生成许可证响应。 加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥) 许可证下发\n",
  "keywords": [
    
  ],
  "articleBody": "Widevine L1 DRM 播放流程解读 下面的时序图展示了 Android 平台 Widevine L1 DRM 的核心工作原理，涵盖了 设备注册、许可证获取、视频解密与安全渲染 三个阶段，并特别标注了 安全关键点（Secure Path）。\n阶段1：设备首次注册 / 公钥上报 App 初始化 DRM\n应用调用 MediaDrm，系统初始化 DRM 会话。 TEE 生成设备密钥对\n设备在 TEE 内部生成 Device Key Pair（公钥/私钥）。 私钥仅存在于 TEE 内部，绝不导出。 设备证书生成\nTEE 通过 generateProvisioningRequest() 生成设备证书，包含设备公钥和签名。 上传设备证书\nApp 将证书发送给 License Server。 License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。 阶段2：许可证请求与 Content Key 加密 生成许可证请求\nApp 调用 getLicenseRequest(Content ID)。 TEE 使用设备私钥对请求进行签名，保证请求合法性。 发送许可证请求\nApp 将签名请求发送给 License Server。 许可证生成\nLicense Server 验证签名。 使用设备公钥加密 Content Key，并生成许可证响应。 加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥) 许可证下发\nApp 收到加密许可证，通过 provideProvisionResponse() 交给 MediaDrm/TEE。 TEE 内部解密许可证\nTEE 使用设备私钥解密，取出 Content Key。 当设备收到加密的许可证后，CDM 会将其传递给 TEE。在 TEE 内部： TEE 直接使用唯一的设备私钥来解密整个许可证，从而直接得到明文的内容密钥。 内容密钥 = RSA_Decrypt(加密后的许可证, 设备私钥) 返回一个 会话句柄 给 MediaDrm，而不是返回明文 Content Key。 阶段3：视频解密与 Secure Path 渲染 MediaCrypto 初始化\nApp 创建 MediaCrypto 实例，绑定 Content Key 会话。 视频解码配置\nApp 配置 MediaCodec，准备播放加密视频流。 播放循环\n(21) App 将加密视频片段交给 MediaCrypto。\n(22) MediaCrypto 把加密数据传给 TEE。\n(23) TEE 使用 Content Key 解密。\n(24) 解密后的帧不会返回 App，而是直接传递到 SecureDecoder（安全硬件解码器）。\n关键点： 解密后数据通过 Secure Buffer / Secure Path，不会暴露到普通内存或应用层。 (25) SecureDecoder 渲染视频帧到屏幕。\n安全关键点总结 设备私钥 (Device Private Key) 永远存储在 TEE 内部，避免泄露。 Content Key 只在 TEE 内部解密，并通过会话句柄访问，App 永远看不到明文密钥。 解密视频帧 通过 Secure Buffer 直接进入 SecureDecoder，保证数据不会泄露到应用层或系统内存。 Secure Path 渲染 确保视频帧只能显示，不能被截屏、拷贝或录制。 Widevine L1 生产预置流程 概述 Widevine L1 的生产预置流程是设备从出厂到获得正式身份认证的一系列安全操作，用于保证 设备私钥不泄露，并让设备能够获得 Google 签名的合法证书，参与 Widevine DRM 的内容解密。整个流程由 OEM 工厂和 Google 云端签名服务共同完成，但 OEM 不持有 Google 的根私钥。\n阶段 1：密钥对生成（Key Pair Generation） OEM 启动预置流程：生产线上的工厂 PC 启动预置程序，准备对新出厂设备进行 Widevine L1 初始化。 运行预置工具：工厂 PC 调用专用预置工具（FactoryTool），与设备芯片内部的 TEE 交互。 TEE 生成设备密钥对：芯片内部的可信执行环境（TEE）生成唯一的 Device Key Pair，其中 私钥永远不会导出，公钥将用于后续申请证书。 安全存储私钥：Device Private Key 被写入 TEE 的安全存储区域（如 Fuse / Keybox / RPMB），确保不可被外部访问。 导出公钥：TEE 将 Device Public Key 提供给预置工具，用于生成证书签名请求（CSR）。 安全亮点：私钥永不离开 TEE，保证设备身份的安全基础。\n阶段 2：证书签名请求（CSR） 生成 CSR：FactoryTool 将设备公钥与唯一的 Device ID 组合成证书签名请求（CSR）。\nCSR 遵循标准 PKI 规范，用于申请数字签名证书。 发送 CSR 至 Google 云端签名服务：CSR 通过加密通道（如专线、VPN 或 HTTPS）上传到 Google 的 Widevine CA 系统。\nGoogle 会先验证 CSR 请求来源是否来自授权 OEM 或工厂。 安全亮点：CSR 通过安全通道传输，保证在传输过程中不被篡改或窃取。\n阶段 3：签名与证书返回 Google 签名 CSR：Google 的证书签名服务使用 Root Private Key 对 CSR 进行数字签名，生成 设备证书（Device Certificate）。 返回签名证书：签名后的设备证书通过加密通道返回给工厂的预置工具。 安全亮点：OEM 不持有 Google 根私钥，签名操作完全在 Google 云端完成，保证了证书的权威性和不可伪造性。\n阶段 4：证书注入与激活 注入设备证书：FactoryTool 将签名证书写入 DeviceTEE 内部，通过 TEE 提供的安全接口完成注入。 TEE 验证签名：设备启动时或注入时，TEE 使用 Google Root Public Key 验证证书签名是否合法。 永久存储证书：签名验证通过后，设备证书被存储在 TEE 的安全存储区域，与私钥共同形成完整身份体系。 返回成功状态：TEE 向 FactoryTool 返回注入成功的状态，表示设备已成为 Widevine L1 合法设备。 签名验证失败（异常情况）：若验证失败，TEE 返回错误状态，流程中止，防止非法设备获得证书。 记录流程结果：FactoryPC 对整个流程进行记录和日志保存，以便追踪和质量管理。 安全亮点：\n设备证书和私钥都存储在 TEE 内，外部软件无法访问。 只有经过 Google 签名的设备证书才能被设备接受并激活 Widevine L1。 整个流程保证了生产阶段的设备身份和密钥管理安全。 总结 设备私钥永不外露，保证了 DRM 内容密钥解密的安全根基。 CSR 安全传输 + Google 云端签名，保证了设备公钥和身份的可信性。 TEE 验证与安全存储，确保只有合法设备才能获得 Widevine L1 认证。 OEM 仅扮演代理角色，负责安全地生成密钥和传递 CSR，签名权威仍在 Google。 Widevine 远程密钥预置 (RKP) 流程 1. RKP 简介 远程密钥预置（Remote Key Provisioning, RKP）是 Widevine L1 认证设备的一种现代密钥安装方法。与传统的工厂预置（Factory Provisioning）模式不同，RKP 允许设备在离开生产线后，于首次使用时，通过安全的网络连接动态地从 Google 服务器获取其唯一的设备密钥。\n这种模式的优势在于：\n简化生产线流程：无需在工厂进行耗时且复杂的密钥烧录操作。 更高的安全性：密钥仅在需要时才生成和安装，减少了生产和运输过程中的安全风险。 设备可更新性：密钥管理和证书可以在设备生命周期内进行远程更新和管理。 2. 关键组件 设备制造商 (OEM)：负责设备的硬件生产和软件集成。 Google RKP 服务：一个安全的云端服务，负责为设备生成和签名密钥。 高通/SoC 厂商：提供支持 RKP 的 TEE（可信执行环境）和相关的库（如 liboemcrypto.so）。 终端设备：待预置的设备，包含 TEE 硬件。 RKP 专用工具：Google 提供给 OEM 的工具，用于在工厂或开发阶段与设备通信，并协助密钥注册。 3. RKP 工作流程 整个 RKP 流程可以分为两个主要阶段：工厂注册和远程激活。\n阶段一：工厂端注册（一次性操作） 这个阶段通常在 OEM 的工厂或开发环境中完成，目的是将设备的基本信息和公钥安全地注册到谷歌的云端服务。\n设备准备：设备出厂时，其 TEE 内已预置了支持 RKP 的基础固件，但没有设备密钥。 证书签名请求 (CSR) 提取：OEM 使用 Google 提供的专用工具（如 rkp_factory_extraction_tool），通过 USB 或其他安全连接与设备通信。该工具指示设备的 TEE 生成一个临时的密钥对，并用其私钥对一个 CSR 进行签名。 CSR 上传：工具将该 CSR 上传到 Google 的 RKP 服务。 Google 签名：RKP 服务验证 CSR 的合法性，并用其根私钥对 CSR 进行签名，生成一个临时的设备证书。这个证书将用于后续远程激活时验证设备的身份。 阶段二：远程密钥获取与激活（首次使用） 这个阶段在设备首次连接到互联网时自动触发，通常在 App 尝试播放受保护内容时由 MediaDrm 框架启动。\n设备密钥生成：设备的 TEE 安全地生成一个永久的、唯一的设备密钥对。 密钥请求：设备将这个永久密钥对的公钥，以及在工厂端获得的临时证书，一起发送给 Google RKP 服务。 密钥签名：RKP 服务验证请求，并用其根私钥对设备的永久公钥进行签名，生成最终的、不可更改的设备证书。 设备激活：设备下载并验证这个签名的设备证书。一旦验证通过，设备密钥即被激活，并可以用于后续的许可证请求。 4. RKP 流程 PlantUML 时序图 ！\n传统的工厂预置私钥方式（Factory-Provisioned Keys） 在Android早期版本（如Android 11及之前）的密钥认证（Key Attestation）机制中，采用的是工厂预置私钥的方式。具体过程如下：\n密钥生成与预置：OEM（原始设备制造商）或ODM（原始设计制造商）在工厂环境中生成密钥对（公钥和私钥）。私钥直接注入（provisioned）到设备的TEE（Trusted Execution Environment，可信执行环境）中。 风险与问题：这要求在工厂处理敏感的私钥秘密，增加了供应链泄露的风险（如工厂员工或供应链环节的潜在泄露）。一旦私钥泄露，整个批次的设备可能受影响，且难以恢复。同时，密钥是静态的，不易轮换，隐私保护较弱（例如，多个应用可能共享同一密钥，导致追踪风险）。 使用流程：设备出厂后，应用请求认证时，直接使用预置的私钥生成凭证链，无需在线请求新证书。但证书链较短，且根信任基于RSA。\n这种方式确实在“第一步”（工厂阶段）就预置了私钥，这也是其主要安全隐患所在。 RKP（远程密钥预置）与传统的区别 RKP是Google从Android 12开始引入的可选机制，并在Android 13中强制要求（针对新设备），旨在取代传统的工厂预置私钥方式，提高安全性和隐私。RKP的核心是不预置私钥，而是由设备自行生成并保护私钥，只在工厂提取公钥。用户提到的“第一步中还是预制了私钥”是不准确的——RKP的第一步（工厂流程）是提取设备生成的公钥，而不是预置私钥。\n密钥生成：密钥对（公钥和私钥）由设备TEE自行生成。私钥从生成起就永不离开TEE的安全环境，确保零暴露。 工厂流程（第一步）：\nOEM在工厂启动设备公钥提取。 设备TEE生成唯一的硬件绑定密钥对。 只提取公钥（DK_PUB），上传到Google服务器存储。私钥不导出、不预置。\n远程配置流程（设备端）：设备开箱联网后，应用触发请求，TEE生成CSR（凭证签名请求），用私钥签名后发送到Google服务器。服务器验证公钥匹配后，签名并返回短期证书链（有效期最长两个月）。证书定期轮换。 安全/隐私优势：\n供应链安全：消除工厂处理私钥的风险，减少泄露可能。 隐私提升：每个应用获得不同的认证密钥，证书短期有效，服务器分段设计（验证公钥的服务器不接触认证密钥），防止设备追踪。 可恢复性：如果设备软件被入侵，Google可停止向其提供新证书，而不影响整个生态。 技术改进：证书链更长，根信任从RSA转向ECDSA，支持更安全的密钥轮换。\n总之，传统的工厂预置确实在第一步预置私钥，但RKP避免了这一点，转而使用设备生成+公钥提取的方式。这大大降低了风险，并已成为Android生态的标准。\n",
  "wordCount" : "486",
  "inLanguage": "en",
  "datePublished": "2025-08-08T11:36:11+08:00",
  "dateModified": "2025-08-08T11:36:11+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/android-dev/media/android-drm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/qnx/" title="QNX开发">
                    <span>QNX开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/android-dev/">Android系统开发</a></div>
    <h1 class="post-title entry-hint-parent">
      Android DRM 框架
    </h1>
    <div class="post-meta"><span title='2025-08-08 11:36:11 +0800 CST'>August 8, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;486 words

</div>
  </header> 
  <div class="post-content"><h2 id="widevine-l1-drm-播放流程解读">Widevine L1 DRM 播放流程解读<a hidden class="anchor" aria-hidden="true" href="#widevine-l1-drm-播放流程解读">#</a></h2>
<p>下面的时序图展示了 <strong>Android 平台 Widevine L1 DRM</strong> 的核心工作原理，涵盖了 <strong>设备注册、许可证获取、视频解密与安全渲染</strong> 三个阶段，并特别标注了 <strong>安全关键点（Secure Path）</strong>。</p>
<hr>
<h3 id="阶段1设备首次注册--公钥上报">阶段1：设备首次注册 / 公钥上报<a hidden class="anchor" aria-hidden="true" href="#阶段1设备首次注册--公钥上报">#</a></h3>
<ol>
<li>
<p><strong>App 初始化 DRM</strong></p>
<ul>
<li>应用调用 <code>MediaDrm</code>，系统初始化 DRM 会话。</li>
</ul>
</li>
<li>
<p><strong>TEE 生成设备密钥对</strong></p>
<ul>
<li>设备在 TEE 内部生成 <strong>Device Key Pair</strong>（公钥/私钥）。</li>
<li><strong>私钥仅存在于 TEE 内部，绝不导出</strong>。</li>
</ul>
</li>
<li>
<p><strong>设备证书生成</strong></p>
<ul>
<li>TEE 通过 <code>generateProvisioningRequest()</code> 生成设备证书，包含设备公钥和签名。</li>
</ul>
</li>
<li>
<p><strong>上传设备证书</strong></p>
<ul>
<li>App 将证书发送给 License Server。</li>
<li>License Server 验证签名，并保存设备公钥，用于后续加密 Content Key。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="阶段2许可证请求与-content-key-加密">阶段2：许可证请求与 Content Key 加密<a hidden class="anchor" aria-hidden="true" href="#阶段2许可证请求与-content-key-加密">#</a></h3>
<ol start="5">
<li>
<p><strong>生成许可证请求</strong></p>
<ul>
<li>App 调用 <code>getLicenseRequest(Content ID)</code>。</li>
<li>TEE 使用设备私钥对请求进行签名，保证请求合法性。</li>
</ul>
</li>
<li>
<p><strong>发送许可证请求</strong></p>
<ul>
<li>App 将签名请求发送给 License Server。</li>
</ul>
</li>
<li>
<p><strong>许可证生成</strong></p>
<ul>
<li>License Server 验证签名。</li>
<li>使用设备公钥加密 Content Key，并生成许可证响应。</li>
<li>加密后的许可证 = RSA_Encrypt(内容密钥, 设备公钥)</li>
</ul>
</li>
<li>
<p><strong>许可证下发</strong></p>
<ul>
<li>App 收到加密许可证，通过 <code>provideProvisionResponse()</code> 交给 MediaDrm/TEE。</li>
</ul>
</li>
<li>
<p><strong>TEE 内部解密许可证</strong></p>
<ul>
<li>TEE 使用设备私钥解密，取出 Content Key。
当设备收到加密的许可证后，CDM 会将其传递给 TEE。在 TEE 内部：
TEE 直接使用唯一的设备私钥来解密整个许可证，从而直接得到明文的内容密钥。
内容密钥 = RSA_Decrypt(加密后的许可证, 设备私钥)</li>
<li>返回一个 <strong>会话句柄</strong> 给 MediaDrm，而不是返回明文 Content Key。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="阶段3视频解密与-secure-path-渲染">阶段3：视频解密与 Secure Path 渲染<a hidden class="anchor" aria-hidden="true" href="#阶段3视频解密与-secure-path-渲染">#</a></h3>
<ol start="10">
<li>
<p><strong>MediaCrypto 初始化</strong></p>
<ul>
<li>App 创建 <code>MediaCrypto</code> 实例，绑定 Content Key 会话。</li>
</ul>
</li>
<li>
<p><strong>视频解码配置</strong></p>
<ul>
<li>App 配置 <code>MediaCodec</code>，准备播放加密视频流。</li>
</ul>
</li>
<li>
<p><strong>播放循环</strong></p>
<ul>
<li>
<p><strong>(21)</strong> App 将加密视频片段交给 <code>MediaCrypto</code>。</p>
</li>
<li>
<p><strong>(22)</strong> <code>MediaCrypto</code> 把加密数据传给 TEE。</p>
</li>
<li>
<p><strong>(23)</strong> TEE 使用 Content Key 解密。</p>
</li>
<li>
<p><strong>(24)</strong> 解密后的帧不会返回 App，而是直接传递到 <strong>SecureDecoder</strong>（安全硬件解码器）。</p>
<ul>
<li><strong>关键点：</strong> 解密后数据通过 <strong>Secure Buffer / Secure Path</strong>，不会暴露到普通内存或应用层。</li>
</ul>
</li>
<li>
<p><strong>(25)</strong> SecureDecoder 渲染视频帧到屏幕。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="安全关键点总结">安全关键点总结<a hidden class="anchor" aria-hidden="true" href="#安全关键点总结">#</a></h3>
<ul>
<li><strong>设备私钥 (Device Private Key)</strong> 永远存储在 TEE 内部，避免泄露。</li>
<li><strong>Content Key</strong> 只在 TEE 内部解密，并通过会话句柄访问，App 永远看不到明文密钥。</li>
<li><strong>解密视频帧</strong> 通过 <strong>Secure Buffer</strong> 直接进入 SecureDecoder，保证数据不会泄露到应用层或系统内存。</li>
<li><strong>Secure Path 渲染</strong> 确保视频帧只能显示，不能被截屏、拷贝或录制。</li>
</ul>
<hr>
<p><img loading="lazy" src="/ethenslab/images/drm-contentkey.png"></p>
<h2 id="widevine-l1-生产预置流程">Widevine L1 生产预置流程<a hidden class="anchor" aria-hidden="true" href="#widevine-l1-生产预置流程">#</a></h2>
<h3 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h3>
<p>Widevine L1 的生产预置流程是设备从出厂到获得正式身份认证的一系列安全操作，用于保证 <strong>设备私钥不泄露</strong>，并让设备能够获得 <strong>Google 签名的合法证书</strong>，参与 Widevine DRM 的内容解密。整个流程由 OEM 工厂和 Google 云端签名服务共同完成，但 OEM 不持有 Google 的根私钥。</p>
<hr>
<h3 id="阶段-1密钥对生成key-pair-generation">阶段 1：密钥对生成（Key Pair Generation）<a hidden class="anchor" aria-hidden="true" href="#阶段-1密钥对生成key-pair-generation">#</a></h3>
<ol>
<li><strong>OEM 启动预置流程</strong>：生产线上的工厂 PC 启动预置程序，准备对新出厂设备进行 Widevine L1 初始化。</li>
<li><strong>运行预置工具</strong>：工厂 PC 调用专用预置工具（FactoryTool），与设备芯片内部的 TEE 交互。</li>
<li><strong>TEE 生成设备密钥对</strong>：芯片内部的可信执行环境（TEE）生成唯一的 Device Key Pair，其中 <strong>私钥永远不会导出</strong>，公钥将用于后续申请证书。</li>
<li><strong>安全存储私钥</strong>：Device Private Key 被写入 TEE 的安全存储区域（如 Fuse / Keybox / RPMB），确保不可被外部访问。</li>
<li><strong>导出公钥</strong>：TEE 将 Device Public Key 提供给预置工具，用于生成证书签名请求（CSR）。</li>
</ol>
<p><strong>安全亮点</strong>：私钥永不离开 TEE，保证设备身份的安全基础。</p>
<hr>
<h3 id="阶段-2证书签名请求csr">阶段 2：证书签名请求（CSR）<a hidden class="anchor" aria-hidden="true" href="#阶段-2证书签名请求csr">#</a></h3>
<ol start="6">
<li>
<p><strong>生成 CSR</strong>：FactoryTool 将设备公钥与唯一的 Device ID 组合成证书签名请求（CSR）。</p>
<ul>
<li>CSR 遵循标准 PKI 规范，用于申请数字签名证书。</li>
</ul>
</li>
<li>
<p><strong>发送 CSR 至 Google 云端签名服务</strong>：CSR 通过加密通道（如专线、VPN 或 HTTPS）上传到 Google 的 Widevine CA 系统。</p>
<ul>
<li>Google 会先验证 CSR 请求来源是否来自授权 OEM 或工厂。</li>
</ul>
</li>
</ol>
<p><strong>安全亮点</strong>：CSR 通过安全通道传输，保证在传输过程中不被篡改或窃取。</p>
<hr>
<h3 id="阶段-3签名与证书返回">阶段 3：签名与证书返回<a hidden class="anchor" aria-hidden="true" href="#阶段-3签名与证书返回">#</a></h3>
<ol start="8">
<li><strong>Google 签名 CSR</strong>：Google 的证书签名服务使用 Root Private Key 对 CSR 进行数字签名，生成 <strong>设备证书（Device Certificate）</strong>。</li>
<li><strong>返回签名证书</strong>：签名后的设备证书通过加密通道返回给工厂的预置工具。</li>
</ol>
<p><strong>安全亮点</strong>：OEM 不持有 Google 根私钥，签名操作完全在 Google 云端完成，保证了证书的权威性和不可伪造性。</p>
<hr>
<h3 id="阶段-4证书注入与激活">阶段 4：证书注入与激活<a hidden class="anchor" aria-hidden="true" href="#阶段-4证书注入与激活">#</a></h3>
<ol start="10">
<li><strong>注入设备证书</strong>：FactoryTool 将签名证书写入 DeviceTEE 内部，通过 TEE 提供的安全接口完成注入。</li>
<li><strong>TEE 验证签名</strong>：设备启动时或注入时，TEE 使用 Google Root Public Key 验证证书签名是否合法。</li>
<li><strong>永久存储证书</strong>：签名验证通过后，设备证书被存储在 TEE 的安全存储区域，与私钥共同形成完整身份体系。</li>
<li><strong>返回成功状态</strong>：TEE 向 FactoryTool 返回注入成功的状态，表示设备已成为 Widevine L1 合法设备。</li>
<li><strong>签名验证失败</strong>（异常情况）：若验证失败，TEE 返回错误状态，流程中止，防止非法设备获得证书。</li>
<li><strong>记录流程结果</strong>：FactoryPC 对整个流程进行记录和日志保存，以便追踪和质量管理。</li>
</ol>
<p><strong>安全亮点</strong>：</p>
<ul>
<li>设备证书和私钥都存储在 TEE 内，外部软件无法访问。</li>
<li>只有经过 Google 签名的设备证书才能被设备接受并激活 Widevine L1。</li>
<li>整个流程保证了生产阶段的设备身份和密钥管理安全。</li>
</ul>
<hr>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<ol>
<li><strong>设备私钥永不外露</strong>，保证了 DRM 内容密钥解密的安全根基。</li>
<li><strong>CSR 安全传输 + Google 云端签名</strong>，保证了设备公钥和身份的可信性。</li>
<li><strong>TEE 验证与安全存储</strong>，确保只有合法设备才能获得 Widevine L1 认证。</li>
<li>OEM 仅扮演代理角色，负责安全地生成密钥和传递 CSR，签名权威仍在 Google。</li>
</ol>
<hr>
<p><img loading="lazy" src="/ethenslab/images/drm-keyprovision.png"></p>
<h2 id="widevine-远程密钥预置-rkp-流程">Widevine 远程密钥预置 (RKP) 流程<a hidden class="anchor" aria-hidden="true" href="#widevine-远程密钥预置-rkp-流程">#</a></h2>
<h3 id="1-rkp-简介"><strong>1. RKP 简介</strong><a hidden class="anchor" aria-hidden="true" href="#1-rkp-简介">#</a></h3>
<p>远程密钥预置（Remote Key Provisioning, RKP）是 Widevine L1 认证设备的一种现代密钥安装方法。与传统的<strong>工厂预置（Factory Provisioning）模式不同，RKP 允许设备在离开生产线后，于首次使用</strong>时，通过安全的网络连接动态地从 Google 服务器获取其唯一的设备密钥。</p>
<p>这种模式的优势在于：</p>
<ul>
<li><strong>简化生产线流程</strong>：无需在工厂进行耗时且复杂的密钥烧录操作。</li>
<li><strong>更高的安全性</strong>：密钥仅在需要时才生成和安装，减少了生产和运输过程中的安全风险。</li>
<li><strong>设备可更新性</strong>：密钥管理和证书可以在设备生命周期内进行远程更新和管理。</li>
</ul>
<h3 id="2-关键组件"><strong>2. 关键组件</strong><a hidden class="anchor" aria-hidden="true" href="#2-关键组件">#</a></h3>
<ul>
<li><strong>设备制造商 (OEM)</strong>：负责设备的硬件生产和软件集成。</li>
<li><strong>Google RKP 服务</strong>：一个安全的云端服务，负责为设备生成和签名密钥。</li>
<li><strong>高通/SoC 厂商</strong>：提供支持 RKP 的 TEE（可信执行环境）和相关的库（如 <code>liboemcrypto.so</code>）。</li>
<li><strong>终端设备</strong>：待预置的设备，包含 TEE 硬件。</li>
<li><strong>RKP 专用工具</strong>：Google 提供给 OEM 的工具，用于在工厂或开发阶段与设备通信，并协助密钥注册。</li>
</ul>
<h3 id="3-rkp-工作流程"><strong>3. RKP 工作流程</strong><a hidden class="anchor" aria-hidden="true" href="#3-rkp-工作流程">#</a></h3>
<p>整个 RKP 流程可以分为两个主要阶段：<strong>工厂注册</strong>和<strong>远程激活</strong>。</p>
<h4 id="阶段一工厂端注册一次性操作"><strong>阶段一：工厂端注册（一次性操作）</strong><a hidden class="anchor" aria-hidden="true" href="#阶段一工厂端注册一次性操作">#</a></h4>
<p>这个阶段通常在 OEM 的工厂或开发环境中完成，目的是将设备的基本信息和公钥安全地注册到谷歌的云端服务。</p>
<ol>
<li><strong>设备准备</strong>：设备出厂时，其 TEE 内已预置了支持 RKP 的基础固件，但<strong>没有</strong>设备密钥。</li>
<li><strong>证书签名请求 (CSR) 提取</strong>：OEM 使用 Google 提供的专用工具（如 <code>rkp_factory_extraction_tool</code>），通过 USB 或其他安全连接与设备通信。该工具指示设备的 TEE 生成一个临时的密钥对，并用其私钥对一个 CSR 进行签名。</li>
<li><strong>CSR 上传</strong>：工具将该 CSR 上传到 Google 的 RKP 服务。</li>
<li><strong>Google 签名</strong>：RKP 服务验证 CSR 的合法性，并用其<strong>根私钥</strong>对 CSR 进行签名，生成一个<strong>临时的设备证书</strong>。这个证书将用于后续远程激活时验证设备的身份。</li>
</ol>
<h4 id="阶段二远程密钥获取与激活首次使用"><strong>阶段二：远程密钥获取与激活（首次使用）</strong><a hidden class="anchor" aria-hidden="true" href="#阶段二远程密钥获取与激活首次使用">#</a></h4>
<p>这个阶段在设备首次连接到互联网时自动触发，通常在 App 尝试播放受保护内容时由 <code>MediaDrm</code> 框架启动。</p>
<ol>
<li><strong>设备密钥生成</strong>：设备的 TEE 安全地生成一个<strong>永久的</strong>、唯一的设备密钥对。</li>
<li><strong>密钥请求</strong>：设备将这个永久密钥对的<strong>公钥</strong>，以及在工厂端获得的临时证书，一起发送给 Google RKP 服务。</li>
<li><strong>密钥签名</strong>：RKP 服务验证请求，并用其<strong>根私钥</strong>对设备的永久公钥进行签名，生成最终的、不可更改的<strong>设备证书</strong>。</li>
<li><strong>设备激活</strong>：设备下载并验证这个签名的设备证书。一旦验证通过，设备密钥即被激活，并可以用于后续的许可证请求。</li>
</ol>
<hr>
<h4 id="4-rkp-流程-plantuml-时序图"><strong>4. RKP 流程 PlantUML 时序图</strong><a hidden class="anchor" aria-hidden="true" href="#4-rkp-流程-plantuml-时序图">#</a></h4>
<p>！<a href="/ethenslab/images/drm-rkp.png"></a></p>
<p>传统的工厂预置私钥方式（Factory-Provisioned Keys）
在Android早期版本（如Android 11及之前）的密钥认证（Key Attestation）机制中，采用的是工厂预置私钥的方式。具体过程如下：</p>
<p>密钥生成与预置：OEM（原始设备制造商）或ODM（原始设计制造商）在工厂环境中生成密钥对（公钥和私钥）。私钥直接注入（provisioned）到设备的TEE（Trusted Execution Environment，可信执行环境）中。
风险与问题：这要求在工厂处理敏感的私钥秘密，增加了供应链泄露的风险（如工厂员工或供应链环节的潜在泄露）。一旦私钥泄露，整个批次的设备可能受影响，且难以恢复。同时，密钥是静态的，不易轮换，隐私保护较弱（例如，多个应用可能共享同一密钥，导致追踪风险）。
使用流程：设备出厂后，应用请求认证时，直接使用预置的私钥生成凭证链，无需在线请求新证书。但证书链较短，且根信任基于RSA。</p>
<p>这种方式确实在“第一步”（工厂阶段）就预置了私钥，这也是其主要安全隐患所在。
RKP（远程密钥预置）与传统的区别
RKP是Google从Android 12开始引入的可选机制，并在Android 13中强制要求（针对新设备），旨在取代传统的工厂预置私钥方式，提高安全性和隐私。RKP的核心是不预置私钥，而是由设备自行生成并保护私钥，只在工厂提取公钥。用户提到的“第一步中还是预制了私钥”是不准确的——RKP的第一步（工厂流程）是提取设备生成的公钥，而不是预置私钥。</p>
<p>密钥生成：密钥对（公钥和私钥）由设备TEE自行生成。私钥从生成起就永不离开TEE的安全环境，确保零暴露。
工厂流程（第一步）：</p>
<p>OEM在工厂启动设备公钥提取。
设备TEE生成唯一的硬件绑定密钥对。
只提取公钥（DK_PUB），上传到Google服务器存储。私钥不导出、不预置。</p>
<p>远程配置流程（设备端）：设备开箱联网后，应用触发请求，TEE生成CSR（凭证签名请求），用私钥签名后发送到Google服务器。服务器验证公钥匹配后，签名并返回短期证书链（有效期最长两个月）。证书定期轮换。
安全/隐私优势：</p>
<p>供应链安全：消除工厂处理私钥的风险，减少泄露可能。
隐私提升：每个应用获得不同的认证密钥，证书短期有效，服务器分段设计（验证公钥的服务器不接触认证密钥），防止设备追踪。
可恢复性：如果设备软件被入侵，Google可停止向其提供新证书，而不影响整个生态。
技术改进：证书链更长，根信任从RSA转向ECDSA，支持更安全的密钥轮换。</p>
<p>总之，传统的工厂预置确实在第一步预置私钥，但RKP避免了这一点，转而使用设备生成+公钥提取的方式。这大大降低了风险，并已成为Android生态的标准。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://ethen-cao.github.io/ethenslab/android-dev/resource/android-theme/">
    <span class="title">Next »</span>
    <br>
    <span>Android Theme</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
