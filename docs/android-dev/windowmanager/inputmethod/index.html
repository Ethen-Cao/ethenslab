<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android 窗口焦点抢占与输入法连接断开技术时序分析 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 概述
@startuml
!theme plain
autonumber

skinparam backgroundColor white
skinparam participantBackgroundColor white
skinparam boxPadding 10
skinparam noteBackgroundColor #FFFFA0
skinparam noteBorderColor #808080

actor "User" as User

box "应用进程 A (Overlay - 当前焦点持有者)" #MistyRose
    participant "ViewRootImpl" as Overlay_VRI
    participant "ImeFocusController" as Overlay_Ctrl
    participant "InputMethodManager\n(IMM)" as Overlay_IMM
end box

box "系统服务 (System Server)" #LightBlue
    participant "InputDispatcher" as InputDispatcher
    participant "WindowManagerService\n(WMS)" as WMS
    participant "DisplayContent\n(DC)" as DC
    participant "InputMethodManagerService\n(IMMS)" as IMMS
end box

box "应用进程 B (Browser - 触摸事件接收者)" #Honeydew
    participant "ViewRootImpl" as Browser_VRI
    participant "Browser\nActivity" as Browser
    participant "InputMethodManager\n(IMM)" as Browser_IMM
end box

== 第一阶段：Overlay 窗口添加与焦点计算 ==

Overlay_VRI -> WMS: <color:red>**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE
activate WMS

    WMS -> WMS: **addWindowInner**() -> **updateFocusedWindowLocked**()

    group WMS 焦点更新逻辑
        WMS -> DC: **findFocusedWindowIfNeeded**()
        activate DC
            DC -> DC: 遍历窗口列表 (Z-Order Top-Down)
            DC -> DC: 检查 Overlay WindowState
            DC -> DC: **mayUseInputMethod**(flags)
            note right of DC
                **判定逻辑：**
                return (flags & FLAG_NOT_FOCUSABLE) == 0;
                **结果：TRUE**
                (系统判定该窗口具备处理 IME 输入的能力)
            end note
        DC --> WMS: 返回 **newFocus = Overlay**
        deactivate DC
    end

    WMS -> WMS: **mCurrentFocus = Overlay**
    
    par 并发通知焦点变更
        WMS -> Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true)
        WMS -> Browser_VRI: **windowFocusChanged**(hasWindowFocus=false)
    end
    
deactivate WMS

== 第二阶段：Overlay 建立输入法连接 ==

activate Overlay_VRI
    note right of Overlay_VRI
        触发条件：
        1. 收到 windowFocusChanged 回调
        2. 或执行 performTraversals 布局遍历
    end note

    Overlay_VRI -> Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**()
    activate Overlay_Ctrl
    
        Overlay_Ctrl -> Overlay_Ctrl: check **mayUseInputMethod**() == true
        
        Overlay_Ctrl -> Overlay_IMM: **onPostWindowGainedFocus**()
        activate Overlay_IMM
            
            note right of Overlay_IMM
                **IPC 请求：**
                请求建立输入连接
            end note
            
            Overlay_IMM -> IMMS: **startInputOrWindowGainedFocus**(\n  reason=WINDOW_FOCUS_GAIN,\n  client=Overlay,\n  windowToken=OverlayToken)
            activate IMMS

== 第三阶段：IMMS 执行客户端切换与解绑 ==

                group IMMS 服务端处理
                    IMMS -> IMMS: **startInputOrWindowGainedFocusInternalLocked**()
                    
                    IMMS -> IMMS: check **mCurClient (Browser) != newClient (Overlay)**
                    
                    IMMS -> IMMS: **prepareClientSwitchLocked**()
                    IMMS -> IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT)
                    
                    activate IMMS #FFBBBB
                        note right of IMMS
                            **状态清理：**
                            1. userData.mCurClient.mClient.setActive(false)
                               -> 通知 Browser 停止输入活动
                            2. finishSessionLocked(session)
                               -> 销毁 Browser 的 InputChannel
                            3. **mCurClient = null**
                        end note
                    deactivate IMMS
                    
                    IMMS -> IMMS: **mCurClient = Overlay**
                    note right of IMMS
                        **当前状态：**
                        IMMS 服务端记录的 Client 已变更为 Overlay
                    end note
                end
                
            IMMS --> Overlay_IMM: return InputBindResult (SUCCESS)
            deactivate IMMS
            
        deactivate Overlay_IMM
    deactivate Overlay_Ctrl
deactivate Overlay_VRI

== 第四阶段：触摸事件派发 (Touch Dispatch) ==

User -> InputDispatcher: 点击屏幕 (Touch Down)
activate InputDispatcher

    note right of InputDispatcher
        **事件派发逻辑：**
        虽然 Overlay Z-Order 最高，但设置了 
        FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外)
        事件向下穿透
    end note

    InputDispatcher -> Browser_VRI: **InputEvent (ACTION_DOWN)**
deactivate InputDispatcher

activate Browser_VRI
    Browser_VRI -> Browser: **dispatchTouchEvent**()
    Browser -> Browser: View.onTouchEvent() -> performClick()
    
    note right of Browser
        Browser 能够接收点击事件
        但此时 Window 焦点已丢失 (HasFocus=false)
    end note

== 第五阶段：请求输入法失败 ==

    Browser -> Browser_IMM: **showSoftInput**(view)
    activate Browser_IMM
    
        group IMM 客户端自检
            Browser_IMM -> Browser_IMM: **checkFocus**()
            Browser_IMM -> Browser_IMM: **hasServedByInputMethodLocked**()
            note left
                **失败点 A (客户端拦截)：**
                由于之前收到 windowFocusChanged(false)
                ViewRootImpl 判定当前窗口无焦点
                mServedView 可能为 null 或不匹配
                **Result: return false** (Log: "Ignoring... is not served")
            end note
        end

        alt 假设绕过客户端检查 (强制请求服务端)
            Browser_IMM -> IMMS: **showSoftInput**(client=Browser)
            activate IMMS
            
            IMMS -> IMMS: check **mCurClient (Overlay) == client (Browser)**
            
            note left of IMMS #FFAAAA
                **失败点 B (服务端拒绝)：**
                Validation Failed.
                请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。
            end note
            
            IMMS -->> Browser_IMM: return false
            deactivate IMMS
        end

    Browser_IMM -->> Browser: return false
    deactivate Browser_IMM

deactivate Browser_VRI

@enduml
本时序图展示了一个配置为 TYPE_APPLICATION_OVERLAY 但缺失 FLAG_NOT_FOCUSABLE 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content=" Android 窗口焦点抢占与输入法连接断开技术时序分析"><meta property="og:description" content='1. 概述 @startuml !theme plain autonumber skinparam backgroundColor white skinparam participantBackgroundColor white skinparam boxPadding 10 skinparam noteBackgroundColor #FFFFA0 skinparam noteBorderColor #808080 actor "User" as User box "应用进程 A (Overlay - 当前焦点持有者)" #MistyRose participant "ViewRootImpl" as Overlay_VRI participant "ImeFocusController" as Overlay_Ctrl participant "InputMethodManager\n(IMM)" as Overlay_IMM end box box "系统服务 (System Server)" #LightBlue participant "InputDispatcher" as InputDispatcher participant "WindowManagerService\n(WMS)" as WMS participant "DisplayContent\n(DC)" as DC participant "InputMethodManagerService\n(IMMS)" as IMMS end box box "应用进程 B (Browser - 触摸事件接收者)" #Honeydew participant "ViewRootImpl" as Browser_VRI participant "Browser\nActivity" as Browser participant "InputMethodManager\n(IMM)" as Browser_IMM end box == 第一阶段：Overlay 窗口添加与焦点计算 == Overlay_VRI -> WMS: <color:red>**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE activate WMS WMS -> WMS: **addWindowInner**() -> **updateFocusedWindowLocked**() group WMS 焦点更新逻辑 WMS -> DC: **findFocusedWindowIfNeeded**() activate DC DC -> DC: 遍历窗口列表 (Z-Order Top-Down) DC -> DC: 检查 Overlay WindowState DC -> DC: **mayUseInputMethod**(flags) note right of DC **判定逻辑：** return (flags & FLAG_NOT_FOCUSABLE) == 0; **结果：TRUE** (系统判定该窗口具备处理 IME 输入的能力) end note DC --> WMS: 返回 **newFocus = Overlay** deactivate DC end WMS -> WMS: **mCurrentFocus = Overlay** par 并发通知焦点变更 WMS -> Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true) WMS -> Browser_VRI: **windowFocusChanged**(hasWindowFocus=false) end deactivate WMS == 第二阶段：Overlay 建立输入法连接 == activate Overlay_VRI note right of Overlay_VRI 触发条件： 1. 收到 windowFocusChanged 回调 2. 或执行 performTraversals 布局遍历 end note Overlay_VRI -> Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**() activate Overlay_Ctrl Overlay_Ctrl -> Overlay_Ctrl: check **mayUseInputMethod**() == true Overlay_Ctrl -> Overlay_IMM: **onPostWindowGainedFocus**() activate Overlay_IMM note right of Overlay_IMM **IPC 请求：** 请求建立输入连接 end note Overlay_IMM -> IMMS: **startInputOrWindowGainedFocus**(\n reason=WINDOW_FOCUS_GAIN,\n client=Overlay,\n windowToken=OverlayToken) activate IMMS == 第三阶段：IMMS 执行客户端切换与解绑 == group IMMS 服务端处理 IMMS -> IMMS: **startInputOrWindowGainedFocusInternalLocked**() IMMS -> IMMS: check **mCurClient (Browser) != newClient (Overlay)** IMMS -> IMMS: **prepareClientSwitchLocked**() IMMS -> IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT) activate IMMS #FFBBBB note right of IMMS **状态清理：** 1. userData.mCurClient.mClient.setActive(false) -> 通知 Browser 停止输入活动 2. finishSessionLocked(session) -> 销毁 Browser 的 InputChannel 3. **mCurClient = null** end note deactivate IMMS IMMS -> IMMS: **mCurClient = Overlay** note right of IMMS **当前状态：** IMMS 服务端记录的 Client 已变更为 Overlay end note end IMMS --> Overlay_IMM: return InputBindResult (SUCCESS) deactivate IMMS deactivate Overlay_IMM deactivate Overlay_Ctrl deactivate Overlay_VRI == 第四阶段：触摸事件派发 (Touch Dispatch) == User -> InputDispatcher: 点击屏幕 (Touch Down) activate InputDispatcher note right of InputDispatcher **事件派发逻辑：** 虽然 Overlay Z-Order 最高，但设置了 FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外) 事件向下穿透 end note InputDispatcher -> Browser_VRI: **InputEvent (ACTION_DOWN)** deactivate InputDispatcher activate Browser_VRI Browser_VRI -> Browser: **dispatchTouchEvent**() Browser -> Browser: View.onTouchEvent() -> performClick() note right of Browser Browser 能够接收点击事件 但此时 Window 焦点已丢失 (HasFocus=false) end note == 第五阶段：请求输入法失败 == Browser -> Browser_IMM: **showSoftInput**(view) activate Browser_IMM group IMM 客户端自检 Browser_IMM -> Browser_IMM: **checkFocus**() Browser_IMM -> Browser_IMM: **hasServedByInputMethodLocked**() note left **失败点 A (客户端拦截)：** 由于之前收到 windowFocusChanged(false) ViewRootImpl 判定当前窗口无焦点 mServedView 可能为 null 或不匹配 **Result: return false** (Log: "Ignoring... is not served") end note end alt 假设绕过客户端检查 (强制请求服务端) Browser_IMM -> IMMS: **showSoftInput**(client=Browser) activate IMMS IMMS -> IMMS: check **mCurClient (Overlay) == client (Browser)** note left of IMMS #FFAAAA **失败点 B (服务端拒绝)：** Validation Failed. 请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。 end note IMMS -->> Browser_IMM: return false deactivate IMMS end Browser_IMM -->> Browser: return false deactivate Browser_IMM deactivate Browser_VRI @enduml 本时序图展示了一个配置为 TYPE_APPLICATION_OVERLAY 但缺失 FLAG_NOT_FOCUSABLE 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T10:22:54+08:00"><meta property="article:modified_time" content="2025-09-29T10:22:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content=" Android 窗口焦点抢占与输入法连接断开技术时序分析"><meta name=twitter:description content='1. 概述
@startuml
!theme plain
autonumber

skinparam backgroundColor white
skinparam participantBackgroundColor white
skinparam boxPadding 10
skinparam noteBackgroundColor #FFFFA0
skinparam noteBorderColor #808080

actor "User" as User

box "应用进程 A (Overlay - 当前焦点持有者)" #MistyRose
    participant "ViewRootImpl" as Overlay_VRI
    participant "ImeFocusController" as Overlay_Ctrl
    participant "InputMethodManager\n(IMM)" as Overlay_IMM
end box

box "系统服务 (System Server)" #LightBlue
    participant "InputDispatcher" as InputDispatcher
    participant "WindowManagerService\n(WMS)" as WMS
    participant "DisplayContent\n(DC)" as DC
    participant "InputMethodManagerService\n(IMMS)" as IMMS
end box

box "应用进程 B (Browser - 触摸事件接收者)" #Honeydew
    participant "ViewRootImpl" as Browser_VRI
    participant "Browser\nActivity" as Browser
    participant "InputMethodManager\n(IMM)" as Browser_IMM
end box

== 第一阶段：Overlay 窗口添加与焦点计算 ==

Overlay_VRI -> WMS: <color:red>**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE
activate WMS

    WMS -> WMS: **addWindowInner**() -> **updateFocusedWindowLocked**()

    group WMS 焦点更新逻辑
        WMS -> DC: **findFocusedWindowIfNeeded**()
        activate DC
            DC -> DC: 遍历窗口列表 (Z-Order Top-Down)
            DC -> DC: 检查 Overlay WindowState
            DC -> DC: **mayUseInputMethod**(flags)
            note right of DC
                **判定逻辑：**
                return (flags & FLAG_NOT_FOCUSABLE) == 0;
                **结果：TRUE**
                (系统判定该窗口具备处理 IME 输入的能力)
            end note
        DC --> WMS: 返回 **newFocus = Overlay**
        deactivate DC
    end

    WMS -> WMS: **mCurrentFocus = Overlay**
    
    par 并发通知焦点变更
        WMS -> Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true)
        WMS -> Browser_VRI: **windowFocusChanged**(hasWindowFocus=false)
    end
    
deactivate WMS

== 第二阶段：Overlay 建立输入法连接 ==

activate Overlay_VRI
    note right of Overlay_VRI
        触发条件：
        1. 收到 windowFocusChanged 回调
        2. 或执行 performTraversals 布局遍历
    end note

    Overlay_VRI -> Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**()
    activate Overlay_Ctrl
    
        Overlay_Ctrl -> Overlay_Ctrl: check **mayUseInputMethod**() == true
        
        Overlay_Ctrl -> Overlay_IMM: **onPostWindowGainedFocus**()
        activate Overlay_IMM
            
            note right of Overlay_IMM
                **IPC 请求：**
                请求建立输入连接
            end note
            
            Overlay_IMM -> IMMS: **startInputOrWindowGainedFocus**(\n  reason=WINDOW_FOCUS_GAIN,\n  client=Overlay,\n  windowToken=OverlayToken)
            activate IMMS

== 第三阶段：IMMS 执行客户端切换与解绑 ==

                group IMMS 服务端处理
                    IMMS -> IMMS: **startInputOrWindowGainedFocusInternalLocked**()
                    
                    IMMS -> IMMS: check **mCurClient (Browser) != newClient (Overlay)**
                    
                    IMMS -> IMMS: **prepareClientSwitchLocked**()
                    IMMS -> IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT)
                    
                    activate IMMS #FFBBBB
                        note right of IMMS
                            **状态清理：**
                            1. userData.mCurClient.mClient.setActive(false)
                               -> 通知 Browser 停止输入活动
                            2. finishSessionLocked(session)
                               -> 销毁 Browser 的 InputChannel
                            3. **mCurClient = null**
                        end note
                    deactivate IMMS
                    
                    IMMS -> IMMS: **mCurClient = Overlay**
                    note right of IMMS
                        **当前状态：**
                        IMMS 服务端记录的 Client 已变更为 Overlay
                    end note
                end
                
            IMMS --> Overlay_IMM: return InputBindResult (SUCCESS)
            deactivate IMMS
            
        deactivate Overlay_IMM
    deactivate Overlay_Ctrl
deactivate Overlay_VRI

== 第四阶段：触摸事件派发 (Touch Dispatch) ==

User -> InputDispatcher: 点击屏幕 (Touch Down)
activate InputDispatcher

    note right of InputDispatcher
        **事件派发逻辑：**
        虽然 Overlay Z-Order 最高，但设置了 
        FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外)
        事件向下穿透
    end note

    InputDispatcher -> Browser_VRI: **InputEvent (ACTION_DOWN)**
deactivate InputDispatcher

activate Browser_VRI
    Browser_VRI -> Browser: **dispatchTouchEvent**()
    Browser -> Browser: View.onTouchEvent() -> performClick()
    
    note right of Browser
        Browser 能够接收点击事件
        但此时 Window 焦点已丢失 (HasFocus=false)
    end note

== 第五阶段：请求输入法失败 ==

    Browser -> Browser_IMM: **showSoftInput**(view)
    activate Browser_IMM
    
        group IMM 客户端自检
            Browser_IMM -> Browser_IMM: **checkFocus**()
            Browser_IMM -> Browser_IMM: **hasServedByInputMethodLocked**()
            note left
                **失败点 A (客户端拦截)：**
                由于之前收到 windowFocusChanged(false)
                ViewRootImpl 判定当前窗口无焦点
                mServedView 可能为 null 或不匹配
                **Result: return false** (Log: "Ignoring... is not served")
            end note
        end

        alt 假设绕过客户端检查 (强制请求服务端)
            Browser_IMM -> IMMS: **showSoftInput**(client=Browser)
            activate IMMS
            
            IMMS -> IMMS: check **mCurClient (Overlay) == client (Browser)**
            
            note left of IMMS #FFAAAA
                **失败点 B (服务端拒绝)：**
                Validation Failed.
                请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。
            end note
            
            IMMS -->> Browser_IMM: return false
            deactivate IMMS
        end

    Browser_IMM -->> Browser: return false
    deactivate Browser_IMM

deactivate Browser_VRI

@enduml
本时序图展示了一个配置为 TYPE_APPLICATION_OVERLAY 但缺失 FLAG_NOT_FOCUSABLE 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"WindowManager","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/"},{"@type":"ListItem","position":3,"name":" Android 窗口焦点抢占与输入法连接断开技术时序分析","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":" Android 窗口焦点抢占与输入法连接断开技术时序分析","name":" Android 窗口焦点抢占与输入法连接断开技术时序分析","description":"1. 概述 @startuml !theme plain autonumber skinparam backgroundColor white skinparam participantBackgroundColor white skinparam boxPadding 10 skinparam noteBackgroundColor #FFFFA0 skinparam noteBorderColor #808080 actor \u0026#34;User\u0026#34; as User box \u0026#34;应用进程 A (Overlay - 当前焦点持有者)\u0026#34; #MistyRose participant \u0026#34;ViewRootImpl\u0026#34; as Overlay_VRI participant \u0026#34;ImeFocusController\u0026#34; as Overlay_Ctrl participant \u0026#34;InputMethodManager\\n(IMM)\u0026#34; as Overlay_IMM end box box \u0026#34;系统服务 (System Server)\u0026#34; #LightBlue participant \u0026#34;InputDispatcher\u0026#34; as InputDispatcher participant \u0026#34;WindowManagerService\\n(WMS)\u0026#34; as WMS participant \u0026#34;DisplayContent\\n(DC)\u0026#34; as DC participant \u0026#34;InputMethodManagerService\\n(IMMS)\u0026#34; as IMMS end box box \u0026#34;应用进程 B (Browser - 触摸事件接收者)\u0026#34; #Honeydew participant \u0026#34;ViewRootImpl\u0026#34; as Browser_VRI participant \u0026#34;Browser\\nActivity\u0026#34; as Browser participant \u0026#34;InputMethodManager\\n(IMM)\u0026#34; as Browser_IMM end box == 第一阶段：Overlay 窗口添加与焦点计算 == Overlay_VRI -\u0026gt; WMS: \u0026lt;color:red\u0026gt;**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE activate WMS WMS -\u0026gt; WMS: **addWindowInner**() -\u0026gt; **updateFocusedWindowLocked**() group WMS 焦点更新逻辑 WMS -\u0026gt; DC: **findFocusedWindowIfNeeded**() activate DC DC -\u0026gt; DC: 遍历窗口列表 (Z-Order Top-Down) DC -\u0026gt; DC: 检查 Overlay WindowState DC -\u0026gt; DC: **mayUseInputMethod**(flags) note right of DC **判定逻辑：** return (flags \u0026amp; FLAG_NOT_FOCUSABLE) == 0; **结果：TRUE** (系统判定该窗口具备处理 IME 输入的能力) end note DC --\u0026gt; WMS: 返回 **newFocus = Overlay** deactivate DC end WMS -\u0026gt; WMS: **mCurrentFocus = Overlay** par 并发通知焦点变更 WMS -\u0026gt; Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true) WMS -\u0026gt; Browser_VRI: **windowFocusChanged**(hasWindowFocus=false) end deactivate WMS == 第二阶段：Overlay 建立输入法连接 == activate Overlay_VRI note right of Overlay_VRI 触发条件： 1. 收到 windowFocusChanged 回调 2. 或执行 performTraversals 布局遍历 end note Overlay_VRI -\u0026gt; Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**() activate Overlay_Ctrl Overlay_Ctrl -\u0026gt; Overlay_Ctrl: check **mayUseInputMethod**() == true Overlay_Ctrl -\u0026gt; Overlay_IMM: **onPostWindowGainedFocus**() activate Overlay_IMM note right of Overlay_IMM **IPC 请求：** 请求建立输入连接 end note Overlay_IMM -\u0026gt; IMMS: **startInputOrWindowGainedFocus**(\\n reason=WINDOW_FOCUS_GAIN,\\n client=Overlay,\\n windowToken=OverlayToken) activate IMMS == 第三阶段：IMMS 执行客户端切换与解绑 == group IMMS 服务端处理 IMMS -\u0026gt; IMMS: **startInputOrWindowGainedFocusInternalLocked**() IMMS -\u0026gt; IMMS: check **mCurClient (Browser) != newClient (Overlay)** IMMS -\u0026gt; IMMS: **prepareClientSwitchLocked**() IMMS -\u0026gt; IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT) activate IMMS #FFBBBB note right of IMMS **状态清理：** 1. userData.mCurClient.mClient.setActive(false) -\u0026gt; 通知 Browser 停止输入活动 2. finishSessionLocked(session) -\u0026gt; 销毁 Browser 的 InputChannel 3. **mCurClient = null** end note deactivate IMMS IMMS -\u0026gt; IMMS: **mCurClient = Overlay** note right of IMMS **当前状态：** IMMS 服务端记录的 Client 已变更为 Overlay end note end IMMS --\u0026gt; Overlay_IMM: return InputBindResult (SUCCESS) deactivate IMMS deactivate Overlay_IMM deactivate Overlay_Ctrl deactivate Overlay_VRI == 第四阶段：触摸事件派发 (Touch Dispatch) == User -\u0026gt; InputDispatcher: 点击屏幕 (Touch Down) activate InputDispatcher note right of InputDispatcher **事件派发逻辑：** 虽然 Overlay Z-Order 最高，但设置了 FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外) 事件向下穿透 end note InputDispatcher -\u0026gt; Browser_VRI: **InputEvent (ACTION_DOWN)** deactivate InputDispatcher activate Browser_VRI Browser_VRI -\u0026gt; Browser: **dispatchTouchEvent**() Browser -\u0026gt; Browser: View.onTouchEvent() -\u0026gt; performClick() note right of Browser Browser 能够接收点击事件 但此时 Window 焦点已丢失 (HasFocus=false) end note == 第五阶段：请求输入法失败 == Browser -\u0026gt; Browser_IMM: **showSoftInput**(view) activate Browser_IMM group IMM 客户端自检 Browser_IMM -\u0026gt; Browser_IMM: **checkFocus**() Browser_IMM -\u0026gt; Browser_IMM: **hasServedByInputMethodLocked**() note left **失败点 A (客户端拦截)：** 由于之前收到 windowFocusChanged(false) ViewRootImpl 判定当前窗口无焦点 mServedView 可能为 null 或不匹配 **Result: return false** (Log: \u0026#34;Ignoring... is not served\u0026#34;) end note end alt 假设绕过客户端检查 (强制请求服务端) Browser_IMM -\u0026gt; IMMS: **showSoftInput**(client=Browser) activate IMMS IMMS -\u0026gt; IMMS: check **mCurClient (Overlay) == client (Browser)** note left of IMMS #FFAAAA **失败点 B (服务端拒绝)：** Validation Failed. 请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。 end note IMMS --\u0026gt;\u0026gt; Browser_IMM: return false deactivate IMMS end Browser_IMM --\u0026gt;\u0026gt; Browser: return false deactivate Browser_IMM deactivate Browser_VRI @enduml 本时序图展示了一个配置为 TYPE_APPLICATION_OVERLAY 但缺失 FLAG_NOT_FOCUSABLE 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。\n","keywords":[],"articleBody":"1. 概述 @startuml !theme plain autonumber skinparam backgroundColor white skinparam participantBackgroundColor white skinparam boxPadding 10 skinparam noteBackgroundColor #FFFFA0 skinparam noteBorderColor #808080 actor \"User\" as User box \"应用进程 A (Overlay - 当前焦点持有者)\" #MistyRose participant \"ViewRootImpl\" as Overlay_VRI participant \"ImeFocusController\" as Overlay_Ctrl participant \"InputMethodManager\\n(IMM)\" as Overlay_IMM end box box \"系统服务 (System Server)\" #LightBlue participant \"InputDispatcher\" as InputDispatcher participant \"WindowManagerService\\n(WMS)\" as WMS participant \"DisplayContent\\n(DC)\" as DC participant \"InputMethodManagerService\\n(IMMS)\" as IMMS end box box \"应用进程 B (Browser - 触摸事件接收者)\" #Honeydew participant \"ViewRootImpl\" as Browser_VRI participant \"Browser\\nActivity\" as Browser participant \"InputMethodManager\\n(IMM)\" as Browser_IMM end box == 第一阶段：Overlay 窗口添加与焦点计算 == Overlay_VRI -\u003e WMS: **addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE activate WMS WMS -\u003e WMS: **addWindowInner**() -\u003e **updateFocusedWindowLocked**() group WMS 焦点更新逻辑 WMS -\u003e DC: **findFocusedWindowIfNeeded**() activate DC DC -\u003e DC: 遍历窗口列表 (Z-Order Top-Down) DC -\u003e DC: 检查 Overlay WindowState DC -\u003e DC: **mayUseInputMethod**(flags) note right of DC **判定逻辑：** return (flags \u0026 FLAG_NOT_FOCUSABLE) == 0; **结果：TRUE** (系统判定该窗口具备处理 IME 输入的能力) end note DC --\u003e WMS: 返回 **newFocus = Overlay** deactivate DC end WMS -\u003e WMS: **mCurrentFocus = Overlay** par 并发通知焦点变更 WMS -\u003e Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true) WMS -\u003e Browser_VRI: **windowFocusChanged**(hasWindowFocus=false) end deactivate WMS == 第二阶段：Overlay 建立输入法连接 == activate Overlay_VRI note right of Overlay_VRI 触发条件： 1. 收到 windowFocusChanged 回调 2. 或执行 performTraversals 布局遍历 end note Overlay_VRI -\u003e Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**() activate Overlay_Ctrl Overlay_Ctrl -\u003e Overlay_Ctrl: check **mayUseInputMethod**() == true Overlay_Ctrl -\u003e Overlay_IMM: **onPostWindowGainedFocus**() activate Overlay_IMM note right of Overlay_IMM **IPC 请求：** 请求建立输入连接 end note Overlay_IMM -\u003e IMMS: **startInputOrWindowGainedFocus**(\\n reason=WINDOW_FOCUS_GAIN,\\n client=Overlay,\\n windowToken=OverlayToken) activate IMMS == 第三阶段：IMMS 执行客户端切换与解绑 == group IMMS 服务端处理 IMMS -\u003e IMMS: **startInputOrWindowGainedFocusInternalLocked**() IMMS -\u003e IMMS: check **mCurClient (Browser) != newClient (Overlay)** IMMS -\u003e IMMS: **prepareClientSwitchLocked**() IMMS -\u003e IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT) activate IMMS #FFBBBB note right of IMMS **状态清理：** 1. userData.mCurClient.mClient.setActive(false) -\u003e 通知 Browser 停止输入活动 2. finishSessionLocked(session) -\u003e 销毁 Browser 的 InputChannel 3. **mCurClient = null** end note deactivate IMMS IMMS -\u003e IMMS: **mCurClient = Overlay** note right of IMMS **当前状态：** IMMS 服务端记录的 Client 已变更为 Overlay end note end IMMS --\u003e Overlay_IMM: return InputBindResult (SUCCESS) deactivate IMMS deactivate Overlay_IMM deactivate Overlay_Ctrl deactivate Overlay_VRI == 第四阶段：触摸事件派发 (Touch Dispatch) == User -\u003e InputDispatcher: 点击屏幕 (Touch Down) activate InputDispatcher note right of InputDispatcher **事件派发逻辑：** 虽然 Overlay Z-Order 最高，但设置了 FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外) 事件向下穿透 end note InputDispatcher -\u003e Browser_VRI: **InputEvent (ACTION_DOWN)** deactivate InputDispatcher activate Browser_VRI Browser_VRI -\u003e Browser: **dispatchTouchEvent**() Browser -\u003e Browser: View.onTouchEvent() -\u003e performClick() note right of Browser Browser 能够接收点击事件 但此时 Window 焦点已丢失 (HasFocus=false) end note == 第五阶段：请求输入法失败 == Browser -\u003e Browser_IMM: **showSoftInput**(view) activate Browser_IMM group IMM 客户端自检 Browser_IMM -\u003e Browser_IMM: **checkFocus**() Browser_IMM -\u003e Browser_IMM: **hasServedByInputMethodLocked**() note left **失败点 A (客户端拦截)：** 由于之前收到 windowFocusChanged(false) ViewRootImpl 判定当前窗口无焦点 mServedView 可能为 null 或不匹配 **Result: return false** (Log: \"Ignoring... is not served\") end note end alt 假设绕过客户端检查 (强制请求服务端) Browser_IMM -\u003e IMMS: **showSoftInput**(client=Browser) activate IMMS IMMS -\u003e IMMS: check **mCurClient (Overlay) == client (Browser)** note left of IMMS #FFAAAA **失败点 B (服务端拒绝)：** Validation Failed. 请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。 end note IMMS --\u003e\u003e Browser_IMM: return false deactivate IMMS end Browser_IMM --\u003e\u003e Browser: return false deactivate Browser_IMM deactivate Browser_VRI @enduml 本时序图展示了一个配置为 TYPE_APPLICATION_OVERLAY 但缺失 FLAG_NOT_FOCUSABLE 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。\n2. 详细流程阶段解析 第一阶段：WMS 焦点仲裁（Focus Arbitration） 此阶段发生在 Overlay 窗口被添加到系统窗口管理器（WMS）的时刻。\n触发动作：Overlay 应用调用 WindowManager.addView，参数中未包含 FLAG_NOT_FOCUSABLE。 WMS 内部逻辑： addWindowInner 触发层级更新，Overlay 被置于 Z-Order 顶层。 随后调用 updateFocusedWindowLocked -\u003e findFocusedWindowIfNeeded 重新计算全局焦点。 关键判定：DisplayContent 从顶层向下遍历窗口。对于 Overlay 窗口，系统调用 mayUseInputMethod(flags) 进行判定。由于 Missing Flag，该方法返回 true。 结果：WMS 将全局焦点变量 mCurrentFocus 锁定为 Overlay，并向各应用进程分发 windowFocusChanged 回调（Overlay 为 true，Browser 为 false）。 第二阶段：Overlay 建立连接（Active Connection Establishment） 此阶段发生在 Overlay 应用的主线程（UI Thread）中。\n触发动作：Overlay 的 ViewRootImpl 收到获焦通知或执行布局遍历（performTraversals）。\n客户端自检：\nImeFocusController 执行 onTraversal 或 onPostWindowFocus。 再次执行本地检查 WindowManager.LayoutParams.mayUseInputMethod，结果为 true。 发起请求：Overlay 进程通过 InputMethodManager 向系统服务发起 IPC 调用 startInputOrWindowGainedFocus，理由为 WINDOW_FOCUS_GAIN。这标志着 Overlay 主动向系统宣誓了输入法的主权。\n第三阶段：IMMS 服务端会话切换（Session Switch） 此阶段发生在系统服务进程（System_Server）的 InputMethodManagerService 中。\n状态校验：IMMS 接收到 Overlay 的请求，对比当前绑定的客户端 mCurClient（此时仍指向 Browser）与请求者（Overlay）。 强制解绑（Critical Step）： 发现客户端不一致，IMMS 调用 prepareClientSwitchLocked。 执行 unbindCurrentClientLocked(SWITCH_CLIENT)。 后果：系统销毁了 Browser 的 InputMethodSession，并将 Browser 对应的 ClientState 标记为非激活。 新绑定：mCurClient 更新为 Overlay。至此，输入法的数据通道已物理切换至 Overlay，Browser 与输入法的连接被彻底切断。 第四阶段：触摸事件与输入焦点的逻辑分离（Touch vs Focus Discrepancy） 此阶段揭示了问题的隐蔽性：用户感知与系统状态的割裂。\n触摸派发（Touch Dispatch）：用户点击屏幕。InputDispatcher 进行命中测试。由于 Overlay 设置了 FLAG_NOT_TOUCH_MODAL（或点击区域位于 Overlay 之外），点击事件（ACTION_DOWN/UP）穿透 Overlay，正常派发给了底层的 Browser。 逻辑冲突：Browser 能够响应 onClick，产生一种“我还在前台”的错觉。但根据 WMS 的状态（第一阶段），它实际上处于“可见但无焦点”的状态。 第五阶段：请求被拒（Request Rejection） 此阶段是用户看到的最终故障现象。\nBrowser 发起请求：Browser 的 EditText 响应点击，调用 showSoftInput。 拦截点 A（客户端本地拦截）：InputMethodManager 检查本地状态 checkFocus()。由于之前收到了 windowFocusChanged(false)，hasServedByInputMethodLocked() 返回 false，请求可能直接在应用进程内被丢弃。 拦截点 B（服务端拦截）：即使请求通过某种方式发出，到达 IMMS 后，服务端的鉴权逻辑会发现 mCurClient (Overlay) 与请求者 (Browser) 不匹配，直接返回 false。 3. 根本原因总结 问题的根源在于 Android 窗口系统中 Z-Order（显示层级） 与 Input Focus（输入焦点） 的默认关联机制。\n机制：默认情况下，可获焦（Focusable）的最高层级窗口自动获得输入焦点。 缺陷：Overlay 窗口作为高层级窗口，若不显式声明放弃焦点（FLAG_NOT_FOCUSABLE），系统会依据标准流程将其认定为输入法目标，从而切断其他应用的输入连接。 4. 解决方案技术原理 在 Overlay 窗口的 LayoutParams 中添加 FLAG_NOT_FOCUSABLE：\n阻断第一阶段：WMS 的 mayUseInputMethod 返回 false，焦点计算跳过 Overlay，保留在 Browser。 阻断第二阶段：Overlay 应用内的 ImeFocusController 判定不需要输入法，不再发送 startInputOrWindowGainedFocus IPC 请求。 保护第三阶段：IMMS 不会收到切换请求，Browser 的 Session 保持活跃。 3. 架构分析 @startuml !theme plain skinparam defaultFontName Arial skinparam defaultFontSize 12 skinparam shadowing false skinparam Nodesep 20 skinparam Padding 10 skinparam Ranksep 50 skinparam rectangle { BackgroundColor White BorderColor Black RoundCorner 0 } skinparam frame { BackgroundColor WhiteSmoke BorderColor Black } skinparam arrow { Color Black } ' --- Layer 1: App Layer --- frame \"App Layer (Application Process)\" { rectangle \"ActivityThread\" as AT rectangle \"Activity\" as Activity #Yellow rectangle \"Dialog\" as Dialog #Yellow } ' --- Layer 2: App Framework API Layer --- frame \"App Framework API Layer (Application Process)\" { rectangle \"WindowManagerImpl\" as WMImpl rectangle \"WindowManagerGlobal\" as WMGlobal rectangle \"ViewRootImpl\" as VRI rectangle \"InputMethodManager\\n\" as IMM rectangle \"IInputMethodClient\\n(Stub / mClient)\" as IIMC #FFE6E6 rectangle \"IInputMethodManagerGlobalInvoker\" as Invoker } ' --- Layer 3: System Server Layer --- frame \"System_Server Layer\" { rectangle \"InputMethodManagerService(IMMS)\" as IMMS } ' --- Relations and Logic Flow --- ' 1. Activity Startup Flow AT --\u003e Activity : 1. handleResumeActivity\\n/ handleStartActivity Activity -down-\u003e WMImpl : 2. makeVisible() -\u003e addView() ' 2. Dialog Startup Flow Dialog -down-\u003e WMImpl : 2. show() -\u003e addView() ' 3. Window Management Flow WMImpl -down-\u003e WMGlobal : 3. addView() WMGlobal -down-\u003e VRI : 4. new ViewRootImpl() ' 4. The Loop Back for Session \u0026 IMM Init VRI -left-\u003e WMGlobal : 5. getWindowSession()\\n(in Constructor) ' 5. IMM Initialization Flow WMGlobal -down-\u003e IMM : 6. ensureDefaultInstanceForDefaultDisplayIfNecessary() IMM -down-\u003e IMM : 7. createRealInstance()\\n(Initialize mClient) IMM -down-\u003e IIMC : (Hold reference to) ' 6. IPC Call Preparation (Forward) IMM -down-\u003e Invoker : 8. addClient(mClient, ...) ' 7. IPC to System Server (Forward) Invoker -down-\u003e IMMS : 9. IPC: addClient\\n(传递 mClient 代理) ' === 反向通信链路 (Reverse Communication Path) === ' 系统服务通过 Binder 回调应用进程的 Stub IMMS .up.\u003e IIMC #Red: **[反向链路] IPC Callback**\\n(onBindMethod, setActive 等) ' Stub 通过 Handler 切回主线程 IIMC --\u003e IMM #Red: sendMessage(MSG_BIND, ...)\\n(切换到主线程处理) @enduml 3.1. 概述 本架构图展示了从应用主线程启动 Activity 或显示 Dialog 开始，到系统底层完成窗口添加，并最终建立应用进程（Client）与系统服务进程（System Server）之间输入法控制通道的完整控制流。\n核心逻辑分为两个方向：\n前向初始化链路（黑色实线 1-9）：应用主动向系统注册，申请窗口令牌与输入法客户端身份。 反向控制链路（红色虚线）：系统服务（IMMS）通过 Binder 回调应用，实现对输入连接生命周期的管理。 3.2. 详细工作流程解析 第一阶段：UI 呈现的触发 (UI Presentation Trigger) 此阶段发生在应用的主线程中，由生命周期事件驱动。\n步骤 1 (Activity 启动)：ActivityThread 作为应用进程的入口，在处理 handleResumeActivity 或 handleStartActivity 时，驱动 Activity 生命周期流转。 步骤 2 (视图添加)： 对于 Activity：调用 makeVisible()，进而调用 WindowManager.addView()。 对于 Dialog：调用 show()，内部同样调用 WindowManager.addView()。 本质：无论是 Activity 还是 Dialog，最终都汇聚于 WindowManagerImpl 这一接口实现层。 第二阶段：窗口管理与核心组件实例化 (Window \u0026 Component Instantiation) 此阶段完成应用侧核心管理对象的创建。\n步骤 3 (全局代理)：WindowManagerImpl 将请求转发给单例对象 WindowManagerGlobal。这是应用进程内所有窗口的统一管理者。 步骤 4 (ViewRootImpl 创建)：WindowManagerGlobal 实例化 ViewRootImpl。ViewRootImpl 是连接 WindowManagerService (WMS) 和应用 View 层次结构的桥梁。 步骤 5 (会话建立与副作用)：在 ViewRootImpl 构造过程中（或获取 WindowSession 时），为了兼容性与初始化需求，会触发 getWindowSession()。 步骤 6 (IMM 懒加载)：getWindowSession() 方法内部包含防御性逻辑，调用 InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary()，确保输入法管理器（IMM）在窗口会话建立前已准备就绪。 第三阶段：输入法客户端构建与注册 (IMM Client Construction \u0026 Registration) 此阶段是建立跨进程通信的关键。\n步骤 7 (实例创建)：InputMethodManager 执行 createRealInstance()。\n关键动作：在此过程中，实例化了 IInputMethodClient.Stub（即图中的 mClient）。这是一个 Binder 服务端对象，它将在后续作为应用进程的“代理人”被传递给系统。\n步骤 8 (IPC 准备)：IMM 通过 IInputMethodManagerGlobalInvoker 封装调用请求。\n步骤 9 (IPC 调用)：通过 addClient(mClient, ...) 方法，应用进程发起 Binder 跨进程调用，将自身的 mClient 存根（Stub）传递给运行在 System Server 中的 InputMethodManagerService (IMMS)。\n至此，IMMS 持有了应用的 IInputMethodClient 代理，建立了逻辑上的“握手”。\n3.3. IInputMethodClient 的核心作用与反向链路 在架构图中，IInputMethodClient (Stub / mClient)（粉色区域）扮演着至关重要的角色。它是 Android 输入架构中实现 控制反转（Inversion of Control） 的关键组件。\nA. 角色定义 它是定义在应用进程（App Process）中的 Binder 服务端（Stub）。尽管它由 Framework 代码实现，但它运行在应用的 Binder 线程池中。它充当了系统服务（IMMS）对应用进行远程控制的回调接口（Callback Interface）。\nB. 工作机制（反向通信链路 - 红色虚线） 当系统侧的状态发生变化（例如：WMS 判定窗口焦点变更、屏幕息屏、用户切换输入法），IMMS 需要通知应用进行相应的状态同步或资源释放。\n系统发起调用：IMMS 通过持有的 IInputMethodClient 代理发起调用（如 onBindMethod、onUnbindMethod、setActive）。 跨进程传输：Binder 驱动将请求传输至应用进程。 Binder 线程响应：应用进程的 Binder 线程池接收请求，执行 IInputMethodClient.Stub 中的方法。 线程切换： 由于 Android UI 工具包不是线程安全的，Binder 线程不能直接操作 View 或 IMM 的内部状态。 因此，Stub 方法（如图示红线）通常通过 sendMessage(MSG_BIND, ...) 将操作封装为消息，发送给主线程的 Handler。 主线程执行：主线程处理消息，完成最终的逻辑（如建立 InputConnection、销毁资源、重置状态）。 C. 核心价值 IInputMethodClient 的存在使得系统服务能够：\n异步管理生命周期：在不阻塞系统服务的前提下，通知应用建立或断开输入连接。 强制状态同步：当系统判定应用失去焦点时（如 Overlay 案例），可以通过此接口强制应用断开连接，确保系统状态的一致性。 总结而言，IInputMethodClient 是应用主动暴露给系统的“控制句柄”，它是输入法服务能够通过标准 IPC 机制调度应用行为的基础。\n","wordCount":"1190","inLanguage":"en","datePublished":"2025-09-29T10:22:54+08:00","dateModified":"2025-09-29T10:22:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/>WindowManager</a></div><h1 class="post-title entry-hint-parent">Android 窗口焦点抢占与输入法连接断开技术时序分析</h1><div class=post-meta><span title='2025-09-29 10:22:54 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1190 words</div></header><div class=post-content><h3 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
autonumber

skinparam backgroundColor white
skinparam participantBackgroundColor white
skinparam boxPadding 10
skinparam noteBackgroundColor #FFFFA0
skinparam noteBorderColor #808080

actor &#34;User&#34; as User

box &#34;应用进程 A (Overlay - 当前焦点持有者)&#34; #MistyRose
    participant &#34;ViewRootImpl&#34; as Overlay_VRI
    participant &#34;ImeFocusController&#34; as Overlay_Ctrl
    participant &#34;InputMethodManager\n(IMM)&#34; as Overlay_IMM
end box

box &#34;系统服务 (System Server)&#34; #LightBlue
    participant &#34;InputDispatcher&#34; as InputDispatcher
    participant &#34;WindowManagerService\n(WMS)&#34; as WMS
    participant &#34;DisplayContent\n(DC)&#34; as DC
    participant &#34;InputMethodManagerService\n(IMMS)&#34; as IMMS
end box

box &#34;应用进程 B (Browser - 触摸事件接收者)&#34; #Honeydew
    participant &#34;ViewRootImpl&#34; as Browser_VRI
    participant &#34;Browser\nActivity&#34; as Browser
    participant &#34;InputMethodManager\n(IMM)&#34; as Browser_IMM
end box

== 第一阶段：Overlay 窗口添加与焦点计算 ==

Overlay_VRI -&gt; WMS: &lt;color:red&gt;**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE
activate WMS

    WMS -&gt; WMS: **addWindowInner**() -&gt; **updateFocusedWindowLocked**()

    group WMS 焦点更新逻辑
        WMS -&gt; DC: **findFocusedWindowIfNeeded**()
        activate DC
            DC -&gt; DC: 遍历窗口列表 (Z-Order Top-Down)
            DC -&gt; DC: 检查 Overlay WindowState
            DC -&gt; DC: **mayUseInputMethod**(flags)
            note right of DC
                **判定逻辑：**
                return (flags &amp; FLAG_NOT_FOCUSABLE) == 0;
                **结果：TRUE**
                (系统判定该窗口具备处理 IME 输入的能力)
            end note
        DC --&gt; WMS: 返回 **newFocus = Overlay**
        deactivate DC
    end

    WMS -&gt; WMS: **mCurrentFocus = Overlay**
    
    par 并发通知焦点变更
        WMS -&gt; Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true)
        WMS -&gt; Browser_VRI: **windowFocusChanged**(hasWindowFocus=false)
    end
    
deactivate WMS

== 第二阶段：Overlay 建立输入法连接 ==

activate Overlay_VRI
    note right of Overlay_VRI
        触发条件：
        1. 收到 windowFocusChanged 回调
        2. 或执行 performTraversals 布局遍历
    end note

    Overlay_VRI -&gt; Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**()
    activate Overlay_Ctrl
    
        Overlay_Ctrl -&gt; Overlay_Ctrl: check **mayUseInputMethod**() == true
        
        Overlay_Ctrl -&gt; Overlay_IMM: **onPostWindowGainedFocus**()
        activate Overlay_IMM
            
            note right of Overlay_IMM
                **IPC 请求：**
                请求建立输入连接
            end note
            
            Overlay_IMM -&gt; IMMS: **startInputOrWindowGainedFocus**(\n  reason=WINDOW_FOCUS_GAIN,\n  client=Overlay,\n  windowToken=OverlayToken)
            activate IMMS

== 第三阶段：IMMS 执行客户端切换与解绑 ==

                group IMMS 服务端处理
                    IMMS -&gt; IMMS: **startInputOrWindowGainedFocusInternalLocked**()
                    
                    IMMS -&gt; IMMS: check **mCurClient (Browser) != newClient (Overlay)**
                    
                    IMMS -&gt; IMMS: **prepareClientSwitchLocked**()
                    IMMS -&gt; IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT)
                    
                    activate IMMS #FFBBBB
                        note right of IMMS
                            **状态清理：**
                            1. userData.mCurClient.mClient.setActive(false)
                               -&gt; 通知 Browser 停止输入活动
                            2. finishSessionLocked(session)
                               -&gt; 销毁 Browser 的 InputChannel
                            3. **mCurClient = null**
                        end note
                    deactivate IMMS
                    
                    IMMS -&gt; IMMS: **mCurClient = Overlay**
                    note right of IMMS
                        **当前状态：**
                        IMMS 服务端记录的 Client 已变更为 Overlay
                    end note
                end
                
            IMMS --&gt; Overlay_IMM: return InputBindResult (SUCCESS)
            deactivate IMMS
            
        deactivate Overlay_IMM
    deactivate Overlay_Ctrl
deactivate Overlay_VRI

== 第四阶段：触摸事件派发 (Touch Dispatch) ==

User -&gt; InputDispatcher: 点击屏幕 (Touch Down)
activate InputDispatcher

    note right of InputDispatcher
        **事件派发逻辑：**
        虽然 Overlay Z-Order 最高，但设置了 
        FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外)
        事件向下穿透
    end note

    InputDispatcher -&gt; Browser_VRI: **InputEvent (ACTION_DOWN)**
deactivate InputDispatcher

activate Browser_VRI
    Browser_VRI -&gt; Browser: **dispatchTouchEvent**()
    Browser -&gt; Browser: View.onTouchEvent() -&gt; performClick()
    
    note right of Browser
        Browser 能够接收点击事件
        但此时 Window 焦点已丢失 (HasFocus=false)
    end note

== 第五阶段：请求输入法失败 ==

    Browser -&gt; Browser_IMM: **showSoftInput**(view)
    activate Browser_IMM
    
        group IMM 客户端自检
            Browser_IMM -&gt; Browser_IMM: **checkFocus**()
            Browser_IMM -&gt; Browser_IMM: **hasServedByInputMethodLocked**()
            note left
                **失败点 A (客户端拦截)：**
                由于之前收到 windowFocusChanged(false)
                ViewRootImpl 判定当前窗口无焦点
                mServedView 可能为 null 或不匹配
                **Result: return false** (Log: &#34;Ignoring... is not served&#34;)
            end note
        end

        alt 假设绕过客户端检查 (强制请求服务端)
            Browser_IMM -&gt; IMMS: **showSoftInput**(client=Browser)
            activate IMMS
            
            IMMS -&gt; IMMS: check **mCurClient (Overlay) == client (Browser)**
            
            note left of IMMS #FFAAAA
                **失败点 B (服务端拒绝)：**
                Validation Failed.
                请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。
            end note
            
            IMMS --&gt;&gt; Browser_IMM: return false
            deactivate IMMS
        end

    Browser_IMM --&gt;&gt; Browser: return false
    deactivate Browser_IMM

deactivate Browser_VRI

@enduml
</code></pre><p>本时序图展示了一个配置为 <code>TYPE_APPLICATION_OVERLAY</code> 但缺失 <code>FLAG_NOT_FOCUSABLE</code> 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。</p><h3 id=2-详细流程阶段解析>2. 详细流程阶段解析<a hidden class=anchor aria-hidden=true href=#2-详细流程阶段解析>#</a></h3><h4 id=第一阶段wms-焦点仲裁focus-arbitration>第一阶段：WMS 焦点仲裁（Focus Arbitration）<a hidden class=anchor aria-hidden=true href=#第一阶段wms-焦点仲裁focus-arbitration>#</a></h4><p>此阶段发生在 Overlay 窗口被添加到系统窗口管理器（WMS）的时刻。</p><ul><li><strong>触发动作</strong>：Overlay 应用调用 <code>WindowManager.addView</code>，参数中未包含 <code>FLAG_NOT_FOCUSABLE</code>。</li><li><strong>WMS 内部逻辑</strong>：<ul><li><code>addWindowInner</code> 触发层级更新，Overlay 被置于 Z-Order 顶层。</li><li>随后调用 <code>updateFocusedWindowLocked</code> -> <code>findFocusedWindowIfNeeded</code> 重新计算全局焦点。</li><li><strong>关键判定</strong>：<code>DisplayContent</code> 从顶层向下遍历窗口。对于 Overlay 窗口，系统调用 <code>mayUseInputMethod(flags)</code> 进行判定。由于 <strong>Missing Flag</strong>，该方法返回 <code>true</code>。</li></ul></li><li><strong>结果</strong>：WMS 将全局焦点变量 <code>mCurrentFocus</code> 锁定为 Overlay，并向各应用进程分发 <code>windowFocusChanged</code> 回调（Overlay 为 true，Browser 为 false）。</li></ul><h4 id=第二阶段overlay-建立连接active-connection-establishment>第二阶段：Overlay 建立连接（Active Connection Establishment）<a hidden class=anchor aria-hidden=true href=#第二阶段overlay-建立连接active-connection-establishment>#</a></h4><p>此阶段发生在 Overlay 应用的主线程（UI Thread）中。</p><ul><li><p><strong>触发动作</strong>：Overlay 的 <code>ViewRootImpl</code> 收到获焦通知或执行布局遍历（<code>performTraversals</code>）。</p></li><li><p><strong>客户端自检</strong>：</p><ul><li><code>ImeFocusController</code> 执行 <code>onTraversal</code> 或 <code>onPostWindowFocus</code>。</li><li>再次执行本地检查 <code>WindowManager.LayoutParams.mayUseInputMethod</code>，结果为 <code>true</code>。</li></ul></li><li><p><strong>发起请求</strong>：Overlay 进程通过 <code>InputMethodManager</code> 向系统服务发起 IPC 调用 <code>startInputOrWindowGainedFocus</code>，理由为 <code>WINDOW_FOCUS_GAIN</code>。<strong>这标志着 Overlay 主动向系统宣誓了输入法的主权。</strong></p></li></ul><h4 id=第三阶段imms-服务端会话切换session-switch>第三阶段：IMMS 服务端会话切换（Session Switch）<a hidden class=anchor aria-hidden=true href=#第三阶段imms-服务端会话切换session-switch>#</a></h4><p>此阶段发生在系统服务进程（System_Server）的 <code>InputMethodManagerService</code> 中。</p><ul><li><strong>状态校验</strong>：IMMS 接收到 Overlay 的请求，对比当前绑定的客户端 <code>mCurClient</code>（此时仍指向 Browser）与请求者（Overlay）。</li><li><strong>强制解绑（Critical Step）</strong>：<ul><li>发现客户端不一致，IMMS 调用 <code>prepareClientSwitchLocked</code>。</li><li>执行 <code>unbindCurrentClientLocked(SWITCH_CLIENT)</code>。</li></ul></li><li><strong>后果</strong>：系统销毁了 Browser 的 <code>InputMethodSession</code>，并将 Browser 对应的 <code>ClientState</code> 标记为非激活。</li><li><strong>新绑定</strong>：<code>mCurClient</code> 更新为 Overlay。至此，输入法的数据通道已物理切换至 Overlay，Browser 与输入法的连接被彻底切断。</li></ul><h4 id=第四阶段触摸事件与输入焦点的逻辑分离touch-vs-focus-discrepancy>第四阶段：触摸事件与输入焦点的逻辑分离（Touch vs Focus Discrepancy）<a hidden class=anchor aria-hidden=true href=#第四阶段触摸事件与输入焦点的逻辑分离touch-vs-focus-discrepancy>#</a></h4><p>此阶段揭示了问题的隐蔽性：用户感知与系统状态的割裂。</p><ul><li><strong>触摸派发（Touch Dispatch）</strong>：用户点击屏幕。<code>InputDispatcher</code> 进行命中测试。由于 Overlay 设置了 <code>FLAG_NOT_TOUCH_MODAL</code>（或点击区域位于 Overlay 之外），点击事件（ACTION_DOWN/UP）穿透 Overlay，正常派发给了底层的 Browser。</li><li><strong>逻辑冲突</strong>：Browser 能够响应 <code>onClick</code>，产生一种“我还在前台”的错觉。但根据 WMS 的状态（第一阶段），它实际上处于“可见但无焦点”的状态。</li></ul><h4 id=第五阶段请求被拒request-rejection>第五阶段：请求被拒（Request Rejection）<a hidden class=anchor aria-hidden=true href=#第五阶段请求被拒request-rejection>#</a></h4><p>此阶段是用户看到的最终故障现象。</p><ul><li><strong>Browser 发起请求</strong>：Browser 的 EditText 响应点击，调用 <code>showSoftInput</code>。</li><li><strong>拦截点 A（客户端本地拦截）</strong>：<code>InputMethodManager</code> 检查本地状态 <code>checkFocus()</code>。由于之前收到了 <code>windowFocusChanged(false)</code>，<code>hasServedByInputMethodLocked()</code> 返回 <code>false</code>，请求可能直接在应用进程内被丢弃。</li><li><strong>拦截点 B（服务端拦截）</strong>：即使请求通过某种方式发出，到达 IMMS 后，服务端的鉴权逻辑会发现 <code>mCurClient</code> (Overlay) 与请求者 (Browser) 不匹配，直接返回 <code>false</code>。</li></ul><h3 id=3-根本原因总结>3. 根本原因总结<a hidden class=anchor aria-hidden=true href=#3-根本原因总结>#</a></h3><p>问题的根源在于 Android 窗口系统中 <strong>Z-Order（显示层级）</strong> 与 <strong>Input Focus（输入焦点）</strong> 的默认关联机制。</p><ul><li><strong>机制</strong>：默认情况下，可获焦（Focusable）的最高层级窗口自动获得输入焦点。</li><li><strong>缺陷</strong>：Overlay 窗口作为高层级窗口，若不显式声明放弃焦点（<code>FLAG_NOT_FOCUSABLE</code>），系统会依据标准流程将其认定为输入法目标，从而切断其他应用的输入连接。</li></ul><h3 id=4-解决方案技术原理>4. 解决方案技术原理<a hidden class=anchor aria-hidden=true href=#4-解决方案技术原理>#</a></h3><p>在 Overlay 窗口的 LayoutParams 中添加 <code>FLAG_NOT_FOCUSABLE</code>：</p><ol><li><strong>阻断第一阶段</strong>：WMS 的 <code>mayUseInputMethod</code> 返回 <code>false</code>，焦点计算跳过 Overlay，保留在 Browser。</li><li><strong>阻断第二阶段</strong>：Overlay 应用内的 <code>ImeFocusController</code> 判定不需要输入法，不再发送 <code>startInputOrWindowGainedFocus</code> IPC 请求。</li><li><strong>保护第三阶段</strong>：IMMS 不会收到切换请求，Browser 的 Session 保持活跃。</li></ol><hr><h2 id=3-架构分析>3. 架构分析<a hidden class=anchor aria-hidden=true href=#3-架构分析>#</a></h2><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
skinparam defaultFontName Arial
skinparam defaultFontSize 12
skinparam shadowing false
skinparam Nodesep 20
skinparam Padding 10
skinparam Ranksep 50

skinparam rectangle {
    BackgroundColor White
    BorderColor Black
    RoundCorner 0
}
skinparam frame {
    BackgroundColor WhiteSmoke
    BorderColor Black
}
skinparam arrow {
    Color Black
}

&#39; --- Layer 1: App Layer ---
frame &#34;App Layer (Application Process)&#34; {
    rectangle &#34;ActivityThread&#34;  as AT 
    rectangle &#34;Activity&#34; as Activity #Yellow
    rectangle &#34;Dialog&#34; as Dialog #Yellow
}

&#39; --- Layer 2: App Framework API Layer ---
frame &#34;App Framework API Layer (Application Process)&#34; {
    rectangle &#34;WindowManagerImpl&#34; as WMImpl
    rectangle &#34;WindowManagerGlobal&#34; as WMGlobal
    rectangle &#34;ViewRootImpl&#34; as VRI
    
    rectangle &#34;InputMethodManager\n&#34; as IMM

    rectangle &#34;IInputMethodClient\n(Stub / mClient)&#34; as IIMC #FFE6E6

    rectangle &#34;IInputMethodManagerGlobalInvoker&#34; as Invoker

}

&#39; --- Layer 3: System Server Layer ---
frame &#34;System_Server Layer&#34; {
    rectangle &#34;InputMethodManagerService(IMMS)&#34; as IMMS
}

&#39; --- Relations and Logic Flow ---

&#39; 1. Activity Startup Flow
AT --&gt; Activity : 1. handleResumeActivity\n/ handleStartActivity
Activity -down-&gt; WMImpl : 2. makeVisible() -&gt; addView()

&#39; 2. Dialog Startup Flow
Dialog -down-&gt; WMImpl : 2. show() -&gt; addView()

&#39; 3. Window Management Flow
WMImpl -down-&gt; WMGlobal : 3. addView()
WMGlobal -down-&gt; VRI : 4. new ViewRootImpl()

&#39; 4. The Loop Back for Session &amp; IMM Init
VRI -left-&gt; WMGlobal : 5. getWindowSession()\n(in Constructor)

&#39; 5. IMM Initialization Flow
WMGlobal -down-&gt; IMM : 6. ensureDefaultInstanceForDefaultDisplayIfNecessary()
IMM -down-&gt; IMM : 7. createRealInstance()\n(Initialize mClient)
IMM -down-&gt; IIMC : (Hold reference to)

&#39; 6. IPC Call Preparation (Forward)
IMM -down-&gt; Invoker : 8. addClient(mClient, ...)

&#39; 7. IPC to System Server (Forward)
Invoker -down-&gt; IMMS : 9. IPC: addClient\n(传递 mClient 代理)

&#39; === 反向通信链路 (Reverse Communication Path) ===
&#39; 系统服务通过 Binder 回调应用进程的 Stub
IMMS .up.&gt; IIMC #Red: **[反向链路] IPC Callback**\n(onBindMethod, setActive 等)

&#39; Stub 通过 Handler 切回主线程
IIMC --&gt; IMM #Red: sendMessage(MSG_BIND, ...)\n(切换到主线程处理)


@enduml
</code></pre><h3 id=31-概述>3.1. 概述<a hidden class=anchor aria-hidden=true href=#31-概述>#</a></h3><p>本架构图展示了从应用主线程启动 Activity 或显示 Dialog 开始，到系统底层完成窗口添加，并最终建立应用进程（Client）与系统服务进程（System Server）之间输入法控制通道的完整控制流。</p><p>核心逻辑分为两个方向：</p><ol><li><strong>前向初始化链路（黑色实线 1-9）</strong>：应用主动向系统注册，申请窗口令牌与输入法客户端身份。</li><li><strong>反向控制链路（红色虚线）</strong>：系统服务（IMMS）通过 Binder 回调应用，实现对输入连接生命周期的管理。</li></ol><h3 id=32-详细工作流程解析>3.2. 详细工作流程解析<a hidden class=anchor aria-hidden=true href=#32-详细工作流程解析>#</a></h3><h4 id=第一阶段ui-呈现的触发-ui-presentation-trigger>第一阶段：UI 呈现的触发 (UI Presentation Trigger)<a hidden class=anchor aria-hidden=true href=#第一阶段ui-呈现的触发-ui-presentation-trigger>#</a></h4><p>此阶段发生在应用的主线程中，由生命周期事件驱动。</p><ul><li><strong>步骤 1 (Activity 启动)</strong>：<code>ActivityThread</code> 作为应用进程的入口，在处理 <code>handleResumeActivity</code> 或 <code>handleStartActivity</code> 时，驱动 Activity 生命周期流转。</li><li><strong>步骤 2 (视图添加)</strong>：</li><li>对于 <strong>Activity</strong>：调用 <code>makeVisible()</code>，进而调用 <code>WindowManager.addView()</code>。</li><li>对于 <strong>Dialog</strong>：调用 <code>show()</code>，内部同样调用 <code>WindowManager.addView()</code>。</li><li><strong>本质</strong>：无论是 Activity 还是 Dialog，最终都汇聚于 <code>WindowManagerImpl</code> 这一接口实现层。</li></ul><h4 id=第二阶段窗口管理与核心组件实例化-window--component-instantiation>第二阶段：窗口管理与核心组件实例化 (Window & Component Instantiation)<a hidden class=anchor aria-hidden=true href=#第二阶段窗口管理与核心组件实例化-window--component-instantiation>#</a></h4><p>此阶段完成应用侧核心管理对象的创建。</p><ul><li><strong>步骤 3 (全局代理)</strong>：<code>WindowManagerImpl</code> 将请求转发给单例对象 <code>WindowManagerGlobal</code>。这是应用进程内所有窗口的统一管理者。</li><li><strong>步骤 4 (ViewRootImpl 创建)</strong>：<code>WindowManagerGlobal</code> 实例化 <code>ViewRootImpl</code>。<code>ViewRootImpl</code> 是连接 <code>WindowManagerService</code> (WMS) 和应用 View 层次结构的桥梁。</li><li><strong>步骤 5 (会话建立与副作用)</strong>：在 <code>ViewRootImpl</code> 构造过程中（或获取 <code>WindowSession</code> 时），为了兼容性与初始化需求，会触发 <code>getWindowSession()</code>。</li><li><strong>步骤 6 (IMM 懒加载)</strong>：<code>getWindowSession()</code> 方法内部包含防御性逻辑，调用 <code>InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary()</code>，确保输入法管理器（IMM）在窗口会话建立前已准备就绪。</li></ul><h4 id=第三阶段输入法客户端构建与注册-imm-client-construction--registration>第三阶段：输入法客户端构建与注册 (IMM Client Construction & Registration)<a hidden class=anchor aria-hidden=true href=#第三阶段输入法客户端构建与注册-imm-client-construction--registration>#</a></h4><p>此阶段是建立跨进程通信的关键。</p><ul><li><p><strong>步骤 7 (实例创建)</strong>：<code>InputMethodManager</code> 执行 <code>createRealInstance()</code>。</p></li><li><p><strong>关键动作</strong>：在此过程中，实例化了 <strong><code>IInputMethodClient.Stub</code></strong>（即图中的 <code>mClient</code>）。这是一个 Binder 服务端对象，它将在后续作为应用进程的“代理人”被传递给系统。</p></li><li><p><strong>步骤 8 (IPC 准备)</strong>：IMM 通过 <code>IInputMethodManagerGlobalInvoker</code> 封装调用请求。</p></li><li><p><strong>步骤 9 (IPC 调用)</strong>：通过 <code>addClient(mClient, ...)</code> 方法，应用进程发起 Binder 跨进程调用，将自身的 <code>mClient</code> 存根（Stub）传递给运行在 System Server 中的 <code>InputMethodManagerService</code> (IMMS)。</p></li></ul><p><strong>至此，IMMS 持有了应用的 IInputMethodClient 代理，建立了逻辑上的“握手”。</strong></p><hr><h3 id=33-iinputmethodclient-的核心作用与反向链路>3.3. IInputMethodClient 的核心作用与反向链路<a hidden class=anchor aria-hidden=true href=#33-iinputmethodclient-的核心作用与反向链路>#</a></h3><p>在架构图中，<strong><code>IInputMethodClient (Stub / mClient)</code></strong>（粉色区域）扮演着至关重要的角色。它是 Android 输入架构中实现 <strong>控制反转（Inversion of Control）</strong> 的关键组件。</p><h4 id=a-角色定义>A. 角色定义<a hidden class=anchor aria-hidden=true href=#a-角色定义>#</a></h4><p>它是定义在应用进程（App Process）中的 Binder 服务端（Stub）。尽管它由 Framework 代码实现，但它运行在应用的 Binder 线程池中。它充当了系统服务（IMMS）对应用进行远程控制的<strong>回调接口（Callback Interface）</strong>。</p><h4 id=b-工作机制反向通信链路---红色虚线>B. 工作机制（反向通信链路 - 红色虚线）<a hidden class=anchor aria-hidden=true href=#b-工作机制反向通信链路---红色虚线>#</a></h4><p>当系统侧的状态发生变化（例如：WMS 判定窗口焦点变更、屏幕息屏、用户切换输入法），IMMS 需要通知应用进行相应的状态同步或资源释放。</p><ol><li><strong>系统发起调用</strong>：IMMS 通过持有的 <code>IInputMethodClient</code> 代理发起调用（如 <code>onBindMethod</code>、<code>onUnbindMethod</code>、<code>setActive</code>）。</li><li><strong>跨进程传输</strong>：Binder 驱动将请求传输至应用进程。</li><li><strong>Binder 线程响应</strong>：应用进程的 Binder 线程池接收请求，执行 <code>IInputMethodClient.Stub</code> 中的方法。</li><li><strong>线程切换</strong>：</li></ol><ul><li>由于 Android UI 工具包不是线程安全的，Binder 线程不能直接操作 View 或 IMM 的内部状态。</li><li>因此，Stub 方法（如图示红线）通常通过 <code>sendMessage(MSG_BIND, ...)</code> 将操作封装为消息，发送给主线程的 <code>Handler</code>。</li></ul><ol start=5><li><strong>主线程执行</strong>：主线程处理消息，完成最终的逻辑（如建立 <code>InputConnection</code>、销毁资源、重置状态）。</li></ol><h4 id=c-核心价值>C. 核心价值<a hidden class=anchor aria-hidden=true href=#c-核心价值>#</a></h4><p><code>IInputMethodClient</code> 的存在使得系统服务能够：</p><ul><li><strong>异步管理生命周期</strong>：在不阻塞系统服务的前提下，通知应用建立或断开输入连接。</li><li><strong>强制状态同步</strong>：当系统判定应用失去焦点时（如 Overlay 案例），可以通过此接口强制应用断开连接，确保系统状态的一致性。</li></ul><p>总结而言，<code>IInputMethodClient</code> 是应用主动暴露给系统的“控制句柄”，它是输入法服务能够通过标准 IPC 机制调度应用行为的基础。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethodservice/><span class=title>« Prev</span><br><span>Android InputMethod 交互流程技术说明文档</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/activity-reparent/><span class=title>Next »</span><br><span>Activity 跨屏幕迁移</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>