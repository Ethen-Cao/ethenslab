<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>WindowInfos Update Flow | Ethen 的实验室</title><meta name=keywords content><meta name=description content="1. 概述 (Overview)
WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：

InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。
AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。

该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture)
数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger)

触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。
异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。
通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。

2.2 中转与分发 (Transport & Dispatch: SystemServer)

WindowInfosListenerReporter (Native):
角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。
职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。

2.3 接收端 (Consumers)

InputDispatcher (Native):


行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。


AccessibilityWindowsPopulator (Java):


行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。

3. 详细时序流程 (Sequence Diagram)
下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="WindowInfos Update Flow"><meta property="og:description" content="1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：
InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport & Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T10:22:54+08:00"><meta property="article:modified_time" content="2025-09-29T10:22:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="WindowInfos Update Flow"><meta name=twitter:description content="1. 概述 (Overview)
WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：

InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。
AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。

该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture)
数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger)

触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。
异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。
通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。

2.2 中转与分发 (Transport & Dispatch: SystemServer)

WindowInfosListenerReporter (Native):
角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。
职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。

2.3 接收端 (Consumers)

InputDispatcher (Native):


行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。


AccessibilityWindowsPopulator (Java):


行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。

3. 详细时序流程 (Sequence Diagram)
下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"WindowManager","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/"},{"@type":"ListItem","position":3,"name":"WindowInfos Update Flow","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WindowInfos Update Flow","name":"WindowInfos Update Flow","description":"1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。\n主要消费者包括：\nInputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。\n2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。\n2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport \u0026amp; Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。\n","keywords":[],"articleBody":"1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。\n主要消费者包括：\nInputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。\n2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。\n2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport \u0026 Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。\n@startuml !theme plain autonumber \"[0]\" title SystemServer: Registration \u0026 WindowInfos Update Flow (Complete) box \"SurfaceFlinger Process\" #E3F2FD participant \"SurfaceFlinger\" as SF end box box \"Kernel Space\" #F5F5F5 participant \"Binder Driver\" as Kernel end box box \"SystemServer Process (Native)\" #FFF3E0 participant \"IPCThreadState\" as IPC participant \"BnWindowInfosListener\\n(Stub)\" as Stub participant \"WindowInfosListenerReporter\\n(Singleton)\" as Reporter participant \"SurfaceComposerClient\" as SCC participant \"InputDispatcher\" as Dispatcher participant \"DispatcherWindowListener\" as Listener end box box \"SystemServer Process (Java)\" #FFE0B2 participant \"AccessibilityWindowsPopulator\\n(A11yPop)\" as A11yPop participant \"WMS Handler Thread\" as WMS_Thread participant \"WindowManagerService\" as WMS participant \"AccessibilityWindowManager\" as AWM participant \"AccessibilityManagerService\" as AMS end box == 0.1 InputDispatcher 注册流程 (Native) == Dispatcher -\u003e Dispatcher: new DispatcherWindowListener(*this) activate Dispatcher note right: 创建本地监听器 Dispatcher -\u003e SCC: addWindowInfosListener(listener) activate SCC SCC -\u003e Reporter: getInstance() SCC -\u003e Reporter: addWindowInfosListener(listener, ...) activate Reporter Reporter -\u003e Reporter: check mWindowInfosListeners.empty() alt #LightGreen 首次注册 (First Time) note right of Reporter 集合为空，说明 Reporter 尚未连接 SF。 将 Reporter (this) 注册到远程。 end note Reporter -\u003e SF: IWindowInfosListener.addWindowInfosListener(this) activate SF SF -\u003e SF: 保存 Reporter 句柄 SF --\u003e Reporter: status deactivate SF else 后续注册 (Re-use) note right of Reporter 集合不为空，通道已建立。 直接复用，不发起 Binder 调用。 end note end Reporter -\u003e Reporter: mWindowInfosListeners.insert(listener) note right: 将 InputDispatcher 加入本地集合 Reporter --\u003e SCC: status deactivate Reporter SCC --\u003e Dispatcher: status deactivate SCC deactivate Dispatcher == 0.2 Accessibility 注册流程 (Java Stack) == note right of AMS 触发时机: 1. 系统启动完毕 2. 开启无障碍服务 (TalkBack等) 3. 显示器插拔 (onDisplayAdded) end note AMS -\u003e AWM: startTrackingWindows() activate AMS AWM -\u003e WMS: setWindowsForAccessibilityCallback() activate AWM WMS -\u003e A11yPop: setWindowsNotification(true) activate WMS activate A11yPop A11yPop -\u003e A11yPop: register() A11yPop -\u003e SCC: nativeRegister() [JNI] activate SCC SCC -\u003e Reporter: addWindowInfosListener(listener) activate Reporter note right of Reporter 检测到 InputDispatcher 已注册， 这里直接复用现有通道， 将 A11yPop 加入本地集合。 end note Reporter -\u003e Reporter: mWindowInfosListeners.insert(A11yPop) Reporter --\u003e SCC: status deactivate Reporter SCC --\u003e A11yPop: status deactivate SCC A11yPop --\u003e WMS: void deactivate A11yPop WMS --\u003e AWM: void deactivate WMS AWM --\u003e AMS: void deactivate AWM deactivate AMS ||| == 1. 跨进程接收 (Binder Thread) == SF -\u003e Kernel: onWindowInfosChanged(data) (Oneway) note left: SF 生产 46KB 数据\\n疯狂发送 Kernel -\u003e IPC: ioctl(BR_TRANSACTION) activate IPC note left: Binder 线程被唤醒 IPC -\u003e Stub: onTransact(...) activate Stub note right: 反序列化 (Unmarshalling)\\n解析 Parcel -\u003e vector Stub -\u003e Reporter: onWindowInfosChanged(windowInfos, ...) deactivate Stub activate Reporter == 2. 进程内分发 (Reporter Loop) == note right of Reporter 同步循环 (Synchronous Loop) 运行在 Binder 线程中。 必须等所有 Listener 处理完才能返回。 end note loop foreach listener in mWindowInfosListeners alt #MistyRose Listener == InputDispatcher (Native) Reporter -\u003e Listener: onWindowInfosChanged(windowInfos) activate Listener == 3. 业务处理 (InputDispatcher) == Listener -\u003e Dispatcher: setInputWindows(windowInfos) activate Dispatcher Dispatcher -\u003e Dispatcher: std::scoped_lock _l(mLock) note right 关键阻塞点 (Critical Block) InputDispatcher 持锁处理。 如果有 Input 事件积压，这里会卡住。 这是导致 Oneway Spamming 的主要原因。 end note Dispatcher -\u003e Dispatcher: setInputWindowsLocked(...) Dispatcher --\u003e Listener: void deactivate Dispatcher Listener --\u003e Reporter: void deactivate Listener else #AliceBlue Listener == AccessibilityWindowsPopulator (Java) Reporter -\u003e A11yPop: onWindowInfosChanged(windowHandles, ...) [JNI] activate A11yPop == 3.1 业务处理 (A11yPopulator) == A11yPop -\u003e A11yPop: mHandler.post(...) note right 异步非阻塞 (Async) 源码: mHandler.post(() -\u003e onWindowInfosChangedInternal) 立即返回，不占用 Binder 线程时间。 end note A11yPop --\u003e Reporter: void deactivate A11yPop A11yPop -[#blue]\u003e WMS_Thread: onWindowInfosChangedInternal(...) activate WMS_Thread note right 延迟处理: 繁重的矩阵计算(Matrix)和 遍历逻辑在此线程执行。 end note deactivate WMS_Thread end end Reporter --\u003e Stub: void deactivate Reporter Stub --\u003e IPC: void IPC -\u003e Kernel: ioctl(BC_FREE_BUFFER) note left: 只有执行到这里，\\n内核缓冲区才会被释放。 deactivate IPC @enduml 4. SurfaceFlinger::updateInputFlinger 工作原理与调用时序 1. 概述\nSurfaceFlinger::updateInputFlinger() 是 Android 图形系统（SurfaceFlinger）向输入系统（InputFlinger/SystemServer）同步窗口信息的核心枢纽。\n它的主要职责是：在图形合成（Composition）流程中，将当前的图层（Layer）状态“翻译”成输入系统能理解的 WindowInfo（包含窗口位置、触摸区域、标志位等），并发送给 InputDispatcher，以确保触摸事件能准确分发给用户看到的那个窗口。\n2. 核心工作原理\nupdateInputFlinger 的执行逻辑设计得非常谨慎，以避免不必要的计算和跨进程通信（IPC）。\n其内部工作流程如下：\nStep 1: 检查更新条件 (Check Dirty Flags)\n函数首先检查两个关键的脏标记（Dirty Flags）： mVisibleRegionsDirty: 表示图层的几何属性（位置、大小、矩阵）、Z-Order 或可见性发生了变化。这通常意味着窗口的“可触摸区域”变了。 mInputInfoChanged: 表示图层的纯输入属性（如 InputConfig、Token、Title 等）发生了变化。 只有当这两者之一为 true 时，才会触发窗口信息的重新构建。 Step 2: 构建窗口信息 (Build Window Infos)\n如果需要更新 (updateWindowInfo = true)，调用 buildWindowInfos(windowInfos, displayInfos)。 buildWindowInfos 的核心任务是将 SurfaceFlinger 的图层树（Layer Hierarchy）扁平化为 InputDispatcher 能理解的窗口列表。 它的工作流程大致如下： 遍历 (Traversal): 它会遍历当前所有 Display 的图层。通常是按照 Z-Order (从上到下 或 从下到上) 进行遍历。InputDispatcher 需要的是从前向后（Front-to-Back）的列表以便进行点击测试（Hit Test），或者 SF 提供列表后由 InputDispatcher 排序。 数据转换 (Translation): 对于每一个可见的 Layer，它会调用类似 Layer::writeToWindowInfo 的方法，提取以下关键信息 Token: 窗口的唯一标识（Binder 句柄）。 Name: 窗口名字（如 “com.cockpit.camera/…\"）。 Flags: InputWindowHandle::InputConfig，例如是否可触摸、是否是 Spy Window、是否遮挡下方等。 TouchableRegion: 经过裁剪（Crop）和父图层变换后的最终触摸区域。 Transform: 将图层坐标系映射到屏幕坐标系的矩阵。 Alpha/Visibility: 只有可见且 Alpha 大于阈值的图层才会生成有效的 WindowInfo。 聚合 (Aggregation): 将所有生成的 WindowInfo 对象放入 std::vector 中，同时收集对应的 DisplayInfo（屏幕尺寸、旋转方向等）。 总结: 这是一个“翻译”过程，把图形系统的图层属性翻译成输入系统的窗口属性。 Step 3: 检查命令队列 (Check Commands)\n除了窗口信息更新，该函数还处理来自 WindowManagerService (WMS) 的输入命令，例如“设置焦点窗口”（Focus Request）。这些命令存储在 mInputWindowCommands 中。当 WMS 决定改变当前焦点窗口时（例如用户启动了新 App，或者点击了某个窗口），WMS 不会直接调用 InputDispatcher，而是通过 SurfaceComposerClient::Transaction 发送一个 requestFocus 命令给 SurfaceFlinger。 流程如下: WMS 调用 t.setFocusedWindow(token, …)。 该命令随 Transaction 发送到 SurfaceFlinger。 SurfaceFlinger 在应用 Transaction 时，将这个请求解析并放入 mInputWindowCommands.focusRequests 队列中。 在 updateInputFlinger 执行时，SF 将这个请求转发给 InputDispatcher。 总结: 这是一个“旁路”机制。大部分帧里这个 list 是空的；只有在发生窗口焦点切换（Focus Switch）的那一帧，这个循环才会执行。 快速返回: 如果既不需要更新窗口信息，也没有输入命令要处理，函数直接返回，不消耗任何资源。 Step 4: 异步发送 (Async Dispatch)\n为了不阻塞 SurfaceFlinger 的主渲染线程（Main Thread），所有与 InputFlinger 的交互（IPC）都被封装在一个 Lambda 表达式中，并投递给 BackgroundExecutor 线程执行。 数据移动: 使用 std::move 将构建好的 windowInfos 大数据块移动到 Lambda 捕获列表中，避免内存拷贝。 Step 5: 跨进程通信 (IPC)\n在后台线程中，调用 mWindowInfosListenerInvoker-\u003ewindowInfosChanged(...)。 这会触发 Binder 驱动，将数据发送给 SystemServer 进程中的 WindowInfosListenerReporter，最终到达 InputDispatcher。 Step 6: 处理焦点请求 (Handle Focus)\n如果在同一帧中有焦点切换请求 (inputWindowCommands.focusRequests)，也会在后台线程中同步调用 inputFlinger-\u003esetFocusedWindow。 3. 调用时序与上下文 (Call Stack \u0026 Context)\nupdateInputFlinger 并非孤立执行，它是 SurfaceFlinger 主合成循环（Main Loop）中不可或缺的一环。\n触发源: VSYNC 信号 -\u003e MessageQueue::Handler::handleMessage。 入口: SurfaceFlinger::commit。这是每帧合成的核心函数。 完整调用链分析：\nVSYNC 到达: 硬件或软件 VSYNC 信号触发，调用 MessageQueue::handleMessage。 开始提交 (Commit): handleMessage 调用 compositor.commit，即 SurfaceFlinger::commit。 事务处理 (Transaction Handling): commitTransactions(): 处理来自应用和 SystemServer 的 Binder 事务（如窗口移动、大小改变）。这是导致 mVisibleRegionsDirty 变脏的主要原因。 几何更新 (Geometry Update): updateLayerGeometry(): 根据新的事务状态，重新计算所有图层的可见区域和变换矩阵。 输入更新 (Input Update): updateInputFlinger() 被调用。 位置关键: 它被特意安排在 commitTransactions 和 updateLayerGeometry 之后。 原因: 必须先处理完所有的窗口变换和层级调整，确认了最终每一层都在哪、谁遮挡了谁，才能生成准确的 InputWindowInfo。 通知追踪 (Tracing): 如果有需要，通知 LayerTracing 记录当前帧状态。 4. 总结图示\nVSYNC Signal ↓ MessageQueue::handleMessage() ↓ SurfaceFlinger::commit() ↓ ├── commitTransactions() \u003c-- 应用改变窗口属性 (Set Dirty Flags) ↓ ├── updateLayerGeometry() \u003c-- 计算最终图层位置 ↓ ├── updateInputFlinger() \u003c-- [本文角主角] │ ↓ │ 若 (Dirty): 构建 WindowInfo │ ↓ │ BackgroundExecutor (异步线程) │ ↓ │ Binder Call -\u003e SystemServer (InputDispatcher) ↓ └── (后续流程) composite() -\u003e 提交给 HWC/GPU 5. 附录 InputWindowCommands的简介 InputWindowCommands 的直接来源是 SurfaceComposerClient::Transaction（即跨进程的 Binder 事务）。\n归根结底，它是 WindowManagerService (WMS)（以及其他系统组件）用来“遥控” InputDispatcher 的一种手段，但必须经过 SurfaceFlinger 中转。\n以下是详细的来源分析：\n1. 数据的源头：WindowManagerService (WMS) WMS 是窗口管理的权威，它决定了哪个窗口应该获得焦点，或者何时需要同步输入状态。\n场景 A：设置焦点 (Focus Requests) 当用户点击某个窗口，或者 App 启动时，WMS 计算出新的焦点窗口。 WMS 会调用 SurfaceControl.Transaction 的 API： // Java 层 (WindowManagerService) transaction.setFocusedWindow(windowToken, displayId, ...); 场景 B：同步输入 (Sync Input Windows) 通常用于测试（CTS）或特殊的同步绘制场景（BLASTSync）。客户端希望确保 InputDispatcher 已经收到了最新的窗口信息。 // Java 层 transaction.syncInputWindows(); 2. 传输通道：Binder Transaction 这些命令被序列化到 Transaction 对象中，通过 Binder 发送给 SurfaceFlinger。 mInputWindowCommands 是 SurfaceFlinger 类的一个成员变量，它充当了一个暂存区。\n3. 收集过程：SurfaceFlinger::applyTransactionState 当 SurfaceFlinger 接收并应用这些 Transaction 时，会将命令提取出来并合并到 mInputWindowCommands 中。\n流程如下：\n接收事务: SurfaceFlinger::setTransactionState 收到 Binder 调用。 应用事务: 在主线程调用 applyTransactionState 处理所有挂起的 Transaction。 提取命令: 遍历 Transaction 中的 InputWindowCommands。 如果是 focusRequests，则 push_back 到 mInputWindowCommands.focusRequests 列表。 如果是 syncInputWindows，则设置 mInputWindowCommands.syncInputWindows = true。 4. 消费过程：updateInputFlinger 在每一帧合成时，updateInputFlinger 会读取这个暂存区。 关键动作: inputWindowCommands = std::move(mInputWindowCommands)。 它使用 std::move 将所有积累的命令“偷”走传给后台线程，然后立刻 clear() 清空暂存区，为下一帧做准备。 总结图示 @startuml !theme plain top to bottom direction ' 定义节点 component \"WindowManagerService\" as WMS component \"CTS Tests\" as CTS component \"SurfaceControl.Transaction\" as Trans component \"SurfaceFlinger\" as SF queue \"mInputWindowCommands\\n(暂存区)\" as Acc component \"updateInputFlinger\" as UIF component \"InputDispatcher\" as ID ' 定义连接关系 WMS --\u003e Trans : 1. t.setFocusedWindow CTS --\u003e Trans : 1. t.syncInputWindows Trans --\u003e SF : 2. Binder IPC SF --\u003e Acc : 3. applyTransactionState Acc --\u003e UIF : 4. std::move UIF --\u003e ID : 5. setFocusedWindow @enduml 总结： InputWindowCommands 是 WMS 等客户端通过 Transaction 捎带给 SurfaceFlinger 的指令包，暂存在 SurfaceFlinger 中，并在下一帧合成时转发给 InputDispatcher。\nSurfaceFlinger合成流程概览 这是一个非常经典且宏大的系统流程。从 VSYNC 信号触发到最终像素上屏，SurfaceFlinger (SF) 完成了一次完整的“心跳”循环。 这个过程主要发生在 SurfaceFlinger Main Thread (主线程) 中，但也涉及到调度线程、Binder 线程池和渲染线程。 以下是基于现代 Android (Android 12/13/14) 架构的详细阶段拆解：\n核心流程概览 @startuml !theme plain autonumber \"[0]\" title SurfaceFlinger: VSYNC to Present Pipeline box \"Hardware / Kernel\" #F5F5F5 participant \"VSYNC Generator\" as HW_VSYNC participant \"HWC / DRM\" as HWC end box box \"SurfaceFlinger Process\" #E3F2FD participant \"Scheduler/EventThread\" as Sched participant \"MessageQueue\" as MQ participant \"SurfaceFlinger (Main)\" as SF participant \"Layer / BufferQueue\" as Layer participant \"CompositionEngine\" as CE participant \"RenderEngine (GPU)\" as RE end box == Phase 1: VSYNC 唤醒 == HW_VSYNC -\u003e Sched: Hardware Vsync Signal Sched -\u003e MQ: dispatchVsync MQ -\u003e SF: handleMessageInvalidate() == Phase 2: 状态更新 (Commit) == activate SF SF -\u003e SF: commit() group 2.1 处理事务 (Transactions) SF -\u003e SF: flushTransactionQueues() SF -\u003e Layer: apply transactions (pos, alpha, z-order...) end group 2.2 锁定缓冲区 (Latch Buffers) SF -\u003e Layer: latchBuffer() Layer -\u003e Layer: acquireBuffer() (from BufferQueue) end group 2.3 几何与输入更新 SF -\u003e SF: updateLayerGeometry() SF -\u003e SF: updateInputFlinger() end == Phase 3: 合成 (Composite) == SF -\u003e CE: composite(display) group 3.1 验证 (HWC Validation) CE -\u003e HWC: validateDisplay() HWC --\u003e CE: changes (Client vs Device composition) end group 3.2 客户端合成 (GPU Rendering) CE -\u003e RE: drawLayers() (SkiaGL/SkiaVk) activate RE RE --\u003e CE: Output Buffer (Framebuffer) deactivate RE end group 3.3 设备合成 (HWC Present) CE -\u003e HWC: setOutputBuffer (if GPU used) CE -\u003e HWC: presentDisplay() end deactivate SF @enduml 详细阶段解析 整个流程通常由 MessageQueue::Handler::handleMessage 触发，主要逻辑封装在 SurfaceFlinger::commit 和 SurfaceFlinger::composite 中。\nPhase 1: VSYNC 调度与唤醒 (Scheduling) 这是流程的起点。硬件发出垂直同步信号，告诉系统“显示器准备好下一帧了”。\n工作内容: 硬件 VSYNC 信号到达内核，DispSync 模型进行校准。 Scheduler 决定是否需要唤醒 SF（如果没有 Layer 更新，SF 会休眠）。 通过 MessageQueue 发送 INVALIDATE 消息给 SF 主线程。 涉及线程:\nDispSyncThread (或类似的 Vsync 线程)\nEventThread (分发 Vsync)\nSF Main Thread (接收消息)\n核心类:\nScheduler: 统管 Vsync 分发和帧率选择。\nEventThread: 连接 DispSync 和 Client (SF/App) 的桥梁。\nMessageQueue: SF 的 Looper 机制。\nPhase 2: 提交与状态更新 (Commit) SF 被唤醒后，首先要处理“逻辑状态”，确定这一帧“该画什么”、“在哪画”。\n2.1 处理事务 (Transactions)\n工作内容: 处理来自 App 或 WMS 的 Binder 调用 (SurfaceControl.Transaction)。\n应用窗口的移动、缩放、隐藏/显示。\nmVisibleRegionsDirty 在此阶段被置为 true。\n核心类: TransactionCallbackInvoker, Layer。\n2.2 锁定缓冲区 (Latch Buffers)\n工作内容: 检查各个 Layer 的 BufferQueue 中是否有应用刚刚生产好的 Buffer（Fence 已 Signal）。\n如果有，调用 acquireBuffer 获取图形数据。\n将 Layer 的状态从“待定”更新为“当前绘制状态”。\n关键点: 这里决定了这一帧显示的是 App 的哪一张图。\n核心类: BufferQueue, BufferLayer, ConsumerBase。\n2.3 几何与输入更新 (Geometry \u0026 Input)\n工作内容:\nupdateLayerGeometry(): 计算可见区域 (Visible Region)、脏区域 (Dirty Region)、遮挡关系。\nupdateInputFlinger(): (我们刚讨论过的) 将计算好的窗口信息同步给 InputDispatcher。\n核心类: Region, Layer, InputWindowCommands。\nPhase 3: 合成 (Composition) 此时逻辑状态已确定，开始生成像素或指令。现代 Android 使用 CompositionEngine (CE) 模块来管理这一步。\n3.1 HWC 验证 (Validation)\n工作内容: SF 询问 HWC：“这些 Layer 你能处理吗？”\nSF 将 Layer 列表发给 HWC。\nHWC 返回每个 Layer 的合成方式：\nDevice Composition: HWC 硬件直接处理（高效，如 Overlay）。\nClient Composition: HWC 处理不了（如复杂 Shader、圆角、模糊），需要 GPU 处理。\n核心类: HWComposer, CompositionEngine, Output.\n3.2 客户端合成 (Client Composition / GPU)\n工作内容: 如果 HWC 说“我处理不了”，SF 就调用 RenderEngine 用 GPU 把这些 Layer 画到一个 Buffer (Framebuffer) 上。\nAndroid 12+ 默认使用 Skia (SkiaGL 或 SkiaVk)。\n涉及线程:\nSF Main Thread: 发起绘制指令。\nRenderEngine Thread: (视实现而定，可能有专门的渲染线程) 执行 GPU 指令提交。\n核心类: RenderEngine, SkiaRenderEngine, FramebufferSurface.\n3.3 设备合成与上屏 (Device Composition \u0026 Present)\n工作内容:\n如果进行了 GPU 合成，将 GPU 生成的 Buffer 作为一个特殊的 Layer 传给 HWC。\n调用 HWC::presentDisplay()。\nHWC 驱动将最终配置提交给显示硬件。\nFence 机制: 系统不会死等 GPU/Display 完成，而是通过 Fence (文件描述符) 同步。\n核心类: HWComposer, DisplayDevice.\n线程模型总结 线程名称 职责 涉及阶段 SurfaceFlinger Main 大总管。负责逻辑状态更新、Buffer锁定、几何计算、指挥合成。90% 的代码运行于此。 All Stages EventThread 节拍器。负责接收硬件 VSYNC 并分发给 SF 主线程和 App。 Phase 1 Binder Threads 接收员。负责接收 App/WMS 的 Transaction 和 queueBuffer 调用，放入队列供主线程消费。 Phase 2 (Pre-processing) RenderEngine 画师。如果需要 GPU 合成，负责执行 OpenGL/Vulkan 指令。 Phase 3.2 HWC / DRM 放映员。内核/硬件层，负责最终将图层叠加并输出到屏幕。 Phase 3.3 关键总结 SurfaceFlinger 的一帧就像一条流水线：\nVSYNC 是发令枪。 Commit 阶段确定“物体”的位置和形状（Logic）。 Latch Buffer 阶段给物体贴上“材质”（Content）。 HWC Validate 阶段决定“谁来画”（Strategy）。 Composite 阶段真正执行“画”的动作（Rendering）。 Present 阶段把画好的图交给屏幕（Display）。 ","wordCount":"1697","inLanguage":"en","datePublished":"2025-09-29T10:22:54+08:00","dateModified":"2025-09-29T10:22:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/>WindowManager</a></div><h1 class="post-title entry-hint-parent">WindowInfos Update Flow</h1><div class=post-meta><span title='2025-09-29 10:22:54 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1697 words</div></header><div class=post-content><h2 id=1-概述-overview>1. 概述 (Overview)<a hidden class=anchor aria-hidden=true href=#1-概述-overview>#</a></h2><p><strong>WindowInfos Update Flow</strong> 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。</p><p>主要消费者包括：</p><ul><li><strong>InputDispatcher (Native)</strong>: 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。</li><li><strong>AccessibilityWindowsPopulator (Java)</strong>: 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。</li></ul><p>该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 <code>DeadSystemException</code>、Binder 缓冲区耗尽）的高发区。</p><h2 id=2-核心架构与组件-architecture>2. 核心架构与组件 (Architecture)<a hidden class=anchor aria-hidden=true href=#2-核心架构与组件-architecture>#</a></h2><p>数据流向遵循 <strong>Producer-Consumer</strong> 模型，并通过 <strong>WindowInfosListenerReporter</strong> 实现多路复用。</p><h3 id=21-发送端-producer-surfaceflinger>2.1 发送端 (Producer: SurfaceFlinger)<a hidden class=anchor aria-hidden=true href=#21-发送端-producer-surfaceflinger>#</a></h3><ul><li><strong>触发源</strong>: 每一帧合成（Vsync）后，若检测到图层属性变化 (<code>mVisibleRegionsDirty</code> 或 <code>mInputInfoChanged</code>)，触发更新。</li><li><strong>异步发送</strong>: 通过 <code>BackgroundExecutor</code> 线程发送，避免阻塞主渲染线程。</li><li><strong>通信接口</strong>: <code>IWindowInfosListener.onWindowInfosChanged</code> (AIDL)，定义为 <code>oneway</code>（非阻塞），允许极高的发送频率。</li></ul><h3 id=22-中转与分发-transport--dispatch-systemserver>2.2 中转与分发 (Transport & Dispatch: SystemServer)<a hidden class=anchor aria-hidden=true href=#22-中转与分发-transport--dispatch-systemserver>#</a></h3><ul><li><strong>WindowInfosListenerReporter (Native)</strong>:</li><li><strong>角色</strong>: SystemServer 进程内的单例 Binder Stub (<code>BnWindowInfosListener</code>)。</li><li><strong>职责</strong>: 它是 SystemServer 与 SurfaceFlinger 之间<strong>唯一</strong>的 Binder 通道。负责接收跨进程数据，并<strong>同步</strong>分发给进程内注册的所有监听器。</li></ul><h3 id=23-接收端-consumers>2.3 接收端 (Consumers)<a hidden class=anchor aria-hidden=true href=#23-接收端-consumers>#</a></h3><ol><li><strong>InputDispatcher (Native)</strong>:</li></ol><ul><li><strong>行为</strong>: <strong>同步阻塞</strong>。在回调中必须获取全局锁 <code>mLock</code> 以更新窗口状态。这是性能瓶颈所在。</li></ul><ol start=2><li><strong>AccessibilityWindowsPopulator (Java)</strong>:</li></ol><ul><li><strong>行为</strong>: <strong>异步非阻塞</strong>。通过 JNI 接收回调后，立即通过 <code>Handler.post</code> 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。</li></ul><h2 id=3-详细时序流程-sequence-diagram>3. 详细时序流程 (Sequence Diagram)<a hidden class=anchor aria-hidden=true href=#3-详细时序流程-sequence-diagram>#</a></h2><p>下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
autonumber &#34;&lt;b&gt;[0]&#34;

title SystemServer: Registration &amp; WindowInfos Update Flow (Complete)

box &#34;SurfaceFlinger Process&#34; #E3F2FD
    participant &#34;SurfaceFlinger&#34; as SF
end box

box &#34;Kernel Space&#34; #F5F5F5
    participant &#34;Binder Driver&#34; as Kernel
end box

box &#34;SystemServer Process (Native)&#34; #FFF3E0
    participant &#34;IPCThreadState&#34; as IPC
    participant &#34;BnWindowInfosListener\n(Stub)&#34; as Stub
    participant &#34;WindowInfosListenerReporter\n(Singleton)&#34; as Reporter
    participant &#34;SurfaceComposerClient&#34; as SCC
    participant &#34;InputDispatcher&#34; as Dispatcher
    participant &#34;DispatcherWindowListener&#34; as Listener
end box

box &#34;SystemServer Process (Java)&#34; #FFE0B2
    participant &#34;AccessibilityWindowsPopulator\n(A11yPop)&#34; as A11yPop
    participant &#34;WMS Handler Thread&#34; as WMS_Thread
    participant &#34;WindowManagerService&#34; as WMS
    participant &#34;AccessibilityWindowManager&#34; as AWM
    participant &#34;AccessibilityManagerService&#34; as AMS
end box

== 0.1 InputDispatcher 注册流程 (Native) ==

Dispatcher -&gt; Dispatcher: new DispatcherWindowListener(*this)
activate Dispatcher
note right: 创建本地监听器

Dispatcher -&gt; SCC: addWindowInfosListener(listener)
activate SCC
SCC -&gt; Reporter: getInstance()
SCC -&gt; Reporter: addWindowInfosListener(listener, ...)
activate Reporter

Reporter -&gt; Reporter: check mWindowInfosListeners.empty()

alt #LightGreen &lt;color:green&gt;&lt;b&gt;首次注册 (First Time)&lt;/b&gt;&lt;/color&gt;
    note right of Reporter
        集合为空，说明 Reporter 尚未连接 SF。
        将 Reporter (this) 注册到远程。
    end note
    Reporter -&gt; SF: IWindowInfosListener.addWindowInfosListener(this)
    activate SF
    SF -&gt; SF: 保存 Reporter 句柄
    SF --&gt; Reporter: status
    deactivate SF
else &lt;color:gray&gt;后续注册 (Re-use)&lt;/color&gt;
    note right of Reporter
        集合不为空，通道已建立。
        直接复用，不发起 Binder 调用。
    end note
end

Reporter -&gt; Reporter: mWindowInfosListeners.insert(listener)
note right: 将 InputDispatcher 加入本地集合

Reporter --&gt; SCC: status
deactivate Reporter
SCC --&gt; Dispatcher: status
deactivate SCC
deactivate Dispatcher

== 0.2 Accessibility 注册流程 (Java Stack) ==

note right of AMS
  &lt;b&gt;触发时机:&lt;/b&gt;
  1. 系统启动完毕
  2. 开启无障碍服务 (TalkBack等)
  3. 显示器插拔 (onDisplayAdded)
end note

AMS -&gt; AWM: startTrackingWindows()
activate AMS
AWM -&gt; WMS: setWindowsForAccessibilityCallback()
activate AWM
WMS -&gt; A11yPop: setWindowsNotification(true)
activate WMS
activate A11yPop

A11yPop -&gt; A11yPop: register()
A11yPop -&gt; SCC: nativeRegister() [JNI]
activate SCC

SCC -&gt; Reporter: addWindowInfosListener(listener)
activate Reporter
note right of Reporter
  检测到 InputDispatcher 已注册，
  这里直接复用现有通道，
  将 A11yPop 加入本地集合。
end note
Reporter -&gt; Reporter: mWindowInfosListeners.insert(A11yPop)

Reporter --&gt; SCC: status
deactivate Reporter
SCC --&gt; A11yPop: status
deactivate SCC
A11yPop --&gt; WMS: void
deactivate A11yPop
WMS --&gt; AWM: void
deactivate WMS
AWM --&gt; AMS: void
deactivate AWM
deactivate AMS

|||

== 1. 跨进程接收 (Binder Thread) ==

SF -&gt; Kernel: onWindowInfosChanged(data) (Oneway)
note left: SF 生产 46KB 数据\n疯狂发送

Kernel -&gt; IPC: ioctl(BR_TRANSACTION)
activate IPC
note left: Binder 线程被唤醒

IPC -&gt; Stub: onTransact(...)
activate Stub
note right: &lt;color:red&gt;&lt;b&gt;反序列化 (Unmarshalling)&lt;/b&gt;&lt;/color&gt;\n解析 Parcel -&gt; vector&lt;WindowInfo&gt;

Stub -&gt; Reporter: onWindowInfosChanged(windowInfos, ...)
deactivate Stub
activate Reporter

== 2. 进程内分发 (Reporter Loop) ==

note right of Reporter
    &lt;color:red&gt;&lt;b&gt;同步循环 (Synchronous Loop)&lt;/b&gt;&lt;/color&gt;
    运行在 Binder 线程中。
    必须等所有 Listener 处理完才能返回。
end note

loop foreach listener in mWindowInfosListeners

    alt #MistyRose Listener == InputDispatcher (Native)
        Reporter -&gt; Listener: onWindowInfosChanged(windowInfos)
        activate Listener
        
        == 3. 业务处理 (InputDispatcher) ==
        
        Listener -&gt; Dispatcher: setInputWindows(windowInfos)
        activate Dispatcher
        
        Dispatcher -&gt; Dispatcher: &lt;color:red&gt;std::scoped_lock _l(mLock)&lt;/color&gt;
        note right
            &lt;color:red&gt;&lt;b&gt;关键阻塞点 (Critical Block)&lt;/b&gt;&lt;/color&gt;
            InputDispatcher 持锁处理。
            如果有 Input 事件积压，这里会卡住。
            &lt;b&gt;这是导致 Oneway Spamming 的主要原因。&lt;/b&gt;
        end note
        
        Dispatcher -&gt; Dispatcher: setInputWindowsLocked(...)
        
        Dispatcher --&gt; Listener: void
        deactivate Dispatcher
        
        Listener --&gt; Reporter: void
        deactivate Listener

    else #AliceBlue Listener == AccessibilityWindowsPopulator (Java)
        Reporter -&gt; A11yPop: onWindowInfosChanged(windowHandles, ...) [JNI]
        activate A11yPop
        
        == 3.1 业务处理 (A11yPopulator) ==
        
        A11yPop -&gt; A11yPop: mHandler.post(...)
        note right
            &lt;color:green&gt;&lt;b&gt;异步非阻塞 (Async)&lt;/b&gt;&lt;/color&gt;
            源码: mHandler.post(() -&gt; onWindowInfosChangedInternal)
            立即返回，不占用 Binder 线程时间。
        end note
        
        A11yPop --&gt; Reporter: void
        deactivate A11yPop
        
        A11yPop -[#blue]&gt; WMS_Thread: onWindowInfosChangedInternal(...)
        activate WMS_Thread
        note right
           &lt;b&gt;延迟处理:&lt;/b&gt;
           繁重的矩阵计算(Matrix)和
           遍历逻辑在此线程执行。
        end note
        deactivate WMS_Thread
    end
end

Reporter --&gt; Stub: void
deactivate Reporter

Stub --&gt; IPC: void
IPC -&gt; Kernel: ioctl(BC_FREE_BUFFER)
note left: 只有执行到这里，\n内核缓冲区才会被释放。
deactivate IPC

@enduml
</code></pre><h2 id=4-surfaceflingerupdateinputflinger-工作原理与调用时序>4. SurfaceFlinger::updateInputFlinger 工作原理与调用时序<a hidden class=anchor aria-hidden=true href=#4-surfaceflingerupdateinputflinger-工作原理与调用时序>#</a></h2><p><strong>1. 概述</strong></p><p><code>SurfaceFlinger::updateInputFlinger()</code> 是 Android 图形系统（SurfaceFlinger）向输入系统（InputFlinger/SystemServer）同步窗口信息的核心枢纽。</p><p>它的主要职责是：在图形合成（Composition）流程中，将当前的图层（Layer）状态“翻译”成输入系统能理解的 <code>WindowInfo</code>（包含窗口位置、触摸区域、标志位等），并发送给 InputDispatcher，以确保触摸事件能准确分发给用户看到的那个窗口。</p><p><strong>2. 核心工作原理</strong></p><p><code>updateInputFlinger</code> 的执行逻辑设计得非常谨慎，以避免不必要的计算和跨进程通信（IPC）。</p><p>其内部工作流程如下：</p><ul><li><p><strong>Step 1: 检查更新条件 (Check Dirty Flags)</strong></p><ul><li>函数首先检查两个关键的脏标记（Dirty Flags）：</li><li><code>mVisibleRegionsDirty</code>: 表示图层的几何属性（位置、大小、矩阵）、Z-Order 或可见性发生了变化。这通常意味着窗口的“可触摸区域”变了。</li><li><code>mInputInfoChanged</code>: 表示图层的纯输入属性（如 <code>InputConfig</code>、Token、Title 等）发生了变化。</li><li><strong>只有</strong>当这两者之一为 <code>true</code> 时，才会触发窗口信息的重新构建。</li></ul></li><li><p><strong>Step 2: 构建窗口信息 (Build Window Infos)</strong></p><ul><li>如果需要更新 (<code>updateWindowInfo = true</code>)，调用 <code>buildWindowInfos(windowInfos, displayInfos)</code>。</li><li>buildWindowInfos 的核心任务是将 SurfaceFlinger 的图层树（Layer Hierarchy）扁平化为 InputDispatcher 能理解的窗口列表。
它的工作流程大致如下：<ul><li>遍历 (Traversal): 它会遍历当前所有 Display 的图层。通常是按照 Z-Order (从上到下 或 从下到上) 进行遍历。InputDispatcher 需要的是从前向后（Front-to-Back）的列表以便进行点击测试（Hit Test），或者 SF 提供列表后由 InputDispatcher 排序。</li><li>数据转换 (Translation): 对于每一个可见的 Layer，它会调用类似 Layer::writeToWindowInfo 的方法，提取以下关键信息<ul><li>Token: 窗口的唯一标识（Binder 句柄）。</li><li>Name: 窗口名字（如 &ldquo;com.cockpit.camera/&mldr;"）。</li><li>Flags: InputWindowHandle::InputConfig，例如是否可触摸、是否是 Spy Window、是否遮挡下方等。</li><li>TouchableRegion: 经过裁剪（Crop）和父图层变换后的最终触摸区域。</li><li>Transform: 将图层坐标系映射到屏幕坐标系的矩阵。</li><li>Alpha/Visibility: 只有可见且 Alpha 大于阈值的图层才会生成有效的 WindowInfo。</li><li>聚合 (Aggregation): 将所有生成的 WindowInfo 对象放入 std::vector<windowinfo> 中，同时收集对应的 DisplayInfo（屏幕尺寸、旋转方向等）。</li><li>总结: 这是一个“翻译”过程，把图形系统的图层属性翻译成输入系统的窗口属性。</li></ul></li></ul></li></ul></li><li><p><strong>Step 3: 检查命令队列 (Check Commands)</strong></p><ul><li>除了窗口信息更新，该函数还处理来自 WindowManagerService (WMS) 的输入命令，例如“设置焦点窗口”（Focus Request）。这些命令存储在 <code>mInputWindowCommands</code> 中。当 WMS 决定改变当前焦点窗口时（例如用户启动了新 App，或者点击了某个窗口），WMS 不会直接调用 InputDispatcher，而是通过 SurfaceComposerClient::Transaction 发送一个 requestFocus 命令给 SurfaceFlinger。
流程如下:<ul><li>WMS 调用 t.setFocusedWindow(token, &mldr;)。</li><li>该命令随 Transaction 发送到 SurfaceFlinger。</li><li>SurfaceFlinger 在应用 Transaction 时，将这个请求解析并放入 mInputWindowCommands.focusRequests 队列中。</li><li>在 updateInputFlinger 执行时，SF 将这个请求转发给 InputDispatcher。</li><li>总结: 这是一个“旁路”机制。大部分帧里这个 list 是空的；只有在发生窗口焦点切换（Focus Switch）的那一帧，这个循环才会执行。</li></ul></li><li><strong>快速返回</strong>: 如果既不需要更新窗口信息，也没有输入命令要处理，函数直接返回，不消耗任何资源。</li></ul></li><li><p><strong>Step 4: 异步发送 (Async Dispatch)</strong></p><ul><li>为了不阻塞 SurfaceFlinger 的主渲染线程（Main Thread），所有与 InputFlinger 的交互（IPC）都被封装在一个 Lambda 表达式中，并投递给 <code>BackgroundExecutor</code> 线程执行。</li><li><strong>数据移动</strong>: 使用 <code>std::move</code> 将构建好的 <code>windowInfos</code> 大数据块移动到 Lambda 捕获列表中，避免内存拷贝。</li></ul></li><li><p><strong>Step 5: 跨进程通信 (IPC)</strong></p><ul><li>在后台线程中，调用 <code>mWindowInfosListenerInvoker->windowInfosChanged(...)</code>。</li><li>这会触发 Binder 驱动，将数据发送给 SystemServer 进程中的 <code>WindowInfosListenerReporter</code>，最终到达 <code>InputDispatcher</code>。</li></ul></li><li><p><strong>Step 6: 处理焦点请求 (Handle Focus)</strong></p><ul><li>如果在同一帧中有焦点切换请求 (<code>inputWindowCommands.focusRequests</code>)，也会在后台线程中同步调用 <code>inputFlinger->setFocusedWindow</code>。</li></ul></li></ul><p><strong>3. 调用时序与上下文 (Call Stack & Context)</strong></p><p><code>updateInputFlinger</code> 并非孤立执行，它是 SurfaceFlinger 主合成循环（Main Loop）中不可或缺的一环。</p><ul><li><strong>触发源</strong>: VSYNC 信号 -> <code>MessageQueue::Handler::handleMessage</code>。</li><li><strong>入口</strong>: <code>SurfaceFlinger::commit</code>。这是每帧合成的核心函数。</li></ul><p><strong>完整调用链分析：</strong></p><ol><li><strong>VSYNC 到达</strong>: 硬件或软件 VSYNC 信号触发，调用 <code>MessageQueue::handleMessage</code>。</li><li><strong>开始提交 (Commit)</strong>: <code>handleMessage</code> 调用 <code>compositor.commit</code>，即 <code>SurfaceFlinger::commit</code>。</li><li><strong>事务处理 (Transaction Handling)</strong>:<ul><li><code>commitTransactions()</code>: 处理来自应用和 SystemServer 的 Binder 事务（如窗口移动、大小改变）。这是导致 <code>mVisibleRegionsDirty</code> 变脏的主要原因。</li></ul></li><li><strong>几何更新 (Geometry Update)</strong>:<ul><li><code>updateLayerGeometry()</code>: 根据新的事务状态，重新计算所有图层的可见区域和变换矩阵。</li></ul></li><li><strong>输入更新 (Input Update)</strong>:<ul><li><strong><code>updateInputFlinger()</code> 被调用</strong>。</li><li><strong>位置关键</strong>: 它被特意安排在 <code>commitTransactions</code> 和 <code>updateLayerGeometry</code> <strong>之后</strong>。</li><li><strong>原因</strong>: 必须先处理完所有的窗口变换和层级调整，确认了最终每一层都在哪、谁遮挡了谁，才能生成准确的 InputWindowInfo。</li></ul></li><li><strong>通知追踪 (Tracing)</strong>:<ul><li>如果有需要，通知 <code>LayerTracing</code> 记录当前帧状态。</li></ul></li></ol><p><strong>4. 总结图示</strong></p><pre tabindex=0><code>VSYNC Signal
  ↓
MessageQueue::handleMessage()
  ↓
SurfaceFlinger::commit()
  ↓
  ├── commitTransactions()      &lt;-- 应用改变窗口属性 (Set Dirty Flags)
  ↓
  ├── updateLayerGeometry()     &lt;-- 计算最终图层位置
  ↓
  ├── updateInputFlinger()      &lt;-- [本文角主角]
  │     ↓
  │     若 (Dirty): 构建 WindowInfo
  │     ↓
  │     BackgroundExecutor (异步线程)
  │     ↓
  │     Binder Call -&gt; SystemServer (InputDispatcher)
  ↓
  └── (后续流程) composite() -&gt; 提交给 HWC/GPU
</code></pre><h2 id=5-附录>5. 附录<a hidden class=anchor aria-hidden=true href=#5-附录>#</a></h2><h3 id=inputwindowcommands的简介>InputWindowCommands的简介<a hidden class=anchor aria-hidden=true href=#inputwindowcommands的简介>#</a></h3><p><code>InputWindowCommands</code> 的直接来源是 <strong>SurfaceComposerClient::Transaction</strong>（即跨进程的 Binder 事务）。</p><p>归根结底，它是 <strong>WindowManagerService (WMS)</strong>（以及其他系统组件）用来“遥控” InputDispatcher 的一种手段，但必须经过 SurfaceFlinger 中转。</p><p>以下是详细的来源分析：</p><h4 id=1-数据的源头windowmanagerservice-wms>1. 数据的源头：WindowManagerService (WMS)<a hidden class=anchor aria-hidden=true href=#1-数据的源头windowmanagerservice-wms>#</a></h4><p>WMS 是窗口管理的权威，它决定了哪个窗口应该获得焦点，或者何时需要同步输入状态。</p><ul><li><strong>场景 A：设置焦点 (Focus Requests)</strong>
当用户点击某个窗口，或者 App 启动时，WMS 计算出新的焦点窗口。
WMS 会调用 <code>SurfaceControl.Transaction</code> 的 API：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Java 层 (WindowManagerService)</span>
</span></span><span style=display:flex><span>transaction.<span style=color:#a6e22e>setFocusedWindow</span>(windowToken, displayId, ...);
</span></span></code></pre></div><ul><li><strong>场景 B：同步输入 (Sync Input Windows)</strong>
通常用于测试（CTS）或特殊的同步绘制场景（BLASTSync）。客户端希望确保 InputDispatcher 已经收到了最新的窗口信息。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Java 层</span>
</span></span><span style=display:flex><span>transaction.<span style=color:#a6e22e>syncInputWindows</span>();
</span></span></code></pre></div><h4 id=2-传输通道binder-transaction>2. 传输通道：Binder Transaction<a hidden class=anchor aria-hidden=true href=#2-传输通道binder-transaction>#</a></h4><p>这些命令被序列化到 <code>Transaction</code> 对象中，通过 Binder 发送给 SurfaceFlinger。
<code>mInputWindowCommands</code> 是 <code>SurfaceFlinger</code> 类的一个成员变量，它充当了一个<strong>暂存区</strong>。</p><h4 id=3-收集过程surfaceflingerapplytransactionstate>3. 收集过程：SurfaceFlinger::applyTransactionState<a hidden class=anchor aria-hidden=true href=#3-收集过程surfaceflingerapplytransactionstate>#</a></h4><p>当 SurfaceFlinger 接收并应用这些 Transaction 时，会将命令提取出来并合并到 <code>mInputWindowCommands</code> 中。</p><p><strong>流程如下：</strong></p><ol><li><strong>接收事务</strong>: <code>SurfaceFlinger::setTransactionState</code> 收到 Binder 调用。</li><li><strong>应用事务</strong>: 在主线程调用 <code>applyTransactionState</code> 处理所有挂起的 Transaction。</li><li><strong>提取命令</strong>: 遍历 Transaction 中的 <code>InputWindowCommands</code>。<ul><li>如果是 <code>focusRequests</code>，则 <code>push_back</code> 到 <code>mInputWindowCommands.focusRequests</code> 列表。</li><li>如果是 <code>syncInputWindows</code>，则设置 <code>mInputWindowCommands.syncInputWindows = true</code>。</li></ul></li></ol><h4 id=4-消费过程updateinputflinger>4. 消费过程：updateInputFlinger<a hidden class=anchor aria-hidden=true href=#4-消费过程updateinputflinger>#</a></h4><ul><li>在每一帧合成时，<code>updateInputFlinger</code> 会读取这个暂存区。</li><li><strong>关键动作</strong>: <code>inputWindowCommands = std::move(mInputWindowCommands)</code>。
它使用 <code>std::move</code> 将所有积累的命令“偷”走传给后台线程，然后立刻 <code>clear()</code> 清空暂存区，为下一帧做准备。</li></ul><h4 id=总结图示>总结图示<a hidden class=anchor aria-hidden=true href=#总结图示>#</a></h4><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
top to bottom direction

&#39; 定义节点
component &#34;WindowManagerService&#34; as WMS
component &#34;CTS Tests&#34; as CTS
component &#34;SurfaceControl.Transaction&#34; as Trans
component &#34;SurfaceFlinger&#34; as SF
queue &#34;mInputWindowCommands\n(暂存区)&#34; as Acc
component &#34;updateInputFlinger&#34; as UIF
component &#34;InputDispatcher&#34; as ID

&#39; 定义连接关系
WMS --&gt; Trans : 1. t.setFocusedWindow
CTS --&gt; Trans : 1. t.syncInputWindows

Trans --&gt; SF : 2. Binder IPC

SF --&gt; Acc : 3. applyTransactionState

Acc --&gt; UIF : 4. std::move

UIF --&gt; ID : 5. setFocusedWindow

@enduml
</code></pre><p><strong>总结：</strong>
<code>InputWindowCommands</code> 是 WMS 等客户端通过 <strong>Transaction</strong> 捎带给 SurfaceFlinger 的指令包，暂存在 SurfaceFlinger 中，并在下一帧合成时转发给 InputDispatcher。</p><h3 id=surfaceflinger合成流程概览>SurfaceFlinger合成流程概览<a hidden class=anchor aria-hidden=true href=#surfaceflinger合成流程概览>#</a></h3><p>这是一个非常经典且宏大的系统流程。从 VSYNC 信号触发到最终像素上屏，SurfaceFlinger (SF) 完成了一次完整的“心跳”循环。
这个过程主要发生在 <strong>SurfaceFlinger Main Thread (主线程)</strong> 中，但也涉及到调度线程、Binder 线程池和渲染线程。
以下是基于现代 Android (Android 12/13/14) 架构的详细阶段拆解：</p><h4 id=核心流程概览>核心流程概览<a hidden class=anchor aria-hidden=true href=#核心流程概览>#</a></h4><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
autonumber &#34;&lt;b&gt;[0]&#34;

title SurfaceFlinger: VSYNC to Present Pipeline

box &#34;Hardware / Kernel&#34; #F5F5F5
    participant &#34;VSYNC Generator&#34; as HW_VSYNC
    participant &#34;HWC / DRM&#34; as HWC
end box

box &#34;SurfaceFlinger Process&#34; #E3F2FD
    participant &#34;Scheduler/EventThread&#34; as Sched
    participant &#34;MessageQueue&#34; as MQ
    participant &#34;SurfaceFlinger (Main)&#34; as SF
    participant &#34;Layer / BufferQueue&#34; as Layer
    participant &#34;CompositionEngine&#34; as CE
    participant &#34;RenderEngine (GPU)&#34; as RE
end box

== Phase 1: VSYNC 唤醒 ==
HW_VSYNC -&gt; Sched: Hardware Vsync Signal
Sched -&gt; MQ: dispatchVsync
MQ -&gt; SF: handleMessageInvalidate()

== Phase 2: 状态更新 (Commit) ==
activate SF
SF -&gt; SF: commit()

group 2.1 处理事务 (Transactions)
    SF -&gt; SF: flushTransactionQueues()
    SF -&gt; Layer: apply transactions (pos, alpha, z-order...)
end

group 2.2 锁定缓冲区 (Latch Buffers)
    SF -&gt; Layer: latchBuffer()
    Layer -&gt; Layer: acquireBuffer() (from BufferQueue)
end

group 2.3 几何与输入更新
    SF -&gt; SF: updateLayerGeometry()
    SF -&gt; SF: updateInputFlinger()
end

== Phase 3: 合成 (Composite) ==

SF -&gt; CE: composite(display)

group 3.1 验证 (HWC Validation)
    CE -&gt; HWC: validateDisplay()
    HWC --&gt; CE: changes (Client vs Device composition)
end

group 3.2 客户端合成 (GPU Rendering)
    CE -&gt; RE: drawLayers() (SkiaGL/SkiaVk)
    activate RE
    RE --&gt; CE: Output Buffer (Framebuffer)
    deactivate RE
end

group 3.3 设备合成 (HWC Present)
    CE -&gt; HWC: setOutputBuffer (if GPU used)
    CE -&gt; HWC: presentDisplay()
end

deactivate SF

@enduml
</code></pre><h4 id=详细阶段解析>详细阶段解析<a hidden class=anchor aria-hidden=true href=#详细阶段解析>#</a></h4><p>整个流程通常由 <code>MessageQueue::Handler::handleMessage</code> 触发，主要逻辑封装在 <code>SurfaceFlinger::commit</code> 和 <code>SurfaceFlinger::composite</code> 中。</p><h5 id=phase-1-vsync-调度与唤醒-scheduling>Phase 1: VSYNC 调度与唤醒 (Scheduling)<a hidden class=anchor aria-hidden=true href=#phase-1-vsync-调度与唤醒-scheduling>#</a></h5><p>这是流程的起点。硬件发出垂直同步信号，告诉系统“显示器准备好下一帧了”。</p><ul><li><strong>工作内容</strong>:</li></ul><ol><li>硬件 VSYNC 信号到达内核，DispSync 模型进行校准。</li><li><code>Scheduler</code> 决定是否需要唤醒 SF（如果没有 Layer 更新，SF 会休眠）。</li><li>通过 <code>MessageQueue</code> 发送 <code>INVALIDATE</code> 消息给 SF 主线程。</li></ol><ul><li><p><strong>涉及线程</strong>:</p></li><li><p><code>DispSyncThread</code> (或类似的 Vsync 线程)</p></li><li><p><code>EventThread</code> (分发 Vsync)</p></li><li><p><strong>SF Main Thread</strong> (接收消息)</p></li><li><p><strong>核心类</strong>:</p></li><li><p><code>Scheduler</code>: 统管 Vsync 分发和帧率选择。</p></li><li><p><code>EventThread</code>: 连接 DispSync 和 Client (SF/App) 的桥梁。</p></li><li><p><code>MessageQueue</code>: SF 的 Looper 机制。</p></li></ul><h4 id=phase-2-提交与状态更新-commit>Phase 2: 提交与状态更新 (Commit)<a hidden class=anchor aria-hidden=true href=#phase-2-提交与状态更新-commit>#</a></h4><p>SF 被唤醒后，首先要处理“逻辑状态”，确定这一帧“该画什么”、“在哪画”。</p><p><strong>2.1 处理事务 (Transactions)</strong></p><ul><li><p><strong>工作内容</strong>: 处理来自 App 或 WMS 的 Binder 调用 (<code>SurfaceControl.Transaction</code>)。</p></li><li><p>应用窗口的移动、缩放、隐藏/显示。</p></li><li><p><code>mVisibleRegionsDirty</code> 在此阶段被置为 true。</p></li><li><p><strong>核心类</strong>: <code>TransactionCallbackInvoker</code>, <code>Layer</code>。</p></li></ul><p><strong>2.2 锁定缓冲区 (Latch Buffers)</strong></p><ul><li><p><strong>工作内容</strong>: 检查各个 Layer 的 BufferQueue 中是否有应用刚刚生产好的 Buffer（Fence 已 Signal）。</p></li><li><p>如果有，调用 <code>acquireBuffer</code> 获取图形数据。</p></li><li><p>将 Layer 的状态从“待定”更新为“当前绘制状态”。</p></li><li><p><strong>关键点</strong>: 这里决定了这一帧显示的是 App 的哪一张图。</p></li><li><p><strong>核心类</strong>: <code>BufferQueue</code>, <code>BufferLayer</code>, <code>ConsumerBase</code>。</p></li></ul><p><strong>2.3 几何与输入更新 (Geometry & Input)</strong></p><ul><li><p><strong>工作内容</strong>:</p></li><li><p><code>updateLayerGeometry()</code>: 计算可见区域 (Visible Region)、脏区域 (Dirty Region)、遮挡关系。</p></li><li><p><code>updateInputFlinger()</code>: <strong>(我们刚讨论过的)</strong> 将计算好的窗口信息同步给 InputDispatcher。</p></li><li><p><strong>核心类</strong>: <code>Region</code>, <code>Layer</code>, <code>InputWindowCommands</code>。</p></li></ul><h4 id=phase-3-合成-composition>Phase 3: 合成 (Composition)<a hidden class=anchor aria-hidden=true href=#phase-3-合成-composition>#</a></h4><p>此时逻辑状态已确定，开始生成像素或指令。现代 Android 使用 <code>CompositionEngine</code> (CE) 模块来管理这一步。</p><p><strong>3.1 HWC 验证 (Validation)</strong></p><ul><li><p><strong>工作内容</strong>: SF 询问 HWC：“这些 Layer 你能处理吗？”</p></li><li><p>SF 将 Layer 列表发给 HWC。</p></li><li><p>HWC 返回每个 Layer 的合成方式：</p></li><li><p><strong>Device Composition</strong>: HWC 硬件直接处理（高效，如 Overlay）。</p></li><li><p><strong>Client Composition</strong>: HWC 处理不了（如复杂 Shader、圆角、模糊），需要 GPU 处理。</p></li><li><p><strong>核心类</strong>: <code>HWComposer</code>, <code>CompositionEngine</code>, <code>Output</code>.</p></li></ul><p><strong>3.2 客户端合成 (Client Composition / GPU)</strong></p><ul><li><p><strong>工作内容</strong>: 如果 HWC 说“我处理不了”，SF 就调用 <code>RenderEngine</code> 用 GPU 把这些 Layer 画到一个 Buffer (Framebuffer) 上。</p></li><li><p>Android 12+ 默认使用 Skia (SkiaGL 或 SkiaVk)。</p></li><li><p><strong>涉及线程</strong>:</p></li><li><p><strong>SF Main Thread</strong>: 发起绘制指令。</p></li><li><p><strong>RenderEngine Thread</strong>: (视实现而定，可能有专门的渲染线程) 执行 GPU 指令提交。</p></li><li><p><strong>核心类</strong>: <code>RenderEngine</code>, <code>SkiaRenderEngine</code>, <code>FramebufferSurface</code>.</p></li></ul><p><strong>3.3 设备合成与上屏 (Device Composition & Present)</strong></p><ul><li><p><strong>工作内容</strong>:</p></li><li><p>如果进行了 GPU 合成，将 GPU 生成的 Buffer 作为一个特殊的 Layer 传给 HWC。</p></li><li><p>调用 <code>HWC::presentDisplay()</code>。</p></li><li><p>HWC 驱动将最终配置提交给显示硬件。</p></li><li><p><strong>Fence 机制</strong>: 系统不会死等 GPU/Display 完成，而是通过 Fence (文件描述符) 同步。</p></li><li><p><strong>核心类</strong>: <code>HWComposer</code>, <code>DisplayDevice</code>.</p></li></ul><h3 id=线程模型总结>线程模型总结<a hidden class=anchor aria-hidden=true href=#线程模型总结>#</a></h3><table><thead><tr><th>线程名称</th><th>职责</th><th>涉及阶段</th></tr></thead><tbody><tr><td><strong>SurfaceFlinger Main</strong></td><td><strong>大总管</strong>。负责逻辑状态更新、Buffer锁定、几何计算、指挥合成。90% 的代码运行于此。</td><td>All Stages</td></tr><tr><td><strong>EventThread</strong></td><td><strong>节拍器</strong>。负责接收硬件 VSYNC 并分发给 SF 主线程和 App。</td><td>Phase 1</td></tr><tr><td><strong>Binder Threads</strong></td><td><strong>接收员</strong>。负责接收 App/WMS 的 <code>Transaction</code> 和 <code>queueBuffer</code> 调用，放入队列供主线程消费。</td><td>Phase 2 (Pre-processing)</td></tr><tr><td><strong>RenderEngine</strong></td><td><strong>画师</strong>。如果需要 GPU 合成，负责执行 OpenGL/Vulkan 指令。</td><td>Phase 3.2</td></tr><tr><td><strong>HWC / DRM</strong></td><td><strong>放映员</strong>。内核/硬件层，负责最终将图层叠加并输出到屏幕。</td><td>Phase 3.3</td></tr></tbody></table><h3 id=关键总结>关键总结<a hidden class=anchor aria-hidden=true href=#关键总结>#</a></h3><p>SurfaceFlinger 的一帧就像一条流水线：</p><ol><li><strong>VSYNC</strong> 是发令枪。</li><li><strong>Commit</strong> 阶段确定“物体”的位置和形状（Logic）。</li><li><strong>Latch Buffer</strong> 阶段给物体贴上“材质”（Content）。</li><li><strong>HWC Validate</strong> 阶段决定“谁来画”（Strategy）。</li><li><strong>Composite</strong> 阶段真正执行“画”的动作（Rendering）。</li><li><strong>Present</strong> 阶段把画好的图交给屏幕（Display）。</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/splitscreen-wmshell/><span class=title>« Prev</span><br><span>SplitScreenController flow</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/spamming-oneway/><span class=title>Next »</span><br><span>Binder spam detection原理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>