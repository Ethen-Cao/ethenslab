<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="Android Subsystem Wiki: WindowInfos Update Flow
1. 概述 (Overview)
WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：

InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。
AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。

该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture)
数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger)

触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。
异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。
通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。

2.2 中转与分发 (Transport & Dispatch: SystemServer)

WindowInfosListenerReporter (Native):
角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。
职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。

2.3 接收端 (Consumers)

InputDispatcher (Native):


行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。


AccessibilityWindowsPopulator (Java):


行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。

3. 详细时序流程 (Sequence Diagram)
下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="Android Subsystem Wiki: WindowInfos Update Flow 1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：
InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport & Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Android Subsystem Wiki: WindowInfos Update Flow
1. 概述 (Overview)
WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。
主要消费者包括：

InputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。
AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。

该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。
2. 核心架构与组件 (Architecture)
数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。
2.1 发送端 (Producer: SurfaceFlinger)

触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。
异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。
通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。

2.2 中转与分发 (Transport & Dispatch: SystemServer)

WindowInfosListenerReporter (Native):
角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。
职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。

2.3 接收端 (Consumers)

InputDispatcher (Native):


行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。


AccessibilityWindowsPopulator (Java):


行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。

3. 详细时序流程 (Sequence Diagram)
下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"WindowManager","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/"},{"@type":"ListItem","position":3,"name":"","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Android Subsystem Wiki: WindowInfos Update Flow 1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。\n主要消费者包括：\nInputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。\n2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。\n2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport \u0026amp; Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。\n","keywords":[],"articleBody":"Android Subsystem Wiki: WindowInfos Update Flow 1. 概述 (Overview) WindowInfos Update Flow 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。\n主要消费者包括：\nInputDispatcher (Native): 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。 AccessibilityWindowsPopulator (Java): 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。 该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 DeadSystemException、Binder 缓冲区耗尽）的高发区。\n2. 核心架构与组件 (Architecture) 数据流向遵循 Producer-Consumer 模型，并通过 WindowInfosListenerReporter 实现多路复用。\n2.1 发送端 (Producer: SurfaceFlinger) 触发源: 每一帧合成（Vsync）后，若检测到图层属性变化 (mVisibleRegionsDirty 或 mInputInfoChanged)，触发更新。 异步发送: 通过 BackgroundExecutor 线程发送，避免阻塞主渲染线程。 通信接口: IWindowInfosListener.onWindowInfosChanged (AIDL)，定义为 oneway（非阻塞），允许极高的发送频率。 2.2 中转与分发 (Transport \u0026 Dispatch: SystemServer) WindowInfosListenerReporter (Native): 角色: SystemServer 进程内的单例 Binder Stub (BnWindowInfosListener)。 职责: 它是 SystemServer 与 SurfaceFlinger 之间唯一的 Binder 通道。负责接收跨进程数据，并同步分发给进程内注册的所有监听器。 2.3 接收端 (Consumers) InputDispatcher (Native): 行为: 同步阻塞。在回调中必须获取全局锁 mLock 以更新窗口状态。这是性能瓶颈所在。 AccessibilityWindowsPopulator (Java): 行为: 异步非阻塞。通过 JNI 接收回调后，立即通过 Handler.post 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。 3. 详细时序流程 (Sequence Diagram) 下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。\n@startuml @startuml !theme plain autonumber \"[0]\" title SystemServer: Registration \u0026 WindowInfos Update Flow (Complete) box \"SurfaceFlinger Process\" #E3F2FD participant \"SurfaceFlinger\" as SF end box box \"Kernel Space\" #F5F5F5 participant \"Binder Driver\" as Kernel end box box \"SystemServer Process (Native)\" #FFF3E0 participant \"IPCThreadState\" as IPC participant \"BnWindowInfosListener\\n(Stub)\" as Stub participant \"WindowInfosListenerReporter\\n(Singleton)\" as Reporter participant \"SurfaceComposerClient\" as SCC participant \"InputDispatcher\" as Dispatcher participant \"DispatcherWindowListener\" as Listener end box box \"SystemServer Process (Java)\" #FFE0B2 participant \"AccessibilityWindowsPopulator\\n(A11yPop)\" as A11yPop participant \"WMS Handler Thread\" as WMS_Thread participant \"WindowManagerService\" as WMS participant \"AccessibilityWindowManager\" as AWM participant \"AccessibilityManagerService\" as AMS end box == 0.1 InputDispatcher 注册流程 (Native) == Dispatcher -\u003e Dispatcher: new DispatcherWindowListener(*this) activate Dispatcher note right: 创建本地监听器 Dispatcher -\u003e SCC: addWindowInfosListener(listener) activate SCC SCC -\u003e Reporter: getInstance() SCC -\u003e Reporter: addWindowInfosListener(listener, ...) activate Reporter Reporter -\u003e Reporter: check mWindowInfosListeners.empty() alt #LightGreen 首次注册 (First Time) note right of Reporter 集合为空，说明 Reporter 尚未连接 SF。 将 Reporter (this) 注册到远程。 end note Reporter -\u003e SF: IWindowInfosListener.addWindowInfosListener(this) activate SF SF -\u003e SF: 保存 Reporter 句柄 SF --\u003e Reporter: status deactivate SF else 后续注册 (Re-use) note right of Reporter 集合不为空，通道已建立。 直接复用，不发起 Binder 调用。 end note end Reporter -\u003e Reporter: mWindowInfosListeners.insert(listener) note right: 将 InputDispatcher 加入本地集合 Reporter --\u003e SCC: status deactivate Reporter SCC --\u003e Dispatcher: status deactivate SCC deactivate Dispatcher == 0.2 Accessibility 注册流程 (Java Stack) == note right of AMS 触发时机: 1. 系统启动完毕 2. 开启无障碍服务 (TalkBack等) 3. 显示器插拔 (onDisplayAdded) end note AMS -\u003e AWM: startTrackingWindows() activate AMS AWM -\u003e WMS: setWindowsForAccessibilityCallback() activate AWM WMS -\u003e A11yPop: setWindowsNotification(true) activate WMS activate A11yPop A11yPop -\u003e A11yPop: register() A11yPop -\u003e SCC: nativeRegister() [JNI] activate SCC SCC -\u003e Reporter: addWindowInfosListener(listener) activate Reporter note right of Reporter 检测到 InputDispatcher 已注册， 这里直接复用现有通道， 将 A11yPop 加入本地集合。 end note Reporter -\u003e Reporter: mWindowInfosListeners.insert(A11yPop) Reporter --\u003e SCC: status deactivate Reporter SCC --\u003e A11yPop: status deactivate SCC A11yPop --\u003e WMS: void deactivate A11yPop WMS --\u003e AWM: void deactivate WMS AWM --\u003e AMS: void deactivate AWM deactivate AMS ||| == 1. 跨进程接收 (Binder Thread) == SF -\u003e Kernel: onWindowInfosChanged(data) (Oneway) note left: SF 生产 46KB 数据\\n疯狂发送 Kernel -\u003e IPC: ioctl(BR_TRANSACTION) activate IPC note left: Binder 线程被唤醒 IPC -\u003e Stub: onTransact(...) activate Stub note right: 反序列化 (Unmarshalling)\\n解析 Parcel -\u003e vector Stub -\u003e Reporter: onWindowInfosChanged(windowInfos, ...) deactivate Stub activate Reporter == 2. 进程内分发 (Reporter Loop) == note right of Reporter 同步循环 (Synchronous Loop) 运行在 Binder 线程中。 必须等所有 Listener 处理完才能返回。 end note loop foreach listener in mWindowInfosListeners alt #MistyRose Listener == InputDispatcher (Native) Reporter -\u003e Listener: onWindowInfosChanged(windowInfos) activate Listener == 3. 业务处理 (InputDispatcher) == Listener -\u003e Dispatcher: setInputWindows(windowInfos) activate Dispatcher Dispatcher -\u003e Dispatcher: std::scoped_lock _l(mLock) note right 关键阻塞点 (Critical Block) InputDispatcher 持锁处理。 如果有 Input 事件积压，这里会卡住。 这是导致 Oneway Spamming 的主要原因。 end note Dispatcher -\u003e Dispatcher: setInputWindowsLocked(...) Dispatcher --\u003e Listener: void deactivate Dispatcher Listener --\u003e Reporter: void deactivate Listener else #AliceBlue Listener == AccessibilityWindowsPopulator (Java) Reporter -\u003e A11yPop: onWindowInfosChanged(windowHandles, ...) [JNI] activate A11yPop == 3.1 业务处理 (A11yPopulator) == A11yPop -\u003e A11yPop: mHandler.post(...) note right 异步非阻塞 (Async) 源码: mHandler.post(() -\u003e onWindowInfosChangedInternal) 立即返回，不占用 Binder 线程时间。 end note A11yPop --\u003e Reporter: void deactivate A11yPop A11yPop -[#blue]\u003e WMS_Thread: onWindowInfosChangedInternal(...) activate WMS_Thread note right 延迟处理: 繁重的矩阵计算(Matrix)和 遍历逻辑在此线程执行。 end note deactivate WMS_Thread end end Reporter --\u003e Stub: void deactivate Reporter Stub --\u003e IPC: void IPC -\u003e Kernel: ioctl(BC_FREE_BUFFER) note left: 只有执行到这里，\\n内核缓冲区才会被释放。 deactivate IPC @enduml ","wordCount":"638","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/>WindowManager</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>3 min&nbsp;·&nbsp;638 words</div></header><div class=post-content><h1 id=android-subsystem-wiki-windowinfos-update-flow>Android Subsystem Wiki: WindowInfos Update Flow<a hidden class=anchor aria-hidden=true href=#android-subsystem-wiki-windowinfos-update-flow>#</a></h1><h2 id=1-概述-overview>1. 概述 (Overview)<a hidden class=anchor aria-hidden=true href=#1-概述-overview>#</a></h2><p><strong>WindowInfos Update Flow</strong> 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。</p><p>主要消费者包括：</p><ul><li><strong>InputDispatcher (Native)</strong>: 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。</li><li><strong>AccessibilityWindowsPopulator (Java)</strong>: 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。</li></ul><p>该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 <code>DeadSystemException</code>、Binder 缓冲区耗尽）的高发区。</p><h2 id=2-核心架构与组件-architecture>2. 核心架构与组件 (Architecture)<a hidden class=anchor aria-hidden=true href=#2-核心架构与组件-architecture>#</a></h2><p>数据流向遵循 <strong>Producer-Consumer</strong> 模型，并通过 <strong>WindowInfosListenerReporter</strong> 实现多路复用。</p><h3 id=21-发送端-producer-surfaceflinger>2.1 发送端 (Producer: SurfaceFlinger)<a hidden class=anchor aria-hidden=true href=#21-发送端-producer-surfaceflinger>#</a></h3><ul><li><strong>触发源</strong>: 每一帧合成（Vsync）后，若检测到图层属性变化 (<code>mVisibleRegionsDirty</code> 或 <code>mInputInfoChanged</code>)，触发更新。</li><li><strong>异步发送</strong>: 通过 <code>BackgroundExecutor</code> 线程发送，避免阻塞主渲染线程。</li><li><strong>通信接口</strong>: <code>IWindowInfosListener.onWindowInfosChanged</code> (AIDL)，定义为 <code>oneway</code>（非阻塞），允许极高的发送频率。</li></ul><h3 id=22-中转与分发-transport--dispatch-systemserver>2.2 中转与分发 (Transport & Dispatch: SystemServer)<a hidden class=anchor aria-hidden=true href=#22-中转与分发-transport--dispatch-systemserver>#</a></h3><ul><li><strong>WindowInfosListenerReporter (Native)</strong>:</li><li><strong>角色</strong>: SystemServer 进程内的单例 Binder Stub (<code>BnWindowInfosListener</code>)。</li><li><strong>职责</strong>: 它是 SystemServer 与 SurfaceFlinger 之间<strong>唯一</strong>的 Binder 通道。负责接收跨进程数据，并<strong>同步</strong>分发给进程内注册的所有监听器。</li></ul><h3 id=23-接收端-consumers>2.3 接收端 (Consumers)<a hidden class=anchor aria-hidden=true href=#23-接收端-consumers>#</a></h3><ol><li><strong>InputDispatcher (Native)</strong>:</li></ol><ul><li><strong>行为</strong>: <strong>同步阻塞</strong>。在回调中必须获取全局锁 <code>mLock</code> 以更新窗口状态。这是性能瓶颈所在。</li></ul><ol start=2><li><strong>AccessibilityWindowsPopulator (Java)</strong>:</li></ol><ul><li><strong>行为</strong>: <strong>异步非阻塞</strong>。通过 JNI 接收回调后，立即通过 <code>Handler.post</code> 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。</li></ul><h2 id=3-详细时序流程-sequence-diagram>3. 详细时序流程 (Sequence Diagram)<a hidden class=anchor aria-hidden=true href=#3-详细时序流程-sequence-diagram>#</a></h2><p>下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
@startuml
!theme plain
autonumber &#34;&lt;b&gt;[0]&#34;

title SystemServer: Registration &amp; WindowInfos Update Flow (Complete)

box &#34;SurfaceFlinger Process&#34; #E3F2FD
    participant &#34;SurfaceFlinger&#34; as SF
end box

box &#34;Kernel Space&#34; #F5F5F5
    participant &#34;Binder Driver&#34; as Kernel
end box

box &#34;SystemServer Process (Native)&#34; #FFF3E0
    participant &#34;IPCThreadState&#34; as IPC
    participant &#34;BnWindowInfosListener\n(Stub)&#34; as Stub
    participant &#34;WindowInfosListenerReporter\n(Singleton)&#34; as Reporter
    participant &#34;SurfaceComposerClient&#34; as SCC
    participant &#34;InputDispatcher&#34; as Dispatcher
    participant &#34;DispatcherWindowListener&#34; as Listener
end box

box &#34;SystemServer Process (Java)&#34; #FFE0B2
    participant &#34;AccessibilityWindowsPopulator\n(A11yPop)&#34; as A11yPop
    participant &#34;WMS Handler Thread&#34; as WMS_Thread
    participant &#34;WindowManagerService&#34; as WMS
    participant &#34;AccessibilityWindowManager&#34; as AWM
    participant &#34;AccessibilityManagerService&#34; as AMS
end box

== 0.1 InputDispatcher 注册流程 (Native) ==

Dispatcher -&gt; Dispatcher: new DispatcherWindowListener(*this)
activate Dispatcher
note right: 创建本地监听器

Dispatcher -&gt; SCC: addWindowInfosListener(listener)
activate SCC
SCC -&gt; Reporter: getInstance()
SCC -&gt; Reporter: addWindowInfosListener(listener, ...)
activate Reporter

Reporter -&gt; Reporter: check mWindowInfosListeners.empty()

alt #LightGreen &lt;color:green&gt;&lt;b&gt;首次注册 (First Time)&lt;/b&gt;&lt;/color&gt;
    note right of Reporter
        集合为空，说明 Reporter 尚未连接 SF。
        将 Reporter (this) 注册到远程。
    end note
    Reporter -&gt; SF: IWindowInfosListener.addWindowInfosListener(this)
    activate SF
    SF -&gt; SF: 保存 Reporter 句柄
    SF --&gt; Reporter: status
    deactivate SF
else &lt;color:gray&gt;后续注册 (Re-use)&lt;/color&gt;
    note right of Reporter
        集合不为空，通道已建立。
        直接复用，不发起 Binder 调用。
    end note
end

Reporter -&gt; Reporter: mWindowInfosListeners.insert(listener)
note right: 将 InputDispatcher 加入本地集合

Reporter --&gt; SCC: status
deactivate Reporter
SCC --&gt; Dispatcher: status
deactivate SCC
deactivate Dispatcher

== 0.2 Accessibility 注册流程 (Java Stack) ==

note right of AMS
  &lt;b&gt;触发时机:&lt;/b&gt;
  1. 系统启动完毕
  2. 开启无障碍服务 (TalkBack等)
  3. 显示器插拔 (onDisplayAdded)
end note

AMS -&gt; AWM: startTrackingWindows()
activate AMS
AWM -&gt; WMS: setWindowsForAccessibilityCallback()
activate AWM
WMS -&gt; A11yPop: setWindowsNotification(true)
activate WMS
activate A11yPop

A11yPop -&gt; A11yPop: register()
A11yPop -&gt; SCC: nativeRegister() [JNI]
activate SCC

SCC -&gt; Reporter: addWindowInfosListener(listener)
activate Reporter
note right of Reporter
  检测到 InputDispatcher 已注册，
  这里直接复用现有通道，
  将 A11yPop 加入本地集合。
end note
Reporter -&gt; Reporter: mWindowInfosListeners.insert(A11yPop)

Reporter --&gt; SCC: status
deactivate Reporter
SCC --&gt; A11yPop: status
deactivate SCC
A11yPop --&gt; WMS: void
deactivate A11yPop
WMS --&gt; AWM: void
deactivate WMS
AWM --&gt; AMS: void
deactivate AWM
deactivate AMS

|||

== 1. 跨进程接收 (Binder Thread) ==

SF -&gt; Kernel: onWindowInfosChanged(data) (Oneway)
note left: SF 生产 46KB 数据\n疯狂发送

Kernel -&gt; IPC: ioctl(BR_TRANSACTION)
activate IPC
note left: Binder 线程被唤醒

IPC -&gt; Stub: onTransact(...)
activate Stub
note right: &lt;color:red&gt;&lt;b&gt;反序列化 (Unmarshalling)&lt;/b&gt;&lt;/color&gt;\n解析 Parcel -&gt; vector&lt;WindowInfo&gt;

Stub -&gt; Reporter: onWindowInfosChanged(windowInfos, ...)
deactivate Stub
activate Reporter

== 2. 进程内分发 (Reporter Loop) ==

note right of Reporter
    &lt;color:red&gt;&lt;b&gt;同步循环 (Synchronous Loop)&lt;/b&gt;&lt;/color&gt;
    运行在 Binder 线程中。
    必须等所有 Listener 处理完才能返回。
end note

loop foreach listener in mWindowInfosListeners

    alt #MistyRose Listener == InputDispatcher (Native)
        Reporter -&gt; Listener: onWindowInfosChanged(windowInfos)
        activate Listener
        
        == 3. 业务处理 (InputDispatcher) ==
        
        Listener -&gt; Dispatcher: setInputWindows(windowInfos)
        activate Dispatcher
        
        Dispatcher -&gt; Dispatcher: &lt;color:red&gt;std::scoped_lock _l(mLock)&lt;/color&gt;
        note right
            &lt;color:red&gt;&lt;b&gt;关键阻塞点 (Critical Block)&lt;/b&gt;&lt;/color&gt;
            InputDispatcher 持锁处理。
            如果有 Input 事件积压，这里会卡住。
            &lt;b&gt;这是导致 Oneway Spamming 的主要原因。&lt;/b&gt;
        end note
        
        Dispatcher -&gt; Dispatcher: setInputWindowsLocked(...)
        
        Dispatcher --&gt; Listener: void
        deactivate Dispatcher
        
        Listener --&gt; Reporter: void
        deactivate Listener

    else #AliceBlue Listener == AccessibilityWindowsPopulator (Java)
        Reporter -&gt; A11yPop: onWindowInfosChanged(windowHandles, ...) [JNI]
        activate A11yPop
        
        == 3.1 业务处理 (A11yPopulator) ==
        
        A11yPop -&gt; A11yPop: mHandler.post(...)
        note right
            &lt;color:green&gt;&lt;b&gt;异步非阻塞 (Async)&lt;/b&gt;&lt;/color&gt;
            源码: mHandler.post(() -&gt; onWindowInfosChangedInternal)
            立即返回，不占用 Binder 线程时间。
        end note
        
        A11yPop --&gt; Reporter: void
        deactivate A11yPop
        
        A11yPop -[#blue]&gt; WMS_Thread: onWindowInfosChangedInternal(...)
        activate WMS_Thread
        note right
           &lt;b&gt;延迟处理:&lt;/b&gt;
           繁重的矩阵计算(Matrix)和
           遍历逻辑在此线程执行。
        end note
        deactivate WMS_Thread
    end
end

Reporter --&gt; Stub: void
deactivate Reporter

Stub --&gt; IPC: void
IPC -&gt; Kernel: ioctl(BC_FREE_BUFFER)
note left: 只有执行到这里，\n内核缓冲区才会被释放。
deactivate IPC

@enduml
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/visualquerydetector/visualquerydetector/><span class=title>« Prev</span><br><span></span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/wmshell/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>