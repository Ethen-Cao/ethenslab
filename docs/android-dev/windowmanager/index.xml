<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>WindowManager on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/</link><description>Recent content in WindowManager on Ethen 的实验室</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Mon, 29 Sep 2025 10:22:54 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/index.xml" rel="self" type="application/rss+xml"/><item><title> Android InputChannel 原理与生命周期详解</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputchannel/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputchannel/</guid><description>&lt;h2 id="1-什么是-inputchannel"&gt;1. 什么是 InputChannel？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;InputChannel&lt;/strong&gt; 是 Android 输入系统（Input System）中用于跨进程传输输入事件（如触摸、按键）的核心通信机制。&lt;/p&gt;
&lt;p&gt;简单来说，它是连接 &lt;strong&gt;SystemServer (InputDispatcher)&lt;/strong&gt; 和 &lt;strong&gt;应用程序 (App Window)&lt;/strong&gt; 之间的一条&lt;strong&gt;全双工管道&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="核心特性"&gt;核心特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于 Socket Pair&lt;/strong&gt;：底层通过 Linux 的 &lt;code&gt;socketpair&lt;/code&gt; (AF_UNIX, SOCK_SEQPACKET) 实现。这意味着它不仅仅是单向通知，还支持双向通信（事件发送 -&amp;gt; 处理完成 ACK）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨进程传输&lt;/strong&gt;：通过 Binder 将 Client 端的文件描述符（FD）传递给应用进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无锁/高性能&lt;/strong&gt;：利用 Socket 缓冲区传输数据，结合 &lt;code&gt;epoll&lt;/code&gt; 机制，不需要复杂的 Binder 调用即可完成高频的 MotionEvent 传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-inputchannel-的架构模型"&gt;2. InputChannel 的架构模型&lt;/h2&gt;
&lt;p&gt;每个能够接收触摸事件的窗口（Window），在 SystemServer 端都对应一个 &lt;code&gt;Connection&lt;/code&gt; 对象，该对象持有一个 Server 端的 &lt;code&gt;InputChannel&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Server 端 (InputDispatcher)&lt;/strong&gt;: 持有 Socket 的一端（写端），负责写入 InputEvent。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Client 端 (App Window)&lt;/strong&gt;: 持有 Socket 的另一端（读端），负责读取 InputEvent，并回复 Finished 信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-生命周期创建-creation"&gt;3. 生命周期：创建 (Creation)&lt;/h2&gt;
&lt;p&gt;InputChannel 的创建伴随着窗口（Window）的添加过程。&lt;/p&gt;</description></item><item><title> Android InputMethod 交互流程技术说明文档</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethodservice/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethodservice/</guid><description>&lt;h3 id="1-流程详细解析"&gt;1. 流程详细解析&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme plain
autonumber
skinparam backgroundColor white
skinparam boxPadding 10
skinparam noteBackgroundColor #FFFFA0
skinparam noteBorderColor #808080
skinparam participantBackgroundColor white
actor &amp;#34;User&amp;#34; as User
box &amp;#34;新应用进程 (New App - 抢焦者)&amp;#34; #Honeydew
participant &amp;#34;ViewRootImpl&amp;#34; as VRI
participant &amp;#34;ImeFocusController&amp;#34; as Controller
participant &amp;#34;InputMethodManager\n(IMM)&amp;#34; as IMM
participant &amp;#34;IInputMethodClient\n(Stub)&amp;#34; as ClientStub
participant &amp;#34;View (EditText)&amp;#34; as EditText
participant &amp;#34;InputConnection\n(Binder Stub)&amp;#34; as IC_Stub
end box
box &amp;#34;系统服务 (System Server)&amp;#34; #LightBlue
participant &amp;#34;WindowManagerService\n(WMS)&amp;#34; as WMS
participant &amp;#34;InputMethodManagerService\n(IMMS)&amp;#34; as IMMS
end box
box &amp;#34;输入法进程 (IME Process)&amp;#34; #MistyRose
participant &amp;#34;InputMethodService\n(IME)&amp;#34; as IME
participant &amp;#34;IInputContext\n(Binder Proxy)&amp;#34; as IC_Proxy
end box
box &amp;#34;旧应用进程 (Old App - 受害者)&amp;#34; #LightGrey
participant &amp;#34;IInputMethodClient\n(Stub)&amp;#34; as Old_Stub
participant &amp;#34;InputMethodManager\n(IMM)&amp;#34; as Old_IMM
end box
== 第一阶段：连接建立与切换 (Switch Client) ==
note right of WMS: App 启动，窗口添加完成
WMS -&amp;gt; VRI: **windowFocusChanged**(true)
activate VRI
VRI -&amp;gt; VRI: handleWindowFocusChanged()
VRI -&amp;gt; Controller: **onPostWindowFocus**()
activate Controller
Controller -&amp;gt; Controller: check **mayUseInputMethod**
Controller -&amp;gt; IMM: **onPostWindowGainedFocus**()
activate IMM
IMM -&amp;gt; IMM: **startInputInner**()
group 关键：创建通信对象
IMM -&amp;gt; EditText: **onCreateInputConnection**()
activate EditText
EditText --&amp;gt; IMM: return **InputConnection**
deactivate EditText
end
IMM -&amp;gt; IMMS: **startInputOrWindowGainedFocus**(client=Stub, inputContext=IC_Stub)
activate IMMS
note right of IMMS
**服务端逻辑 (Switch Client)：**
1. 发现请求者(New) != 当前记录(Old)
2. **必须先清理旧状态**
3. 再绑定新应用
end note
group [新增] 通知旧应用断开连接 (Unbind Sequence)
IMMS -&amp;gt; Old_Stub: **onUnbindMethod**(sequence, UNBIND_REASON_SWITCH_CLIENT)
activate Old_Stub
note right of Old_Stub
**反向控制生效：**
系统通知旧应用下线
end note
Old_Stub -&amp;gt; Old_IMM: sendMessage(MSG_UNBIND)
activate Old_IMM
Old_IMM -&amp;gt; Old_IMM: **closeCurrentInput()**
note right of Old_IMM
1. 销毁 InputChannel
2. 断开 InputConnection
3. 停止光标闪烁
end note
deactivate Old_IMM
deactivate Old_Stub
end
IMMS -&amp;gt; IME: **startInput**(inputContext=IC_Proxy)
activate IME
IME -&amp;gt; IME: 保存 IC_Proxy (持有 New App 的操作句柄)
deactivate IME
IMMS -&amp;gt; ClientStub: **onBindMethod**(res)
activate ClientStub
note right of ClientStub
**反向链路生效：**
系统回传 InputChannel (Socket)
end note
ClientStub -&amp;gt; IMM: sendMessage(MSG_BIND)
deactivate ClientStub
IMMS --&amp;gt; IMM: Success
deactivate IMMS
IMM -&amp;gt; IMM: **handleMessage(MSG_BIND)**
note left of IMM
连接建立完成
New App 持有 IME Channel
IME 持有 New App InputConnection
end note
deactivate IMM
deactivate Controller
deactivate VRI
== 第二阶段：显示控制 (Touch -&amp;gt; Show) ==
User -&amp;gt; EditText: 点击输入框
activate EditText
EditText -&amp;gt; IMM: **showSoftInput**(view)
activate IMM
IMM -&amp;gt; IMMS: **showSoftInput**(client)
activate IMMS
IMMS -&amp;gt; IME: **showSoftInput**()
activate IME
IME -&amp;gt; IME: **showWindow**(true)
note right of IME
软键盘 UI 此时对用户可见
end note
deactivate IME
deactivate IMMS
deactivate IMM
deactivate EditText
== 第三阶段：文本分发 (Typing -&amp;gt; Commit) ==
User -&amp;gt; IME: 点击虚拟键盘 &amp;#34;A&amp;#34;
activate IME
IME -&amp;gt; IME: onCodeInput(&amp;#34;A&amp;#34;)
note right of IME
**核心交互：**
IME 使用之前保存的 Proxy
直接操作 App 内部状态
end note
IME -&amp;gt; IC_Proxy: **commitText**(&amp;#34;A&amp;#34;, 1)
activate IC_Proxy
IC_Proxy -&amp;gt; IC_Stub: **IPC: Transmit Text**
deactivate IC_Proxy
activate IC_Stub
note left of IC_Stub
**App 进程响应：**
Binder 线程收到数据
修改 Editable Buffer
end note
IC_Stub -&amp;gt; EditText: **Editable.replace**(...)
EditText -&amp;gt; VRI: invalidate() -&amp;gt; onDraw()
deactivate IC_Stub
VRI -&amp;gt; User: 屏幕显示字符 &amp;#34;A&amp;#34;
deactivate IME
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本节对应时序图中的三个核心阶段，描述代码层面的执行逻辑。&lt;/p&gt;</description></item><item><title> Android 窗口焦点抢占与输入法连接断开技术时序分析</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/</guid><description>&lt;h3 id="1-概述"&gt;1. 概述&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
!theme plain
autonumber
skinparam backgroundColor white
skinparam participantBackgroundColor white
skinparam boxPadding 10
skinparam noteBackgroundColor #FFFFA0
skinparam noteBorderColor #808080
actor &amp;#34;User&amp;#34; as User
box &amp;#34;应用进程 A (Overlay - 当前焦点持有者)&amp;#34; #MistyRose
participant &amp;#34;ViewRootImpl&amp;#34; as Overlay_VRI
participant &amp;#34;ImeFocusController&amp;#34; as Overlay_Ctrl
participant &amp;#34;InputMethodManager\n(IMM)&amp;#34; as Overlay_IMM
end box
box &amp;#34;系统服务 (System Server)&amp;#34; #LightBlue
participant &amp;#34;InputDispatcher&amp;#34; as InputDispatcher
participant &amp;#34;WindowManagerService\n(WMS)&amp;#34; as WMS
participant &amp;#34;DisplayContent\n(DC)&amp;#34; as DC
participant &amp;#34;InputMethodManagerService\n(IMMS)&amp;#34; as IMMS
end box
box &amp;#34;应用进程 B (Browser - 触摸事件接收者)&amp;#34; #Honeydew
participant &amp;#34;ViewRootImpl&amp;#34; as Browser_VRI
participant &amp;#34;Browser\nActivity&amp;#34; as Browser
participant &amp;#34;InputMethodManager\n(IMM)&amp;#34; as Browser_IMM
end box
== 第一阶段：Overlay 窗口添加与焦点计算 ==
Overlay_VRI -&amp;gt; WMS: &amp;lt;color:red&amp;gt;**addWindow**(TYPE_APPLICATION_OVERLAY)Flags 中**未包含** FLAG_NOT_FOCUSABLE
activate WMS
WMS -&amp;gt; WMS: **addWindowInner**() -&amp;gt; **updateFocusedWindowLocked**()
group WMS 焦点更新逻辑
WMS -&amp;gt; DC: **findFocusedWindowIfNeeded**()
activate DC
DC -&amp;gt; DC: 遍历窗口列表 (Z-Order Top-Down)
DC -&amp;gt; DC: 检查 Overlay WindowState
DC -&amp;gt; DC: **mayUseInputMethod**(flags)
note right of DC
**判定逻辑：**
return (flags &amp;amp; FLAG_NOT_FOCUSABLE) == 0;
**结果：TRUE**
(系统判定该窗口具备处理 IME 输入的能力)
end note
DC --&amp;gt; WMS: 返回 **newFocus = Overlay**
deactivate DC
end
WMS -&amp;gt; WMS: **mCurrentFocus = Overlay**
par 并发通知焦点变更
WMS -&amp;gt; Overlay_VRI: **windowFocusChanged**(hasWindowFocus=true)
WMS -&amp;gt; Browser_VRI: **windowFocusChanged**(hasWindowFocus=false)
end
deactivate WMS
== 第二阶段：Overlay 建立输入法连接 ==
activate Overlay_VRI
note right of Overlay_VRI
触发条件：
1. 收到 windowFocusChanged 回调
2. 或执行 performTraversals 布局遍历
end note
Overlay_VRI -&amp;gt; Overlay_Ctrl: **onPostWindowFocus**() / **onTraversal**()
activate Overlay_Ctrl
Overlay_Ctrl -&amp;gt; Overlay_Ctrl: check **mayUseInputMethod**() == true
Overlay_Ctrl -&amp;gt; Overlay_IMM: **onPostWindowGainedFocus**()
activate Overlay_IMM
note right of Overlay_IMM
**IPC 请求：**
请求建立输入连接
end note
Overlay_IMM -&amp;gt; IMMS: **startInputOrWindowGainedFocus**(\n reason=WINDOW_FOCUS_GAIN,\n client=Overlay,\n windowToken=OverlayToken)
activate IMMS
== 第三阶段：IMMS 执行客户端切换与解绑 ==
group IMMS 服务端处理
IMMS -&amp;gt; IMMS: **startInputOrWindowGainedFocusInternalLocked**()
IMMS -&amp;gt; IMMS: check **mCurClient (Browser) != newClient (Overlay)**
IMMS -&amp;gt; IMMS: **prepareClientSwitchLocked**()
IMMS -&amp;gt; IMMS: **unbindCurrentClientLocked**(SWITCH_CLIENT)
activate IMMS #FFBBBB
note right of IMMS
**状态清理：**
1. userData.mCurClient.mClient.setActive(false)
-&amp;gt; 通知 Browser 停止输入活动
2. finishSessionLocked(session)
-&amp;gt; 销毁 Browser 的 InputChannel
3. **mCurClient = null**
end note
deactivate IMMS
IMMS -&amp;gt; IMMS: **mCurClient = Overlay**
note right of IMMS
**当前状态：**
IMMS 服务端记录的 Client 已变更为 Overlay
end note
end
IMMS --&amp;gt; Overlay_IMM: return InputBindResult (SUCCESS)
deactivate IMMS
deactivate Overlay_IMM
deactivate Overlay_Ctrl
deactivate Overlay_VRI
== 第四阶段：触摸事件派发 (Touch Dispatch) ==
User -&amp;gt; InputDispatcher: 点击屏幕 (Touch Down)
activate InputDispatcher
note right of InputDispatcher
**事件派发逻辑：**
虽然 Overlay Z-Order 最高，但设置了
FLAG_NOT_TOUCH_MODAL (或点击区域在 Overlay 范围外)
事件向下穿透
end note
InputDispatcher -&amp;gt; Browser_VRI: **InputEvent (ACTION_DOWN)**
deactivate InputDispatcher
activate Browser_VRI
Browser_VRI -&amp;gt; Browser: **dispatchTouchEvent**()
Browser -&amp;gt; Browser: View.onTouchEvent() -&amp;gt; performClick()
note right of Browser
Browser 能够接收点击事件
但此时 Window 焦点已丢失 (HasFocus=false)
end note
== 第五阶段：请求输入法失败 ==
Browser -&amp;gt; Browser_IMM: **showSoftInput**(view)
activate Browser_IMM
group IMM 客户端自检
Browser_IMM -&amp;gt; Browser_IMM: **checkFocus**()
Browser_IMM -&amp;gt; Browser_IMM: **hasServedByInputMethodLocked**()
note left
**失败点 A (客户端拦截)：**
由于之前收到 windowFocusChanged(false)
ViewRootImpl 判定当前窗口无焦点
mServedView 可能为 null 或不匹配
**Result: return false** (Log: &amp;#34;Ignoring... is not served&amp;#34;)
end note
end
alt 假设绕过客户端检查 (强制请求服务端)
Browser_IMM -&amp;gt; IMMS: **showSoftInput**(client=Browser)
activate IMMS
IMMS -&amp;gt; IMMS: check **mCurClient (Overlay) == client (Browser)**
note left of IMMS #FFAAAA
**失败点 B (服务端拒绝)：**
Validation Failed.
请求者 Browser 与当前记录的 mCurClient (Overlay) 不一致。
end note
IMMS --&amp;gt;&amp;gt; Browser_IMM: return false
deactivate IMMS
end
Browser_IMM --&amp;gt;&amp;gt; Browser: return false
deactivate Browser_IMM
deactivate Browser_VRI
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本时序图展示了一个配置为 &lt;code&gt;TYPE_APPLICATION_OVERLAY&lt;/code&gt; 但缺失 &lt;code&gt;FLAG_NOT_FOCUSABLE&lt;/code&gt; 属性的悬浮窗口（Overlay），如何在系统层（WMS）和输入法服务层（IMMS）通过标准生命周期回调，强制剥夺底层应用（Browser）的输入法连接权（Input Connection），导致底层应用虽然能响应点击但无法弹出软键盘的异常流程。&lt;/p&gt;</description></item><item><title>Activity 跨屏幕迁移</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/activity-reparent/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/activity-reparent/</guid><description>&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/activity-reparent.png" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="分步说明与生命周期映射"&gt;分步说明（与生命周期映射）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Launcher 发起&lt;/strong&gt;：用户点击 → Launcher 构造 &lt;code&gt;Intent&lt;/code&gt;（带 &lt;code&gt;launchDisplayId=2&lt;/code&gt;）并调用 &lt;code&gt;startActivity()&lt;/code&gt; 到 ATMS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ATMS 决策&lt;/strong&gt;：ATMS 在 system_server 内部查看 &lt;code&gt;ActivityRecord/TaskRecord&lt;/code&gt;，决定把某个 Task 从 Display1 移到 Display2（修改 parent：&lt;code&gt;TaskDisplayArea&lt;/code&gt;）。这一步只是服务端的数据结构变化，不会直接调用应用对象的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协调 WMS&lt;/strong&gt;：ATMS 通知 WMS 准备窗口切换（应用 transition），以便在 surface 层面上能做平滑迁移。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;暂停目标 Display 上的当前前台&lt;/strong&gt;（ActivityB）：为了保证目标 Display 上只会有一个 resumed Activity，ATMS 先对 Display2 上当前的前台 Activity（ActivityB）发 &lt;code&gt;IApplicationThread.schedulePauseActivity&lt;/code&gt;，等待应用进程回 ACK（pauseFinished）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;暂停将要被移动的 ActivityA（源 Display1）&lt;/strong&gt;：ATMS 对 ActivityA 发 &lt;code&gt;schedulePauseActivity&lt;/code&gt;，应用进程进入 &lt;code&gt;onPause()&lt;/code&gt;，并回 ACK。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这一步非常重要：把要移动的 Activity 保持在非-resumed 状态，便于改变它的窗口所属 Display/Surface。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;WMS 做 Window/Surface reparent&lt;/strong&gt;：ATMS 请求 WMS 将对应的 &lt;code&gt;WindowContainer&lt;/code&gt;/task 窗口树从 Display1 移到 Display2；WMS 在 SurfaceControl 层（通过 SurfaceFlinger）把 layer 重新 attach 到目标 Display 的 layer stack。&lt;/p&gt;</description></item><item><title>Insets animation flow</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/</guid><description>&lt;p&gt;Insets 动画 API 的核心价值在于&lt;strong&gt;消除系统 UI 动画和应用 UI 动画之间的“割裂感”&lt;/strong&gt;，将两者融合成一个平滑、无缝的整体。&lt;/p&gt;
&lt;p&gt;以下是一些典型的应用场景，从最常见到更高级的交互：&lt;/p&gt;
&lt;h3 id="1-核心场景键盘的显示与隐藏-messaging--input"&gt;1. 核心场景：键盘的显示与隐藏 (Messaging &amp;amp; Input)&lt;/h3&gt;
&lt;p&gt;这是最经典、最能体现其价值的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传统体验 (问题所在):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个聊天应用里，你点击底部的输入框。&lt;/li&gt;
&lt;li&gt;键盘从底部滑出，这个动画是系统负责的。&lt;/li&gt;
&lt;li&gt;在键盘动画的同时，应用收到一个“可用空间变小了”的通知。&lt;/li&gt;
&lt;li&gt;应用为了防止输入框被键盘遮挡，只能&lt;strong&gt;跳变式地&lt;/strong&gt;将整个聊天列表和输入框向上移动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 Insets 动画 (解决方案):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击输入框。&lt;/li&gt;
&lt;li&gt;应用接管键盘的动画控制权。&lt;/li&gt;
&lt;li&gt;在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并&lt;strong&gt;同步地、等速地&lt;/strong&gt;将自己的聊天列表和输入框也向上推。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 在用户看来，整个过程是一个连贯的动画：&lt;strong&gt;仿佛是键盘“推”着聊天内容向上移动&lt;/strong&gt;，非常自然、流畅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;场景&lt;/th&gt;
&lt;th style="text-align: left"&gt;传统方式的问题&lt;/th&gt;
&lt;th style="text-align: left"&gt;Insets 动画的效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;聊天应用&lt;/td&gt;
&lt;td style="text-align: left"&gt;键盘动画与内容移动分离，内容&lt;strong&gt;跳变&lt;/strong&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;键盘&lt;strong&gt;平滑推起&lt;/strong&gt;内容，动画无缝衔接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="2-沉浸式模式的过渡-video--photo-apps"&gt;2. 沉浸式模式的过渡 (Video &amp;amp; Photo Apps)&lt;/h3&gt;
&lt;p&gt;当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传统体验 (问题所在):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。&lt;/li&gt;
&lt;li&gt;系统状态栏和导航栏&lt;strong&gt;突然出现&lt;/strong&gt;或&lt;strong&gt;淡入&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;应用内容区域（图片）为了适应变小的空间，&lt;strong&gt;突然缩放或移动&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 Insets 动画 (解决方案):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击屏幕。&lt;/li&gt;
&lt;li&gt;应用接管状态栏和导航栏的动画。&lt;/li&gt;
&lt;li&gt;当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都&lt;strong&gt;同步地、平滑地&lt;/strong&gt;将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 整个过渡非常优雅，感觉像是&lt;strong&gt;画面和系统栏一起构成了一场精心编排的转场动画&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-高级交互场景手势控制动画"&gt;3. 高级交互场景：手势控制动画&lt;/h3&gt;
&lt;p&gt;这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。&lt;/p&gt;</description></item><item><title>SplitScreenController flow</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/splitscreen-wmshell/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/splitscreen-wmshell/</guid><description>&lt;h2 id="时序图"&gt;时序图&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/splitscreen_wmshell.png" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="debug"&gt;Debug&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打印分屏区域&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;adb shell dumpsys activity service SystemUIService WMShell
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dump SystemUI&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ adb shell dumpsys activity service SystemUIService
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enable protolog&lt;/p&gt;
&lt;p&gt;参考 &lt;code&gt;frameworks/base/libs/WindowManager/Shell/src/com/android/wm/shell/ProtoLogController.java&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;help命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ adb shell dumpsys activity service SystemUIService WMShell help
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看protolog status：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; $ adb shell dumpsys activity service SystemUIService WMShell protolog status
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; SERVICE com.android.systemui/.SystemUIService e73cb38 pid&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;4871&lt;/span&gt; user&lt;span style="color:#f92672"&gt;=&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Client:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; com.android.systemui.wmshell.WMShell:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ----------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; ProtoLog status: Disabled
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Enabled log groups:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Proto: TEST_GROUP WM_DEBUG_ADD_REMOVE WM_DEBUG_ANIM WM_DEBUG_APP_TRANSITIONS WM_DEBUG_APP_TRANSITIONS_ANIM WM_DEBUG_BACK_PREVIEW WM_DEBUG_BOOT WM_DEBUG_CONFIGURATION WM_DEBUG_CONTAINERS WM_DEBUG_CONTENT_RECORDING WM_DEBUG_DRAW WM_DEBUG_DREAM WM_DEBUG_FOCUS WM_DEBUG_FOCUS_LIGHT WM_DEBUG_IME WM_DEBUG_IMMERSIVE WM_DEBUG_KEEP_SCREEN_ON WM_DEBUG_LOCKTASK WM_DEBUG_ORIENTATION WM_DEBUG_RECENTS_ANIMATIONS WM_DEBUG_REMOTE_ANIMATIONS WM_DEBUG_RESIZE WM_DEBUG_SCREEN_ON WM_DEBUG_STARTING_WINDOW WM_DEBUG_STATES WM_DEBUG_SWITCH WM_DEBUG_SYNC_ENGINE WM_DEBUG_TASKS WM_DEBUG_WALLPAPER WM_DEBUG_WINDOW_INSETS WM_DEBUG_WINDOW_MOVEMENT WM_DEBUG_WINDOW_ORGANIZER WM_DEBUG_WINDOW_TRANSITIONS WM_DEBUG_WINDOW_TRANSITIONS_MIN WM_ERROR WM_SHELL_BACK_PREVIEW WM_SHELL_DESKTOP_MODE WM_SHELL_DRAG_AND_DROP WM_SHELL_FLOATING_APPS WM_SHELL_FOLDABLE WM_SHELL_INIT WM_SHELL_PICTURE_IN_PICTURE WM_SHELL_RECENTS_TRANSITION WM_SHELL_RECENT_TASKS WM_SHELL_SPLIT_SCREEN WM_SHELL_STARTING_WINDOW WM_SHELL_SYSUI_EVENTS WM_SHELL_TASK_ORG WM_SHELL_TRANSITIONS WM_SHOW_SURFACE_ALLOC WM_SHOW_TRANSACTIONS
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Logcat: WM_DEBUG_BACK_PREVIEW WM_DEBUG_CONTENT_RECORDING WM_DEBUG_DREAM WM_DEBUG_WINDOW_TRANSITIONS_MIN WM_ERROR WM_SHELL_BACK_PREVIEW WM_SHELL_DRAG_AND_DROP WM_SHELL_INIT WM_SHELL_PICTURE_IN_PICTURE WM_SHELL_RECENTS_TRANSITION WM_SHELL_SPLIT_SCREEN WM_SHELL_TRANSITIONS
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Logging definitions loaded: &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Dump took 2ms
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;enable protolog：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ adb shell dumpsys activity service SystemUIService WMShell protolog enable WM_SHELL_TRANSITIONS WM_SHELL_DRAG_AND_DROP WM_SHELL_SPLIT_SCREEN
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;$ adb shell dumpsys activity service SystemUIService WMShell protolog start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>WindowInfos Update Flow</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/</link><pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowinfo-update-flow/</guid><description>&lt;h2 id="1-概述-overview"&gt;1. 概述 (Overview)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;WindowInfos Update Flow&lt;/strong&gt; 是 Android 图形与输入系统协同工作的核心机制。它负责将 SurfaceFlinger (SF) 合成过程中产生的最新窗口属性（WindowInfo，如几何位置、Z-Order、透明度、触摸区域、焦点及其变换矩阵）实时同步给 SystemServer 进程。&lt;/p&gt;
&lt;p&gt;主要消费者包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InputDispatcher (Native)&lt;/strong&gt;: 负责根据窗口信息计算触摸事件的目标窗口（Hit Testing）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AccessibilityWindowsPopulator (Java)&lt;/strong&gt;: 负责为无障碍服务（A11y）构建屏幕内容的窗口节点树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该机制的高效性直接决定了触摸响应的延迟和窗口焦点的准确性。由于涉及高频跨进程通信（IPC）和大数据量传输，它是系统稳定性问题（如 &lt;code&gt;DeadSystemException&lt;/code&gt;、Binder 缓冲区耗尽）的高发区。&lt;/p&gt;
&lt;h2 id="2-核心架构与组件-architecture"&gt;2. 核心架构与组件 (Architecture)&lt;/h2&gt;
&lt;p&gt;数据流向遵循 &lt;strong&gt;Producer-Consumer&lt;/strong&gt; 模型，并通过 &lt;strong&gt;WindowInfosListenerReporter&lt;/strong&gt; 实现多路复用。&lt;/p&gt;
&lt;h3 id="21-发送端-producer-surfaceflinger"&gt;2.1 发送端 (Producer: SurfaceFlinger)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;触发源&lt;/strong&gt;: 每一帧合成（Vsync）后，若检测到图层属性变化 (&lt;code&gt;mVisibleRegionsDirty&lt;/code&gt; 或 &lt;code&gt;mInputInfoChanged&lt;/code&gt;)，触发更新。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步发送&lt;/strong&gt;: 通过 &lt;code&gt;BackgroundExecutor&lt;/code&gt; 线程发送，避免阻塞主渲染线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信接口&lt;/strong&gt;: &lt;code&gt;IWindowInfosListener.onWindowInfosChanged&lt;/code&gt; (AIDL)，定义为 &lt;code&gt;oneway&lt;/code&gt;（非阻塞），允许极高的发送频率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="22-中转与分发-transport--dispatch-systemserver"&gt;2.2 中转与分发 (Transport &amp;amp; Dispatch: SystemServer)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WindowInfosListenerReporter (Native)&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;角色&lt;/strong&gt;: SystemServer 进程内的单例 Binder Stub (&lt;code&gt;BnWindowInfosListener&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;职责&lt;/strong&gt;: 它是 SystemServer 与 SurfaceFlinger 之间&lt;strong&gt;唯一&lt;/strong&gt;的 Binder 通道。负责接收跨进程数据，并&lt;strong&gt;同步&lt;/strong&gt;分发给进程内注册的所有监听器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="23-接收端-consumers"&gt;2.3 接收端 (Consumers)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;InputDispatcher (Native)&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行为&lt;/strong&gt;: &lt;strong&gt;同步阻塞&lt;/strong&gt;。在回调中必须获取全局锁 &lt;code&gt;mLock&lt;/code&gt; 以更新窗口状态。这是性能瓶颈所在。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;AccessibilityWindowsPopulator (Java)&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行为&lt;/strong&gt;: &lt;strong&gt;异步非阻塞&lt;/strong&gt;。通过 JNI 接收回调后，立即通过 &lt;code&gt;Handler.post&lt;/code&gt; 将繁重逻辑转移至 WMS 线程，不占用 Binder 线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-详细时序流程-sequence-diagram"&gt;3. 详细时序流程 (Sequence Diagram)&lt;/h2&gt;
&lt;p&gt;下图展示了从 InputDispatcher 注册监听，到 SurfaceFlinger 分发数据，再到不同消费者处理数据的完整时序。&lt;/p&gt;</description></item><item><title>WindowManagerService 解析</title><link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</link><pubDate>Tue, 29 Jul 2025 10:22:54 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</guid><description>&lt;h2 id="windowmanagerservice-概述"&gt;WindowManagerService 概述&lt;/h2&gt;
&lt;p&gt;WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。&lt;/p&gt;
&lt;p&gt;作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。&lt;/p&gt;
&lt;p&gt;WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;窗口的创建与管理 (Creation &amp;amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布局与计算 (Layout &amp;amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层级与Z序 (Layer &amp;amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绘制与合成 (Drawing &amp;amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="窗口的创建与管理"&gt;窗口的创建与管理&lt;/h2&gt;
&lt;p&gt;窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/windowstate-creation.png" alt="WindowState 创建时序示意图" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。&lt;/li&gt;
&lt;li&gt;ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。&lt;/li&gt;
&lt;li&gt;Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：
&lt;ul&gt;
&lt;li&gt;Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。
&lt;img src="https://ethen-cao.github.io/ethenslab/images/windowtoken-creation-transport.png" alt="WindowToken创建与使用示意图" /&gt;&lt;/li&gt;
&lt;li&gt;WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WMS 的响应动作&lt;/strong&gt;：&lt;/p&gt;</description></item></channel></rss>