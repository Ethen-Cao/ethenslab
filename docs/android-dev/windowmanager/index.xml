<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WindowManager on Ethen 的实验室</title>
    <link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/</link>
    <description>Recent content in WindowManager on Ethen 的实验室</description>
    <generator>Hugo -- 0.150.1</generator>
    <language>en</language>
    <lastBuildDate>Mon, 29 Sep 2025 10:22:54 +0800</lastBuildDate>
    <atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Insets animation flow</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/</link>
      <pubDate>Mon, 29 Sep 2025 10:22:54 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/</guid>
      <description>&lt;p&gt;Insets 动画 API 的核心价值在于&lt;strong&gt;消除系统 UI 动画和应用 UI 动画之间的“割裂感”&lt;/strong&gt;，将两者融合成一个平滑、无缝的整体。&lt;/p&gt;
&lt;p&gt;以下是一些典型的应用场景，从最常见到更高级的交互：&lt;/p&gt;
&lt;h3 id=&#34;1-核心场景键盘的显示与隐藏-messaging--input&#34;&gt;1. 核心场景：键盘的显示与隐藏 (Messaging &amp;amp; Input)&lt;/h3&gt;
&lt;p&gt;这是最经典、最能体现其价值的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传统体验 (问题所在):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个聊天应用里，你点击底部的输入框。&lt;/li&gt;
&lt;li&gt;键盘从底部滑出，这个动画是系统负责的。&lt;/li&gt;
&lt;li&gt;在键盘动画的同时，应用收到一个“可用空间变小了”的通知。&lt;/li&gt;
&lt;li&gt;应用为了防止输入框被键盘遮挡，只能&lt;strong&gt;跳变式地&lt;/strong&gt;将整个聊天列表和输入框向上移动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 Insets 动画 (解决方案):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击输入框。&lt;/li&gt;
&lt;li&gt;应用接管键盘的动画控制权。&lt;/li&gt;
&lt;li&gt;在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并&lt;strong&gt;同步地、等速地&lt;/strong&gt;将自己的聊天列表和输入框也向上推。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 在用户看来，整个过程是一个连贯的动画：&lt;strong&gt;仿佛是键盘“推”着聊天内容向上移动&lt;/strong&gt;，非常自然、流畅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;场景&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;传统方式的问题&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Insets 动画的效果&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;聊天应用&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;键盘动画与内容移动分离，内容&lt;strong&gt;跳变&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;键盘&lt;strong&gt;平滑推起&lt;/strong&gt;内容，动画无缝衔接&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-沉浸式模式的过渡-video--photo-apps&#34;&gt;2. 沉浸式模式的过渡 (Video &amp;amp; Photo Apps)&lt;/h3&gt;
&lt;p&gt;当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传统体验 (问题所在):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。&lt;/li&gt;
&lt;li&gt;系统状态栏和导航栏&lt;strong&gt;突然出现&lt;/strong&gt;或&lt;strong&gt;淡入&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;应用内容区域（图片）为了适应变小的空间，&lt;strong&gt;突然缩放或移动&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 Insets 动画 (解决方案):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击屏幕。&lt;/li&gt;
&lt;li&gt;应用接管状态栏和导航栏的动画。&lt;/li&gt;
&lt;li&gt;当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都&lt;strong&gt;同步地、平滑地&lt;/strong&gt;将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果：&lt;/strong&gt; 整个过渡非常优雅，感觉像是&lt;strong&gt;画面和系统栏一起构成了一场精心编排的转场动画&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-高级交互场景手势控制动画&#34;&gt;3. 高级交互场景：手势控制动画&lt;/h3&gt;
&lt;p&gt;这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。&lt;/p&gt;</description>
    </item>
    <item>
      <title>WindowManagerService 解析</title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</link>
      <pubDate>Tue, 29 Jul 2025 10:22:54 +0800</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/</guid>
      <description>&lt;h2 id=&#34;windowmanagerservice-概述&#34;&gt;WindowManagerService 概述&lt;/h2&gt;
&lt;p&gt;WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。&lt;/p&gt;
&lt;p&gt;作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。&lt;/p&gt;
&lt;p&gt;WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;窗口的创建与管理 (Creation &amp;amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布局与计算 (Layout &amp;amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层级与Z序 (Layer &amp;amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绘制与合成 (Drawing &amp;amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;窗口的创建与管理&#34;&gt;窗口的创建与管理&lt;/h2&gt;
&lt;p&gt;窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;WindowState 创建时序示意图&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/windowstate-creation.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。&lt;/li&gt;
&lt;li&gt;ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。&lt;/li&gt;
&lt;li&gt;Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：
&lt;ul&gt;
&lt;li&gt;Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。
&lt;img alt=&#34;WindowToken创建与使用示意图&#34; loading=&#34;lazy&#34; src=&#34;https://ethen-cao.github.io/ethenslab/images/windowtoken-creation-transport.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;WMS 的响应动作&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/wmshell.log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/wmshell.log/</guid>
      <description>&lt;p&gt;09-30 17:05:03.689  2508  2508 D SplitScreenController: java.lang.Throwable
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.wm.shell.splitscreen.SplitScreenController.&lt;!-- raw HTML omitted --&gt;(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:3)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.wm.shell.dagger.WMShellModule_ProvideSplitScreenControllerFactory.provideSplitScreenController(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:37)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get0(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:118)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:23)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at dagger.internal.DoubleCheck.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:14)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get0(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:119)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:23)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at dagger.internal.DoubleCheck.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:14)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get0(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:153)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:23)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at dagger.internal.DoubleCheck.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:14)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get0(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:154)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl$SwitchingProvider.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:23)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at dagger.internal.DoubleCheck.get(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:14)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.dagger.DaggerReferenceGlobalRootComponent$WMComponentImpl.getShell(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:3)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.SystemUIInitializer.init(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:130)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.SystemUIAppComponentFactoryBase.access$createSystemUIInitializerInternal(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:22)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.SystemUIAppComponentFactoryBase$instantiateProviderCompat$1.onContextAvailable(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:9)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.systemui.keyguard.CustomizationProvider.attachInfo(go/retraceme b7eab7420076376e0041efdff558cb89d757dece22a32b7922faabcdeaeca84a:8)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread.installProvider(ActivityThread.java:7765)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread.installContentProviders(ActivityThread.java:7276)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6983)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread.-$$Nest$mhandleBindApplication(Unknown Source:0)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2236)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.os.Handler.dispatchMessage(Handler.java:106)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.os.Looper.loopOnce(Looper.java:205)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.os.Looper.loop(Looper.java:294)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at android.app.ActivityThread.main(ActivityThread.java:8177)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at java.lang.reflect.Method.invoke(Native Method)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
09-30 17:05:03.689  2508  2508 D SplitScreenController: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
