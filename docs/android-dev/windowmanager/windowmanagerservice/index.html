<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>WindowManagerService 解析 | Ethen 的实验室</title>
<meta name="keywords" content="">
<meta name="description" content="WindowManagerService 概述
WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。
作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。
WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：


窗口的创建与管理 (Creation &amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。


布局与计算 (Layout &amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。


层级与Z序 (Layer &amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。


绘制与合成 (Drawing &amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。


窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。


输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。


窗口的创建与管理
窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。

触发流程：

应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。
ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。
Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：

Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。

WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。



WMS 的响应动作：">
<meta name="author" content="">
<link rel="canonical" href="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/">
<link crossorigin="anonymous" href="/ethenslab/assets/css/stylesheet.8d92b99258d2a8aea36dee98116af3631ad91e255aef20c2caa81c9459a68fd8.css" integrity="sha256-jZK5kljSqK6jbe6YEWrzYxrZHiVa7yDCyqgclFmmj9g=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ethen-cao.github.io/ethenslab/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ethen-cao.github.io/ethenslab/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ethen-cao.github.io/ethenslab/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ethen-cao.github.io/ethenslab/apple-touch-icon.png">
<link rel="mask-icon" href="https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/">
  <meta property="og:site_name" content="Ethen 的实验室">
  <meta property="og:title" content="WindowManagerService 解析">
  <meta property="og:description" content="WindowManagerService 概述 WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。
作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。
WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：
窗口的创建与管理 (Creation &amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。
布局与计算 (Layout &amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。
层级与Z序 (Layer &amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。
绘制与合成 (Drawing &amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。
窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。
输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。
窗口的创建与管理 窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。
触发流程：
应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。 ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。 Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息： Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。 WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。 WMS 的响应动作：">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="android-dev">
    <meta property="article:published_time" content="2025-07-29T10:22:54+08:00">
    <meta property="article:modified_time" content="2025-07-29T10:22:54+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WindowManagerService 解析">
<meta name="twitter:description" content="WindowManagerService 概述
WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。
作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。
WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：


窗口的创建与管理 (Creation &amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。


布局与计算 (Layout &amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。


层级与Z序 (Layer &amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。


绘制与合成 (Drawing &amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。


窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。


输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。


窗口的创建与管理
窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。

触发流程：

应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。
ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。
Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：

Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。

WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。



WMS 的响应动作：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Android系统开发",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "WindowManager",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "WindowManagerService 解析",
      "item": "https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WindowManagerService 解析",
  "name": "WindowManagerService 解析",
  "description": "WindowManagerService 概述 WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。\n作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。\nWMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：\n窗口的创建与管理 (Creation \u0026amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。\n布局与计算 (Layout \u0026amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。\n层级与Z序 (Layer \u0026amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。\n绘制与合成 (Drawing \u0026amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。\n窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。\n输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。\n窗口的创建与管理 窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。\n触发流程：\n应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。 ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。 Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息： Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。 WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。 WMS 的响应动作：\n",
  "keywords": [
    
  ],
  "articleBody": "WindowManagerService 概述 WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。\n作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。\nWMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：\n窗口的创建与管理 (Creation \u0026 Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。\n布局与计算 (Layout \u0026 Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。\n层级与Z序 (Layer \u0026 Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。\n绘制与合成 (Drawing \u0026 Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。\n窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。\n输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。\n窗口的创建与管理 窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。\n触发流程：\n应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。 ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。 Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息： Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。 WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。 WMS 的响应动作：\n权限验证：WMS 首先会检查调用者是否有权限添加所请求类型的窗口。例如，应用不能随意添加系统警报窗口（TYPE_APPLICATION_OVERLAY），这需要特殊权限。 创建 WindowState 实例：验证通过后，WMS 会 new WindowState(…)，创建一个新的 WindowState 对象。这个对象会保存所有从 LayoutParams 传递过来的属性。 创建绘图表面 (SurfaceControl)：紧接着，WMS 会为这个新的 WindowState 创建一个对应的 SurfaceControl。这是一个指向 SurfaceFlinger 中一个图层（Layer）的句柄，是窗口能够被看见和渲染的基础。 加入层级树：WMS 根据 Window Token 找到其归属的 Task 和 TaskFragment，然后将新创建的 WindowState 添加到这个容器的子节点列表中，完成了其在窗口层级树中的“注册”。 返回结果给应用：WMS 将 SurfaceControl 的信息以及其他必要的配置返回给应用进程的 ViewRootImpl。ViewRootImpl 收到后，就可以创建出应用侧的 Surface 对象，并开始组织第一次绘制。 调度布局：由于新窗口的加入改变了屏幕的整体布局，WMS 会将布局状态标记为“待定”（dirty），并在下一个合适的时机触发一次 WindowSurfacePlacer 的布局遍历。 一旦 WindowState 被创建并加入到层级树中，它就进入了被 WMS 持续管理的“活动”状态。管理主要体现在以下几个方面：\n状态追踪：WindowState 内部维护了大量的状态标志，如是否可见、是否拥有焦点、是否正在播放动画、是否可以接收触摸事件等。WMS 会根据用户交互和系统事件不断更新这些状态。 布局与定位：在每一次 WindowSurfacePlacer 的布局遍历中，WMS 都会访问每一个 WindowState，读取其 LayoutParams，并结合其父容器的约束，计算出它最终的 Frame（位置和尺寸）。计算结果会通过 SurfaceControl 的事务（Transaction）更新到 SurfaceFlinger。 层级（Z-Order）调整：WMS 维护着一个所有窗口的Z序列表。当用户触摸某个窗口使其获得焦点时，WMS 会调整这个列表，将该窗口及其所属的 Task 提升到更高的层级，以确保它显示在最前面。 响应属性更新：应用可以通过 WindowManager.updateViewLayout() 方法在运行时修改窗口的 LayoutParams。这个请求会通过 Binder 发送到 WMS，WMS 会更新对应的 WindowState 对象的属性，并再次调度布局以应用变更。 输入事件路由：当触摸事件发生时，WMS（与 InputDispatcher 协同）会从Z序最高的窗口开始检查，判断触摸点是否落在该 WindowState 的 Frame 内，以及该窗口是否可以接收输入。一旦找到合适的目标，输入事件就会被派发给该窗口。 Feature ID 什么是 Feature？ 在 Android 窗口管理中，一个 “Feature” 通常指一项特定的、可以独立开关或管理的窗口功能。最典型的例子就是画中画（Picture-in-Picture）和分屏（Split-screen）。每个这样的功能都会在系统内部注册，并被分配一个唯一的整数ID，这个ID就是 mFeatureId。\n为什么需要 mFeatureId？ DisplayArea 是窗口的容器，它可以嵌套组织。当一个特殊功能（如画中画）需要一个专属的区域来管理它的窗口时，系统就会创建一个 DisplayArea。mFeatureId 在这里起到了关键的识别作用：\n唯一识别：系统可以通过这个 ID 快速找到由特定功能（比如画中-画）创建的根 DisplayArea。例如，当系统需要管理所有画中画窗口时，它就可以通过查找 featureId 为 FEATURE_PICTURE_IN_PICTURE 的 DisplayArea 来定位到它们的容器。\n功能归属：它明确了这个 DisplayArea 的“主人”是谁。这片区域内的窗口布局、行为和逻辑都应该遵循其所属功能的规则。\n逻辑隔离：通过这种方式，不同功能的窗口管理逻辑被清晰地隔离在各自的 DisplayArea 中，使得整个窗口管理体系（WindowContainer 树）更加清晰和模块化。\n示例：当用户开启一个画中画窗口时，系统会创建一个专门用于承载这个小窗口的 DisplayArea，并将其 mFeatureId 设置为 WindowManager.FEATURE_PICTURE_IN_PICTURE。在分屏模式下，主要和次要任务所在的区域也可能由带有特定 featureId 的 DisplayArea 来管理。\n总之，mFeatureId 是一个内部标识，它将一个 DisplayArea 容器与创建它的特定窗口功能（如画中画）绑定在一起，方便系统进行识别、查找和管理。\n系统预定义的 mFeatureId 主要定义在 android.window.DisplayAreaOrganizer 这个类中。这些ID代表了不同的、需要独立容器（DisplayArea）来管理的系统级窗口功能。\n以下是系统当前主要的 mFeatureId 类型及其作用：\n/** * The value in display area indicating that no value has been set. */ public static final int FEATURE_UNDEFINED = -1; /** * The Root display area on a display */ public static final int FEATURE_SYSTEM_FIRST = 0; /** * The Root display area on a display */ public static final int FEATURE_ROOT = FEATURE_SYSTEM_FIRST; /** * Display area hosting the default task container. */ public static final int FEATURE_DEFAULT_TASK_CONTAINER = FEATURE_SYSTEM_FIRST + 1; /** * Display area hosting non-activity window tokens. */ public static final int FEATURE_WINDOW_TOKENS = FEATURE_SYSTEM_FIRST + 2; /** * Display area for one handed feature */ public static final int FEATURE_ONE_HANDED = FEATURE_SYSTEM_FIRST + 3; /** * Display area that can be magnified in * {@link Settings.Secure.ACCESSIBILITY_MAGNIFICATION_MODE_WINDOW}. It contains all windows * below {@link WindowManager.LayoutParams#TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY}. */ public static final int FEATURE_WINDOWED_MAGNIFICATION = FEATURE_SYSTEM_FIRST + 4; /** * Display area that can be magnified in * {@link Settings.Secure.ACCESSIBILITY_MAGNIFICATION_MODE_FULLSCREEN}. This is different from * {@link #FEATURE_WINDOWED_MAGNIFICATION} that the whole display will be magnified. * @hide */ public static final int FEATURE_FULLSCREEN_MAGNIFICATION = FEATURE_SYSTEM_FIRST + 5; /** * Display area for hiding display cutout feature * @hide */ public static final int FEATURE_HIDE_DISPLAY_CUTOUT = FEATURE_SYSTEM_FIRST + 6; /** * Display area that the IME container can be placed in. Should be enabled on every root * hierarchy if IME container may be reparented to that hierarchy when the IME target changed. * @hide */ public static final int FEATURE_IME_PLACEHOLDER = FEATURE_SYSTEM_FIRST + 7; /** * Display area hosting IME window tokens (@see ImeContainer). By default, IMEs are parented * to FEATURE_IME_PLACEHOLDER but can be reparented under other RootDisplayArea. * * This feature can register organizers in order to disable the reparenting logic and manage * the position and settings of the container manually. This is useful for foldable devices * which require custom UX rules for the IME position (e.g. IME on one screen and the focused * app on another screen). */ public static final int FEATURE_IME = FEATURE_SYSTEM_FIRST + 8; /** * The last boundary of display area for system features */ public static final int FEATURE_SYSTEM_LAST = 10_000; /** * Vendor specific display area definition can start with this value. */ public static final int FEATURE_VENDOR_FIRST = FEATURE_SYSTEM_LAST + 1; /** * Last possible vendor specific display area id. * @hide */ public static final int FEATURE_VENDOR_LAST = FEATURE_VENDOR_FIRST + 10_000; /** * Task display areas that can be created at runtime start with this value. * @see #createTaskDisplayArea(int, int, String) * @hide */ public static final int FEATURE_RUNTIME_TASK_CONTAINER_FIRST = FEATURE_VENDOR_LAST + 1; WindowContainer层级管理 区域 说明 DisplayArea.Tokens (Wallpaper) 管理 WallpaperWindowToken（壁纸窗口），Z-order 最低。 TaskDisplayArea (Default) 管理普通应用任务（Activity 所在 Task）。 DisplayArea (Split-screen) 管理分屏模式窗口，包括主副屏的两个 TaskDisplayArea。 DisplayArea (PIP) 管理画中画窗口，Z-order 较高。系统动态决定其是否显示。 DisplayArea.Tokens (InputMethod) 输入法专用窗口区域，显示时通常被置于较高层级。 DisplayArea.Tokens (System Overlays) 管理弹窗、提示（如 Toast、Dialog、PopupWindow）。 DisplayArea.Tokens (StatusBar) 通常为最顶层，用于状态栏、导航栏、系统通知等 SystemUI 组件。 PictureInPicture 原理 ",
  "wordCount" : "688",
  "inLanguage": "en",
  "datePublished": "2025-07-29T10:22:54+08:00",
  "dateModified": "2025-07-29T10:22:54+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ethen 的实验室",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ethen-cao.github.io/ethenslab/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ethen-cao.github.io/ethenslab/" accesskey="h" title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-dev/" title="Android系统开发">
                    <span>Android系统开发</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/" title="Android Automotive">
                    <span>Android Automotive</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/ivi-solution/" title="智能座舱方案">
                    <span>智能座舱方案</span>
                </a>
            </li>
            <li>
                <a href="https://ethen-cao.github.io/ethenslab/explore-ai" title="Explore AI">
                    <span>Explore AI</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ethen-cao.github.io/ethenslab/">Home</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/android-dev/">Android系统开发</a>&nbsp;»&nbsp;<a href="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/">WindowManager</a></div>
    <h1 class="post-title entry-hint-parent">
      WindowManagerService 解析
    </h1>
    <div class="post-meta"><span title='2025-07-29 10:22:54 +0800 CST'>July 29, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;688 words

</div>
  </header> 
  <div class="post-content"><h2 id="windowmanagerservice-概述">WindowManagerService 概述<a hidden class="anchor" aria-hidden="true" href="#windowmanagerservice-概述">#</a></h2>
<p>WindowManagerService（简称WMS）是Android系统中负责窗口（Window）管理的核心系统服务。它是屏幕上所有可见元素的“总管家”，决定了所有窗口的外观、行为和交互方式。</p>
<p>作为Android框架层（Framework Layer）的关键部分，WMS随系统启动，并稳定运行在权限极高的 system_server 进程中。这个位置赋予了它管理所有应用窗口和系统窗口的最高权限。</p>
<p>WMS的角色像一个“总指挥”，它并不亲自执行所有底层操作，而是协调系统中的多个组件来共同完成对窗口的生命周期管理。其核心作用包括：</p>
<ul>
<li>
<p>窗口的创建与管理 (Creation &amp; Management): 与 ActivityManagerService (AMS) 协同工作。当AMS决定要显示某个Activity时，WMS负责为其创建和管理对应的窗口实例（WindowState）。</p>
</li>
<li>
<p>布局与计算 (Layout &amp; Calculation): 通过自顶向下的遍历，精确计算出每个窗口在屏幕上的最终位置和尺寸（Frame），从而适配不同尺寸的屏幕以及分屏、小窗等各种显示模式。</p>
</li>
<li>
<p>层级与Z序 (Layer &amp; Z-Order): 维护所有窗口的前后堆叠顺序（Z-Order），决定哪个窗口显示在最上层，哪个窗口被遮挡，确保界面元素以正确的次序呈现。</p>
</li>
<li>
<p>绘制与合成 (Drawing &amp; Composition): WMS自身不负责绘制窗口内容。它管理窗口的绘图表面（Surface），并将所有窗口的元数据（位置、层级、透明度等）统一提交给 SurfaceFlinger，由后者完成最终的画面合成。</p>
</li>
<li>
<p>窗口动画 (Window Animation): 负责实现窗口切换、应用启动/退出、调整大小等过程中的过渡动画，为用户提供流畅的视觉体验。</p>
</li>
<li>
<p>输入事件分发 (Input Event Dispatching): 作为输入系统的关键一环，WMS接收原始的触摸、按键等事件，准确判断事件应该由哪个窗口接收，并交由 InputDispatcher 进行精确投递。</p>
</li>
</ul>
<h2 id="窗口的创建与管理">窗口的创建与管理<a hidden class="anchor" aria-hidden="true" href="#窗口的创建与管理">#</a></h2>
<p>窗口的创建请求总是由应用进程发起的，WMS 则是请求的响应者和执行者。</p>
<p><img alt="WindowState 创建时序示意图" loading="lazy" src="/ethenslab/images/windowstate-creation.png"></p>
<p><strong>触发流程</strong>：</p>
<ul>
<li>应用层调用：当一个 Activity 的 onResume() 回调被触发，准备变得可见时，其内部的 PhoneWindow 会通过 WindowManager.addView() 方法将它的根视图（DecorView）添加到窗口中。这个调用是应用请求显示UI的起点。</li>
<li>ViewRootImpl 的桥梁作用：addView() 的调用会创建一个名为 ViewRootImpl 的关键对象。ViewRootImpl 充当了应用UI和WMS之间的“信使”和“桥梁”。</li>
<li>Binder IPC 调用：ViewRootImpl 通过一个名为 IWindowSession 的 Binder 接口，向 WMS 发起一个远程调用，通常是 addToDisplay()。这个调用会携带两个核心信息：
<ul>
<li>Window Token: 一个唯一的 Binder 令牌，用于将这个窗口与 AMS 中的 ActivityRecord 关联起来，WMS据此知道这个窗口属于哪个Activity。
<img alt="WindowToken创建与使用示意图" loading="lazy" src="/ethenslab/images/windowtoken-creation-transport.png"></li>
<li>WindowManager.LayoutParams: 一个包含了窗口所有期望属性的参数集，如窗口的类型（应用窗口、系统窗口）、尺寸（MATCH_PARENT等）、标志（FLAG_NOT_FOCUSABLE等）和 gravity。</li>
</ul>
</li>
</ul>
<p><strong>WMS 的响应动作</strong>：</p>
<ul>
<li>权限验证：WMS 首先会检查调用者是否有权限添加所请求类型的窗口。例如，应用不能随意添加系统警报窗口（TYPE_APPLICATION_OVERLAY），这需要特殊权限。</li>
<li>创建 WindowState 实例：验证通过后，WMS 会 new WindowState(&hellip;)，创建一个新的 WindowState 对象。这个对象会保存所有从 LayoutParams 传递过来的属性。</li>
<li>创建绘图表面 (SurfaceControl)：紧接着，WMS 会为这个新的 WindowState 创建一个对应的 SurfaceControl。这是一个指向 SurfaceFlinger 中一个图层（Layer）的句柄，是窗口能够被看见和渲染的基础。</li>
<li>加入层级树：WMS 根据 Window Token 找到其归属的 Task 和 TaskFragment，然后将新创建的 WindowState 添加到这个容器的子节点列表中，完成了其在窗口层级树中的“注册”。</li>
<li>返回结果给应用：WMS 将 SurfaceControl 的信息以及其他必要的配置返回给应用进程的 ViewRootImpl。ViewRootImpl 收到后，就可以创建出应用侧的 Surface 对象，并开始组织第一次绘制。</li>
<li>调度布局：由于新窗口的加入改变了屏幕的整体布局，WMS 会将布局状态标记为“待定”（dirty），并在下一个合适的时机触发一次 WindowSurfacePlacer 的布局遍历。</li>
</ul>
<p>一旦 WindowState 被创建并加入到层级树中，它就进入了被 WMS 持续管理的“活动”状态。管理主要体现在以下几个方面：</p>
<ul>
<li>状态追踪：WindowState 内部维护了大量的状态标志，如是否可见、是否拥有焦点、是否正在播放动画、是否可以接收触摸事件等。WMS 会根据用户交互和系统事件不断更新这些状态。</li>
<li>布局与定位：在每一次 WindowSurfacePlacer 的布局遍历中，WMS 都会访问每一个 WindowState，读取其 LayoutParams，并结合其父容器的约束，计算出它最终的 Frame（位置和尺寸）。计算结果会通过 SurfaceControl 的事务（Transaction）更新到 SurfaceFlinger。</li>
<li>层级（Z-Order）调整：WMS 维护着一个所有窗口的Z序列表。当用户触摸某个窗口使其获得焦点时，WMS 会调整这个列表，将该窗口及其所属的 Task 提升到更高的层级，以确保它显示在最前面。</li>
<li>响应属性更新：应用可以通过 WindowManager.updateViewLayout() 方法在运行时修改窗口的 LayoutParams。这个请求会通过 Binder 发送到 WMS，WMS 会更新对应的 WindowState 对象的属性，并再次调度布局以应用变更。</li>
<li>输入事件路由：当触摸事件发生时，WMS（与 InputDispatcher 协同）会从Z序最高的窗口开始检查，判断触摸点是否落在该 WindowState 的 Frame 内，以及该窗口是否可以接收输入。一旦找到合适的目标，输入事件就会被派发给该窗口。</li>
</ul>
<h3 id="feature-id">Feature ID<a hidden class="anchor" aria-hidden="true" href="#feature-id">#</a></h3>
<ol>
<li>
<p>什么是 Feature？
在 Android 窗口管理中，一个 &ldquo;Feature&rdquo; 通常指一项特定的、可以独立开关或管理的窗口功能。最典型的例子就是画中画（Picture-in-Picture）和分屏（Split-screen）。每个这样的功能都会在系统内部注册，并被分配一个唯一的整数ID，这个ID就是 mFeatureId。</p>
</li>
<li>
<p>为什么需要 mFeatureId？
DisplayArea 是窗口的容器，它可以嵌套组织。当一个特殊功能（如画中画）需要一个专属的区域来管理它的窗口时，系统就会创建一个 DisplayArea。mFeatureId 在这里起到了关键的识别作用：</p>
<ul>
<li>
<p>唯一识别：系统可以通过这个 ID 快速找到由特定功能（比如画中-画）创建的根 DisplayArea。例如，当系统需要管理所有画中画窗口时，它就可以通过查找 featureId 为 FEATURE_PICTURE_IN_PICTURE 的 DisplayArea 来定位到它们的容器。</p>
</li>
<li>
<p>功能归属：它明确了这个 DisplayArea 的“主人”是谁。这片区域内的窗口布局、行为和逻辑都应该遵循其所属功能的规则。</p>
</li>
<li>
<p>逻辑隔离：通过这种方式，不同功能的窗口管理逻辑被清晰地隔离在各自的 DisplayArea 中，使得整个窗口管理体系（WindowContainer 树）更加清晰和模块化。</p>
</li>
</ul>
</li>
<li>
<p>示例：当用户开启一个画中画窗口时，系统会创建一个专门用于承载这个小窗口的 DisplayArea，并将其 mFeatureId 设置为 WindowManager.FEATURE_PICTURE_IN_PICTURE。在分屏模式下，主要和次要任务所在的区域也可能由带有特定 featureId 的 DisplayArea 来管理。</p>
</li>
</ol>
<p>总之，mFeatureId 是一个内部标识，它将一个 DisplayArea 容器与创建它的特定窗口功能（如画中画）绑定在一起，方便系统进行识别、查找和管理。</p>
<p>系统预定义的 mFeatureId 主要定义在 android.window.DisplayAreaOrganizer 这个类中。这些ID代表了不同的、需要独立容器（DisplayArea）来管理的系统级窗口功能。</p>
<p>以下是系统当前主要的 mFeatureId 类型及其作用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The value in display area indicating that no value has been set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_UNDEFINED <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The Root display area on a display
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The Root display area on a display
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_ROOT <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area hosting the default task container.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_DEFAULT_TASK_CONTAINER <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area hosting non-activity window tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_WINDOW_TOKENS <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area for one handed feature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_ONE_HANDED <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area that can be magnified in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * {@link Settings.Secure.ACCESSIBILITY_MAGNIFICATION_MODE_WINDOW}. It contains all windows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * below {@link WindowManager.LayoutParams#TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY}.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_WINDOWED_MAGNIFICATION <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 4;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area that can be magnified in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * {@link Settings.Secure.ACCESSIBILITY_MAGNIFICATION_MODE_FULLSCREEN}. This is different from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * {@link #FEATURE_WINDOWED_MAGNIFICATION} that the whole display will be magnified.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @hide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_FULLSCREEN_MAGNIFICATION <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 5;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area for hiding display cutout feature
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @hide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_HIDE_DISPLAY_CUTOUT <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 6;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area that the IME container can be placed in. Should be enabled on every root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * hierarchy if IME container may be reparented to that hierarchy when the IME target changed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @hide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_IME_PLACEHOLDER <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 7;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Display area hosting IME window tokens (@see ImeContainer). By default, IMEs are parented
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * to FEATURE_IME_PLACEHOLDER but can be reparented under other RootDisplayArea.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * This feature can register organizers in order to disable the reparenting logic and manage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the position and settings of the container manually. This is useful for foldable devices
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * which require custom UX rules for the IME position (e.g. IME on one screen and the focused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * app on another screen).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_IME <span style="color:#f92672">=</span> FEATURE_SYSTEM_FIRST <span style="color:#f92672">+</span> 8;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The last boundary of display area for system features
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_SYSTEM_LAST <span style="color:#f92672">=</span> 10_000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Vendor specific display area definition can start with this value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_VENDOR_FIRST <span style="color:#f92672">=</span> FEATURE_SYSTEM_LAST <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Last possible vendor specific display area id.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @hide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_VENDOR_LAST <span style="color:#f92672">=</span> FEATURE_VENDOR_FIRST <span style="color:#f92672">+</span> 10_000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Task display areas that can be created at runtime start with this value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @see #createTaskDisplayArea(int, int, String)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @hide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> FEATURE_RUNTIME_TASK_CONTAINER_FIRST <span style="color:#f92672">=</span> FEATURE_VENDOR_LAST <span style="color:#f92672">+</span> 1;
</span></span></code></pre></div><h3 id="windowcontainer层级管理">WindowContainer层级管理<a hidden class="anchor" aria-hidden="true" href="#windowcontainer层级管理">#</a></h3>
<p><img alt="WindowContainer层级管理" loading="lazy" src="/ethenslab/images/DisplayContent.Token.png"></p>
<table>
  <thead>
      <tr>
          <th>区域</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DisplayArea.Tokens (Wallpaper)</strong></td>
          <td>管理 <code>WallpaperWindowToken</code>（壁纸窗口），Z-order 最低。</td>
      </tr>
      <tr>
          <td><strong>TaskDisplayArea (Default)</strong></td>
          <td>管理普通应用任务（Activity 所在 Task）。</td>
      </tr>
      <tr>
          <td><strong>DisplayArea (Split-screen)</strong></td>
          <td>管理分屏模式窗口，包括主副屏的两个 TaskDisplayArea。</td>
      </tr>
      <tr>
          <td><strong>DisplayArea (PIP)</strong></td>
          <td>管理画中画窗口，Z-order 较高。系统动态决定其是否显示。</td>
      </tr>
      <tr>
          <td><strong>DisplayArea.Tokens (InputMethod)</strong></td>
          <td>输入法专用窗口区域，显示时通常被置于较高层级。</td>
      </tr>
      <tr>
          <td><strong>DisplayArea.Tokens (System Overlays)</strong></td>
          <td>管理弹窗、提示（如 Toast、Dialog、PopupWindow）。</td>
      </tr>
      <tr>
          <td><strong>DisplayArea.Tokens (StatusBar)</strong></td>
          <td>通常为最顶层，用于状态栏、导航栏、系统通知等 SystemUI 组件。</td>
      </tr>
  </tbody>
</table>
<h3 id="pictureinpicture-原理">PictureInPicture 原理<a hidden class="anchor" aria-hidden="true" href="#pictureinpicture-原理">#</a></h3>
<p><img alt="PiP创建流程" loading="lazy" src="/ethenslab/images/pip.puml"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/">
    <span class="title">Next »</span>
    <br>
    <span>ActivityManager 深度解析</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ethen-cao.github.io/ethenslab/">Ethen 的实验室</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
