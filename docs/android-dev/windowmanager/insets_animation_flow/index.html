<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Insets animation flow | Ethen 的实验室</title><meta name=keywords content><meta name=description content="Insets 动画 API 的核心价值在于消除系统 UI 动画和应用 UI 动画之间的“割裂感”，将两者融合成一个平滑、无缝的整体。
以下是一些典型的应用场景，从最常见到更高级的交互：
1. 核心场景：键盘的显示与隐藏 (Messaging & Input)
这是最经典、最能体现其价值的场景。


传统体验 (问题所在):

在一个聊天应用里，你点击底部的输入框。
键盘从底部滑出，这个动画是系统负责的。
在键盘动画的同时，应用收到一个“可用空间变小了”的通知。
应用为了防止输入框被键盘遮挡，只能跳变式地将整个聊天列表和输入框向上移动。
结果： 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。



使用 Insets 动画 (解决方案):

点击输入框。
应用接管键盘的动画控制权。
在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并同步地、等速地将自己的聊天列表和输入框也向上推。
结果： 在用户看来，整个过程是一个连贯的动画：仿佛是键盘“推”着聊天内容向上移动，非常自然、流畅。




  
      
          场景
          传统方式的问题
          Insets 动画的效果
      
  
  
      
          聊天应用
          键盘动画与内容移动分离，内容跳变
          键盘平滑推起内容，动画无缝衔接
      
  

2. 沉浸式模式的过渡 (Video & Photo Apps)
当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。


传统体验 (问题所在):

你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。
系统状态栏和导航栏突然出现或淡入。
应用内容区域（图片）为了适应变小的空间，突然缩放或移动。
结果： 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。



使用 Insets 动画 (解决方案):

点击屏幕。
应用接管状态栏和导航栏的动画。
当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都同步地、平滑地将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。
结果： 整个过渡非常优雅，感觉像是画面和系统栏一起构成了一场精心编排的转场动画。



3. 高级交互场景：手势控制动画
这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Insets animation flow"><meta property="og:description" content="Insets 动画 API 的核心价值在于消除系统 UI 动画和应用 UI 动画之间的“割裂感”，将两者融合成一个平滑、无缝的整体。
以下是一些典型的应用场景，从最常见到更高级的交互：
1. 核心场景：键盘的显示与隐藏 (Messaging & Input) 这是最经典、最能体现其价值的场景。
传统体验 (问题所在):
在一个聊天应用里，你点击底部的输入框。 键盘从底部滑出，这个动画是系统负责的。 在键盘动画的同时，应用收到一个“可用空间变小了”的通知。 应用为了防止输入框被键盘遮挡，只能跳变式地将整个聊天列表和输入框向上移动。 结果： 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。 使用 Insets 动画 (解决方案):
点击输入框。 应用接管键盘的动画控制权。 在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并同步地、等速地将自己的聊天列表和输入框也向上推。 结果： 在用户看来，整个过程是一个连贯的动画：仿佛是键盘“推”着聊天内容向上移动，非常自然、流畅。 场景 传统方式的问题 Insets 动画的效果 聊天应用 键盘动画与内容移动分离，内容跳变 键盘平滑推起内容，动画无缝衔接 2. 沉浸式模式的过渡 (Video & Photo Apps) 当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。
传统体验 (问题所在):
你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。 系统状态栏和导航栏突然出现或淡入。 应用内容区域（图片）为了适应变小的空间，突然缩放或移动。 结果： 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。 使用 Insets 动画 (解决方案):
点击屏幕。 应用接管状态栏和导航栏的动画。 当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都同步地、平滑地将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。 结果： 整个过渡非常优雅，感觉像是画面和系统栏一起构成了一场精心编排的转场动画。 3. 高级交互场景：手势控制动画 这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T10:22:54+08:00"><meta property="article:modified_time" content="2025-09-29T10:22:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Insets animation flow"><meta name=twitter:description content="Insets 动画 API 的核心价值在于消除系统 UI 动画和应用 UI 动画之间的“割裂感”，将两者融合成一个平滑、无缝的整体。
以下是一些典型的应用场景，从最常见到更高级的交互：
1. 核心场景：键盘的显示与隐藏 (Messaging & Input)
这是最经典、最能体现其价值的场景。


传统体验 (问题所在):

在一个聊天应用里，你点击底部的输入框。
键盘从底部滑出，这个动画是系统负责的。
在键盘动画的同时，应用收到一个“可用空间变小了”的通知。
应用为了防止输入框被键盘遮挡，只能跳变式地将整个聊天列表和输入框向上移动。
结果： 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。



使用 Insets 动画 (解决方案):

点击输入框。
应用接管键盘的动画控制权。
在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并同步地、等速地将自己的聊天列表和输入框也向上推。
结果： 在用户看来，整个过程是一个连贯的动画：仿佛是键盘“推”着聊天内容向上移动，非常自然、流畅。




  
      
          场景
          传统方式的问题
          Insets 动画的效果
      
  
  
      
          聊天应用
          键盘动画与内容移动分离，内容跳变
          键盘平滑推起内容，动画无缝衔接
      
  

2. 沉浸式模式的过渡 (Video & Photo Apps)
当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。


传统体验 (问题所在):

你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。
系统状态栏和导航栏突然出现或淡入。
应用内容区域（图片）为了适应变小的空间，突然缩放或移动。
结果： 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。



使用 Insets 动画 (解决方案):

点击屏幕。
应用接管状态栏和导航栏的动画。
当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都同步地、平滑地将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。
结果： 整个过渡非常优雅，感觉像是画面和系统栏一起构成了一场精心编排的转场动画。



3. 高级交互场景：手势控制动画
这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"WindowManager","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/"},{"@type":"ListItem","position":3,"name":"Insets animation flow","item":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Insets animation flow","name":"Insets animation flow","description":"Insets 动画 API 的核心价值在于消除系统 UI 动画和应用 UI 动画之间的“割裂感”，将两者融合成一个平滑、无缝的整体。\n以下是一些典型的应用场景，从最常见到更高级的交互：\n1. 核心场景：键盘的显示与隐藏 (Messaging \u0026amp; Input) 这是最经典、最能体现其价值的场景。\n传统体验 (问题所在):\n在一个聊天应用里，你点击底部的输入框。 键盘从底部滑出，这个动画是系统负责的。 在键盘动画的同时，应用收到一个“可用空间变小了”的通知。 应用为了防止输入框被键盘遮挡，只能跳变式地将整个聊天列表和输入框向上移动。 结果： 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。 使用 Insets 动画 (解决方案):\n点击输入框。 应用接管键盘的动画控制权。 在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并同步地、等速地将自己的聊天列表和输入框也向上推。 结果： 在用户看来，整个过程是一个连贯的动画：仿佛是键盘“推”着聊天内容向上移动，非常自然、流畅。 场景 传统方式的问题 Insets 动画的效果 聊天应用 键盘动画与内容移动分离，内容跳变 键盘平滑推起内容，动画无缝衔接 2. 沉浸式模式的过渡 (Video \u0026amp; Photo Apps) 当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。\n传统体验 (问题所在):\n你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。 系统状态栏和导航栏突然出现或淡入。 应用内容区域（图片）为了适应变小的空间，突然缩放或移动。 结果： 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。 使用 Insets 动画 (解决方案):\n点击屏幕。 应用接管状态栏和导航栏的动画。 当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都同步地、平滑地将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。 结果： 整个过渡非常优雅，感觉像是画面和系统栏一起构成了一场精心编排的转场动画。 3. 高级交互场景：手势控制动画 这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。\n","keywords":[],"articleBody":"Insets 动画 API 的核心价值在于消除系统 UI 动画和应用 UI 动画之间的“割裂感”，将两者融合成一个平滑、无缝的整体。\n以下是一些典型的应用场景，从最常见到更高级的交互：\n1. 核心场景：键盘的显示与隐藏 (Messaging \u0026 Input) 这是最经典、最能体现其价值的场景。\n传统体验 (问题所在):\n在一个聊天应用里，你点击底部的输入框。 键盘从底部滑出，这个动画是系统负责的。 在键盘动画的同时，应用收到一个“可用空间变小了”的通知。 应用为了防止输入框被键盘遮挡，只能跳变式地将整个聊天列表和输入框向上移动。 结果： 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。 使用 Insets 动画 (解决方案):\n点击输入框。 应用接管键盘的动画控制权。 在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并同步地、等速地将自己的聊天列表和输入框也向上推。 结果： 在用户看来，整个过程是一个连贯的动画：仿佛是键盘“推”着聊天内容向上移动，非常自然、流畅。 场景 传统方式的问题 Insets 动画的效果 聊天应用 键盘动画与内容移动分离，内容跳变 键盘平滑推起内容，动画无缝衔接 2. 沉浸式模式的过渡 (Video \u0026 Photo Apps) 当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。\n传统体验 (问题所在):\n你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。 系统状态栏和导航栏突然出现或淡入。 应用内容区域（图片）为了适应变小的空间，突然缩放或移动。 结果： 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。 使用 Insets 动画 (解决方案):\n点击屏幕。 应用接管状态栏和导航栏的动画。 当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都同步地、平滑地将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。 结果： 整个过渡非常优雅，感觉像是画面和系统栏一起构成了一场精心编排的转场动画。 3. 高级交互场景：手势控制动画 这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。\n场景描述：可拖拽的键盘 想象在一个笔记应用中，键盘已经弹出。你突然想看看被键盘挡住的文字，但又不想完全收起键盘。 实现方式： 应用可以监听屏幕上的向下拖拽手势。 当用户手指向下滑动时，应用利用 Insets 动画控制器，实时地将键盘的位置与用户手指的位置绑定。 用户向下滑动 100 像素，键盘就跟着下降 100 像素，同时笔记内容也跟着向下移动 100 像素。 当用户松手时，应用可以判断是应该让键盘弹回原位，还是完全收起。 结果： 键盘不再是一个简单的“开/关”状态，而是变成了一个可以被用户自由拖拽、控制的“物理”对象，提供了“预览”、“窥探”等高级交互可能性。 4. 复杂布局的协调动画 场景描述：带输入框的底部工作表 (BottomSheet) 一个地图应用，你点击某个地点，底部弹出一个包含评论输入框的 BottomSheet。 当你点击评论框时，需要同时弹出键盘。 传统体验 (问题所在): BottomSheet 弹出的动画和键盘弹出的动画很难协调，经常会发生一个先动、一个后动，或者位置计算错误导致界面抖动的问题。 使用 Insets 动画 (解决方案): 应用可以完全控制键盘的动画。当 BottomSheet 向上滑动时，应用可以精确地让键盘以同样的速度或一个协调的曲线跟随 BottomSheet 一起向上滑动，实现两个组件天衣无缝的组合动画。 总结 类别 场景举例 核心价值 基础体验优化 聊天/输入框 消除键盘与内容移动的割裂感，实现平滑过渡 视觉效果增强 视频/图片全屏 优雅地处理系统 UI 的显隐，实现沉浸式的转场 高级交互创新 手势拖拽键盘 将系统 UI 动画变为可交互的，响应用户手势 复杂布局协调 底部面板与键盘联动 精确同步多个运动组件，避免动画冲突和抖动 总而言之，Insets 动画 API 将原本属于系统“黑盒”的 UI 动画控制权开放给了应用，让开发者能够打造出体验更统一、交互更丰富的界面。\n时序图 StatusBar的Inset动画调用堆栈 09-30 18:21:07.769 4336 4655 D SurfaceControl: Surface(name=78b05bb StatusBar)/@0x8e6b5fe - animation-leash of insets_animation setMatrix: dsdx = 1.0, dtdx = 0.0, dtdy = 0.0, dsdy = 1.0 09-30 18:21:07.769 4336 4655 D SurfaceControl: java.lang.Throwable 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.SurfaceControl$Transaction.setMatrix(SurfaceControl.java:3081) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.SurfaceControl$Transaction.setMatrix(SurfaceControl.java:3100) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.SyncRtSurfaceTransactionApplier.applyParams(SyncRtSurfaceTransactionApplier.java:108) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsAnimationThreadControlRunner$1.applySurfaceParams(InsetsAnimationThreadControlRunner.java:90) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsAnimationControlImpl.applyChangeInsets(InsetsAnimationControlImpl.java:298) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsAnimationThreadControlRunner$1.scheduleApplyChangeInsets(InsetsAnimationThreadControlRunner.java:70) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsAnimationControlImpl.setInsetsAndAlpha(InsetsAnimationControlImpl.java:270) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsAnimationControlImpl.finish(InsetsAnimationControlImpl.java:331) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController$InternalAnimationControlListener.onAnimationFinish(InsetsController.java:539) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController$InternalAnimationControlListener$2.onAnimationEnd(InsetsController.java:462) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.Animator$AnimatorListener.onAnimationEnd(Animator.java:711) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.Animator$AnimatorCaller$$ExternalSyntheticLambda1.call(Unknown Source:4) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.Animator.callOnList(Animator.java:669) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.Animator.notifyListeners(Animator.java:608) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.Animator.notifyEndListeners(Animator.java:633) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.ValueAnimator.endAnimation(ValueAnimator.java:1306) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.ValueAnimator.doAnimationFrame(ValueAnimator.java:1566) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.AnimationHandler.doAnimationFrame(AnimationHandler.java:328) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.AnimationHandler.-$$Nest$mdoAnimationFrame(Unknown Source:0) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.animation.AnimationHandler$1.doFrame(AnimationHandler.java:86) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1337) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1348) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer.doCallbacks(Choreographer.java:952) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer.doFrame(Choreographer.java:878) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1322) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Handler.handleCallback(Handler.java:958) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Handler.dispatchMessage(Handler.java:99) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Looper.loopOnce(Looper.java:205) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Looper.loop(Looper.java:294) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.HandlerThread.run(HandlerThread.java:67) 09-30 18:21:07.769 4336 4655 D SurfaceControl: Created from: java.lang.Throwable 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.SurfaceControl.(SurfaceControl.java:1267) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsSourceControl.(InsetsSourceControl.java:71) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.collectSourceControls(InsetsController.java:1498) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.controlAnimationUncheckedInner(InsetsController.java:1349) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.controlAnimationUnchecked(InsetsController.java:1280) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.applyAnimation(InsetsController.java:1769) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.applyAnimation(InsetsController.java:1745) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.show(InsetsController.java:1140) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.InsetsController.show(InsetsController.java:1068) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.ViewRootImpl.controlInsetsForCompatibility(ViewRootImpl.java:2693) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:3179) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:2465) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:9305) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1339) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1348) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer.doCallbacks(Choreographer.java:952) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer.doFrame(Choreographer.java:882) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1322) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Handler.handleCallback(Handler.java:958) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Handler.dispatchMessage(Handler.java:99) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Looper.loopOnce(Looper.java:205) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.os.Looper.loop(Looper.java:294) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at android.app.ActivityThread.main(ActivityThread.java:8177) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at java.lang.reflect.Method.invoke(Native Method) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552) 09-30 18:21:07.769 4336 4655 D SurfaceControl: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971) 流程图总览 该流程图详细描绘了一个现代 Android 系统中非常强大且高效的动画机制：由第三方应用临时接管并驱动系统级 UI（如此处的状态栏）动画的全过程。\n核心思想是，为了实现应用内容与系统 UI (如状态栏、导航栏、键盘) 之间天衣无缝的过渡动画，系统 (WMS) 可以选择将系统 UI 对应图层 (Surface) 的动画控制权，临时授权给当前的应用。应用在获得授权后，负责计算动画的每一帧，并通过 RenderThread 直接将变换指令提交给系统的最终合成器 SurfaceFlinger。\n这套机制彻底解决了过去因应用和系统动画不同步而导致的“跳变”或“割裂感”问题，创造出极致平滑的视觉体验。\n分步时序详解 整个流程可以分为三个主要阶段：\n阶段一：动画授权与准备 (Authorization \u0026 Preparation) 这个阶段是整个协作的“握手”和“授权”环节。\n应用发起请求: 故事始于您的应用 com.UCMobile (App) 向 WindowManagerService (WMS) 发起一个将导致界面 Insets 变化的请求，最常见的例子就是请求进入全屏模式。 WMS 决策与授权: WMS 作为系统窗口的“总管”，接收到请求。它判断需要隐藏状态栏，并且发现 com.UCMobile 应用具备处理并监听了此类动画的能力。因此，WMS 决定不亲自播放系统默认的隐藏动画，而是将这个任务委托出去。 移交控制权: WMS 通知 SystemUI 进程准备好状态栏，但不要播放动画。同时，WMS 创建一个 InsetsSourceControl 对象，它包含了一个关键的凭证——状态栏 Surface 的 Leash (一个可以被跨进程操作的“遥控器”)。WMS 随后通过 Binder 调用 controlWindowInsetsAnimation，将这个“遥控器”发送给 com.UCMobile 应用。 应用准备就绪: 应用的主线程 (AppMain) 收到授权后，在其内部创建 InsetsController 等管理类，为即将到来的动画做好准备。 阶段二：App 执行动画帧 (App Executes Animation Frames) 这是流程的核心，应用开始真正地“导演”这场动画。\n启动并委托动画: 应用主线程启动动画逻辑，但为了不阻塞主线程影响流畅性（这是一个关键的性能优化），它将计算和驱动动画的任务交给了另一个专用的动画线程 (AppAnim)。 VSYNC 驱动循环: 动画线程上的 Choreographer 与系统的显示刷新信号 (VSYNC) 同步。每当 VSYNC 信号到来时（例如每秒 60 或 120 次），Choreographer 就会触发一次 doFrame 回调，驱动动画向前“走”一帧。 计算并调度: 在 doFrame 回调中，ValueAnimator 等动画类会计算出当前帧状态栏应该处于的位置、透明度等属性。然后，动画线程并不直接操作视图，而是调用 applyParams 方法，将这些计算出的变换参数（如 Matrix 矩阵）调度给更为底层的渲染线程 (AppRT)。 提交渲染指令: 应用的 RenderThread 是一个专门与 GPU 和 SurfaceFlinger 打交道的线程。它接收到参数后，会创建一个 SurfaceControl.Transaction 对象（一个原子性的变更指令集），并将变换矩阵设置到它所持有的状态栏 Leash 上。最后，它调用 transaction.apply() 将这个指令集直接发送给 SurfaceFlinger。这个提交动作非常轻量，只是“发出命令”而已。 阶段三：动画结束 (Animation Ends) 动画结束回调: 由于动画是由应用内部的 ValueAnimator 驱动的，当它播放完毕时，会触发 onAnimationEnd 回调。 通知 WMS: 应用的动画线程通知主线程动画已结束。主线程随即调用 onAnimationFinish() 通知 WMS，表示“我已经完成了动画，现在可以将控制权交还了”。这标志着授权的结束。 SurfaceFlinger 最终合成: 在整个动画过程中，SurfaceFlinger 不断地接收来自 com.UCMobile 的 Transaction。在每个 VSYNC 时刻，SurfaceFlinger 会将收集到的所有 Transaction（无论来自哪个进程）一次性地、原子性地应用，然后将屏幕上所有图层（应用窗口、状态栏 Leash、导航栏等）合成为最终的一帧画面并显示在屏幕上。这保证了所有元素的运动都是完美同步的。 总结 这份流程图揭示了 Android UI 系统的一个精妙设计：通过授权和责任分离，实现了极致的性能和流畅度。应用负责计算动画逻辑，RenderThread 负责提交指令，SurfaceFlinger 负责最终合成。整个过程高效、解耦，是打造现代、流畅 Android 应用体验的关键所在。\n","wordCount":"782","inLanguage":"en","datePublished":"2025-09-29T10:22:54+08:00","dateModified":"2025-09-29T10:22:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/insets_animation_flow/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/>WindowManager</a></div><h1 class="post-title entry-hint-parent">Insets animation flow</h1><div class=post-meta><span title='2025-09-29 10:22:54 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;782 words</div></header><div class=post-content><p>Insets 动画 API 的核心价值在于<strong>消除系统 UI 动画和应用 UI 动画之间的“割裂感”</strong>，将两者融合成一个平滑、无缝的整体。</p><p>以下是一些典型的应用场景，从最常见到更高级的交互：</p><h3 id=1-核心场景键盘的显示与隐藏-messaging--input>1. 核心场景：键盘的显示与隐藏 (Messaging & Input)<a hidden class=anchor aria-hidden=true href=#1-核心场景键盘的显示与隐藏-messaging--input>#</a></h3><p>这是最经典、最能体现其价值的场景。</p><ul><li><p><strong>传统体验 (问题所在):</strong></p><ul><li>在一个聊天应用里，你点击底部的输入框。</li><li>键盘从底部滑出，这个动画是系统负责的。</li><li>在键盘动画的同时，应用收到一个“可用空间变小了”的通知。</li><li>应用为了防止输入框被键盘遮挡，只能<strong>跳变式地</strong>将整个聊天列表和输入框向上移动。</li><li><strong>结果：</strong> 用户会感觉键盘和聊天界面是两个独立的东西在动，体验很生硬。</li></ul></li><li><p><strong>使用 Insets 动画 (解决方案):</strong></p><ul><li>点击输入框。</li><li>应用接管键盘的动画控制权。</li><li>在键盘从底部向上滑出的每一帧，应用都精确地计算出键盘的当前高度，并<strong>同步地、等速地</strong>将自己的聊天列表和输入框也向上推。</li><li><strong>结果：</strong> 在用户看来，整个过程是一个连贯的动画：<strong>仿佛是键盘“推”着聊天内容向上移动</strong>，非常自然、流畅。</li></ul></li></ul><table><thead><tr><th style=text-align:left>场景</th><th style=text-align:left>传统方式的问题</th><th style=text-align:left>Insets 动画的效果</th></tr></thead><tbody><tr><td style=text-align:left>聊天应用</td><td style=text-align:left>键盘动画与内容移动分离，内容<strong>跳变</strong></td><td style=text-align:left>键盘<strong>平滑推起</strong>内容，动画无缝衔接</td></tr></tbody></table><h3 id=2-沉浸式模式的过渡-video--photo-apps>2. 沉浸式模式的过渡 (Video & Photo Apps)<a hidden class=anchor aria-hidden=true href=#2-沉浸式模式的过渡-video--photo-apps>#</a></h3><p>当应用进入或退出全屏（沉浸式）模式时，状态栏和导航栏会显示或隐藏。</p><ul><li><p><strong>传统体验 (问题所在):</strong></p><ul><li>你在一个相册应用中全屏查看一张图片。你点击屏幕，希望退出全屏。</li><li>系统状态栏和导航栏<strong>突然出现</strong>或<strong>淡入</strong>。</li><li>应用内容区域（图片）为了适应变小的空间，<strong>突然缩放或移动</strong>。</li><li><strong>结果：</strong> 动画不协调，感觉像是系统 UI 粗暴地“覆盖”在了内容上。</li></ul></li><li><p><strong>使用 Insets 动画 (解决方案):</strong></p><ul><li>点击屏幕。</li><li>应用接管状态栏和导航栏的动画。</li><li>当状态栏从顶部滑入、导航栏从底部滑入的每一帧，应用都<strong>同步地、平滑地</strong>将图片进行缩放和平移，使其正好填充在两个系统栏之间的新空间里。</li><li><strong>结果：</strong> 整个过渡非常优雅，感觉像是<strong>画面和系统栏一起构成了一场精心编排的转场动画</strong>。</li></ul></li></ul><h3 id=3-高级交互场景手势控制动画>3. 高级交互场景：手势控制动画<a hidden class=anchor aria-hidden=true href=#3-高级交互场景手势控制动画>#</a></h3><p>这是 Insets 动画 API 强大灵活性的体现，允许开发者创造更丰富的交互。</p><ul><li><strong>场景描述：可拖拽的键盘</strong><ul><li>想象在一个笔记应用中，键盘已经弹出。你突然想看看被键盘挡住的文字，但又不想完全收起键盘。</li><li><strong>实现方式：</strong> 应用可以监听屏幕上的向下拖拽手势。</li><li>当用户手指向下滑动时，应用利用 Insets 动画控制器，<strong>实时地将键盘的位置与用户手指的位置绑定</strong>。</li><li>用户向下滑动 100 像素，键盘就跟着下降 100 像素，同时笔记内容也跟着向下移动 100 像素。</li><li>当用户松手时，应用可以判断是应该让键盘弹回原位，还是完全收起。</li><li><strong>结果：</strong> 键盘不再是一个简单的“开/关”状态，而是变成了一个<strong>可以被用户自由拖拽、控制的“物理”对象</strong>，提供了“预览”、“窥探”等高级交互可能性。</li></ul></li></ul><h3 id=4-复杂布局的协调动画>4. 复杂布局的协调动画<a hidden class=anchor aria-hidden=true href=#4-复杂布局的协调动画>#</a></h3><ul><li><strong>场景描述：带输入框的底部工作表 (BottomSheet)</strong><ul><li>一个地图应用，你点击某个地点，底部弹出一个包含评论输入框的 BottomSheet。</li><li>当你点击评论框时，需要同时弹出键盘。</li><li><strong>传统体验 (问题所在):</strong> BottomSheet 弹出的动画和键盘弹出的动画很难协调，经常会发生一个先动、一个后动，或者位置计算错误导致界面抖动的问题。</li><li><strong>使用 Insets 动画 (解决方案):</strong> 应用可以完全控制键盘的动画。当 BottomSheet 向上滑动时，应用可以<strong>精确地让键盘以同样的速度或一个协调的曲线</strong>跟随 BottomSheet 一起向上滑动，实现两个组件天衣无缝的组合动画。</li></ul></li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><table><thead><tr><th style=text-align:left>类别</th><th style=text-align:left>场景举例</th><th style=text-align:left>核心价值</th></tr></thead><tbody><tr><td style=text-align:left><strong>基础体验优化</strong></td><td style=text-align:left>聊天/输入框</td><td style=text-align:left>消除键盘与内容移动的<strong>割裂感</strong>，实现平滑过渡</td></tr><tr><td style=text-align:left><strong>视觉效果增强</strong></td><td style=text-align:left>视频/图片全屏</td><td style=text-align:left>优雅地处理系统 UI 的显隐，实现<strong>沉浸式</strong>的转场</td></tr><tr><td style=text-align:left><strong>高级交互创新</strong></td><td style=text-align:left>手势拖拽键盘</td><td style=text-align:left>将系统 UI 动画变为<strong>可交互</strong>的，响应用户手势</td></tr><tr><td style=text-align:left><strong>复杂布局协调</strong></td><td style=text-align:left>底部面板与键盘联动</td><td style=text-align:left>精确同步多个运动组件，避免<strong>动画冲突和抖动</strong></td></tr></tbody></table><p>总而言之，Insets 动画 API 将原本属于系统“黑盒”的 UI 动画控制权开放给了应用，让开发者能够打造出体验更统一、交互更丰富的界面。</p><h3 id=时序图>时序图<a hidden class=anchor aria-hidden=true href=#时序图>#</a></h3><p><img loading=lazy src=/ethenslab/images/Insets_animation_flow.png></p><p><img loading=lazy src=/ethenslab/images/inputmethod_inset_animation.png></p><h3 id=statusbar的inset动画调用堆栈>StatusBar的Inset动画调用堆栈<a hidden class=anchor aria-hidden=true href=#statusbar的inset动画调用堆栈>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: Surface(name=78b05bb StatusBar)/@0x8e6b5fe - animation-leash of insets_animation setMatrix: dsdx = 1.0, dtdx = 0.0, dtdy = 0.0, dsdy = 1.0
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: java.lang.Throwable
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.SurfaceControl$Transaction.setMatrix(SurfaceControl.java:3081)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.SurfaceControl$Transaction.setMatrix(SurfaceControl.java:3100)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.SyncRtSurfaceTransactionApplier.applyParams(SyncRtSurfaceTransactionApplier.java:108)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsAnimationThreadControlRunner$1.applySurfaceParams(InsetsAnimationThreadControlRunner.java:90)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsAnimationControlImpl.applyChangeInsets(InsetsAnimationControlImpl.java:298)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsAnimationThreadControlRunner$1.scheduleApplyChangeInsets(InsetsAnimationThreadControlRunner.java:70)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsAnimationControlImpl.setInsetsAndAlpha(InsetsAnimationControlImpl.java:270)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsAnimationControlImpl.finish(InsetsAnimationControlImpl.java:331)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController$InternalAnimationControlListener.onAnimationFinish(InsetsController.java:539)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController$InternalAnimationControlListener$2.onAnimationEnd(InsetsController.java:462)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.Animator$AnimatorListener.onAnimationEnd(Animator.java:711)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.Animator$AnimatorCaller$$ExternalSyntheticLambda1.call(Unknown Source:4)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.Animator.callOnList(Animator.java:669)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.Animator.notifyListeners(Animator.java:608)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.Animator.notifyEndListeners(Animator.java:633)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.ValueAnimator.endAnimation(ValueAnimator.java:1306)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.ValueAnimator.doAnimationFrame(ValueAnimator.java:1566)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.AnimationHandler.doAnimationFrame(AnimationHandler.java:328)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.AnimationHandler.-$$Nest$mdoAnimationFrame(Unknown Source:0)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.animation.AnimationHandler$1.doFrame(AnimationHandler.java:86)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1337)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1348)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer.doCallbacks(Choreographer.java:952)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer.doFrame(Choreographer.java:878)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1322)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Handler.handleCallback(Handler.java:958)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Handler.dispatchMessage(Handler.java:99)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Looper.loopOnce(Looper.java:205)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Looper.loop(Looper.java:294)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.HandlerThread.run(HandlerThread.java:67)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: Created from: java.lang.Throwable
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.SurfaceControl.&lt;init&gt;(SurfaceControl.java:1267)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsSourceControl.&lt;init&gt;(InsetsSourceControl.java:71)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.collectSourceControls(InsetsController.java:1498)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.controlAnimationUncheckedInner(InsetsController.java:1349)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.controlAnimationUnchecked(InsetsController.java:1280)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.applyAnimation(InsetsController.java:1769)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.applyAnimation(InsetsController.java:1745)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.show(InsetsController.java:1140)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.InsetsController.show(InsetsController.java:1068)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.ViewRootImpl.controlInsetsForCompatibility(ViewRootImpl.java:2693)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:3179)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:2465)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:9305)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1339)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1348)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer.doCallbacks(Choreographer.java:952)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer.doFrame(Choreographer.java:882)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:1322)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Handler.handleCallback(Handler.java:958)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Handler.dispatchMessage(Handler.java:99)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Looper.loopOnce(Looper.java:205)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.os.Looper.loop(Looper.java:294)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at android.app.ActivityThread.main(ActivityThread.java:8177)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at java.lang.reflect.Method.invoke(Native Method)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
</span></span><span style=display:flex><span>09-30 18:21:07.769  4336  4655 D SurfaceControl: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)
</span></span></code></pre></div><p><img loading=lazy src=/ethenslab/images/statusbar_inset_animation.png></p><h4 id=流程图总览>流程图总览<a hidden class=anchor aria-hidden=true href=#流程图总览>#</a></h4><p>该流程图详细描绘了一个现代 Android 系统中非常强大且高效的动画机制：<strong>由第三方应用临时接管并驱动系统级 UI（如此处的状态栏）动画的全过程</strong>。</p><p>核心思想是，为了实现应用内容与系统 UI (如状态栏、导航栏、键盘) 之间天衣无缝的过渡动画，系统 (WMS) 可以选择将系统 UI 对应图层 (Surface) 的动画控制权，临时<strong>授权</strong>给当前的应用。应用在获得授权后，负责计算动画的每一帧，并通过 <code>RenderThread</code> 直接将变换指令提交给系统的最终合成器 <code>SurfaceFlinger</code>。</p><p>这套机制彻底解决了过去因应用和系统动画不同步而导致的“跳变”或“割裂感”问题，创造出极致平滑的视觉体验。</p><h4 id=分步时序详解>分步时序详解<a hidden class=anchor aria-hidden=true href=#分步时序详解>#</a></h4><p>整个流程可以分为三个主要阶段：</p><h5 id=阶段一动画授权与准备-authorization--preparation>阶段一：动画授权与准备 (Authorization & Preparation)<a hidden class=anchor aria-hidden=true href=#阶段一动画授权与准备-authorization--preparation>#</a></h5><p>这个阶段是整个协作的“握手”和“授权”环节。</p><ol><li><strong>应用发起请求</strong>: 故事始于您的应用 <code>com.UCMobile</code> (App) 向 <code>WindowManagerService</code> (WMS) 发起一个将导致界面 Insets 变化的请求，最常见的例子就是请求进入全屏模式。</li><li><strong>WMS 决策与授权</strong>: WMS 作为系统窗口的“总管”，接收到请求。它判断需要隐藏状态栏，并且发现 <code>com.UCMobile</code> 应用具备处理并监听了此类动画的能力。因此，WMS 决定<strong>不亲自播放</strong>系统默认的隐藏动画，而是将这个任务<strong>委托</strong>出去。</li><li><strong>移交控制权</strong>: WMS 通知 <code>SystemUI</code> 进程准备好状态栏，但不要播放动画。同时，WMS 创建一个 <code>InsetsSourceControl</code> 对象，它包含了一个关键的凭证——状态栏 Surface 的 Leash (一个可以被跨进程操作的“遥控器”)。WMS 随后通过 Binder 调用 <code>controlWindowInsetsAnimation</code>，将这个“遥控器”发送给 <code>com.UCMobile</code> 应用。</li><li><strong>应用准备就绪</strong>: 应用的主线程 (<code>AppMain</code>) 收到授权后，在其内部创建 <code>InsetsController</code> 等管理类，为即将到来的动画做好准备。</li></ol><h5 id=阶段二app-执行动画帧-app-executes-animation-frames>阶段二：App 执行动画帧 (App Executes Animation Frames)<a hidden class=anchor aria-hidden=true href=#阶段二app-执行动画帧-app-executes-animation-frames>#</a></h5><p>这是流程的核心，应用开始真正地“导演”这场动画。</p><ol><li><strong>启动并委托动画</strong>: 应用主线程启动动画逻辑，但为了不阻塞主线程影响流畅性（这是一个关键的性能优化），它将计算和驱动动画的任务交给了另一个专用的<strong>动画线程 (<code>AppAnim</code>)</strong>。</li><li><strong>VSYNC 驱动循环</strong>: 动画线程上的 <code>Choreographer</code> 与系统的显示刷新信号 (VSYNC) 同步。每当 VSYNC 信号到来时（例如每秒 60 或 120 次），<code>Choreographer</code> 就会触发一次 <code>doFrame</code> 回调，驱动动画向前“走”一帧。</li><li><strong>计算并调度</strong>: 在 <code>doFrame</code> 回调中，<code>ValueAnimator</code> 等动画类会计算出当前帧状态栏应该处于的位置、透明度等属性。然后，动画线程并<strong>不直接操作视图</strong>，而是调用 <code>applyParams</code> 方法，将这些计算出的变换参数（如 Matrix 矩阵）<strong>调度</strong>给更为底层的<strong>渲染线程 (<code>AppRT</code>)</strong>。</li><li><strong>提交渲染指令</strong>: 应用的 <code>RenderThread</code> 是一个专门与 GPU 和 <code>SurfaceFlinger</code> 打交道的线程。它接收到参数后，会创建一个 <code>SurfaceControl.Transaction</code> 对象（一个原子性的变更指令集），并将变换矩阵设置到它所持有的状态栏 Leash 上。最后，它调用 <code>transaction.apply()</code> 将这个指令集直接发送给 <code>SurfaceFlinger</code>。这个提交动作非常轻量，只是“发出命令”而已。</li></ol><h5 id=阶段三动画结束-animation-ends>阶段三：动画结束 (Animation Ends)<a hidden class=anchor aria-hidden=true href=#阶段三动画结束-animation-ends>#</a></h5><ol><li><strong>动画结束回调</strong>: 由于动画是由应用内部的 <code>ValueAnimator</code> 驱动的，当它播放完毕时，会触发 <code>onAnimationEnd</code> 回调。</li><li><strong>通知 WMS</strong>: 应用的动画线程通知主线程动画已结束。主线程随即调用 <code>onAnimationFinish()</code> 通知 WMS，表示“我已经完成了动画，现在可以将控制权交还了”。这标志着授权的结束。</li><li><strong>SurfaceFlinger 最终合成</strong>: 在整个动画过程中，<code>SurfaceFlinger</code> 不断地接收来自 <code>com.UCMobile</code> 的 <code>Transaction</code>。在每个 VSYNC 时刻，<code>SurfaceFlinger</code> 会将收集到的所有 <code>Transaction</code>（无论来自哪个进程）一次性地、原子性地应用，然后将屏幕上所有图层（应用窗口、状态栏 Leash、导航栏等）合成为最终的一帧画面并显示在屏幕上。这保证了所有元素的运动都是完美同步的。</li></ol><h4 id=总结-1>总结<a hidden class=anchor aria-hidden=true href=#总结-1>#</a></h4><p>这份流程图揭示了 Android UI 系统的一个精妙设计：通过<strong>授权</strong>和<strong>责任分离</strong>，实现了极致的性能和流畅度。应用负责<strong>计算</strong>动画逻辑，<code>RenderThread</code> 负责<strong>提交</strong>指令，<code>SurfaceFlinger</code> 负责最终<strong>合成</strong>。整个过程高效、解耦，是打造现代、流畅 Android 应用体验的关键所在。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/activity-reparent/><span class=title>« Prev</span><br><span>Activity 跨屏幕迁移</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/splitscreen-wmshell/><span class=title>Next »</span><br><span>SplitScreenController flow</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>