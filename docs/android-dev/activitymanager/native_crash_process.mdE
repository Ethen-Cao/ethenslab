
这个时序图展示了从信号捕获、`crash_dump` 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。

### Native Process Crash 处理时序图

![](/ethenslab/images/android-Native-Process-Crash.png)

### 关键流程代码依据解析

1.  **信号拦截 (debuggerd_signal_handler)**

      * 当 Native 进程 Crash 时，内核回调 `debuggerd_signal_handler` 。
      * 代码中显式使用了 `pthread_mutex_lock`  确保同一时间只有一个线程处理 Crash。
      * 为了在不耗尽原进程文件描述符（FD）的情况下执行操作，代码调用 `clone` 创建了一个 **Pseudothread** 。

2.  **启动 crash_dump (Exec)**

      * Pseudothread 调用 `execle` 启动 `/apex/com.android.runtime/bin/crash_dump64` 。
      * 这里通过管道（Pipe）传递了 `Crashing TID` 和 `Pseudothread TID` 给 `crash_dump`。

3.  **握手与 Ptrace**

      * `crash_dump` 启动后，首先 `ptrace` 附着（Seize）目标进程的所有线程 。
      * 为了安全地读取内存，`crash_dump` 通过管道写 `\1` 通知 Pseudothread 。
      * Pseudothread 收到通知后，调用 `create_vm_process()` ，本质上是 `fork` 出一个子进程（镜像），供 `crash_dump` 读取内存，防止在读取过程中因目标进程内存损坏而卡死。
      * Pseudothread 将 `CrashInfo`（包含寄存器信息 `ucontext`）写入管道发送给 `crash_dump` 。

4.  **连接 Tombstoned**

      * `crash_dump` 调用 `connect_tombstone_server` 连接 `tombstoned` 守护进程 。
      * `tombstoned` 收到请求后（`kDumpRequest`），在 `/data/tombstones/` 下创建临时文件 ，并通过 Socket 将文件描述符（FD）传回给 `crash_dump` 。

5.  **生成 Tombstone 与 Logcat**

      * `crash_dump` 调用 `engrave_tombstone` 。
      * 它使用 `libunwindstack` 进行堆栈回溯，并将结果写入从 `tombstoned` 获取的 FD 中。
      * 同时，`tombstone_proto_to_text.cpp` 中的回调会调用 `_LOG` 函数 。
      * `_LOG` 函数会调用 `__android_log_buf_write` 将 Crash 的关键信息写入 **Logcat** (`LOG_ID_CRASH`) 。

6.  **通知 AMS**

      * `crash_dump` 调用 `activity_manager_notify` 。
      * 它连接 `/data/system/ndebugsocket` ，将 Crash 信息发送给 `ActivityManagerService`。
      * AMS 接收到数据后，会将其保存到 **DropBox** (`data_app_native_crash` 或 `system_app_native_crash`)。

7.  **清理与退出**

      * `crash_dump` 通知 `tombstoned` 完成转储 (`notify_completion`) 。`tombstoned` 此时将临时文件重命名为正式的 `tombstone_xx` 。
      * Pseudothread 调用 `resend_signal` ，将原本导致 Crash 的信号（如 SIGSEGV）重新发送给自己，确保父进程（Init 或 Zygote）能收到正确的退出状态码（WIFSIGNALED）。
  
基于提供的代码文件 `debuggerd_handler.cpp`，**Pseudothread（伪线程）** 是 Android `debuggerd` 机制中为了解决“在极端崩溃环境下安全启动 crash\_dump”而设计的一个极其巧妙的底层技巧。

它的核心目的是：**在进程可能已经耗尽文件描述符（FD Exhaustion）的情况下，依然能够成功创建管道（Pipe）并启动 `crash_dump` 进程。**

以下是 Pseudothread 的详细工作原理分析：

### 1\. 什么是 Pseudothread？

在 Linux 内核视角下，它是一个通过 `clone` 系统调用创建的执行流。它处于一种“似线程非线程”的中间状态：

  * **像线程：** 它共享父进程的地址空间（内存）。
  * **像进程：** 它**不共享**父进程的文件描述符表（File Descriptor Table）。

### 2\. 核心代码实现：`clone` 的魔法

在 `debuggerd_signal_handler` 函数中，代码并没有直接调用 `fork()` 或 `pthread_create()`，而是直接调用了 `clone()` 系统调用。

[cite_start]请看代码引用 [cite: 2636]：

```cpp
pid_t child_pid =
    clone(debuggerd_dispatch_pseudothread, pseudothread_stack,
          CLONE_THREAD | CLONE_SIGHAND | CLONE_VM | CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID,
          &thread_info, nullptr, nullptr, &thread_info.pseudothread_tid);
```

这里的关键在于 **Flags（标志位）** 的组合：

  * **`CLONE_VM`**: 共享内存。这使得 Pseudothread 可以直接读取崩溃线程的 `siginfo`、寄存器上下文等数据，无需复杂的 IPC。
  * **`CLONE_THREAD`**: 放入同一个线程组。
  * **`CLONE_SIGHAND`**: 共享信号处理表。
  * **关键点：缺少了 `CLONE_FILES`**。
      * 普通的 `pthread_create` 会包含 `CLONE_FILES`，意味着新线程和旧线程共享打开的文件句柄。
      * **Pseudothread 故意不加这个标志**。这意味着 Pseudothread 启动时，会**拷贝**一份父进程的文件描述符表，但在 Pseudothread 里关闭文件，**不会影响**原崩溃进程。

### 3\. Pseudothread 的执行流程 (`debuggerd_dispatch_pseudothread`)

Pseudothread 启动后，执行 `debuggerd_dispatch_pseudothread` 函数，其工作流如下：

#### A. 暴力腾挪空间 (FD Cleaning)

这是 Pseudothread 存在的最大意义。如果原进程是因为打开了太多文件（FD 耗尽）而 Crash 的，那么普通的 `fork` 或 `exec` 可能会因为无法打开管道或 Socket 而失败。

[cite_start]代码 [cite: 2540 - 2541]：

```cpp
for (int i = 0; i < 1024; ++i) {
    // Don't use close to avoid bionic's file descriptor ownership checks.
    syscall(__NR_close, i);
}
```

Pseudothread 会直接关闭自己拷贝过来的前 1024 个文件描述符。因为没有 `CLONE_FILES`，**这个操作是安全的，不会关闭原崩溃进程正在用的文件**（比如日志文件或数据库连接），但却为 Pseudothread 腾出了大量的空闲 FD。

#### B. 准备通信管道

[cite_start]腾出 FD 后，它终于可以安全地创建管道了 [cite: 2544]：

```cpp
if (!Pipe(&input_read, &input_write) != 0 || !Pipe(&output_read, &output_write)) {
    fatal_errno("failed to create pipe");
}
```

这些管道用于连接 `crash_dump` 进程。

#### C. 启动真正的 crash\_dump

[cite_start]准备好环境后，Pseudothread 调用 `_Fork()` (避免触发 pthread\_atfork 锁) 来创建子进程，并执行 `execle` 加载 `crash_dump64` [cite: 2558 - 2564]。

```cpp
execle(CRASH_DUMP_PATH, CRASH_DUMP_NAME, main_tid, pseudothread_tid, debuggerd_dump_type, nullptr, nullptr);
```

#### D. 中转数据与保活

1.  [cite_start]**握手：** `crash_dump` 启动后，会通过管道发送一个 `\1` 字节 [cite: 2567]。Pseudothread 收到这个字节，意味着 `crash_dump` 已经成功 `ptrace` 住了所有线程。
2.  [cite_start]**镜像进程：** 收到握手后，Pseudothread 调用 `create_vm_process()` [cite: 2569]，再次 `fork` 一个子进程。这个子进程是崩溃瞬间的**内存镜像**，专门供 `crash_dump` 读取内存。这样做是为了防止读取内存时卡死主进程。
3.  [cite_start]**阻塞等待：** 最后，Pseudothread 会读取管道等待，直到 `crash_dump` 完成工作。这实际上起到了**暂停崩溃进程**的作用，防止它过早退出导致 `tombstone` 生成失败 [cite: 2580]。

### 总结

**Pseudothread** 是 Android 系统编程中的一个“特种兵”。它利用 `clone` 系统调用的灵活性，创造了一个\*\*“内存共享但文件描述符独立”\*\*的特殊执行环境。

**解决了什么痛点？**

1.  **死锁规避：** 不使用 `malloc` 或 pthread 锁，直接使用 syscall。
2.  **资源耗尽保护：** 即使主进程 FD 耗尽（导致 Crash），Pseudothread 也能通过“私有化并清空 FD 表”的方式，强行腾出资源来启动调试进程，确保 Crash Log (Tombstone) 能够被抓取到。