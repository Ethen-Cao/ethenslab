<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ActivityManager on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/</link><description>Recent content in ActivityManager on Ethen 的实验室</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Mon, 29 Jul 2024 10:00:00 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/index.xml" rel="self" type="application/rss+xml"/><item><title>ActivityManager 深度解析</title><link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/</link><pubDate>Mon, 29 Jul 2024 10:00:00 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/</guid><description>&lt;p&gt;Activity Manager详解&lt;/p&gt;</description></item><item><title/><link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/</guid><description>&lt;p&gt;当 &lt;code&gt;startActivity&lt;/code&gt; 请求将一个已存在于主屏的 &lt;code&gt;Activity&lt;/code&gt; 移动到副屏时，核心决策发生在 &lt;code&gt;ActivityStarter&lt;/code&gt; 的 &lt;code&gt;setTargetRootTaskIfNeeded&lt;/code&gt; 方法中。该方法会直接调用 &lt;code&gt;Task.reparent()&lt;/code&gt; 来执行跨屏迁移。由于继承关系，这个调用最终会执行 &lt;code&gt;WindowContainer.reparent()&lt;/code&gt; 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部&lt;strong&gt;直接调用 &lt;code&gt;onDisplayChanged&lt;/code&gt;&lt;/strong&gt;，并将变更以递归方式通知到目标 &lt;code&gt;ActivityRecord&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="从-startactivity-到-ondisplaychanged-的精确流程与调用堆栈"&gt;从 &lt;code&gt;startActivity&lt;/code&gt; 到 &lt;code&gt;onDisplayChanged&lt;/code&gt; 的精确流程与调用堆栈&lt;/h3&gt;
&lt;h4 id="阶段一activitytaskmanagerservice--activitystarter---决策与指令发起"&gt;阶段一：ActivityTaskManagerService &amp;amp; ActivityStarter - 决策与指令发起&lt;/h4&gt;
&lt;p&gt;此阶段在 &lt;code&gt;system_server&lt;/code&gt; 的 ATMS 线程中进行，&lt;code&gt;ActivityStarter&lt;/code&gt; 是核心决策者。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;入口: &lt;code&gt;ActivityTaskManagerService.startActivity()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户或应用发起 &lt;code&gt;startActivity&lt;/code&gt; 请求，通过 Binder 调用进入 &lt;code&gt;ActivityTaskManagerService&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;ATMS 将请求委托给一个 &lt;code&gt;ActivityStarter&lt;/code&gt; 实例来处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ActivityStarter.execute()&lt;/code&gt; -&amp;gt; &lt;code&gt;startActivityUnchecked()&lt;/code&gt; -&amp;gt; &lt;code&gt;startActivityInner()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是所有 Activity 启动请求的统一处理流程。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;startActivityInner()&lt;/code&gt; 内部，系统会调用 &lt;code&gt;getReusableTask()&lt;/code&gt; 来寻找一个可以重用的、已存在的 &lt;code&gt;Task&lt;/code&gt;。在您的场景中，这一步会成功找到 &lt;code&gt;MainActivity&lt;/code&gt; 所在的 &lt;code&gt;Task&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为找到了 &lt;code&gt;reusedTask&lt;/code&gt;，流程会进入 &lt;code&gt;recycleTask()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ActivityStarter.recycleTask()&lt;/code&gt; -&amp;gt; &lt;code&gt;setTargetRootTaskIfNeeded()&lt;/code&gt;: 做出 &lt;code&gt;reparent&lt;/code&gt; 决策&lt;/strong&gt;&lt;/p&gt;</description></item><item><title/><link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_task_stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_task_stack/</guid><description>&lt;p&gt;ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)
Display #0 (activities from top to bottom):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Task{21a4759 #1 type=home U=0 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Task{836b5dc #211 type=home I=com.android.launcher3/.uioverrides.QuickstepLauncher U=0 rootTaskId=1 visible=true visibleRequested=true mode=fullscreen translucent=false sz=1}
mLastPausedActivity: ActivityRecord{6fa5a4f u0 com.android.launcher3/.uioverrides.QuickstepLauncher t211}
mLastNonFullscreenBounds=Rect(260, 635 - 821, 1715)
isSleeping=false
topResumedActivity=ActivityRecord{6fa5a4f u0 com.android.launcher3/.uioverrides.QuickstepLauncher t211}
&lt;ul&gt;
&lt;li&gt;Hist #0: ActivityRecord{6fa5a4f u0 com.android.launcher3/.uioverrides.QuickstepLauncher t211}
packageName=com.android.launcher3 processName=com.android.launcher3
launchedFromUid=0 launchedFromPackage=null launchedFromFeature=null userId=0
app=ProcessRecord{7863d74 2961:com.android.launcher3/u0a134}
Intent { act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000100 cmp=com.android.launcher3/.uioverrides.QuickstepLauncher (has extras) }
rootOfTask=true task=Task{836b5dc #211 type=home I=com.android.launcher3/.uioverrides.QuickstepLauncher}
taskAffinity=null
mActivityComponent=com.android.launcher3/.uioverrides.QuickstepLauncher
baseDir=/system_ext/priv-app/Launcher3QuickStep/Launcher3QuickStep.apk
dataDir=/data/user/0/com.android.launcher3
stateNotNeeded=true componentSpecified=false mActivityType=home
compat={420dpi} labelRes=0x7f11008e icon=0x7f080270 theme=0x7f12000c
mLastReportedConfigurations:
mGlobalConfig={1.0 ?mcc0mnc [en_US] ldltr sw411dp w411dp h792dp 420dpi nrml long hdr widecg port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2340) mAppBounds=Rect(0, 136 - 1080, 2214) mMaxBounds=Rect(0, 0 - 1080, 2340) mDisplayRotation=ROTATION_0 mWindowingMode=fullscreen mDisplayWindowingMode=fullscreen mActivityType=undefined mAlwaysOnTop=undefined mRotation=ROTATION_0} s.15 fontWeightAdjustment=0}
mOverrideConfig={1.0 ?mcc0mnc [en_US] ldltr sw411dp w411dp h792dp 420dpi nrml long hdr widecg port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2340) mAppBounds=Rect(0, 136 - 1080, 2214) mMaxBounds=Rect(0, 0 - 1080, 2340) mDisplayRotation=ROTATION_0 mWindowingMode=fullscreen mDisplayWindowingMode=fullscreen mActivityType=home mAlwaysOnTop=undefined mRotation=ROTATION_0} s.2 fontWeightAdjustment=0}
CurrentConfiguration={1.0 ?mcc0mnc [en_US] ldltr sw411dp w411dp h792dp 420dpi nrml long hdr widecg port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2340) mAppBounds=Rect(0, 136 - 1080, 2214) mMaxBounds=Rect(0, 0 - 1080, 2340) mDisplayRotation=ROTATION_0 mWindowingMode=fullscreen mDisplayWindowingMode=fullscreen mActivityType=home mAlwaysOnTop=undefined mRotation=ROTATION_0} s.2 fontWeightAdjustment=0}
RequestedOverrideConfiguration={0.0 ?mcc0mnc ?localeList ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?ldr ?wideColorGamut ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=null mMaxBounds=Rect(0, 0 - 0, 0) mDisplayRotation=undefined mWindowingMode=undefined mDisplayWindowingMode=undefined mActivityType=home mAlwaysOnTop=undefined mRotation=undefined} ?fontWeightAdjustment}
taskDescription: label=&amp;ldquo;null&amp;rdquo; icon=null iconResource=/0 iconFilename=null primaryColor=fff2f1e5
backgroundColor=fff2f1e5 statusBarColor=0 navigationBarColor=0
backgroundColorFloating=fff2f1e5
launchFailed=false launchCount=0 lastLaunchTime=-9m20s147ms
mHaveState=false mIcicle=null
state=RESUMED delayedResume=false finishing=false
keysPaused=false inHistory=true idle=true
occludesParent=true noDisplay=false immersive=false launchMode=2
frozenBeforeDestroy=false forceNewConfig=false
mActivityType=home
mImeInsetsFrozenUntilStartInput=false
windows=[Window{5cb5743 u0 com.android.launcher3/com.android.launcher3.uioverrides.QuickstepLauncher}]
windowType=2 waitingToShow=true
mOccludesParent=true
overrideOrientation=SCREEN_ORIENTATION_NOSENSOR
requestedOrientation=SCREEN_ORIENTATION_NOSENSOR
mVisibleRequested=true mVisible=true mClientVisible=true reportedDrawn=true reportedVisible=true
mNumInterestingWindows=1 mNumDrawnWindows=1 allDrawn=true lastAllDrawn=true)
startingData=null firstWindowDrawn=true mIsExiting=false
nowVisible=true lastVisibleTime=-1m3s817ms
connections={ConnectionRecord{bc23dfe u0 com.android.launcher3/com.android.quickstep.TouchInteractionService:@f9045b9 flags=0x0}}
resizeMode=RESIZE_MODE_RESIZEABLE
mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false
supportsSizeChanges=SIZE_CHANGES_UNSUPPORTED_METADATA
configChanges=0xdf3
neverSandboxDisplayApis=false
alwaysSandboxDisplayApis=false
areBoundsLetterboxed=false
mCameraCompatControlState=hidden
mCameraCompatControlEnabled=false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Task{46e36e5 #2 type=undefined U=0 visible=false visibleRequested=false mode=fullscreen translucent=true sz=2}
mCreatedByOrganizer=true&lt;/p&gt;</description></item><item><title/><link>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/native_crash_process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/native_crash_process/</guid><description>&lt;p&gt;这个时序图展示了从信号捕获、&lt;code&gt;crash_dump&lt;/code&gt; 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。&lt;/p&gt;
&lt;h3 id="native-process-crash-处理时序图"&gt;Native Process Crash 处理时序图&lt;/h3&gt;
&lt;p&gt;&lt;img loading="lazy" src="https://ethen-cao.github.io/ethenslab/images/android-Native-Process-Crash.png"&gt;&lt;/p&gt;
&lt;h3 id="关键流程代码依据解析"&gt;关键流程代码依据解析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号拦截 (debuggerd_signal_handler)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 Native 进程 Crash 时，内核回调 &lt;code&gt;debuggerd_signal_handler&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;代码中显式使用了 &lt;code&gt;pthread_mutex_lock&lt;/code&gt; 确保同一时间只有一个线程处理 Crash。&lt;/li&gt;
&lt;li&gt;为了在不耗尽原进程文件描述符（FD）的情况下执行操作，代码调用 &lt;code&gt;clone&lt;/code&gt; 创建了一个 &lt;strong&gt;Pseudothread&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动 crash_dump (Exec)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pseudothread 调用 &lt;code&gt;execle&lt;/code&gt; 启动 &lt;code&gt;/apex/com.android.runtime/bin/crash_dump64&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;这里通过管道（Pipe）传递了 &lt;code&gt;Crashing TID&lt;/code&gt; 和 &lt;code&gt;Pseudothread TID&lt;/code&gt; 给 &lt;code&gt;crash_dump&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;握手与 Ptrace&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;crash_dump&lt;/code&gt; 启动后，首先 &lt;code&gt;ptrace&lt;/code&gt; 附着（Seize）目标进程的所有线程 。&lt;/li&gt;
&lt;li&gt;为了安全地读取内存，&lt;code&gt;crash_dump&lt;/code&gt; 通过管道写 &lt;code&gt;\1&lt;/code&gt; 通知 Pseudothread 。&lt;/li&gt;
&lt;li&gt;Pseudothread 收到通知后，调用 &lt;code&gt;create_vm_process()&lt;/code&gt; ，本质上是 &lt;code&gt;fork&lt;/code&gt; 出一个子进程（镜像），供 &lt;code&gt;crash_dump&lt;/code&gt; 读取内存，防止在读取过程中因目标进程内存损坏而卡死。&lt;/li&gt;
&lt;li&gt;Pseudothread 将 &lt;code&gt;CrashInfo&lt;/code&gt;（包含寄存器信息 &lt;code&gt;ucontext&lt;/code&gt;）写入管道发送给 &lt;code&gt;crash_dump&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接 Tombstoned&lt;/strong&gt;&lt;/p&gt;</description></item></channel></rss>