<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="当 startActivity 请求将一个已存在于主屏的 Activity 移动到副屏时，核心决策发生在 ActivityStarter 的 setTargetRootTaskIfNeeded 方法中。该方法会直接调用 Task.reparent() 来执行跨屏迁移。由于继承关系，这个调用最终会执行 WindowContainer.reparent() 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部直接调用 onDisplayChanged，并将变更以递归方式通知到目标 ActivityRecord。
从 startActivity 到 onDisplayChanged 的精确流程与调用堆栈
阶段一：ActivityTaskManagerService & ActivityStarter - 决策与指令发起
此阶段在 system_server 的 ATMS 线程中进行，ActivityStarter 是核心决策者。


入口: ActivityTaskManagerService.startActivity()

用户或应用发起 startActivity 请求，通过 Binder 调用进入 ActivityTaskManagerService。
ATMS 将请求委托给一个 ActivityStarter 实例来处理。



ActivityStarter.execute() -> startActivityUnchecked() -> startActivityInner()

这是所有 Activity 启动请求的统一处理流程。
在 startActivityInner() 内部，系统会调用 getReusableTask() 来寻找一个可以重用的、已存在的 Task。在您的场景中，这一步会成功找到 MainActivity 所在的 Task。
因为找到了 reusedTask，流程会进入 recycleTask() 方法。



ActivityStarter.recycleTask() -> setTargetRootTaskIfNeeded(): 做出 reparent 决策"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="当 startActivity 请求将一个已存在于主屏的 Activity 移动到副屏时，核心决策发生在 ActivityStarter 的 setTargetRootTaskIfNeeded 方法中。该方法会直接调用 Task.reparent() 来执行跨屏迁移。由于继承关系，这个调用最终会执行 WindowContainer.reparent() 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部直接调用 onDisplayChanged，并将变更以递归方式通知到目标 ActivityRecord。
从 startActivity 到 onDisplayChanged 的精确流程与调用堆栈 阶段一：ActivityTaskManagerService & ActivityStarter - 决策与指令发起 此阶段在 system_server 的 ATMS 线程中进行，ActivityStarter 是核心决策者。
入口: ActivityTaskManagerService.startActivity()
用户或应用发起 startActivity 请求，通过 Binder 调用进入 ActivityTaskManagerService。 ATMS 将请求委托给一个 ActivityStarter 实例来处理。 ActivityStarter.execute() -> startActivityUnchecked() -> startActivityInner()
这是所有 Activity 启动请求的统一处理流程。 在 startActivityInner() 内部，系统会调用 getReusableTask() 来寻找一个可以重用的、已存在的 Task。在您的场景中，这一步会成功找到 MainActivity 所在的 Task。 因为找到了 reusedTask，流程会进入 recycleTask() 方法。 ActivityStarter.recycleTask() -> setTargetRootTaskIfNeeded(): 做出 reparent 决策"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="当 startActivity 请求将一个已存在于主屏的 Activity 移动到副屏时，核心决策发生在 ActivityStarter 的 setTargetRootTaskIfNeeded 方法中。该方法会直接调用 Task.reparent() 来执行跨屏迁移。由于继承关系，这个调用最终会执行 WindowContainer.reparent() 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部直接调用 onDisplayChanged，并将变更以递归方式通知到目标 ActivityRecord。
从 startActivity 到 onDisplayChanged 的精确流程与调用堆栈
阶段一：ActivityTaskManagerService & ActivityStarter - 决策与指令发起
此阶段在 system_server 的 ATMS 线程中进行，ActivityStarter 是核心决策者。


入口: ActivityTaskManagerService.startActivity()

用户或应用发起 startActivity 请求，通过 Binder 调用进入 ActivityTaskManagerService。
ATMS 将请求委托给一个 ActivityStarter 实例来处理。



ActivityStarter.execute() -> startActivityUnchecked() -> startActivityInner()

这是所有 Activity 启动请求的统一处理流程。
在 startActivityInner() 内部，系统会调用 getReusableTask() 来寻找一个可以重用的、已存在的 Task。在您的场景中，这一步会成功找到 MainActivity 所在的 Task。
因为找到了 reusedTask，流程会进入 recycleTask() 方法。



ActivityStarter.recycleTask() -> setTargetRootTaskIfNeeded(): 做出 reparent 决策"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"ActivityManager","item":"https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/"},{"@type":"ListItem","position":3,"name":"","item":"https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"当 startActivity 请求将一个已存在于主屏的 Activity 移动到副屏时，核心决策发生在 ActivityStarter 的 setTargetRootTaskIfNeeded 方法中。该方法会直接调用 Task.reparent() 来执行跨屏迁移。由于继承关系，这个调用最终会执行 WindowContainer.reparent() 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部直接调用 onDisplayChanged，并将变更以递归方式通知到目标 ActivityRecord。\n从 startActivity 到 onDisplayChanged 的精确流程与调用堆栈 阶段一：ActivityTaskManagerService \u0026amp; ActivityStarter - 决策与指令发起 此阶段在 system_server 的 ATMS 线程中进行，ActivityStarter 是核心决策者。\n入口: ActivityTaskManagerService.startActivity()\n用户或应用发起 startActivity 请求，通过 Binder 调用进入 ActivityTaskManagerService。 ATMS 将请求委托给一个 ActivityStarter 实例来处理。 ActivityStarter.execute() -\u0026gt; startActivityUnchecked() -\u0026gt; startActivityInner()\n这是所有 Activity 启动请求的统一处理流程。 在 startActivityInner() 内部，系统会调用 getReusableTask() 来寻找一个可以重用的、已存在的 Task。在您的场景中，这一步会成功找到 MainActivity 所在的 Task。 因为找到了 reusedTask，流程会进入 recycleTask() 方法。 ActivityStarter.recycleTask() -\u0026gt; setTargetRootTaskIfNeeded(): 做出 reparent 决策\n","keywords":[],"articleBody":"当 startActivity 请求将一个已存在于主屏的 Activity 移动到副屏时，核心决策发生在 ActivityStarter 的 setTargetRootTaskIfNeeded 方法中。该方法会直接调用 Task.reparent() 来执行跨屏迁移。由于继承关系，这个调用最终会执行 WindowContainer.reparent() 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部直接调用 onDisplayChanged，并将变更以递归方式通知到目标 ActivityRecord。\n从 startActivity 到 onDisplayChanged 的精确流程与调用堆栈 阶段一：ActivityTaskManagerService \u0026 ActivityStarter - 决策与指令发起 此阶段在 system_server 的 ATMS 线程中进行，ActivityStarter 是核心决策者。\n入口: ActivityTaskManagerService.startActivity()\n用户或应用发起 startActivity 请求，通过 Binder 调用进入 ActivityTaskManagerService。 ATMS 将请求委托给一个 ActivityStarter 实例来处理。 ActivityStarter.execute() -\u003e startActivityUnchecked() -\u003e startActivityInner()\n这是所有 Activity 启动请求的统一处理流程。 在 startActivityInner() 内部，系统会调用 getReusableTask() 来寻找一个可以重用的、已存在的 Task。在您的场景中，这一步会成功找到 MainActivity 所在的 Task。 因为找到了 reusedTask，流程会进入 recycleTask() 方法。 ActivityStarter.recycleTask() -\u003e setTargetRootTaskIfNeeded(): 做出 reparent 决策\n在 recycleTask() 方法中，它会调用 setTargetRootTaskIfNeeded() 来最终确定和调整 Activity 所在的 Task 的位置。 setTargetRootTaskIfNeeded() 方法会检查 ActivityOptions 中是否指定了 launchDisplayId，并据此找到或创建位于目标 Display 上的 mTargetRootTask。 当它发现 Activity 当前所在的 Task (intentTask) 并不在目标 mTargetRootTask 的层级下时（即跨屏），它就会调用 Task.reparent() 来执行移动。 关键源码佐证 (ActivityStarter.java 的 setTargetRootTaskIfNeeded 方法): private void setTargetRootTaskIfNeeded(ActivityRecord intentActivity) { // ... Task intentTask = intentActivity.getTask(); // ... // mTargetRootTask 会被设置为位于新 Display (如 display 3) 上的 Root Task mTargetRootTask = getOrCreateRootTask(...); // ... // 检查 intentActivity 是否已经在目标层级下 if (intentActivity.isDescendantOf(mTargetRootTask)) { // ... } else if (intentActivity.getWindowingMode() != WINDOWING_MODE_PINNED) { // 决策：需要移动 Task。直接调用 Task.reparent() intentTask.reparent(mTargetRootTask, ON_TOP, REPARENT_MOVE_ROOT_TASK_TO_FRONT, ANIMATE, DEFER_RESUME, \"reparentToTargetRootTask\"); mMovedToFront = true; } } 此阶段堆栈: com.android.server.wm.Task.reparent(Task.java:...) com.android.server.wm.ActivityStarter.setTargetRootTaskIfNeeded(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.recycleTask(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:...) com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:...) ... (Binder call from App) 阶段二：WindowContainer 层级 - 执行 reparent 并通知变更 此阶段由 ActivityStarter 的调用触发，进入了 WMS 核心数据结构的变更流程。\nTask.reparent() -\u003e WindowContainer.reparent()\nTask.reparent(Task, ...) 被调用。 在 Task.java 内部，这个方法会调用其另一个重载方法 reparent(newParent, position)。 由于 Task 继承自 TaskFragment，而 TaskFragment 继承自 WindowContainer，因此该调用会直接解析到 WindowContainer.java 中的 reparent(WindowContainer, int) 方法。 WindowContainer.reparent(): 转场动画的起点与变更的执行\n这是整个 reparent 和动画流程的核心。它负责发起动画、变更层级并触发通知。 关键源码佐证 (WindowContainer.java): void reparent(WindowContainer newParent, int position) { // ... // 1. 发起转场请求，创建 mCollectingTransition mTransitionController.collectReparentChange(this, newParent); // ... final DisplayContent prevDc = oldParent.getDisplayContent(); final DisplayContent dc = newParent.getDisplayContent(); // 2. 执行实际的父子关系变更 (removeChild / addChild) oldParent.removeChild(this); newParent.addChild(this, position); // ... if (prevDc != dc) { // 3. 直接调用 onDisplayChanged，启动递归通知 onDisplayChanged(dc); prevDc.setLayoutNeeded(); } // ... // 4. 在 onDisplayChanged 之后，才调用 onParentChanged onParentChanged(newParent, oldParent); } onDisplayChanged() 的递归调用\nWindowContainer.reparent() 在检测到 DisplayContent 发生变化后，直接调用 onDisplayChanged()。 该调用会从被 reparent 的 Task 开始，递归地向下传递给它的所有子容器。 到达最终目标: ActivityRecord.onDisplayChanged()\nTask.onDisplayChanged() 会遍历其下的 ActivityRecord 并调用它们的 onDisplayChanged() 方法。 最终的完整堆栈: // 这是 ActivityRecord.onDisplayChanged() 被调用时的完整堆栈 com.android.server.wm.ActivityRecord.onDisplayChanged(ActivityRecord.java:...) com.android.server.wm.WindowContainer.onDisplayChanged(WindowContainer.java:...) // ActivityRecord 的 super.onDisplayChanged com.android.server.wm.Task.onDisplayChanged(Task.java:...) // Task 分发给 ActivityRecord // 注意：onDisplayChanged 是被 reparent 直接调用的，而不是 onParentChanged com.android.server.wm.WindowContainer.reparent(WindowContainer.java:...) // reparent 流程的起点 com.android.server.wm.Task.reparent(Task.java:...) // 继承链调用 com.android.server.wm.ActivityStarter.setTargetRootTaskIfNeeded(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.recycleTask(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:...) com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:...) com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:...) ... (Binder call from App) WindowContainer.onParentChanged 触发 ActivityRecord.onConfigurationChanged WindowContainer继承自 ConfigurationContainer,在WindowContainer.reparent()中调用onParentChanged:\nWindowContainer.reparent() -\u003e WindowContainer.onParentChanged() -\u003e super.onParentChanged -\u003e ConfigurationContainer.onParentChanged() -\u003e ConfigurationContainer.onConfigurationChanged() -\u003e child.onConfigurationChanged -\u003e ActivityRecord.onConfigurationChanged() Relaunching ActivityRecord 当configuration改变后，在ActivityRecord visible更新的过程中，会触发relaunch。 ``` Moving to RESUMED Relaunching ActivityRecord{f40f734 u0 com.example.test/.MainActivity} t113} callers= com.android.server.wm.ActivityRecord.ensureActivityConfiguration:9479 com.android.server.wm.ActivityRecord.ensureActivityConfiguration:9310 com.android.server.wm.EnsureActivitiesVisibleHelper.setActivityVisibilityState:191 com.android.server.wm.EnsureActivitiesVisibleHelper.process:144 com.android.server.wm.TaskFragment.updateActivityVisibilities:1165 com.android.server.wm.Task.lambda$ensureActivitiesVisible$19:4895 ``` 下面是 Task.java的 `ensureActivitiesVisible` 实现 ```java /** * Ensure visibility with an option to also update the configuration of visible activities. * @see #ensureActivitiesVisible(ActivityRecord, int, boolean) * @see RootWindowContainer#ensureActivitiesVisible(ActivityRecord, int, boolean) * @param starting The top most activity in the task. * The activity is either starting or resuming. * Caller should ensure starting activity is visible. * @param notifyClients Flag indicating whether the visibility updates should be sent to the * clients in {@link EnsureActivitiesVisibleHelper}. * @param preserveWindows Flag indicating whether windows should be preserved when updating * configuration in {@link EnsureActivitiesVisibleHelper}. * @param configChanges Parts of the configuration that changed for this activity for evaluating * if the screen should be frozen as part of * {@link EnsureActivitiesVisibleHelper}. */ // TODO: Should be re-worked based on the fact that each task as a root task in most cases. void ensureActivitiesVisible(@Nullable ActivityRecord starting, int configChanges, boolean preserveWindows, boolean notifyClients) { mTaskSupervisor.beginActivityVisibilityUpdate(); try { forAllLeafTasks(task -\u003e { task.updateActivityVisibilities(starting, configChanges, preserveWindows, notifyClients); }, true /* traverseTopToBottom */); if (mTranslucentActivityWaiting != null \u0026\u0026 mUndrawnActivitiesBelowTopTranslucent.isEmpty()) { // Nothing is getting drawn or everything was already visible, don't wait for // timeout. notifyActivityDrawnLocked(null); } } finally { mTaskSupervisor.endActivityVisibilityUpdate(); } } ``` 在ensureActivityConfiguration中就会调用relaunchActivityLocked： ``` ActivityRecord.ensureActivityConfiguration： -\u003e ActivityRecord.relaunchActivityLocked -\u003e ActivityRecord.startFreezingScreenLocked ``` ","wordCount":"578","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_raparent/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/>ActivityManager</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>3 min&nbsp;·&nbsp;578 words</div></header><div class=post-content><p>当 <code>startActivity</code> 请求将一个已存在于主屏的 <code>Activity</code> 移动到副屏时，核心决策发生在 <code>ActivityStarter</code> 的 <code>setTargetRootTaskIfNeeded</code> 方法中。该方法会直接调用 <code>Task.reparent()</code> 来执行跨屏迁移。由于继承关系，这个调用最终会执行 <code>WindowContainer.reparent()</code> 方法，该方法是整个转场动画和窗口层级变更的真正起点，它在内部<strong>直接调用 <code>onDisplayChanged</code></strong>，并将变更以递归方式通知到目标 <code>ActivityRecord</code>。</p><h3 id=从-startactivity-到-ondisplaychanged-的精确流程与调用堆栈>从 <code>startActivity</code> 到 <code>onDisplayChanged</code> 的精确流程与调用堆栈<a hidden class=anchor aria-hidden=true href=#从-startactivity-到-ondisplaychanged-的精确流程与调用堆栈>#</a></h3><h4 id=阶段一activitytaskmanagerservice--activitystarter---决策与指令发起>阶段一：ActivityTaskManagerService & ActivityStarter - 决策与指令发起<a hidden class=anchor aria-hidden=true href=#阶段一activitytaskmanagerservice--activitystarter---决策与指令发起>#</a></h4><p>此阶段在 <code>system_server</code> 的 ATMS 线程中进行，<code>ActivityStarter</code> 是核心决策者。</p><ol><li><p><strong>入口: <code>ActivityTaskManagerService.startActivity()</code></strong></p><ul><li>用户或应用发起 <code>startActivity</code> 请求，通过 Binder 调用进入 <code>ActivityTaskManagerService</code>。</li><li>ATMS 将请求委托给一个 <code>ActivityStarter</code> 实例来处理。</li></ul></li><li><p><strong><code>ActivityStarter.execute()</code> -> <code>startActivityUnchecked()</code> -> <code>startActivityInner()</code></strong></p><ul><li>这是所有 Activity 启动请求的统一处理流程。</li><li>在 <code>startActivityInner()</code> 内部，系统会调用 <code>getReusableTask()</code> 来寻找一个可以重用的、已存在的 <code>Task</code>。在您的场景中，这一步会成功找到 <code>MainActivity</code> 所在的 <code>Task</code>。</li><li>因为找到了 <code>reusedTask</code>，流程会进入 <code>recycleTask()</code> 方法。</li></ul></li><li><p><strong><code>ActivityStarter.recycleTask()</code> -> <code>setTargetRootTaskIfNeeded()</code>: 做出 <code>reparent</code> 决策</strong></p><ul><li>在 <code>recycleTask()</code> 方法中，它会调用 <code>setTargetRootTaskIfNeeded()</code> 来最终确定和调整 <code>Activity</code> 所在的 <code>Task</code> 的位置。</li><li><code>setTargetRootTaskIfNeeded()</code> 方法会检查 <code>ActivityOptions</code> 中是否指定了 <code>launchDisplayId</code>，并据此找到或创建位于目标 Display 上的 <code>mTargetRootTask</code>。</li><li>当它发现 <code>Activity</code> 当前所在的 <code>Task</code> (<code>intentTask</code>) 并不在目标 <code>mTargetRootTask</code> 的层级下时（即跨屏），它就会调用 <code>Task.reparent()</code> 来执行移动。</li><li><strong>关键源码佐证 (<code>ActivityStarter.java</code> 的 <code>setTargetRootTaskIfNeeded</code> 方法)</strong>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setTargetRootTaskIfNeeded</span>(ActivityRecord intentActivity) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    Task intentTask <span style=color:#f92672>=</span> intentActivity.<span style=color:#a6e22e>getTask</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// mTargetRootTask 会被设置为位于新 Display (如 display 3) 上的 Root Task</span>
</span></span><span style=display:flex><span>    mTargetRootTask <span style=color:#f92672>=</span> getOrCreateRootTask(...);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查 intentActivity 是否已经在目标层级下</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (intentActivity.<span style=color:#a6e22e>isDescendantOf</span>(mTargetRootTask)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (intentActivity.<span style=color:#a6e22e>getWindowingMode</span>() <span style=color:#f92672>!=</span> WINDOWING_MODE_PINNED) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 决策：需要移动 Task。直接调用 Task.reparent()</span>
</span></span><span style=display:flex><span>        intentTask.<span style=color:#a6e22e>reparent</span>(mTargetRootTask, ON_TOP, REPARENT_MOVE_ROOT_TASK_TO_FRONT,
</span></span><span style=display:flex><span>                ANIMATE, DEFER_RESUME, <span style=color:#e6db74>&#34;reparentToTargetRootTask&#34;</span>);
</span></span><span style=display:flex><span>        mMovedToFront <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><strong>此阶段堆栈</strong>:<pre tabindex=0><code>com.android.server.wm.Task.reparent(Task.java:...)
com.android.server.wm.ActivityStarter.setTargetRootTaskIfNeeded(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.recycleTask(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:...)
com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:...)
... (Binder call from App)
</code></pre></li></ul></li></ol><h4 id=阶段二windowcontainer-层级---执行-reparent-并通知变更>阶段二：WindowContainer 层级 - 执行 <code>reparent</code> 并通知变更<a hidden class=anchor aria-hidden=true href=#阶段二windowcontainer-层级---执行-reparent-并通知变更>#</a></h4><p>此阶段由 <code>ActivityStarter</code> 的调用触发，进入了 WMS 核心数据结构的变更流程。</p><ol><li><p><strong><code>Task.reparent()</code> -> <code>WindowContainer.reparent()</code></strong></p><ul><li><code>Task.reparent(Task, ...)</code> 被调用。</li><li>在 <code>Task.java</code> 内部，这个方法会调用其另一个重载方法 <code>reparent(newParent, position)</code>。</li><li>由于 <code>Task</code> 继承自 <code>TaskFragment</code>，而 <code>TaskFragment</code> 继承自 <code>WindowContainer</code>，因此该调用会<strong>直接解析到 <code>WindowContainer.java</code> 中的 <code>reparent(WindowContainer, int)</code> 方法</strong>。</li></ul></li><li><p><strong><code>WindowContainer.reparent()</code>: 转场动画的起点与变更的执行</strong></p><ul><li>这是整个 <code>reparent</code> 和动画流程的核心。它负责发起动画、变更层级并触发通知。</li><li><strong>关键源码佐证 (<code>WindowContainer.java</code>)</strong>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>reparent</span>(WindowContainer newParent, <span style=color:#66d9ef>int</span> position) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 发起转场请求，创建 mCollectingTransition</span>
</span></span><span style=display:flex><span>    mTransitionController.<span style=color:#a6e22e>collectReparentChange</span>(<span style=color:#66d9ef>this</span>, newParent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> DisplayContent prevDc <span style=color:#f92672>=</span> oldParent.<span style=color:#a6e22e>getDisplayContent</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> DisplayContent dc <span style=color:#f92672>=</span> newParent.<span style=color:#a6e22e>getDisplayContent</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 执行实际的父子关系变更 (removeChild / addChild)</span>
</span></span><span style=display:flex><span>    oldParent.<span style=color:#a6e22e>removeChild</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    newParent.<span style=color:#a6e22e>addChild</span>(<span style=color:#66d9ef>this</span>, position);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prevDc <span style=color:#f92672>!=</span> dc) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. 直接调用 onDisplayChanged，启动递归通知</span>
</span></span><span style=display:flex><span>        onDisplayChanged(dc);
</span></span><span style=display:flex><span>        prevDc.<span style=color:#a6e22e>setLayoutNeeded</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 在 onDisplayChanged 之后，才调用 onParentChanged</span>
</span></span><span style=display:flex><span>    onParentChanged(newParent, oldParent);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul></li><li><p><strong><code>onDisplayChanged()</code> 的递归调用</strong></p><ul><li><code>WindowContainer.reparent()</code> 在检测到 <code>DisplayContent</code> 发生变化后，<strong>直接调用</strong> <code>onDisplayChanged()</code>。</li><li>该调用会从被 <code>reparent</code> 的 <code>Task</code> 开始，递归地向下传递给它的所有子容器。</li></ul></li><li><p><strong>到达最终目标: <code>ActivityRecord.onDisplayChanged()</code></strong></p><ul><li><code>Task.onDisplayChanged()</code> 会遍历其下的 <code>ActivityRecord</code> 并调用它们的 <code>onDisplayChanged()</code> 方法。</li><li><strong>最终的完整堆栈</strong>:<pre tabindex=0><code>// 这是 ActivityRecord.onDisplayChanged() 被调用时的完整堆栈
com.android.server.wm.ActivityRecord.onDisplayChanged(ActivityRecord.java:...)
com.android.server.wm.WindowContainer.onDisplayChanged(WindowContainer.java:...)  // ActivityRecord 的 super.onDisplayChanged
com.android.server.wm.Task.onDisplayChanged(Task.java:...)                      // Task 分发给 ActivityRecord
// 注意：onDisplayChanged 是被 reparent 直接调用的，而不是 onParentChanged
com.android.server.wm.WindowContainer.reparent(WindowContainer.java:...)           // reparent 流程的起点
com.android.server.wm.Task.reparent(Task.java:...)                                   // 继承链调用
com.android.server.wm.ActivityStarter.setTargetRootTaskIfNeeded(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.recycleTask(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.startActivityInner(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:...)
com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:...)
com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:...)
... (Binder call from App)
</code></pre></li></ul></li><li><p><strong>WindowContainer.onParentChanged 触发 ActivityRecord.onConfigurationChanged</strong>
WindowContainer继承自 ConfigurationContainer,在<code>WindowContainer.reparent()</code>中调用onParentChanged:</p><pre tabindex=0><code>WindowContainer.reparent() 
 -&gt; WindowContainer.onParentChanged() 
     -&gt; super.onParentChanged 
         -&gt; ConfigurationContainer.onParentChanged() 
             -&gt; ConfigurationContainer.onConfigurationChanged() 
                 -&gt; child.onConfigurationChanged 
                     -&gt; ActivityRecord.onConfigurationChanged()
</code></pre></li></ol><h4 id=relaunching-activityrecord>Relaunching ActivityRecord<a hidden class=anchor aria-hidden=true href=#relaunching-activityrecord>#</a></h4><pre><code>当configuration改变后，在ActivityRecord visible更新的过程中，会触发relaunch。
```
Moving to RESUMED Relaunching ActivityRecord{f40f734 u0 com.example.test/.MainActivity} t113} callers=
com.android.server.wm.ActivityRecord.ensureActivityConfiguration:9479 
com.android.server.wm.ActivityRecord.ensureActivityConfiguration:9310 
com.android.server.wm.EnsureActivitiesVisibleHelper.setActivityVisibilityState:191 
com.android.server.wm.EnsureActivitiesVisibleHelper.process:144 
com.android.server.wm.TaskFragment.updateActivityVisibilities:1165 
com.android.server.wm.Task.lambda$ensureActivitiesVisible$19:4895
```

下面是 Task.java的 `ensureActivitiesVisible` 实现

```java
    /**
 * Ensure visibility with an option to also update the configuration of visible activities.
 * @see #ensureActivitiesVisible(ActivityRecord, int, boolean)
 * @see RootWindowContainer#ensureActivitiesVisible(ActivityRecord, int, boolean)
 * @param starting The top most activity in the task.
 *                 The activity is either starting or resuming.
 *                 Caller should ensure starting activity is visible.
 * @param notifyClients Flag indicating whether the visibility updates should be sent to the
 *                      clients in {@link EnsureActivitiesVisibleHelper}.
 * @param preserveWindows Flag indicating whether windows should be preserved when updating
 *                        configuration in {@link EnsureActivitiesVisibleHelper}.
 * @param configChanges Parts of the configuration that changed for this activity for evaluating
 *                      if the screen should be frozen as part of
 *                      {@link EnsureActivitiesVisibleHelper}.
 */
// TODO: Should be re-worked based on the fact that each task as a root task in most cases.
void ensureActivitiesVisible(@Nullable ActivityRecord starting, int configChanges,
        boolean preserveWindows, boolean notifyClients) {
    mTaskSupervisor.beginActivityVisibilityUpdate();
    try {
        forAllLeafTasks(task -&gt; {
            task.updateActivityVisibilities(starting, configChanges, preserveWindows,
                    notifyClients);
        }, true /* traverseTopToBottom */);

        if (mTranslucentActivityWaiting != null &amp;&amp;
                mUndrawnActivitiesBelowTopTranslucent.isEmpty()) {
            // Nothing is getting drawn or everything was already visible, don't wait for
            // timeout.
            notifyActivityDrawnLocked(null);
        }
    } finally {
        mTaskSupervisor.endActivityVisibilityUpdate();
    }
}
```

在ensureActivityConfiguration中就会调用relaunchActivityLocked：
```
ActivityRecord.ensureActivityConfiguration：
    -&gt; ActivityRecord.relaunchActivityLocked 
        -&gt; ActivityRecord.startFreezingScreenLocked
```
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activitymanager/><span class=title>« Prev</span><br><span>ActivityManager 深度解析</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/activitymanager/activity_task_stack/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>