<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android App Java Crash 捕捉流程分析 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 App 进程 到 System Server 进程 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：

  @startuml
skinparam theme plain
skinparam shadowing false
skinparam DefaultFontName "SansSerif"
skinparam DefaultFontSize 12
skinparam ActivityIconSize 42

&#39; 强制黑字以提高可见性
skinparam sequence {
    ParticipantPadding 30
    MessageAlign center
    ArrowColor #263238
    ActorBorderColor #263238
    LifeLineBorderColor #263238
    ParticipantBorderColor #263238
    ParticipantBackgroundColor #ECEFF1
    ParticipantFontColor #000000
    GroupBorderColor #263238
    GroupFontColor #000000
}

participant "App Process\n(JVM)" as App
participant "RuntimeInit" as RI
participant "ActivityManagerService\n(AMS)" as AMS
participant "AppErrors" as AE
participant "DropBoxManagerService" as DBMS
participant "Statsd\n(Native Daemon)" as Statsd

== 阶段 1: 异常捕获与堆栈提取 (App 进程) ==

App -> App : 抛出 Exception
note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧)

App -> RI : dispatchUncaughtException(e)
activate RI

RI -> RI : LoggingHandler.uncaughtException(e)
RI -> RI : logUncaught(..., e)
note right: **首次提取堆栈**：调用 e.printStackTrace() \n将内存堆栈转换为 String 输出至 Logcat

RI -> RI : new ParcelableCrashInfo(e)
note right: **堆栈封装**：将 Throwable 序列化为 \nCrashInfo 字符串，准备跨进程传输

RI -> AMS : handleApplicationCrash(token, crashInfo)
activate AMS

== 阶段 2: 系统级状态记录与统计 (system_server) ==

AMS -> AMS : handleApplicationCrashInner()

group 增量统计 (Incremental Metrics)
    AMS -> AMS : 检查是否为 Incremental package
end

group 与 Statsd 交互 (FrameworkStatsLog)
    AMS -> Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...)
    note right: 包含 crashInfo 中的 Exception Name
end

group 持久化记录 (DropBox)
    AMS -> DBMS : addErrorToDropBox(..., crashInfo)
    activate DBMS
    DBMS -> DBMS : 异步启动 Worker Thread
    DBMS -> DBMS : **堆栈落盘**：将 crashInfo.stackTrace \n与其他 Header 信息拼接并写入 \n/data/system/dropbox/ 压缩文件
    DBMS --> AMS : 返回
    deactivate DBMS
end

== 阶段 3: 策略决策与 UI 处理 (AppErrors) ==

AMS -> AE : crashApplication(r, crashInfo)
activate AE

AE -> AE : noteAppKill() 
note right: 将堆栈摘要存入 AppExitInfoManager

AE -> AE : handleAppCrashLSPB()

alt 达到崩溃上限 (Bad Process)
    AE -> AE : markBadProcess(..., stackTrace)
    note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射
    AE -> AMS : removeProcessLocked()
else 允许显示 UI
    AE -> AMS : 发送 SHOW_ERROR_UI_MSG
    AMS -> AE : AppErrorDialog.show(data)
    note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace
end

AE --> AMS : 返回结果
deactivate AE

== 阶段 4: 最终清理与自杀 (App 进程) ==

AMS --> RI : 处理完毕 (Binder 返回)
deactivate AMS

RI -> RI : Process.killProcess(myPid)
RI -> RI : System.exit(10)
deactivate RI

@enduml

1. 流程概览
当 Java 异常未被捕获时，虚拟机将控制权交给 Thread.UncaughtExceptionHandler。Android 默认通过 RuntimeInit 类安装了自定义处理器，启动四个阶段的处理：'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android-exception-handler/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android-exception-handler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android-exception-handler/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Android App Java Crash 捕捉流程分析"><meta property="og:description" content='在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 App 进程 到 System Server 进程 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：
@startuml skinparam theme plain skinparam shadowing false skinparam DefaultFontName "SansSerif" skinparam DefaultFontSize 12 skinparam ActivityIconSize 42 &#39; 强制黑字以提高可见性 skinparam sequence { ParticipantPadding 30 MessageAlign center ArrowColor #263238 ActorBorderColor #263238 LifeLineBorderColor #263238 ParticipantBorderColor #263238 ParticipantBackgroundColor #ECEFF1 ParticipantFontColor #000000 GroupBorderColor #263238 GroupFontColor #000000 } participant "App Process\n(JVM)" as App participant "RuntimeInit" as RI participant "ActivityManagerService\n(AMS)" as AMS participant "AppErrors" as AE participant "DropBoxManagerService" as DBMS participant "Statsd\n(Native Daemon)" as Statsd == 阶段 1: 异常捕获与堆栈提取 (App 进程) == App -> App : 抛出 Exception note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧) App -> RI : dispatchUncaughtException(e) activate RI RI -> RI : LoggingHandler.uncaughtException(e) RI -> RI : logUncaught(..., e) note right: **首次提取堆栈**：调用 e.printStackTrace() \n将内存堆栈转换为 String 输出至 Logcat RI -> RI : new ParcelableCrashInfo(e) note right: **堆栈封装**：将 Throwable 序列化为 \nCrashInfo 字符串，准备跨进程传输 RI -> AMS : handleApplicationCrash(token, crashInfo) activate AMS == 阶段 2: 系统级状态记录与统计 (system_server) == AMS -> AMS : handleApplicationCrashInner() group 增量统计 (Incremental Metrics) AMS -> AMS : 检查是否为 Incremental package end group 与 Statsd 交互 (FrameworkStatsLog) AMS -> Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...) note right: 包含 crashInfo 中的 Exception Name end group 持久化记录 (DropBox) AMS -> DBMS : addErrorToDropBox(..., crashInfo) activate DBMS DBMS -> DBMS : 异步启动 Worker Thread DBMS -> DBMS : **堆栈落盘**：将 crashInfo.stackTrace \n与其他 Header 信息拼接并写入 \n/data/system/dropbox/ 压缩文件 DBMS --> AMS : 返回 deactivate DBMS end == 阶段 3: 策略决策与 UI 处理 (AppErrors) == AMS -> AE : crashApplication(r, crashInfo) activate AE AE -> AE : noteAppKill() note right: 将堆栈摘要存入 AppExitInfoManager AE -> AE : handleAppCrashLSPB() alt 达到崩溃上限 (Bad Process) AE -> AE : markBadProcess(..., stackTrace) note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射 AE -> AMS : removeProcessLocked() else 允许显示 UI AE -> AMS : 发送 SHOW_ERROR_UI_MSG AMS -> AE : AppErrorDialog.show(data) note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace end AE --> AMS : 返回结果 deactivate AE == 阶段 4: 最终清理与自杀 (App 进程) == AMS --> RI : 处理完毕 (Binder 返回) deactivate AMS RI -> RI : Process.killProcess(myPid) RI -> RI : System.exit(10) deactivate RI @enduml 1. 流程概览 当 Java 异常未被捕获时，虚拟机将控制权交给 Thread.UncaughtExceptionHandler。Android 默认通过 RuntimeInit 类安装了自定义处理器，启动四个阶段的处理：'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T11:36:11+08:00"><meta property="article:modified_time" content="2025-09-29T11:36:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android App Java Crash 捕捉流程分析"><meta name=twitter:description content='在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 App 进程 到 System Server 进程 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：

  @startuml
skinparam theme plain
skinparam shadowing false
skinparam DefaultFontName "SansSerif"
skinparam DefaultFontSize 12
skinparam ActivityIconSize 42

&#39; 强制黑字以提高可见性
skinparam sequence {
    ParticipantPadding 30
    MessageAlign center
    ArrowColor #263238
    ActorBorderColor #263238
    LifeLineBorderColor #263238
    ParticipantBorderColor #263238
    ParticipantBackgroundColor #ECEFF1
    ParticipantFontColor #000000
    GroupBorderColor #263238
    GroupFontColor #000000
}

participant "App Process\n(JVM)" as App
participant "RuntimeInit" as RI
participant "ActivityManagerService\n(AMS)" as AMS
participant "AppErrors" as AE
participant "DropBoxManagerService" as DBMS
participant "Statsd\n(Native Daemon)" as Statsd

== 阶段 1: 异常捕获与堆栈提取 (App 进程) ==

App -> App : 抛出 Exception
note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧)

App -> RI : dispatchUncaughtException(e)
activate RI

RI -> RI : LoggingHandler.uncaughtException(e)
RI -> RI : logUncaught(..., e)
note right: **首次提取堆栈**：调用 e.printStackTrace() \n将内存堆栈转换为 String 输出至 Logcat

RI -> RI : new ParcelableCrashInfo(e)
note right: **堆栈封装**：将 Throwable 序列化为 \nCrashInfo 字符串，准备跨进程传输

RI -> AMS : handleApplicationCrash(token, crashInfo)
activate AMS

== 阶段 2: 系统级状态记录与统计 (system_server) ==

AMS -> AMS : handleApplicationCrashInner()

group 增量统计 (Incremental Metrics)
    AMS -> AMS : 检查是否为 Incremental package
end

group 与 Statsd 交互 (FrameworkStatsLog)
    AMS -> Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...)
    note right: 包含 crashInfo 中的 Exception Name
end

group 持久化记录 (DropBox)
    AMS -> DBMS : addErrorToDropBox(..., crashInfo)
    activate DBMS
    DBMS -> DBMS : 异步启动 Worker Thread
    DBMS -> DBMS : **堆栈落盘**：将 crashInfo.stackTrace \n与其他 Header 信息拼接并写入 \n/data/system/dropbox/ 压缩文件
    DBMS --> AMS : 返回
    deactivate DBMS
end

== 阶段 3: 策略决策与 UI 处理 (AppErrors) ==

AMS -> AE : crashApplication(r, crashInfo)
activate AE

AE -> AE : noteAppKill() 
note right: 将堆栈摘要存入 AppExitInfoManager

AE -> AE : handleAppCrashLSPB()

alt 达到崩溃上限 (Bad Process)
    AE -> AE : markBadProcess(..., stackTrace)
    note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射
    AE -> AMS : removeProcessLocked()
else 允许显示 UI
    AE -> AMS : 发送 SHOW_ERROR_UI_MSG
    AMS -> AE : AppErrorDialog.show(data)
    note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace
end

AE --> AMS : 返回结果
deactivate AE

== 阶段 4: 最终清理与自杀 (App 进程) ==

AMS --> RI : 处理完毕 (Binder 返回)
deactivate AMS

RI -> RI : Process.killProcess(myPid)
RI -> RI : System.exit(10)
deactivate RI

@enduml

1. 流程概览
当 Java 异常未被捕获时，虚拟机将控制权交给 Thread.UncaughtExceptionHandler。Android 默认通过 RuntimeInit 类安装了自定义处理器，启动四个阶段的处理：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":3,"name":"Android App Java Crash 捕捉流程分析","item":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android-exception-handler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android App Java Crash 捕捉流程分析","name":"Android App Java Crash 捕捉流程分析","description":"在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 App 进程 到 System Server 进程 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：\n@startuml skinparam theme plain skinparam shadowing false skinparam DefaultFontName \u0026#34;SansSerif\u0026#34; skinparam DefaultFontSize 12 skinparam ActivityIconSize 42 \u0026#39; 强制黑字以提高可见性 skinparam sequence { ParticipantPadding 30 MessageAlign center ArrowColor #263238 ActorBorderColor #263238 LifeLineBorderColor #263238 ParticipantBorderColor #263238 ParticipantBackgroundColor #ECEFF1 ParticipantFontColor #000000 GroupBorderColor #263238 GroupFontColor #000000 } participant \u0026#34;App Process\\n(JVM)\u0026#34; as App participant \u0026#34;RuntimeInit\u0026#34; as RI participant \u0026#34;ActivityManagerService\\n(AMS)\u0026#34; as AMS participant \u0026#34;AppErrors\u0026#34; as AE participant \u0026#34;DropBoxManagerService\u0026#34; as DBMS participant \u0026#34;Statsd\\n(Native Daemon)\u0026#34; as Statsd == 阶段 1: 异常捕获与堆栈提取 (App 进程) == App -\u0026gt; App : 抛出 Exception note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧) App -\u0026gt; RI : dispatchUncaughtException(e) activate RI RI -\u0026gt; RI : LoggingHandler.uncaughtException(e) RI -\u0026gt; RI : logUncaught(..., e) note right: **首次提取堆栈**：调用 e.printStackTrace() \\n将内存堆栈转换为 String 输出至 Logcat RI -\u0026gt; RI : new ParcelableCrashInfo(e) note right: **堆栈封装**：将 Throwable 序列化为 \\nCrashInfo 字符串，准备跨进程传输 RI -\u0026gt; AMS : handleApplicationCrash(token, crashInfo) activate AMS == 阶段 2: 系统级状态记录与统计 (system_server) == AMS -\u0026gt; AMS : handleApplicationCrashInner() group 增量统计 (Incremental Metrics) AMS -\u0026gt; AMS : 检查是否为 Incremental package end group 与 Statsd 交互 (FrameworkStatsLog) AMS -\u0026gt; Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...) note right: 包含 crashInfo 中的 Exception Name end group 持久化记录 (DropBox) AMS -\u0026gt; DBMS : addErrorToDropBox(..., crashInfo) activate DBMS DBMS -\u0026gt; DBMS : 异步启动 Worker Thread DBMS -\u0026gt; DBMS : **堆栈落盘**：将 crashInfo.stackTrace \\n与其他 Header 信息拼接并写入 \\n/data/system/dropbox/ 压缩文件 DBMS --\u0026gt; AMS : 返回 deactivate DBMS end == 阶段 3: 策略决策与 UI 处理 (AppErrors) == AMS -\u0026gt; AE : crashApplication(r, crashInfo) activate AE AE -\u0026gt; AE : noteAppKill() note right: 将堆栈摘要存入 AppExitInfoManager AE -\u0026gt; AE : handleAppCrashLSPB() alt 达到崩溃上限 (Bad Process) AE -\u0026gt; AE : markBadProcess(..., stackTrace) note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射 AE -\u0026gt; AMS : removeProcessLocked() else 允许显示 UI AE -\u0026gt; AMS : 发送 SHOW_ERROR_UI_MSG AMS -\u0026gt; AE : AppErrorDialog.show(data) note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace end AE --\u0026gt; AMS : 返回结果 deactivate AE == 阶段 4: 最终清理与自杀 (App 进程) == AMS --\u0026gt; RI : 处理完毕 (Binder 返回) deactivate AMS RI -\u0026gt; RI : Process.killProcess(myPid) RI -\u0026gt; RI : System.exit(10) deactivate RI @enduml 1. 流程概览 当 Java 异常未被捕获时，虚拟机将控制权交给 Thread.UncaughtExceptionHandler。Android 默认通过 RuntimeInit 类安装了自定义处理器，启动四个阶段的处理：\n","keywords":[],"articleBody":"在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 App 进程 到 System Server 进程 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：\n@startuml skinparam theme plain skinparam shadowing false skinparam DefaultFontName \"SansSerif\" skinparam DefaultFontSize 12 skinparam ActivityIconSize 42 ' 强制黑字以提高可见性 skinparam sequence { ParticipantPadding 30 MessageAlign center ArrowColor #263238 ActorBorderColor #263238 LifeLineBorderColor #263238 ParticipantBorderColor #263238 ParticipantBackgroundColor #ECEFF1 ParticipantFontColor #000000 GroupBorderColor #263238 GroupFontColor #000000 } participant \"App Process\\n(JVM)\" as App participant \"RuntimeInit\" as RI participant \"ActivityManagerService\\n(AMS)\" as AMS participant \"AppErrors\" as AE participant \"DropBoxManagerService\" as DBMS participant \"Statsd\\n(Native Daemon)\" as Statsd == 阶段 1: 异常捕获与堆栈提取 (App 进程) == App -\u003e App : 抛出 Exception note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧) App -\u003e RI : dispatchUncaughtException(e) activate RI RI -\u003e RI : LoggingHandler.uncaughtException(e) RI -\u003e RI : logUncaught(..., e) note right: **首次提取堆栈**：调用 e.printStackTrace() \\n将内存堆栈转换为 String 输出至 Logcat RI -\u003e RI : new ParcelableCrashInfo(e) note right: **堆栈封装**：将 Throwable 序列化为 \\nCrashInfo 字符串，准备跨进程传输 RI -\u003e AMS : handleApplicationCrash(token, crashInfo) activate AMS == 阶段 2: 系统级状态记录与统计 (system_server) == AMS -\u003e AMS : handleApplicationCrashInner() group 增量统计 (Incremental Metrics) AMS -\u003e AMS : 检查是否为 Incremental package end group 与 Statsd 交互 (FrameworkStatsLog) AMS -\u003e Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...) note right: 包含 crashInfo 中的 Exception Name end group 持久化记录 (DropBox) AMS -\u003e DBMS : addErrorToDropBox(..., crashInfo) activate DBMS DBMS -\u003e DBMS : 异步启动 Worker Thread DBMS -\u003e DBMS : **堆栈落盘**：将 crashInfo.stackTrace \\n与其他 Header 信息拼接并写入 \\n/data/system/dropbox/ 压缩文件 DBMS --\u003e AMS : 返回 deactivate DBMS end == 阶段 3: 策略决策与 UI 处理 (AppErrors) == AMS -\u003e AE : crashApplication(r, crashInfo) activate AE AE -\u003e AE : noteAppKill() note right: 将堆栈摘要存入 AppExitInfoManager AE -\u003e AE : handleAppCrashLSPB() alt 达到崩溃上限 (Bad Process) AE -\u003e AE : markBadProcess(..., stackTrace) note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射 AE -\u003e AMS : removeProcessLocked() else 允许显示 UI AE -\u003e AMS : 发送 SHOW_ERROR_UI_MSG AMS -\u003e AE : AppErrorDialog.show(data) note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace end AE --\u003e AMS : 返回结果 deactivate AE == 阶段 4: 最终清理与自杀 (App 进程) == AMS --\u003e RI : 处理完毕 (Binder 返回) deactivate AMS RI -\u003e RI : Process.killProcess(myPid) RI -\u003e RI : System.exit(10) deactivate RI @enduml 1. 流程概览 当 Java 异常未被捕获时，虚拟机将控制权交给 Thread.UncaughtExceptionHandler。Android 默认通过 RuntimeInit 类安装了自定义处理器，启动四个阶段的处理：\n异常捕获与提取：App 进程内格式化堆栈。 系统记录与统计：AMS 收集崩溃元数据并上报 Statsd。 策略决策与 UI：AppErrors 判断是否为“Bad Process”并决定是否弹出对话框。 清理与自杀：App 进程强制退出。 2. 详细阶段分析 2.1 阶段 1：异常捕获与堆栈提取 (App 进程) 当异常发生时，JVM 会自动填充 Throwable 对象的 Native 栈帧。\n堆栈文本化：LoggingHandler 调用 e.printStackTrace()。这是堆栈第一次从内存对象转换为可读字符串，并输出到 Logcat。 数据序列化：堆栈被封装进 ParcelableCrashInfo 对象中。该对象通过 Binder 驱动跨进程传输到 system_server 进程。 2.2 阶段 2：系统级记录与统计 (System Server) AMS (ActivityManagerService) 接收到崩溃调用后，执行以下核心操作：\n增量监控：如果是增量包（Incremental package），系统会获取加载进度，分析崩溃是否由于资源未下载完成导致。 数据埋点：通过 FrameworkStatsLog 向 Statsd 发送 APP_CRASH_OCCURRED 事件，用于系统稳定性大数据统计。 DropBox 持久化：调用 DropBoxManagerService。 异步处理：为避免阻塞 AMS，系统启动 Worker 线程。 落盘：堆栈连同 PID、UID、包名等 Header 信息被存入 /data/system/dropbox/，文件名通常以 data_app_crash 开头。 2.3 阶段 3：策略决策与 UI 处理 (AppErrors) AppErrors 负责根据崩溃历史决定如何处置该应用：\n重复崩溃限制 (Bad Process)：调用 handleAppCrashLSPB()。如果应用在短时间内连续崩溃（例如 30s 内 2 次），将被标记为 “Bad Process”，系统会直接杀掉进程并限制其自启动，不再弹出对话框。 用户交互：如果符合显示条件，AMS 会向 UiHandler 发送消息，弹出崩溃对话框。对话框中的“显示详情”数据来源正是阶段 1 中传输过来的 stackTrace。 2.4 阶段 4：最终清理与自杀 当 system_server 处理完毕并返回 Binder 调用后：\n自杀：App 进程通过 Process.killProcess(myPid) 确保彻底退出，避免残留的异常线程导致系统行为异常。 3. 特殊情况：system_server 崩溃 如果崩溃进程是 system_server 本身，流程会有显著不同：\n同步执行：为了确保在系统框架彻底崩溃前留下证据，DropBox 写入改为同步执行（不再启动新线程）。 全局重启：RuntimeInit 会设置系统属性 sys.system_server.crash_java，随后 init 进程会因为检测到关键服务死亡而重启整个 Zygote 树。 4. 调试与分析建议 提取堆栈：使用 adb shell dumpsys dropbox --print data_app_crash 查看历史崩溃堆栈。 查看计数：执行 getprop sys.system_server.crash_java 检查系统服务是否发生过崩溃重启。 Bad Process 状态：通过 adb shell dumpsys activity processes 检查应用是否被标记为坏进程。 ","wordCount":"484","inLanguage":"en","datePublished":"2025-09-29T11:36:11+08:00","dateModified":"2025-09-29T11:36:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android-exception-handler/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a></div><h1 class="post-title entry-hint-parent">Android App Java Crash 捕捉流程分析</h1><div class=post-meta><span title='2025-09-29 11:36:11 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;484 words</div></header><div class=post-content><p>在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 <strong>App 进程</strong> 到 <strong>System Server 进程</strong> 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：</p><pre class=plantuml-container style=display:none>
  <code class=language-plantuml>@startuml
skinparam theme plain
skinparam shadowing false
skinparam DefaultFontName &#34;SansSerif&#34;
skinparam DefaultFontSize 12
skinparam ActivityIconSize 42

&#39; 强制黑字以提高可见性
skinparam sequence {
    ParticipantPadding 30
    MessageAlign center
    ArrowColor #263238
    ActorBorderColor #263238
    LifeLineBorderColor #263238
    ParticipantBorderColor #263238
    ParticipantBackgroundColor #ECEFF1
    ParticipantFontColor #000000
    GroupBorderColor #263238
    GroupFontColor #000000
}

participant &#34;App Process\n(JVM)&#34; as App
participant &#34;RuntimeInit&#34; as RI
participant &#34;ActivityManagerService\n(AMS)&#34; as AMS
participant &#34;AppErrors&#34; as AE
participant &#34;DropBoxManagerService&#34; as DBMS
participant &#34;Statsd\n(Native Daemon)&#34; as Statsd

== 阶段 1: 异常捕获与堆栈提取 (App 进程) ==

App -&gt; App : 抛出 Exception
note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧)

App -&gt; RI : dispatchUncaughtException(e)
activate RI

RI -&gt; RI : LoggingHandler.uncaughtException(e)
RI -&gt; RI : logUncaught(..., e)
note right: **首次提取堆栈**：调用 e.printStackTrace() \n将内存堆栈转换为 String 输出至 Logcat

RI -&gt; RI : new ParcelableCrashInfo(e)
note right: **堆栈封装**：将 Throwable 序列化为 \nCrashInfo 字符串，准备跨进程传输

RI -&gt; AMS : handleApplicationCrash(token, crashInfo)
activate AMS

== 阶段 2: 系统级状态记录与统计 (system_server) ==

AMS -&gt; AMS : handleApplicationCrashInner()

group 增量统计 (Incremental Metrics)
    AMS -&gt; AMS : 检查是否为 Incremental package
end

group 与 Statsd 交互 (FrameworkStatsLog)
    AMS -&gt; Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...)
    note right: 包含 crashInfo 中的 Exception Name
end

group 持久化记录 (DropBox)
    AMS -&gt; DBMS : addErrorToDropBox(..., crashInfo)
    activate DBMS
    DBMS -&gt; DBMS : 异步启动 Worker Thread
    DBMS -&gt; DBMS : **堆栈落盘**：将 crashInfo.stackTrace \n与其他 Header 信息拼接并写入 \n/data/system/dropbox/ 压缩文件
    DBMS --&gt; AMS : 返回
    deactivate DBMS
end

== 阶段 3: 策略决策与 UI 处理 (AppErrors) ==

AMS -&gt; AE : crashApplication(r, crashInfo)
activate AE

AE -&gt; AE : noteAppKill() 
note right: 将堆栈摘要存入 AppExitInfoManager

AE -&gt; AE : handleAppCrashLSPB()

alt 达到崩溃上限 (Bad Process)
    AE -&gt; AE : markBadProcess(..., stackTrace)
    note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射
    AE -&gt; AMS : removeProcessLocked()
else 允许显示 UI
    AE -&gt; AMS : 发送 SHOW_ERROR_UI_MSG
    AMS -&gt; AE : AppErrorDialog.show(data)
    note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace
end

AE --&gt; AMS : 返回结果
deactivate AE

== 阶段 4: 最终清理与自杀 (App 进程) ==

AMS --&gt; RI : 处理完毕 (Binder 返回)
deactivate AMS

RI -&gt; RI : Process.killProcess(myPid)
RI -&gt; RI : System.exit(10)
deactivate RI

@enduml</code>
</pre><hr><h2 id=1-流程概览>1. 流程概览<a hidden class=anchor aria-hidden=true href=#1-流程概览>#</a></h2><p>当 Java 异常未被捕获时，虚拟机将控制权交给 <code>Thread.UncaughtExceptionHandler</code>。Android 默认通过 <code>RuntimeInit</code> 类安装了自定义处理器，启动四个阶段的处理：</p><ol><li><strong>异常捕获与提取</strong>：App 进程内格式化堆栈。</li><li><strong>系统记录与统计</strong>：AMS 收集崩溃元数据并上报 Statsd。</li><li><strong>策略决策与 UI</strong>：AppErrors 判断是否为“Bad Process”并决定是否弹出对话框。</li><li><strong>清理与自杀</strong>：App 进程强制退出。</li></ol><hr><h2 id=2-详细阶段分析>2. 详细阶段分析<a hidden class=anchor aria-hidden=true href=#2-详细阶段分析>#</a></h2><h3 id=21-阶段-1异常捕获与堆栈提取-app-进程>2.1 阶段 1：异常捕获与堆栈提取 (App 进程)<a hidden class=anchor aria-hidden=true href=#21-阶段-1异常捕获与堆栈提取-app-进程>#</a></h3><p>当异常发生时，JVM 会自动填充 <code>Throwable</code> 对象的 Native 栈帧。</p><ul><li><strong>堆栈文本化</strong>：<code>LoggingHandler</code> 调用 <code>e.printStackTrace()</code>。这是堆栈第一次从内存对象转换为可读字符串，并输出到 Logcat。</li><li><strong>数据序列化</strong>：堆栈被封装进 <code>ParcelableCrashInfo</code> 对象中。该对象通过 Binder 驱动跨进程传输到 <code>system_server</code> 进程。</li></ul><h3 id=22-阶段-2系统级记录与统计-system-server>2.2 阶段 2：系统级记录与统计 (System Server)<a hidden class=anchor aria-hidden=true href=#22-阶段-2系统级记录与统计-system-server>#</a></h3><p>AMS (ActivityManagerService) 接收到崩溃调用后，执行以下核心操作：</p><ul><li><strong>增量监控</strong>：如果是增量包（Incremental package），系统会获取加载进度，分析崩溃是否由于资源未下载完成导致。</li><li><strong>数据埋点</strong>：通过 <code>FrameworkStatsLog</code> 向 <code>Statsd</code> 发送 <code>APP_CRASH_OCCURRED</code> 事件，用于系统稳定性大数据统计。</li><li><strong>DropBox 持久化</strong>：调用 <code>DropBoxManagerService</code>。</li><li><strong>异步处理</strong>：为避免阻塞 AMS，系统启动 Worker 线程。</li><li><strong>落盘</strong>：堆栈连同 PID、UID、包名等 Header 信息被存入 <code>/data/system/dropbox/</code>，文件名通常以 <code>data_app_crash</code> 开头。</li></ul><h3 id=23-阶段-3策略决策与-ui-处理-apperrors>2.3 阶段 3：策略决策与 UI 处理 (AppErrors)<a hidden class=anchor aria-hidden=true href=#23-阶段-3策略决策与-ui-处理-apperrors>#</a></h3><p><code>AppErrors</code> 负责根据崩溃历史决定如何处置该应用：</p><ul><li><strong>重复崩溃限制 (Bad Process)</strong>：调用 <code>handleAppCrashLSPB()</code>。如果应用在短时间内连续崩溃（例如 30s 内 2 次），将被标记为 &ldquo;Bad Process&rdquo;，系统会直接杀掉进程并限制其自启动，不再弹出对话框。</li><li><strong>用户交互</strong>：如果符合显示条件，AMS 会向 <code>UiHandler</code> 发送消息，弹出崩溃对话框。对话框中的“显示详情”数据来源正是阶段 1 中传输过来的 <code>stackTrace</code>。</li></ul><h3 id=24-阶段-4最终清理与自杀>2.4 阶段 4：最终清理与自杀<a hidden class=anchor aria-hidden=true href=#24-阶段-4最终清理与自杀>#</a></h3><p>当 <code>system_server</code> 处理完毕并返回 Binder 调用后：</p><ul><li><strong>自杀</strong>：App 进程通过 <code>Process.killProcess(myPid)</code> 确保彻底退出，避免残留的异常线程导致系统行为异常。</li></ul><hr><h2 id=3-特殊情况system_server-崩溃>3. 特殊情况：system_server 崩溃<a hidden class=anchor aria-hidden=true href=#3-特殊情况system_server-崩溃>#</a></h2><p>如果崩溃进程是 <code>system_server</code> 本身，流程会有显著不同：</p><ul><li><strong>同步执行</strong>：为了确保在系统框架彻底崩溃前留下证据，<code>DropBox</code> 写入改为<strong>同步执行</strong>（不再启动新线程）。</li><li><strong>全局重启</strong>：<code>RuntimeInit</code> 会设置系统属性 <code>sys.system_server.crash_java</code>，随后 <code>init</code> 进程会因为检测到关键服务死亡而重启整个 Zygote 树。</li></ul><hr><h2 id=4-调试与分析建议>4. 调试与分析建议<a hidden class=anchor aria-hidden=true href=#4-调试与分析建议>#</a></h2><ul><li><strong>提取堆栈</strong>：使用 <code>adb shell dumpsys dropbox --print data_app_crash</code> 查看历史崩溃堆栈。</li><li><strong>查看计数</strong>：执行 <code>getprop sys.system_server.crash_java</code> 检查系统服务是否发生过崩溃重启。</li><li><strong>Bad Process 状态</strong>：通过 <code>adb shell dumpsys activity processes</code> 检查应用是否被标记为坏进程。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/debug/vscode-aosp/><span class=title>« Prev</span><br><span>使用 Visual Studio Code 高效开发 AOSP</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android_binderproxy_detection/><span class=title>Next »</span><br><span>Android Binder Proxy 限制机制</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>