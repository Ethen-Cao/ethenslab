<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android Perfetto "飞行记录仪" (Flight Recorder) 实施方案 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 需求概述
本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：

开机自启：系统启动后，自动启动 Perfetto 追踪服务。
内存循环录制：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留最近 15 秒的数据，不占用磁盘 I/O。
事件触发落盘：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。
自动复位：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。

2. 核心架构与流程
本方案利用 Android init 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 trigger 机制来实现“按需落盘”。
工作流程图

@startuml
!theme plain
autonumber
skinparam defaultFontName Arial

title Perfetto 循环录制与触发流程

participant "Android Init" as Init
participant "Service: polaris_logger" as Svc
participant "Perfetto Process" as Perfetto
participant "Disk Storage" as Disk

note over Svc: 状态: Running

Init -> Svc: 启动服务 (polaris_runner.sh)
Svc -> Perfetto: 启动 perfetto (阻塞模式)
activate Perfetto
Perfetto -> Perfetto: **内存循环录制 (Ring Buffer)**
note right of Perfetto: 仅在 RAM 中覆写数据\n不写入磁盘

... 系统运行中 (等待事件) ...

group 触发阶段
-> Init: setprop sys.polaris.dump 1
Init -> Perfetto: 发送 Trigger 信号
Perfetto -> Disk: **将 Buffer 数据写入文件**
Perfetto -> Perfetto: 停止录制 & 退出 (Exit 0)
deactivate Perfetto
end

Svc -> Init: 脚本执行结束 (Service Stopped)

group 自动复位
Init -> Init: 检测到服务非正常停止(非oneshot)
Init -> Svc: **重启服务 (Restart)**
Svc -> Perfetto: 再次启动 perfetto
activate Perfetto
note right of Perfetto: 开始新一轮循环录制
end

@enduml
3. 详细实施步骤
步骤 1：Perfetto 配置文件 (.pbtxt)
此配置定义了“怎么录”。核心是使用 RING_BUFFER 模式和 trigger_config。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perfetto/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perfetto/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perfetto/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content='Android Perfetto "飞行记录仪" (Flight Recorder) 实施方案'><meta property="og:description" content='1. 需求概述 本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：
开机自启：系统启动后，自动启动 Perfetto 追踪服务。 内存循环录制：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留最近 15 秒的数据，不占用磁盘 I/O。 事件触发落盘：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。 自动复位：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。 2. 核心架构与流程 本方案利用 Android init 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 trigger 机制来实现“按需落盘”。
工作流程图 @startuml !theme plain autonumber skinparam defaultFontName Arial title Perfetto 循环录制与触发流程 participant "Android Init" as Init participant "Service: polaris_logger" as Svc participant "Perfetto Process" as Perfetto participant "Disk Storage" as Disk note over Svc: 状态: Running Init -> Svc: 启动服务 (polaris_runner.sh) Svc -> Perfetto: 启动 perfetto (阻塞模式) activate Perfetto Perfetto -> Perfetto: **内存循环录制 (Ring Buffer)** note right of Perfetto: 仅在 RAM 中覆写数据\n不写入磁盘 ... 系统运行中 (等待事件) ... group 触发阶段 -> Init: setprop sys.polaris.dump 1 Init -> Perfetto: 发送 Trigger 信号 Perfetto -> Disk: **将 Buffer 数据写入文件** Perfetto -> Perfetto: 停止录制 & 退出 (Exit 0) deactivate Perfetto end Svc -> Init: 脚本执行结束 (Service Stopped) group 自动复位 Init -> Init: 检测到服务非正常停止(非oneshot) Init -> Svc: **重启服务 (Restart)** Svc -> Perfetto: 再次启动 perfetto activate Perfetto note right of Perfetto: 开始新一轮循环录制 end @enduml 3. 详细实施步骤 步骤 1：Perfetto 配置文件 (.pbtxt) 此配置定义了“怎么录”。核心是使用 RING_BUFFER 模式和 trigger_config。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T11:36:11+08:00"><meta property="article:modified_time" content="2025-09-29T11:36:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content='Android Perfetto "飞行记录仪" (Flight Recorder) 实施方案'><meta name=twitter:description content='1. 需求概述
本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：

开机自启：系统启动后，自动启动 Perfetto 追踪服务。
内存循环录制：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留最近 15 秒的数据，不占用磁盘 I/O。
事件触发落盘：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。
自动复位：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。

2. 核心架构与流程
本方案利用 Android init 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 trigger 机制来实现“按需落盘”。
工作流程图

@startuml
!theme plain
autonumber
skinparam defaultFontName Arial

title Perfetto 循环录制与触发流程

participant "Android Init" as Init
participant "Service: polaris_logger" as Svc
participant "Perfetto Process" as Perfetto
participant "Disk Storage" as Disk

note over Svc: 状态: Running

Init -> Svc: 启动服务 (polaris_runner.sh)
Svc -> Perfetto: 启动 perfetto (阻塞模式)
activate Perfetto
Perfetto -> Perfetto: **内存循环录制 (Ring Buffer)**
note right of Perfetto: 仅在 RAM 中覆写数据\n不写入磁盘

... 系统运行中 (等待事件) ...

group 触发阶段
-> Init: setprop sys.polaris.dump 1
Init -> Perfetto: 发送 Trigger 信号
Perfetto -> Disk: **将 Buffer 数据写入文件**
Perfetto -> Perfetto: 停止录制 & 退出 (Exit 0)
deactivate Perfetto
end

Svc -> Init: 脚本执行结束 (Service Stopped)

group 自动复位
Init -> Init: 检测到服务非正常停止(非oneshot)
Init -> Svc: **重启服务 (Restart)**
Svc -> Perfetto: 再次启动 perfetto
activate Perfetto
note right of Perfetto: 开始新一轮循环录制
end

@enduml
3. 详细实施步骤
步骤 1：Perfetto 配置文件 (.pbtxt)
此配置定义了“怎么录”。核心是使用 RING_BUFFER 模式和 trigger_config。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":3,"name":"Android Perfetto \"飞行记录仪\" (Flight Recorder) 实施方案","item":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perfetto/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android Perfetto \"飞行记录仪\" (Flight Recorder) 实施方案","name":"Android Perfetto \u0022飞行记录仪\u0022 (Flight Recorder) 实施方案","description":"1. 需求概述 本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：\n开机自启：系统启动后，自动启动 Perfetto 追踪服务。 内存循环录制：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留最近 15 秒的数据，不占用磁盘 I/O。 事件触发落盘：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。 自动复位：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。 2. 核心架构与流程 本方案利用 Android init 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 trigger 机制来实现“按需落盘”。\n工作流程图 @startuml !theme plain autonumber skinparam defaultFontName Arial title Perfetto 循环录制与触发流程 participant \u0026#34;Android Init\u0026#34; as Init participant \u0026#34;Service: polaris_logger\u0026#34; as Svc participant \u0026#34;Perfetto Process\u0026#34; as Perfetto participant \u0026#34;Disk Storage\u0026#34; as Disk note over Svc: 状态: Running Init -\u0026gt; Svc: 启动服务 (polaris_runner.sh) Svc -\u0026gt; Perfetto: 启动 perfetto (阻塞模式) activate Perfetto Perfetto -\u0026gt; Perfetto: **内存循环录制 (Ring Buffer)** note right of Perfetto: 仅在 RAM 中覆写数据\\n不写入磁盘 ... 系统运行中 (等待事件) ... group 触发阶段 -\u0026gt; Init: setprop sys.polaris.dump 1 Init -\u0026gt; Perfetto: 发送 Trigger 信号 Perfetto -\u0026gt; Disk: **将 Buffer 数据写入文件** Perfetto -\u0026gt; Perfetto: 停止录制 \u0026amp; 退出 (Exit 0) deactivate Perfetto end Svc -\u0026gt; Init: 脚本执行结束 (Service Stopped) group 自动复位 Init -\u0026gt; Init: 检测到服务非正常停止(非oneshot) Init -\u0026gt; Svc: **重启服务 (Restart)** Svc -\u0026gt; Perfetto: 再次启动 perfetto activate Perfetto note right of Perfetto: 开始新一轮循环录制 end @enduml 3. 详细实施步骤 步骤 1：Perfetto 配置文件 (.pbtxt) 此配置定义了“怎么录”。核心是使用 RING_BUFFER 模式和 trigger_config。\n","keywords":[],"articleBody":"1. 需求概述 本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：\n开机自启：系统启动后，自动启动 Perfetto 追踪服务。 内存循环录制：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留最近 15 秒的数据，不占用磁盘 I/O。 事件触发落盘：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。 自动复位：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。 2. 核心架构与流程 本方案利用 Android init 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 trigger 机制来实现“按需落盘”。\n工作流程图 @startuml !theme plain autonumber skinparam defaultFontName Arial title Perfetto 循环录制与触发流程 participant \"Android Init\" as Init participant \"Service: polaris_logger\" as Svc participant \"Perfetto Process\" as Perfetto participant \"Disk Storage\" as Disk note over Svc: 状态: Running Init -\u003e Svc: 启动服务 (polaris_runner.sh) Svc -\u003e Perfetto: 启动 perfetto (阻塞模式) activate Perfetto Perfetto -\u003e Perfetto: **内存循环录制 (Ring Buffer)** note right of Perfetto: 仅在 RAM 中覆写数据\\n不写入磁盘 ... 系统运行中 (等待事件) ... group 触发阶段 -\u003e Init: setprop sys.polaris.dump 1 Init -\u003e Perfetto: 发送 Trigger 信号 Perfetto -\u003e Disk: **将 Buffer 数据写入文件** Perfetto -\u003e Perfetto: 停止录制 \u0026 退出 (Exit 0) deactivate Perfetto end Svc -\u003e Init: 脚本执行结束 (Service Stopped) group 自动复位 Init -\u003e Init: 检测到服务非正常停止(非oneshot) Init -\u003e Svc: **重启服务 (Restart)** Svc -\u003e Perfetto: 再次启动 perfetto activate Perfetto note right of Perfetto: 开始新一轮循环录制 end @enduml 3. 详细实施步骤 步骤 1：Perfetto 配置文件 (.pbtxt) 此配置定义了“怎么录”。核心是使用 RING_BUFFER 模式和 trigger_config。\n文件路径示例：/data/local/tmp/polaris_ring.pbtxt # 1. 缓冲区设置 (核心) # size_kb 决定了能回溯多久的时间。 # 估算公式：Size = 数据吞吐率(MB/s) * 目标时长(s) * 1024 # 假设吞吐率为 2MB/s，要保留 15s，则需要 30MB。建议预留 40-60MB。 buffers: { size_kb: 40960 # 40MB fill_policy: RING_BUFFER # 环形缓冲，满后覆盖旧数据 } # 2. 数据源 (根据实际调试需求修改) data_sources: { config { name: \"linux.ftrace\" ftrace_config { ftrace_events: \"sched/sched_switch\" ftrace_events: \"power/cpu_frequency\" ftrace_events: \"power/cpu_idle\" buffer_size_kb: 2048 drain_period_ms: 1000 } } } # 3. 触发器配置 (核心) trigger_config { trigger_mode: STOP_TRACING # 触发后停止 triggers { name: \"polaris_event\" # 触发器暗号 stop_delay_ms: 0 # 收到信号后立即停止（0延迟） # 若设为 1000，则会多录 1秒 \"事后\" 数据 } } # 4. 录制控制 duration_ms: 0 # 0 = 无限时长，直到被触发 write_into_file: true # 允许写文件 file_write_period_ms: 604800000 # 设置极大值(7天)，禁止中途自动刷盘 # 确保数据只在内存中，直到 Trigger 发生 步骤 2：启动脚本 (.sh) 此脚本负责为每次 Trace 生成独立的文件名，并阻塞执行。\n文件路径示例：/system/bin/polaris_runner.sh (需 chmod +x) #!/system/bin/sh OUT_DIR=\"/data/misc/perfetto-traces\" # 定义一个临时文件路径（内存缓冲的暂存目标） TEMP_FILE=\"${OUT_DIR}/trace_buffer_running.tmp\" # 确保目录存在 if [ ! -d \"$OUT_DIR\" ]; then mkdir -p \"$OUT_DIR\" fi # 启动 Perfetto (阻塞模式) # 【修正点】：加上了 --txt 参数 /system/bin/perfetto \\ -c /data/local/tmp/polaris_ring.pbtxt \\ --txt \\ -o \"$TEMP_FILE\" # ======================================================= # 代码执行到这里，说明 Trigger 已经被触发，且文件写入完毕 # ======================================================= # 获取 Trigger 发生时的时间戳 TRIGGER_TIMESTAMP=$(date +%Y%m%d_%H%M%S) FINAL_FILE=\"${OUT_DIR}/crash_dump_${TRIGGER_TIMESTAMP}.perfetto-trace\" # 重命名文件，固化证据 if [ -f \"$TEMP_FILE\" ]; then mv \"$TEMP_FILE\" \"$FINAL_FILE\" # 可选：打印日志到 logcat echo \"Polaris: Trace saved and renamed to $FINAL_FILE\" else echo \"Polaris: Error - Trace file not found.\" fi 步骤 3：Init 服务配置 (.rc) 此配置负责服务的生命周期管理和信号监听。\n文件路径示例：/system/etc/init/polaris_monitor.rc # 定义主服务 service polaris_logger /system/bin/sh /system/bin/polaris_runner.sh class core user shell group shell # 关键：如果有 SELinux 限制，需确保 shell 域有权写目标文件 seclabel u:r:shell:s0 # 【核心逻辑】 # 不要加 'oneshot'！ # 当 perfetto 因 trigger 退出导致脚本结束时，init 会自动重启此服务， # 从而开始下一次录制。 # 限制重启频率，防止出错时死循环 (5秒内重启不超1次) restart_period 5 # 默认不启动，等待 boot_completed disabled # 开机且 Traced 服务就绪后，启动服务 on property:sys.boot_completed=1 \u0026\u0026 property:persist.traced.enable=1 # 确保输出目录存在且可写 mkdir /data/misc/perfetto-traces 0777 shell shell start polaris_logger # 【触发逻辑】 # 外部设置属性 sys.polaris.dump=1 时触发 on property:sys.polaris.dump=1 # 发送 trigger 信号给正在运行的 perfetto 实例 # 这里的暗号 \"polaris_event\" 必须与 pbtxt 中的 triggers.name 一致 exec_background - shell shell -- /system/bin/perfetto --trigger polaris_event # 立即重置属性，以便下次还能触发 setprop sys.polaris.dump 0 4. 验证与测试 部署文件：将上述三个文件推送到设备对应目录，并赋予执行权限。\n重启设备：adb reboot。\n确认运行：\nadb shell ps -A | grep perfetto # 应该能看到一个 perfetto 进程正在运行 手动触发：\nadb shell setprop sys.polaris.dump 1 验证结果：\n查看 /data/misc/perfetto-traces/，应该生成了一个新文件。 再次执行 ps -A | grep perfetto，进程号（PID）应该变了（说明旧的退出了，新的自动启动了）。 5. 关键注意事项 (Caveats) 1. 缓冲区大小 (Size vs Time) 误区：Perfetto 没有直接配置 “只录 15秒” 的参数。 正解：duration_ms 控制的是总运行时长（设为 0 表示无限）。“15秒” 是由 buffers.size_kb 决定的物理容量限制。 计算：你需要实测你的 Trace 配置产生数据的速度。如果每秒产生 2MB 数据，要保留 15 秒，Buffer 至少设为 30MB (30720kb)。如果 Buffer 设小了，可能只能回溯 5 秒；设太大了浪费内存。 2. SELinux 权限 在 userdebug 版本中，使用 u:r:shell:s0 通常可行。 在 user 版本（正式版）中，shell 域的权限被严格限制，可能无法写入 /data/misc 或执行 perfetto。 生产环境建议：如果你是 ROM 开发者，建议定义专门的 sepolicy 域（例如 perfetto_logger），并授予其 file_type 的读写权限。 3. 文件写入策略 配置中必须设置 file_write_period_ms 为极大值（如 7天）。 如果不设置或设置很短，Perfetto 会定期把 Buffer 里的数据搬运到磁盘文件中。这样不仅失去了“黑匣子”只在出事时记录的意义，还会迅速填满存储空间并损耗 Flash 寿命。 4. 触发时的系统负载 当 Trigger 发生时，Perfetto 会进行一次密集的磁盘写入操作（例如瞬间写入 50MB）。这可能会对系统性能产生短暂影响。建议在 stop_delay_ms 中根据业务场景权衡，或者确保写入路径所在的分区 I/O 性能足够。 ","wordCount":"578","inLanguage":"en","datePublished":"2025-09-29T11:36:11+08:00","dateModified":"2025-09-29T11:36:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/perfetto/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a></div><h1 class="post-title entry-hint-parent">Android Perfetto "飞行记录仪" (Flight Recorder) 实施方案</h1><div class=post-meta><span title='2025-09-29 11:36:11 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;578 words</div></header><div class=post-content><h2 id=1-需求概述>1. 需求概述<a hidden class=anchor aria-hidden=true href=#1-需求概述>#</a></h2><p>本方案旨在实现一套基于 Android Perfetto 的系统级自动追踪机制，模拟飞机的“黑匣子”功能：</p><ol><li><strong>开机自启</strong>：系统启动后，自动启动 Perfetto 追踪服务。</li><li><strong>内存循环录制</strong>：采用 Ring Buffer（环形缓冲区）模式在内存中循环录制，始终保留<strong>最近 15 秒</strong>的数据，不占用磁盘 I/O。</li><li><strong>事件触发落盘</strong>：当特定事件发生时（通过 Property 信号触发），立即停止录制并将内存中的数据写入磁盘文件。</li><li><strong>自动复位</strong>：数据落盘完成后，自动重新开始新一轮的内存循环录制，等待下一次触发。</li></ol><h2 id=2-核心架构与流程>2. 核心架构与流程<a hidden class=anchor aria-hidden=true href=#2-核心架构与流程>#</a></h2><p>本方案利用 Android <code>init</code> 进程的服务管理机制来实现“自动复位”，利用 Perfetto 的 <code>trigger</code> 机制来实现“按需落盘”。</p><h3 id=工作流程图>工作流程图<a hidden class=anchor aria-hidden=true href=#工作流程图>#</a></h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>
@startuml
!theme plain
autonumber
skinparam defaultFontName Arial

title Perfetto 循环录制与触发流程

participant &#34;Android Init&#34; as Init
participant &#34;Service: polaris_logger&#34; as Svc
participant &#34;Perfetto Process&#34; as Perfetto
participant &#34;Disk Storage&#34; as Disk

note over Svc: 状态: Running

Init -&gt; Svc: 启动服务 (polaris_runner.sh)
Svc -&gt; Perfetto: 启动 perfetto (阻塞模式)
activate Perfetto
Perfetto -&gt; Perfetto: **内存循环录制 (Ring Buffer)**
note right of Perfetto: 仅在 RAM 中覆写数据\n不写入磁盘

... 系统运行中 (等待事件) ...

group 触发阶段
-&gt; Init: setprop sys.polaris.dump 1
Init -&gt; Perfetto: 发送 Trigger 信号
Perfetto -&gt; Disk: **将 Buffer 数据写入文件**
Perfetto -&gt; Perfetto: 停止录制 &amp; 退出 (Exit 0)
deactivate Perfetto
end

Svc -&gt; Init: 脚本执行结束 (Service Stopped)

group 自动复位
Init -&gt; Init: 检测到服务非正常停止(非oneshot)
Init -&gt; Svc: **重启服务 (Restart)**
Svc -&gt; Perfetto: 再次启动 perfetto
activate Perfetto
note right of Perfetto: 开始新一轮循环录制
end

@enduml
</code></pre><h2 id=3-详细实施步骤>3. 详细实施步骤<a hidden class=anchor aria-hidden=true href=#3-详细实施步骤>#</a></h2><h3 id=步骤-1perfetto-配置文件-pbtxt>步骤 1：Perfetto 配置文件 (<code>.pbtxt</code>)<a hidden class=anchor aria-hidden=true href=#步骤-1perfetto-配置文件-pbtxt>#</a></h3><p>此配置定义了“怎么录”。核心是使用 <code>RING_BUFFER</code> 模式和 <code>trigger_config</code>。</p><ul><li><strong>文件路径示例</strong>：<code>/data/local/tmp/polaris_ring.pbtxt</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>1.</span> <span style=color:#960050;background-color:#1e0010>缓冲区设置</span> (<span style=color:#960050;background-color:#1e0010>核心</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> size_kb <span style=color:#960050;background-color:#1e0010>决定了能回溯多久的时间。
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>估算公式：</span>Size <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>数据吞吐率</span>(MB<span style=color:#f92672>/</span>s) <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#960050;background-color:#1e0010>目标时长</span>(s) <span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#ae81ff>1024</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>假设吞吐率为</span> <span style=color:#ae81ff>2</span>MB<span style=color:#f92672>/</span>s<span style=color:#960050;background-color:#1e0010>，要保留</span> <span style=color:#ae81ff>15</span>s<span style=color:#960050;background-color:#1e0010>，则需要</span> <span style=color:#ae81ff>30</span>MB<span style=color:#960050;background-color:#1e0010>。建议预留</span> <span style=color:#ae81ff>40</span><span style=color:#f92672>-</span><span style=color:#ae81ff>60</span>MB<span style=color:#960050;background-color:#1e0010>。
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>buffers<span style=color:#f92672>:</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    size_kb<span style=color:#f92672>:</span> <span style=color:#ae81ff>40960</span>              <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>40</span>MB<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    fill_policy<span style=color:#f92672>:</span> RING_BUFFER    <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>环形缓冲，满后覆盖旧数据
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>2.</span> <span style=color:#960050;background-color:#1e0010>数据源</span> (<span style=color:#960050;background-color:#1e0010>根据实际调试需求修改</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>data_sources<span style=color:#f92672>:</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    config {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>        name<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;linux.ftrace&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>        ftrace_config {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>            ftrace_events<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;sched/sched_switch&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>            ftrace_events<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;power/cpu_frequency&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>            ftrace_events<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;power/cpu_idle&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>            buffer_size_kb<span style=color:#f92672>:</span> <span style=color:#ae81ff>2048</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>            drain_period_ms<span style=color:#f92672>:</span> <span style=color:#ae81ff>1000</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>        }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>3.</span> <span style=color:#960050;background-color:#1e0010>触发器配置</span> (<span style=color:#960050;background-color:#1e0010>核心</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>trigger_config {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    trigger_mode<span style=color:#f92672>:</span> STOP_TRACING  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>触发后停止
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    triggers {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>        name<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;polaris_event&#34;</span>   <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>触发器暗号
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>        stop_delay_ms<span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>收到信号后立即停止（</span><span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>延迟）
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>                                <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>若设为</span> <span style=color:#ae81ff>1000</span><span style=color:#960050;background-color:#1e0010>，则会多录</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>秒</span> <span style=color:#e6db74>&#34;事后&#34;</span> <span style=color:#960050;background-color:#1e0010>数据
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>4.</span> <span style=color:#960050;background-color:#1e0010>录制控制
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>duration_ms<span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>                  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>无限时长，直到被触发
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>write_into_file<span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>           <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>允许写文件
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>file_write_period_ms<span style=color:#f92672>:</span> <span style=color:#ae81ff>604800000</span> <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>设置极大值</span>(<span style=color:#ae81ff>7</span><span style=color:#960050;background-color:#1e0010>天</span>)<span style=color:#960050;background-color:#1e0010>，禁止中途自动刷盘
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>                                <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>确保数据只在内存中，直到</span> Trigger <span style=color:#960050;background-color:#1e0010>发生
</span></span></span></code></pre></div></li></ul><h3 id=步骤-2启动脚本-sh>步骤 2：启动脚本 (<code>.sh</code>)<a hidden class=anchor aria-hidden=true href=#步骤-2启动脚本-sh>#</a></h3><p>此脚本负责为每次 Trace 生成独立的文件名，并阻塞执行。</p><ul><li><strong>文件路径示例</strong>：<code>/system/bin/polaris_runner.sh</code> (需 <code>chmod +x</code>)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/system/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>OUT_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/data/misc/perfetto-traces&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义一个临时文件路径（内存缓冲的暂存目标）</span>
</span></span><span style=display:flex><span>TEMP_FILE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>OUT_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/trace_buffer_running.tmp&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 确保目录存在</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d <span style=color:#e6db74>&#34;</span>$OUT_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    mkdir -p <span style=color:#e6db74>&#34;</span>$OUT_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动 Perfetto (阻塞模式)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 【修正点】：加上了 --txt 参数</span>
</span></span><span style=display:flex><span>/system/bin/perfetto <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-c /data/local/tmp/polaris_ring.pbtxt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--txt <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-o <span style=color:#e6db74>&#34;</span>$TEMP_FILE<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =======================================================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 代码执行到这里，说明 Trigger 已经被触发，且文件写入完毕</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =======================================================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 获取 Trigger 发生时的时间戳</span>
</span></span><span style=display:flex><span>TRIGGER_TIMESTAMP<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +%Y%m%d_%H%M%S<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>FINAL_FILE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>OUT_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/crash_dump_</span><span style=color:#e6db74>${</span>TRIGGER_TIMESTAMP<span style=color:#e6db74>}</span><span style=color:#e6db74>.perfetto-trace&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 重命名文件，固化证据</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f <span style=color:#e6db74>&#34;</span>$TEMP_FILE<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    mv <span style=color:#e6db74>&#34;</span>$TEMP_FILE<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$FINAL_FILE<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 可选：打印日志到 logcat</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Polaris: Trace saved and renamed to </span>$FINAL_FILE<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Polaris: Error - Trace file not found.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div></li></ul><h3 id=步骤-3init-服务配置-rc>步骤 3：Init 服务配置 (<code>.rc</code>)<a hidden class=anchor aria-hidden=true href=#步骤-3init-服务配置-rc>#</a></h3><p>此配置负责服务的生命周期管理和信号监听。</p><ul><li><strong>文件路径示例</strong>：<code>/system/etc/init/polaris_monitor.rc</code><pre tabindex=0><code class=language-rc data-lang=rc># 定义主服务
service polaris_logger /system/bin/sh /system/bin/polaris_runner.sh
    class core
    user shell
    group shell
    # 关键：如果有 SELinux 限制，需确保 shell 域有权写目标文件
    seclabel u:r:shell:s0

    # 【核心逻辑】
    # 不要加 &#39;oneshot&#39;！
    # 当 perfetto 因 trigger 退出导致脚本结束时，init 会自动重启此服务，
    # 从而开始下一次录制。

    # 限制重启频率，防止出错时死循环 (5秒内重启不超1次)
    restart_period 5

    # 默认不启动，等待 boot_completed
    disabled

# 开机且 Traced 服务就绪后，启动服务
on property:sys.boot_completed=1 &amp;&amp; property:persist.traced.enable=1
    # 确保输出目录存在且可写
    mkdir /data/misc/perfetto-traces 0777 shell shell
    start polaris_logger

# 【触发逻辑】
# 外部设置属性 sys.polaris.dump=1 时触发
on property:sys.polaris.dump=1
    # 发送 trigger 信号给正在运行的 perfetto 实例
    # 这里的暗号 &#34;polaris_event&#34; 必须与 pbtxt 中的 triggers.name 一致
    exec_background - shell shell -- /system/bin/perfetto --trigger polaris_event

    # 立即重置属性，以便下次还能触发
    setprop sys.polaris.dump 0
</code></pre></li></ul><h2 id=4-验证与测试>4. 验证与测试<a hidden class=anchor aria-hidden=true href=#4-验证与测试>#</a></h2><ol><li><p><strong>部署文件</strong>：将上述三个文件推送到设备对应目录，并赋予执行权限。</p></li><li><p><strong>重启设备</strong>：<code>adb reboot</code>。</p></li><li><p><strong>确认运行</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell ps -A | grep perfetto
</span></span><span style=display:flex><span><span style=color:#75715e># 应该能看到一个 perfetto 进程正在运行</span>
</span></span></code></pre></div></li><li><p><strong>手动触发</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell setprop sys.polaris.dump <span style=color:#ae81ff>1</span>
</span></span></code></pre></div></li><li><p><strong>验证结果</strong>：</p><ul><li>查看 <code>/data/misc/perfetto-traces/</code>，应该生成了一个新文件。</li><li>再次执行 <code>ps -A | grep perfetto</code>，进程号（PID）应该变了（说明旧的退出了，新的自动启动了）。</li></ul></li></ol><h2 id=5-关键注意事项-caveats>5. 关键注意事项 (Caveats)<a hidden class=anchor aria-hidden=true href=#5-关键注意事项-caveats>#</a></h2><h3 id=1-缓冲区大小-size-vs-time>1. 缓冲区大小 (Size vs Time)<a hidden class=anchor aria-hidden=true href=#1-缓冲区大小-size-vs-time>#</a></h3><ul><li><strong>误区</strong>：Perfetto 没有直接配置 &ldquo;只录 15秒&rdquo; 的参数。</li><li><strong>正解</strong>：<code>duration_ms</code> 控制的是<strong>总运行时长</strong>（设为 0 表示无限）。&ldquo;15秒&rdquo; 是由 <code>buffers.size_kb</code> 决定的物理容量限制。</li><li><strong>计算</strong>：你需要实测你的 Trace 配置产生数据的速度。如果每秒产生 2MB 数据，要保留 15 秒，Buffer 至少设为 30MB (30720kb)。如果 Buffer 设小了，可能只能回溯 5 秒；设太大了浪费内存。</li></ul><h3 id=2-selinux-权限>2. SELinux 权限<a hidden class=anchor aria-hidden=true href=#2-selinux-权限>#</a></h3><ul><li>在 <code>userdebug</code> 版本中，使用 <code>u:r:shell:s0</code> 通常可行。</li><li>在 <code>user</code> 版本（正式版）中，<code>shell</code> 域的权限被严格限制，可能无法写入 <code>/data/misc</code> 或执行 <code>perfetto</code>。</li><li><strong>生产环境建议</strong>：如果你是 ROM 开发者，建议定义专门的 <code>sepolicy</code> 域（例如 <code>perfetto_logger</code>），并授予其 <code>file_type</code> 的读写权限。</li></ul><h3 id=3-文件写入策略>3. 文件写入策略<a hidden class=anchor aria-hidden=true href=#3-文件写入策略>#</a></h3><ul><li>配置中必须设置 <code>file_write_period_ms</code> 为极大值（如 7天）。</li><li>如果不设置或设置很短，Perfetto 会定期把 Buffer 里的数据搬运到磁盘文件中。这样不仅失去了“黑匣子”只在出事时记录的意义，还会迅速填满存储空间并损耗 Flash 寿命。</li></ul><h3 id=4-触发时的系统负载>4. 触发时的系统负载<a hidden class=anchor aria-hidden=true href=#4-触发时的系统负载>#</a></h3><ul><li>当 <code>Trigger</code> 发生时，Perfetto 会进行一次密集的磁盘写入操作（例如瞬间写入 50MB）。这可能会对系统性能产生短暂影响。建议在 <code>stop_delay_ms</code> 中根据业务场景权衡，或者确保写入路径所在的分区 I/O 性能足够。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android_binderproxy_detection/><span class=title>« Prev</span><br><span>Android Binder Proxy 限制机制</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/><span class=title>Next »</span><br><span>BinderCallsStatsService 技术详解</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>