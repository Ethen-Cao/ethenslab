<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>crash_dump流程 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='下图展示了从信号捕获、crash_dump 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。
Native Process Crash 处理时序图
@startuml
!theme plain
autonumber

participant "Native Process\n(Crasher)" as P
participant "Signal Handler\n(debuggerd_handler)" as SH
participant "Pseudothread\n(In Crasher)" as PT
participant "crash_dump\n(Debuggerd)" as CD
participant "tombstoned\n(Daemon)" as T
participant "AMS\n(ActivityManager)" as AMS
participant "Logcat\n(liblog)" as LOG
participant "Init\n(PID 1)" as INIT

== 1. 崩溃触发与拦截 ==
P -> P: 发生异常 (e.g., SIGSEGV)
activate P
P -> SH: 触发 debuggerd_signal_handler 
activate SH

SH -> SH: pthread_mutex_lock \n防止多线程同时dump 
SH -> LOG: log_signal_summary (Fatal signal...) 

note right of SH
  为了不污染原进程文件描述符，
  debuggerd 使用 clone 创建
  一个 Pseudothread 来处理
end note

SH -> PT: clone() 创建伪线程 
activate PT

== 2. 启动 crash_dump 与握手 ==
PT -> CD: execle("/apex/.../crash_dump64") 
activate CD

CD -> CD: 解析参数 (PID, TID) 
CD -> P: ptrace(PTRACE_SEIZE) 附着目标线程 

note right of CD
  crash_dump 通过管道与
  目标进程握手
end note

CD -> PT: Write pipe (Handshake &#39;\1&#39;) 
PT -> PT: read pipe 

PT -> PT: create_vm_process() \n(Fork 进程镜像供读取内存) 
PT -> CD: Write pipe (CrashInfo: siginfo, regs) 

== 3. 连接 Tombstoned 获取文件句柄 ==
CD -> CD: ReadCrashInfo() 
CD -> T: connect_tombstone_server() 
activate T

T -> T: CrashQueue::get_output() 
T -> T: openat() 创建临时文件 
T --> CD: 返回 Text FD 和 Proto FD 
deactivate T

== 4. 生成 Tombstone 与 Logcat ==
CD -> CD: unwinder.Initialize() 
CD -> CD: engrave_tombstone() 

group 生成 Tombstone 内容
    CD -> CD: 读取寄存器、Memory、Maps
    CD -> CD: Unwind Stack (回溯堆栈)
    CD -> T: Write to FD (写入磁盘文件) 
end

group 输出 Logcat
    CD -> LOG: _LOG(..., "backtrace: ...") 
    note right of LOG
        libdebuggerd/utility.cpp 中的 _LOG 
        将 tombstone 内容摘要写入 logcat
    end note
end

== 5. 通知 AMS (DropBox) ==
CD -> AMS: activity_manager_notify() 
activate AMS
note right of AMS
  连接 /data/system/ndebugsocket
  发送 PID, Signal, abort_msg
  AMS 将生成 DropBox 条目
end note
CD -> AMS: write(socket, crash_info) 
deactivate AMS

== 6. 完成与清理 ==
CD -> T: notify_completion() 
activate T
T -> T: rename_tombstone_fd() \n(重命名为 tombstone_xx) 
deactivate T

CD -> P: ptrace(DETACH) 
deactivate CD
destroy CD

PT -> P: resend_signal() (重发信号自杀) 
deactivate PT
deactivate SH
deactivate P
destroy P

P -> INIT: SIGCHLD (进程死亡)
INIT -> INIT: Process Reaping (回收僵尸进程)

@enduml
关键流程代码依据解析


信号拦截 (debuggerd_signal_handler)'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/native_crash_process/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/native_crash_process/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/native_crash_process/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="crash_dump流程"><meta property="og:description" content='下图展示了从信号捕获、crash_dump 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。
Native Process Crash 处理时序图 @startuml !theme plain autonumber participant "Native Process\n(Crasher)" as P participant "Signal Handler\n(debuggerd_handler)" as SH participant "Pseudothread\n(In Crasher)" as PT participant "crash_dump\n(Debuggerd)" as CD participant "tombstoned\n(Daemon)" as T participant "AMS\n(ActivityManager)" as AMS participant "Logcat\n(liblog)" as LOG participant "Init\n(PID 1)" as INIT == 1. 崩溃触发与拦截 == P -> P: 发生异常 (e.g., SIGSEGV) activate P P -> SH: 触发 debuggerd_signal_handler activate SH SH -> SH: pthread_mutex_lock \n防止多线程同时dump SH -> LOG: log_signal_summary (Fatal signal...) note right of SH 为了不污染原进程文件描述符， debuggerd 使用 clone 创建 一个 Pseudothread 来处理 end note SH -> PT: clone() 创建伪线程 activate PT == 2. 启动 crash_dump 与握手 == PT -> CD: execle("/apex/.../crash_dump64") activate CD CD -> CD: 解析参数 (PID, TID) CD -> P: ptrace(PTRACE_SEIZE) 附着目标线程 note right of CD crash_dump 通过管道与 目标进程握手 end note CD -> PT: Write pipe (Handshake &#39;\1&#39;) PT -> PT: read pipe PT -> PT: create_vm_process() \n(Fork 进程镜像供读取内存) PT -> CD: Write pipe (CrashInfo: siginfo, regs) == 3. 连接 Tombstoned 获取文件句柄 == CD -> CD: ReadCrashInfo() CD -> T: connect_tombstone_server() activate T T -> T: CrashQueue::get_output() T -> T: openat() 创建临时文件 T --> CD: 返回 Text FD 和 Proto FD deactivate T == 4. 生成 Tombstone 与 Logcat == CD -> CD: unwinder.Initialize() CD -> CD: engrave_tombstone() group 生成 Tombstone 内容 CD -> CD: 读取寄存器、Memory、Maps CD -> CD: Unwind Stack (回溯堆栈) CD -> T: Write to FD (写入磁盘文件) end group 输出 Logcat CD -> LOG: _LOG(..., "backtrace: ...") note right of LOG libdebuggerd/utility.cpp 中的 _LOG 将 tombstone 内容摘要写入 logcat end note end == 5. 通知 AMS (DropBox) == CD -> AMS: activity_manager_notify() activate AMS note right of AMS 连接 /data/system/ndebugsocket 发送 PID, Signal, abort_msg AMS 将生成 DropBox 条目 end note CD -> AMS: write(socket, crash_info) deactivate AMS == 6. 完成与清理 == CD -> T: notify_completion() activate T T -> T: rename_tombstone_fd() \n(重命名为 tombstone_xx) deactivate T CD -> P: ptrace(DETACH) deactivate CD destroy CD PT -> P: resend_signal() (重发信号自杀) deactivate PT deactivate SH deactivate P destroy P P -> INIT: SIGCHLD (进程死亡) INIT -> INIT: Process Reaping (回收僵尸进程) @enduml 关键流程代码依据解析 信号拦截 (debuggerd_signal_handler)'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2024-07-29T10:00:00+08:00"><meta property="article:modified_time" content="2024-07-29T10:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="crash_dump流程"><meta name=twitter:description content='下图展示了从信号捕获、crash_dump 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。
Native Process Crash 处理时序图
@startuml
!theme plain
autonumber

participant "Native Process\n(Crasher)" as P
participant "Signal Handler\n(debuggerd_handler)" as SH
participant "Pseudothread\n(In Crasher)" as PT
participant "crash_dump\n(Debuggerd)" as CD
participant "tombstoned\n(Daemon)" as T
participant "AMS\n(ActivityManager)" as AMS
participant "Logcat\n(liblog)" as LOG
participant "Init\n(PID 1)" as INIT

== 1. 崩溃触发与拦截 ==
P -> P: 发生异常 (e.g., SIGSEGV)
activate P
P -> SH: 触发 debuggerd_signal_handler 
activate SH

SH -> SH: pthread_mutex_lock \n防止多线程同时dump 
SH -> LOG: log_signal_summary (Fatal signal...) 

note right of SH
  为了不污染原进程文件描述符，
  debuggerd 使用 clone 创建
  一个 Pseudothread 来处理
end note

SH -> PT: clone() 创建伪线程 
activate PT

== 2. 启动 crash_dump 与握手 ==
PT -> CD: execle("/apex/.../crash_dump64") 
activate CD

CD -> CD: 解析参数 (PID, TID) 
CD -> P: ptrace(PTRACE_SEIZE) 附着目标线程 

note right of CD
  crash_dump 通过管道与
  目标进程握手
end note

CD -> PT: Write pipe (Handshake &#39;\1&#39;) 
PT -> PT: read pipe 

PT -> PT: create_vm_process() \n(Fork 进程镜像供读取内存) 
PT -> CD: Write pipe (CrashInfo: siginfo, regs) 

== 3. 连接 Tombstoned 获取文件句柄 ==
CD -> CD: ReadCrashInfo() 
CD -> T: connect_tombstone_server() 
activate T

T -> T: CrashQueue::get_output() 
T -> T: openat() 创建临时文件 
T --> CD: 返回 Text FD 和 Proto FD 
deactivate T

== 4. 生成 Tombstone 与 Logcat ==
CD -> CD: unwinder.Initialize() 
CD -> CD: engrave_tombstone() 

group 生成 Tombstone 内容
    CD -> CD: 读取寄存器、Memory、Maps
    CD -> CD: Unwind Stack (回溯堆栈)
    CD -> T: Write to FD (写入磁盘文件) 
end

group 输出 Logcat
    CD -> LOG: _LOG(..., "backtrace: ...") 
    note right of LOG
        libdebuggerd/utility.cpp 中的 _LOG 
        将 tombstone 内容摘要写入 logcat
    end note
end

== 5. 通知 AMS (DropBox) ==
CD -> AMS: activity_manager_notify() 
activate AMS
note right of AMS
  连接 /data/system/ndebugsocket
  发送 PID, Signal, abort_msg
  AMS 将生成 DropBox 条目
end note
CD -> AMS: write(socket, crash_info) 
deactivate AMS

== 6. 完成与清理 ==
CD -> T: notify_completion() 
activate T
T -> T: rename_tombstone_fd() \n(重命名为 tombstone_xx) 
deactivate T

CD -> P: ptrace(DETACH) 
deactivate CD
destroy CD

PT -> P: resend_signal() (重发信号自杀) 
deactivate PT
deactivate SH
deactivate P
destroy P

P -> INIT: SIGCHLD (进程死亡)
INIT -> INIT: Process Reaping (回收僵尸进程)

@enduml
关键流程代码依据解析


信号拦截 (debuggerd_signal_handler)'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":3,"name":"crash_dump流程","item":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/native_crash_process/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"crash_dump流程","name":"crash_dump流程","description":"下图展示了从信号捕获、crash_dump 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。\nNative Process Crash 处理时序图 @startuml !theme plain autonumber participant \u0026#34;Native Process\\n(Crasher)\u0026#34; as P participant \u0026#34;Signal Handler\\n(debuggerd_handler)\u0026#34; as SH participant \u0026#34;Pseudothread\\n(In Crasher)\u0026#34; as PT participant \u0026#34;crash_dump\\n(Debuggerd)\u0026#34; as CD participant \u0026#34;tombstoned\\n(Daemon)\u0026#34; as T participant \u0026#34;AMS\\n(ActivityManager)\u0026#34; as AMS participant \u0026#34;Logcat\\n(liblog)\u0026#34; as LOG participant \u0026#34;Init\\n(PID 1)\u0026#34; as INIT == 1. 崩溃触发与拦截 == P -\u0026gt; P: 发生异常 (e.g., SIGSEGV) activate P P -\u0026gt; SH: 触发 debuggerd_signal_handler activate SH SH -\u0026gt; SH: pthread_mutex_lock \\n防止多线程同时dump SH -\u0026gt; LOG: log_signal_summary (Fatal signal...) note right of SH 为了不污染原进程文件描述符， debuggerd 使用 clone 创建 一个 Pseudothread 来处理 end note SH -\u0026gt; PT: clone() 创建伪线程 activate PT == 2. 启动 crash_dump 与握手 == PT -\u0026gt; CD: execle(\u0026#34;/apex/.../crash_dump64\u0026#34;) activate CD CD -\u0026gt; CD: 解析参数 (PID, TID) CD -\u0026gt; P: ptrace(PTRACE_SEIZE) 附着目标线程 note right of CD crash_dump 通过管道与 目标进程握手 end note CD -\u0026gt; PT: Write pipe (Handshake \u0026#39;\\1\u0026#39;) PT -\u0026gt; PT: read pipe PT -\u0026gt; PT: create_vm_process() \\n(Fork 进程镜像供读取内存) PT -\u0026gt; CD: Write pipe (CrashInfo: siginfo, regs) == 3. 连接 Tombstoned 获取文件句柄 == CD -\u0026gt; CD: ReadCrashInfo() CD -\u0026gt; T: connect_tombstone_server() activate T T -\u0026gt; T: CrashQueue::get_output() T -\u0026gt; T: openat() 创建临时文件 T --\u0026gt; CD: 返回 Text FD 和 Proto FD deactivate T == 4. 生成 Tombstone 与 Logcat == CD -\u0026gt; CD: unwinder.Initialize() CD -\u0026gt; CD: engrave_tombstone() group 生成 Tombstone 内容 CD -\u0026gt; CD: 读取寄存器、Memory、Maps CD -\u0026gt; CD: Unwind Stack (回溯堆栈) CD -\u0026gt; T: Write to FD (写入磁盘文件) end group 输出 Logcat CD -\u0026gt; LOG: _LOG(..., \u0026#34;backtrace: ...\u0026#34;) note right of LOG libdebuggerd/utility.cpp 中的 _LOG 将 tombstone 内容摘要写入 logcat end note end == 5. 通知 AMS (DropBox) == CD -\u0026gt; AMS: activity_manager_notify() activate AMS note right of AMS 连接 /data/system/ndebugsocket 发送 PID, Signal, abort_msg AMS 将生成 DropBox 条目 end note CD -\u0026gt; AMS: write(socket, crash_info) deactivate AMS == 6. 完成与清理 == CD -\u0026gt; T: notify_completion() activate T T -\u0026gt; T: rename_tombstone_fd() \\n(重命名为 tombstone_xx) deactivate T CD -\u0026gt; P: ptrace(DETACH) deactivate CD destroy CD PT -\u0026gt; P: resend_signal() (重发信号自杀) deactivate PT deactivate SH deactivate P destroy P P -\u0026gt; INIT: SIGCHLD (进程死亡) INIT -\u0026gt; INIT: Process Reaping (回收僵尸进程) @enduml 关键流程代码依据解析 信号拦截 (debuggerd_signal_handler)\n","keywords":[],"articleBody":"下图展示了从信号捕获、crash_dump 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。\nNative Process Crash 处理时序图 @startuml !theme plain autonumber participant \"Native Process\\n(Crasher)\" as P participant \"Signal Handler\\n(debuggerd_handler)\" as SH participant \"Pseudothread\\n(In Crasher)\" as PT participant \"crash_dump\\n(Debuggerd)\" as CD participant \"tombstoned\\n(Daemon)\" as T participant \"AMS\\n(ActivityManager)\" as AMS participant \"Logcat\\n(liblog)\" as LOG participant \"Init\\n(PID 1)\" as INIT == 1. 崩溃触发与拦截 == P -\u003e P: 发生异常 (e.g., SIGSEGV) activate P P -\u003e SH: 触发 debuggerd_signal_handler activate SH SH -\u003e SH: pthread_mutex_lock \\n防止多线程同时dump SH -\u003e LOG: log_signal_summary (Fatal signal...) note right of SH 为了不污染原进程文件描述符， debuggerd 使用 clone 创建 一个 Pseudothread 来处理 end note SH -\u003e PT: clone() 创建伪线程 activate PT == 2. 启动 crash_dump 与握手 == PT -\u003e CD: execle(\"/apex/.../crash_dump64\") activate CD CD -\u003e CD: 解析参数 (PID, TID) CD -\u003e P: ptrace(PTRACE_SEIZE) 附着目标线程 note right of CD crash_dump 通过管道与 目标进程握手 end note CD -\u003e PT: Write pipe (Handshake '\\1') PT -\u003e PT: read pipe PT -\u003e PT: create_vm_process() \\n(Fork 进程镜像供读取内存) PT -\u003e CD: Write pipe (CrashInfo: siginfo, regs) == 3. 连接 Tombstoned 获取文件句柄 == CD -\u003e CD: ReadCrashInfo() CD -\u003e T: connect_tombstone_server() activate T T -\u003e T: CrashQueue::get_output() T -\u003e T: openat() 创建临时文件 T --\u003e CD: 返回 Text FD 和 Proto FD deactivate T == 4. 生成 Tombstone 与 Logcat == CD -\u003e CD: unwinder.Initialize() CD -\u003e CD: engrave_tombstone() group 生成 Tombstone 内容 CD -\u003e CD: 读取寄存器、Memory、Maps CD -\u003e CD: Unwind Stack (回溯堆栈) CD -\u003e T: Write to FD (写入磁盘文件) end group 输出 Logcat CD -\u003e LOG: _LOG(..., \"backtrace: ...\") note right of LOG libdebuggerd/utility.cpp 中的 _LOG 将 tombstone 内容摘要写入 logcat end note end == 5. 通知 AMS (DropBox) == CD -\u003e AMS: activity_manager_notify() activate AMS note right of AMS 连接 /data/system/ndebugsocket 发送 PID, Signal, abort_msg AMS 将生成 DropBox 条目 end note CD -\u003e AMS: write(socket, crash_info) deactivate AMS == 6. 完成与清理 == CD -\u003e T: notify_completion() activate T T -\u003e T: rename_tombstone_fd() \\n(重命名为 tombstone_xx) deactivate T CD -\u003e P: ptrace(DETACH) deactivate CD destroy CD PT -\u003e P: resend_signal() (重发信号自杀) deactivate PT deactivate SH deactivate P destroy P P -\u003e INIT: SIGCHLD (进程死亡) INIT -\u003e INIT: Process Reaping (回收僵尸进程) @enduml 关键流程代码依据解析 信号拦截 (debuggerd_signal_handler)\n当 Native 进程 Crash 时，内核回调 debuggerd_signal_handler 。 代码中显式使用了 pthread_mutex_lock 确保同一时间只有一个线程处理 Crash。 为了在不耗尽原进程文件描述符（FD）的情况下执行操作，代码调用 clone 创建了一个 Pseudothread 。 启动 crash_dump (Exec)\nPseudothread 调用 execle 启动 /apex/com.android.runtime/bin/crash_dump64 。 这里通过管道（Pipe）传递了 Crashing TID 和 Pseudothread TID 给 crash_dump。 握手与 Ptrace\ncrash_dump 启动后，首先 ptrace 附着（Seize）目标进程的所有线程 。 为了安全地读取内存，crash_dump 通过管道写 \\1 通知 Pseudothread 。 Pseudothread 收到通知后，调用 create_vm_process() ，本质上是 fork 出一个子进程（镜像），供 crash_dump 读取内存，防止在读取过程中因目标进程内存损坏而卡死。 Pseudothread 将 CrashInfo（包含寄存器信息 ucontext）写入管道发送给 crash_dump 。 连接 Tombstoned\ncrash_dump 调用 connect_tombstone_server 连接 tombstoned 守护进程 。 tombstoned 收到请求后（kDumpRequest），在 /data/tombstones/ 下创建临时文件 ，并通过 Socket 将文件描述符（FD）传回给 crash_dump 。 生成 Tombstone 与 Logcat\ncrash_dump 调用 engrave_tombstone 。 它使用 libunwindstack 进行堆栈回溯，并将结果写入从 tombstoned 获取的 FD 中。 同时，tombstone_proto_to_text.cpp 中的回调会调用 _LOG 函数 。 _LOG 函数会调用 __android_log_buf_write 将 Crash 的关键信息写入 Logcat (LOG_ID_CRASH) 。 通知 AMS\ncrash_dump 调用 activity_manager_notify 。 它连接 /data/system/ndebugsocket ，将 Crash 信息发送给 ActivityManagerService。 AMS 接收到数据后，会将其保存到 DropBox (data_app_native_crash 或 system_app_native_crash)。 清理与退出\ncrash_dump 通知 tombstoned 完成转储 (notify_completion) 。tombstoned 此时将临时文件重命名为正式的 tombstone_xx 。 Pseudothread 调用 resend_signal ，将原本导致 Crash 的信号（如 SIGSEGV）重新发送给自己，确保父进程（Init 或 Zygote）能收到正确的退出状态码（WIFSIGNALED）。 Pseudothread Pseudothread（伪线程） 是 Android debuggerd 机制中为了解决“在极端崩溃环境下安全启动 crash_dump”而设计的一个极其巧妙的底层技巧。\n它的核心目的是：在进程可能已经耗尽文件描述符（FD Exhaustion）的情况下，依然能够成功创建管道（Pipe）并启动 crash_dump 进程。\n以下是 Pseudothread 的详细工作原理分析：\n什么是 Pseudothread？ 在 Linux 内核视角下，它是一个通过 clone 系统调用创建的执行流。它处于一种“似线程非线程”的中间状态：\n像线程： 它共享父进程的地址空间（内存）。 像进程： 它不共享父进程的文件描述符表（File Descriptor Table）。 核心代码实现：clone 的魔法 在 debuggerd_signal_handler 函数中，代码并没有直接调用 fork() 或 pthread_create()，而是直接调用了 clone() 系统调用。\n代码引用 ：\npid_t child_pid = clone(debuggerd_dispatch_pseudothread, pseudothread_stack, CLONE_THREAD | CLONE_SIGHAND | CLONE_VM | CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID, \u0026thread_info, nullptr, nullptr, \u0026thread_info.pseudothread_tid); 这里的关键在于 Flags（标志位） 的组合：\nCLONE_VM: 共享内存。这使得 Pseudothread 可以直接读取崩溃线程的 siginfo、寄存器上下文等数据，无需复杂的 IPC。 CLONE_THREAD: 放入同一个线程组。 CLONE_SIGHAND: 共享信号处理表。 关键点：缺少了 CLONE_FILES。 普通的 pthread_create 会包含 CLONE_FILES，意味着新线程和旧线程共享打开的文件句柄。 Pseudothread 故意不加这个标志。这意味着 Pseudothread 启动时，会拷贝一份父进程的文件描述符表，但在 Pseudothread 里关闭文件，不会影响原崩溃进程。 Pseudothread 的执行流程 (debuggerd_dispatch_pseudothread) Pseudothread 启动后，执行 debuggerd_dispatch_pseudothread 函数，其工作流如下：\n暴力腾挪空间 (FD Cleaning) 这是 Pseudothread 存在的最大意义。如果原进程是因为打开了太多文件（FD 耗尽）而 Crash 的，那么普通的 fork 或 exec 可能会因为无法打开管道或 Socket 而失败。\n代码 ：\nfor (int i = 0; i \u003c 1024; ++i) { // Don't use close to avoid bionic's file descriptor ownership checks. syscall(__NR_close, i); } Pseudothread 会直接关闭自己拷贝过来的前 1024 个文件描述符。因为没有 CLONE_FILES，这个操作是安全的，不会关闭原崩溃进程正在用的文件（比如日志文件或数据库连接），但却为 Pseudothread 腾出了大量的空闲 FD。\n准备通信管道 腾出 FD 后，它终于可以安全地创建管道了 ：\nif (!Pipe(\u0026input_read, \u0026input_write) != 0 || !Pipe(\u0026output_read, \u0026output_write)) { fatal_errno(\"failed to create pipe\"); } 这些管道用于连接 crash_dump 进程。\n启动真正的 crash_dump 准备好环境后，Pseudothread 调用 _Fork() (避免触发 pthread_atfork 锁) 来创建子进程，并执行 execle 加载 crash_dump64 。\nexecle(CRASH_DUMP_PATH, CRASH_DUMP_NAME, main_tid, pseudothread_tid, debuggerd_dump_type, nullptr, nullptr); 中转数据与保活 握手： crash_dump 启动后，会通过管道发送一个 \\1 字节 。Pseudothread 收到这个字节，意味着 crash_dump 已经成功 ptrace 住了所有线程。 镜像进程： 收到握手后，Pseudothread 调用 create_vm_process() ，再次 fork 一个子进程。这个子进程是崩溃瞬间的内存镜像，专门供 crash_dump 读取内存。这样做是为了防止读取内存时卡死主进程。 阻塞等待： 最后，Pseudothread 会读取管道等待，直到 crash_dump 完成工作。这实际上起到了暂停崩溃进程的作用，防止它过早退出导致 tombstone 生成失败 。 总结 Pseudothread 是 Android 系统编程中的一个“特种兵”。它利用 clone 系统调用的灵活性，创造了一个**“内存共享但文件描述符独立”**的特殊执行环境。\n解决了什么痛点？\n死锁规避： 不使用 malloc 或 pthread 锁，直接使用 syscall。 资源耗尽保护： 即使主进程 FD 耗尽（导致 Crash），Pseudothread 也能通过“私有化并清空 FD 表”的方式，强行腾出资源来启动调试进程，确保 Crash Log (Tombstone) 能够被抓取到。 ","wordCount":"723","inLanguage":"en","datePublished":"2024-07-29T10:00:00+08:00","dateModified":"2024-07-29T10:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/native_crash_process/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a></div><h1 class="post-title entry-hint-parent">crash_dump流程</h1><div class=post-meta><span title='2024-07-29 10:00:00 +0800 CST'>July 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;723 words</div></header><div class=post-content><p>下图展示了从信号捕获、<code>crash_dump</code> 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。</p><h3 id=native-process-crash-处理时序图>Native Process Crash 处理时序图<a hidden class=anchor aria-hidden=true href=#native-process-crash-处理时序图>#</a></h3><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml
!theme plain
autonumber

participant &#34;Native Process\n(Crasher)&#34; as P
participant &#34;Signal Handler\n(debuggerd_handler)&#34; as SH
participant &#34;Pseudothread\n(In Crasher)&#34; as PT
participant &#34;crash_dump\n(Debuggerd)&#34; as CD
participant &#34;tombstoned\n(Daemon)&#34; as T
participant &#34;AMS\n(ActivityManager)&#34; as AMS
participant &#34;Logcat\n(liblog)&#34; as LOG
participant &#34;Init\n(PID 1)&#34; as INIT

== 1. 崩溃触发与拦截 ==
P -&gt; P: 发生异常 (e.g., SIGSEGV)
activate P
P -&gt; SH: 触发 debuggerd_signal_handler 
activate SH

SH -&gt; SH: pthread_mutex_lock \n防止多线程同时dump 
SH -&gt; LOG: log_signal_summary (Fatal signal...) 

note right of SH
  为了不污染原进程文件描述符，
  debuggerd 使用 clone 创建
  一个 Pseudothread 来处理
end note

SH -&gt; PT: clone() 创建伪线程 
activate PT

== 2. 启动 crash_dump 与握手 ==
PT -&gt; CD: execle(&#34;/apex/.../crash_dump64&#34;) 
activate CD

CD -&gt; CD: 解析参数 (PID, TID) 
CD -&gt; P: ptrace(PTRACE_SEIZE) 附着目标线程 

note right of CD
  crash_dump 通过管道与
  目标进程握手
end note

CD -&gt; PT: Write pipe (Handshake &#39;\1&#39;) 
PT -&gt; PT: read pipe 

PT -&gt; PT: create_vm_process() \n(Fork 进程镜像供读取内存) 
PT -&gt; CD: Write pipe (CrashInfo: siginfo, regs) 

== 3. 连接 Tombstoned 获取文件句柄 ==
CD -&gt; CD: ReadCrashInfo() 
CD -&gt; T: connect_tombstone_server() 
activate T

T -&gt; T: CrashQueue::get_output() 
T -&gt; T: openat() 创建临时文件 
T --&gt; CD: 返回 Text FD 和 Proto FD 
deactivate T

== 4. 生成 Tombstone 与 Logcat ==
CD -&gt; CD: unwinder.Initialize() 
CD -&gt; CD: engrave_tombstone() 

group 生成 Tombstone 内容
    CD -&gt; CD: 读取寄存器、Memory、Maps
    CD -&gt; CD: Unwind Stack (回溯堆栈)
    CD -&gt; T: Write to FD (写入磁盘文件) 
end

group 输出 Logcat
    CD -&gt; LOG: _LOG(..., &#34;backtrace: ...&#34;) 
    note right of LOG
        libdebuggerd/utility.cpp 中的 _LOG 
        将 tombstone 内容摘要写入 logcat
    end note
end

== 5. 通知 AMS (DropBox) ==
CD -&gt; AMS: activity_manager_notify() 
activate AMS
note right of AMS
  连接 /data/system/ndebugsocket
  发送 PID, Signal, abort_msg
  AMS 将生成 DropBox 条目
end note
CD -&gt; AMS: write(socket, crash_info) 
deactivate AMS

== 6. 完成与清理 ==
CD -&gt; T: notify_completion() 
activate T
T -&gt; T: rename_tombstone_fd() \n(重命名为 tombstone_xx) 
deactivate T

CD -&gt; P: ptrace(DETACH) 
deactivate CD
destroy CD

PT -&gt; P: resend_signal() (重发信号自杀) 
deactivate PT
deactivate SH
deactivate P
destroy P

P -&gt; INIT: SIGCHLD (进程死亡)
INIT -&gt; INIT: Process Reaping (回收僵尸进程)

@enduml
</code></pre><h3 id=关键流程代码依据解析>关键流程代码依据解析<a hidden class=anchor aria-hidden=true href=#关键流程代码依据解析>#</a></h3><ol><li><p><strong>信号拦截 (debuggerd_signal_handler)</strong></p><ul><li>当 Native 进程 Crash 时，内核回调 <code>debuggerd_signal_handler</code> 。</li><li>代码中显式使用了 <code>pthread_mutex_lock</code> 确保同一时间只有一个线程处理 Crash。</li><li>为了在不耗尽原进程文件描述符（FD）的情况下执行操作，代码调用 <code>clone</code> 创建了一个 <strong>Pseudothread</strong> 。</li></ul></li><li><p><strong>启动 crash_dump (Exec)</strong></p><ul><li>Pseudothread 调用 <code>execle</code> 启动 <code>/apex/com.android.runtime/bin/crash_dump64</code> 。</li><li>这里通过管道（Pipe）传递了 <code>Crashing TID</code> 和 <code>Pseudothread TID</code> 给 <code>crash_dump</code>。</li></ul></li><li><p><strong>握手与 Ptrace</strong></p><ul><li><code>crash_dump</code> 启动后，首先 <code>ptrace</code> 附着（Seize）目标进程的所有线程 。</li><li>为了安全地读取内存，<code>crash_dump</code> 通过管道写 <code>\1</code> 通知 Pseudothread 。</li><li>Pseudothread 收到通知后，调用 <code>create_vm_process()</code> ，本质上是 <code>fork</code> 出一个子进程（镜像），供 <code>crash_dump</code> 读取内存，防止在读取过程中因目标进程内存损坏而卡死。</li><li>Pseudothread 将 <code>CrashInfo</code>（包含寄存器信息 <code>ucontext</code>）写入管道发送给 <code>crash_dump</code> 。</li></ul></li><li><p><strong>连接 Tombstoned</strong></p><ul><li><code>crash_dump</code> 调用 <code>connect_tombstone_server</code> 连接 <code>tombstoned</code> 守护进程 。</li><li><code>tombstoned</code> 收到请求后（<code>kDumpRequest</code>），在 <code>/data/tombstones/</code> 下创建临时文件 ，并通过 Socket 将文件描述符（FD）传回给 <code>crash_dump</code> 。</li></ul></li><li><p><strong>生成 Tombstone 与 Logcat</strong></p><ul><li><code>crash_dump</code> 调用 <code>engrave_tombstone</code> 。</li><li>它使用 <code>libunwindstack</code> 进行堆栈回溯，并将结果写入从 <code>tombstoned</code> 获取的 FD 中。</li><li>同时，<code>tombstone_proto_to_text.cpp</code> 中的回调会调用 <code>_LOG</code> 函数 。</li><li><code>_LOG</code> 函数会调用 <code>__android_log_buf_write</code> 将 Crash 的关键信息写入 <strong>Logcat</strong> (<code>LOG_ID_CRASH</code>) 。</li></ul></li><li><p><strong>通知 AMS</strong></p><ul><li><code>crash_dump</code> 调用 <code>activity_manager_notify</code> 。</li><li>它连接 <code>/data/system/ndebugsocket</code> ，将 Crash 信息发送给 <code>ActivityManagerService</code>。</li><li>AMS 接收到数据后，会将其保存到 <strong>DropBox</strong> (<code>data_app_native_crash</code> 或 <code>system_app_native_crash</code>)。</li></ul></li><li><p><strong>清理与退出</strong></p><ul><li><code>crash_dump</code> 通知 <code>tombstoned</code> 完成转储 (<code>notify_completion</code>) 。<code>tombstoned</code> 此时将临时文件重命名为正式的 <code>tombstone_xx</code> 。</li><li>Pseudothread 调用 <code>resend_signal</code> ，将原本导致 Crash 的信号（如 SIGSEGV）重新发送给自己，确保父进程（Init 或 Zygote）能收到正确的退出状态码（WIFSIGNALED）。</li></ul></li></ol><h3 id=pseudothread>Pseudothread<a hidden class=anchor aria-hidden=true href=#pseudothread>#</a></h3><p><strong>Pseudothread（伪线程）</strong> 是 Android <code>debuggerd</code> 机制中为了解决“在极端崩溃环境下安全启动 crash_dump”而设计的一个极其巧妙的底层技巧。</p><p>它的核心目的是：<strong>在进程可能已经耗尽文件描述符（FD Exhaustion）的情况下，依然能够成功创建管道（Pipe）并启动 <code>crash_dump</code> 进程。</strong></p><p>以下是 Pseudothread 的详细工作原理分析：</p><ol><li>什么是 Pseudothread？</li></ol><p>在 Linux 内核视角下，它是一个通过 <code>clone</code> 系统调用创建的执行流。它处于一种“似线程非线程”的中间状态：</p><ul><li><strong>像线程：</strong> 它共享父进程的地址空间（内存）。</li><li><strong>像进程：</strong> 它<strong>不共享</strong>父进程的文件描述符表（File Descriptor Table）。</li></ul><ol start=2><li>核心代码实现：<code>clone</code> 的魔法</li></ol><p>在 <code>debuggerd_signal_handler</code> 函数中，代码并没有直接调用 <code>fork()</code> 或 <code>pthread_create()</code>，而是直接调用了 <code>clone()</code> 系统调用。</p><p>代码引用 ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>pid_t child_pid <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    clone(debuggerd_dispatch_pseudothread, pseudothread_stack,
</span></span><span style=display:flex><span>          CLONE_THREAD <span style=color:#f92672>|</span> CLONE_SIGHAND <span style=color:#f92672>|</span> CLONE_VM <span style=color:#f92672>|</span> CLONE_CHILD_SETTID <span style=color:#f92672>|</span> CLONE_CHILD_CLEARTID,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;</span>thread_info, <span style=color:#66d9ef>nullptr</span>, <span style=color:#66d9ef>nullptr</span>, <span style=color:#f92672>&amp;</span>thread_info.pseudothread_tid);
</span></span></code></pre></div><p>这里的关键在于 <strong>Flags（标志位）</strong> 的组合：</p><ul><li><strong><code>CLONE_VM</code></strong>: 共享内存。这使得 Pseudothread 可以直接读取崩溃线程的 <code>siginfo</code>、寄存器上下文等数据，无需复杂的 IPC。</li><li><strong><code>CLONE_THREAD</code></strong>: 放入同一个线程组。</li><li><strong><code>CLONE_SIGHAND</code></strong>: 共享信号处理表。</li><li><strong>关键点：缺少了 <code>CLONE_FILES</code></strong>。<ul><li>普通的 <code>pthread_create</code> 会包含 <code>CLONE_FILES</code>，意味着新线程和旧线程共享打开的文件句柄。</li><li><strong>Pseudothread 故意不加这个标志</strong>。这意味着 Pseudothread 启动时，会<strong>拷贝</strong>一份父进程的文件描述符表，但在 Pseudothread 里关闭文件，<strong>不会影响</strong>原崩溃进程。</li></ul></li></ul><ol start=3><li>Pseudothread 的执行流程 (<code>debuggerd_dispatch_pseudothread</code>)</li></ol><p>Pseudothread 启动后，执行 <code>debuggerd_dispatch_pseudothread</code> 函数，其工作流如下：</p><ul><li>暴力腾挪空间 (FD Cleaning)</li></ul><p>这是 Pseudothread 存在的最大意义。如果原进程是因为打开了太多文件（FD 耗尽）而 Crash 的，那么普通的 <code>fork</code> 或 <code>exec</code> 可能会因为无法打开管道或 Socket 而失败。</p><p>代码 ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1024</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Don&#39;t use close to avoid bionic&#39;s file descriptor ownership checks.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    syscall(__NR_close, i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pseudothread 会直接关闭自己拷贝过来的前 1024 个文件描述符。因为没有 <code>CLONE_FILES</code>，<strong>这个操作是安全的，不会关闭原崩溃进程正在用的文件</strong>（比如日志文件或数据库连接），但却为 Pseudothread 腾出了大量的空闲 FD。</p><ul><li>准备通信管道</li></ul><p>腾出 FD 后，它终于可以安全地创建管道了 ：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Pipe(<span style=color:#f92672>&amp;</span>input_read, <span style=color:#f92672>&amp;</span>input_write) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>Pipe(<span style=color:#f92672>&amp;</span>output_read, <span style=color:#f92672>&amp;</span>output_write)) {
</span></span><span style=display:flex><span>    fatal_errno(<span style=color:#e6db74>&#34;failed to create pipe&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这些管道用于连接 <code>crash_dump</code> 进程。</p><ul><li>启动真正的 crash_dump</li></ul><p>准备好环境后，Pseudothread 调用 <code>_Fork()</code> (避免触发 pthread_atfork 锁) 来创建子进程，并执行 <code>execle</code> 加载 <code>crash_dump64</code> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>execle(CRASH_DUMP_PATH, CRASH_DUMP_NAME, main_tid, pseudothread_tid, debuggerd_dump_type, <span style=color:#66d9ef>nullptr</span>, <span style=color:#66d9ef>nullptr</span>);
</span></span></code></pre></div><ul><li>中转数据与保活</li></ul><ol><li><strong>握手：</strong> <code>crash_dump</code> 启动后，会通过管道发送一个 <code>\1</code> 字节 。Pseudothread 收到这个字节，意味着 <code>crash_dump</code> 已经成功 <code>ptrace</code> 住了所有线程。</li><li><strong>镜像进程：</strong> 收到握手后，Pseudothread 调用 <code>create_vm_process()</code> ，再次 <code>fork</code> 一个子进程。这个子进程是崩溃瞬间的<strong>内存镜像</strong>，专门供 <code>crash_dump</code> 读取内存。这样做是为了防止读取内存时卡死主进程。</li><li><strong>阻塞等待：</strong> 最后，Pseudothread 会读取管道等待，直到 <code>crash_dump</code> 完成工作。这实际上起到了<strong>暂停崩溃进程</strong>的作用，防止它过早退出导致 <code>tombstone</code> 生成失败 。</li></ol><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p><strong>Pseudothread</strong> 是 Android 系统编程中的一个“特种兵”。它利用 <code>clone</code> 系统调用的灵活性，创造了一个**“内存共享但文件描述符独立”**的特殊执行环境。</p><p><strong>解决了什么痛点？</strong></p><ol><li><strong>死锁规避：</strong> 不使用 <code>malloc</code> 或 pthread 锁，直接使用 syscall。</li><li><strong>资源耗尽保护：</strong> 即使主进程 FD 耗尽（导致 Crash），Pseudothread 也能通过“私有化并清空 FD 表”的方式，强行腾出资源来启动调试进程，确保 Crash Log (Tombstone) 能够被抓取到。</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/windowmanagerservice/><span class=title>« Prev</span><br><span>WindowManagerService 解析</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/display/hwc_setbrightness/><span class=title>Next »</span><br><span></span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>