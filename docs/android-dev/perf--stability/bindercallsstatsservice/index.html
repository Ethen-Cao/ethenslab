<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BinderCallsStatsService 技术详解 | Ethen 的实验室</title><meta name=keywords content><meta name=description content="1. 简介
BinderCallsStatsService 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 system_server 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。
它能够回答以下关键问题：

哪个 App 在疯狂调用系统服务？
哪个系统 API（如 startActivity）是当前的性能瓶颈？
系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？


2. 实现原理
2.1 核心机制
BinderCallsStatsService 的实现基于 Android Binder 框架提供的 Observer（观察者）模式。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。

注入 (Injection): 服务启动时，通过 Binder.setObserver() 将自身注册为全局 Binder 监听器。
拦截 (Interception): 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 AMS.startActivity）之前，都会先经过 Binder.execTransact。
统计 (Measurement):

Call Started: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。
Call Ended: 记录结束时间，计算差值，并统计数据包大小。


聚合 (Aggregation): 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。

2.2 架构时序图 (PlantUML)
以下图表展示了 Binder 调用是如何被拦截和统计的："><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="BinderCallsStatsService 技术详解"><meta property="og:description" content="1. 简介 BinderCallsStatsService 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 system_server 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。
它能够回答以下关键问题：
哪个 App 在疯狂调用系统服务？ 哪个系统 API（如 startActivity）是当前的性能瓶颈？ 系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？ 2. 实现原理 2.1 核心机制 BinderCallsStatsService 的实现基于 Android Binder 框架提供的 Observer（观察者）模式。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。
注入 (Injection): 服务启动时，通过 Binder.setObserver() 将自身注册为全局 Binder 监听器。 拦截 (Interception): 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 AMS.startActivity）之前，都会先经过 Binder.execTransact。 统计 (Measurement): Call Started: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。 Call Ended: 记录结束时间，计算差值，并统计数据包大小。 聚合 (Aggregation): 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。 2.2 架构时序图 (PlantUML) 以下图表展示了 Binder 调用是如何被拦截和统计的："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-09-29T11:36:11+08:00"><meta property="article:modified_time" content="2025-09-29T11:36:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="BinderCallsStatsService 技术详解"><meta name=twitter:description content="1. 简介
BinderCallsStatsService 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 system_server 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。
它能够回答以下关键问题：

哪个 App 在疯狂调用系统服务？
哪个系统 API（如 startActivity）是当前的性能瓶颈？
系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？


2. 实现原理
2.1 核心机制
BinderCallsStatsService 的实现基于 Android Binder 框架提供的 Observer（观察者）模式。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。

注入 (Injection): 服务启动时，通过 Binder.setObserver() 将自身注册为全局 Binder 监听器。
拦截 (Interception): 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 AMS.startActivity）之前，都会先经过 Binder.execTransact。
统计 (Measurement):

Call Started: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。
Call Ended: 记录结束时间，计算差值，并统计数据包大小。


聚合 (Aggregation): 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。

2.2 架构时序图 (PlantUML)
以下图表展示了 Binder 调用是如何被拦截和统计的："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":3,"name":"BinderCallsStatsService 技术详解","item":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BinderCallsStatsService 技术详解","name":"BinderCallsStatsService 技术详解","description":"1. 简介 BinderCallsStatsService 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 system_server 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。\n它能够回答以下关键问题：\n哪个 App 在疯狂调用系统服务？ 哪个系统 API（如 startActivity）是当前的性能瓶颈？ 系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？ 2. 实现原理 2.1 核心机制 BinderCallsStatsService 的实现基于 Android Binder 框架提供的 Observer（观察者）模式。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。\n注入 (Injection): 服务启动时，通过 Binder.setObserver() 将自身注册为全局 Binder 监听器。 拦截 (Interception): 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 AMS.startActivity）之前，都会先经过 Binder.execTransact。 统计 (Measurement): Call Started: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。 Call Ended: 记录结束时间，计算差值，并统计数据包大小。 聚合 (Aggregation): 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。 2.2 架构时序图 (PlantUML) 以下图表展示了 Binder 调用是如何被拦截和统计的：\n","keywords":[],"articleBody":"1. 简介 BinderCallsStatsService 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 system_server 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。\n它能够回答以下关键问题：\n哪个 App 在疯狂调用系统服务？ 哪个系统 API（如 startActivity）是当前的性能瓶颈？ 系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？ 2. 实现原理 2.1 核心机制 BinderCallsStatsService 的实现基于 Android Binder 框架提供的 Observer（观察者）模式。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。\n注入 (Injection): 服务启动时，通过 Binder.setObserver() 将自身注册为全局 Binder 监听器。 拦截 (Interception): 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 AMS.startActivity）之前，都会先经过 Binder.execTransact。 统计 (Measurement): Call Started: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。 Call Ended: 记录结束时间，计算差值，并统计数据包大小。 聚合 (Aggregation): 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。 2.2 架构时序图 (PlantUML) 以下图表展示了 Binder 调用是如何被拦截和统计的：\n3. 配置与使用指南 默认情况下，为了节省性能，该服务开启了 高采样率 (1/1000) 且 仅在电池供电时关闭统计。在开发调试阶段，我们需要强制开启全量记录。\n3.1 调试流程 由于系统默认的“省电策略”，连接 USB 调试时通常无法获取数据。请严格按照以下顺序操作：\n步骤 1：解除限制并配置 # 1. 强制开启详细追踪（记录具体的类名和方法名，而不仅仅是 Transaction Code） adb shell dumpsys binder_calls_stats --enable-detailed-tracking # 2. 关闭采样限制（记录每一次调用，默认是 1000 次记 1 次） adb shell dumpsys binder_calls_stats --no-sampling 步骤 2：解决“充电状态不记录”的问题 这是最容易被忽略的一步。系统默认认为充电时不需要关注功耗，因此不记录 Stats。\n# 欺骗系统，伪装成“拔掉电源”状态 adb shell dumpsys battery unplug 步骤 3：重置与复现 # 清空历史数据 adb shell dumpsys binder_calls_stats --reset # ... 此时操作手机复现卡顿或运行 App ... 步骤 4：获取报告 # 输出统计结果 adb shell dumpsys binder_calls_stats -a 步骤 5：恢复环境 (调试结束后) adb shell dumpsys battery reset adb shell dumpsys binder_calls_stats --disable-detailed-tracking 4. Dumpsys 结果字段详解 运行命令后会得到一段 CSV 格式的 Per-UID raw data。以下是各列字段的详细定义与分析思路。\n数据示例： shared:android.uid.system/1000,shared:android.uid.system/1000,com.android.server.am.ActivityManagerService#bindServiceInstance,false,7498,803,13929,3325,0,640,8,19,19\n序号 字段名 (Key) 示例值 含义解释 性能分析价值 1 UID / Package ...system/1000 调用方。谁发起的请求。 找出“元凶”APP。 2 WorkSource ...system/1000 归属方。通常同 UID，但在代理任务中显示实际责任人。 辅助确认真实的资源消耗者。 3 Call Desc AMS#bindService 接口名。具体的服务类和方法名。 核心字段。确定是哪个功能点（如启动 Activity、查询 Package）在耗时。 4 Screen Interactive false 屏幕状态。true=亮屏，false=灭屏。 检查 App 是否在灭屏后依然频繁唤醒系统服务（异常耗电）。 5 CPU Time (micros) 7498 服务端 CPU 总耗时。代码在 CPU 上实际运行的时间总和。 衡量系统服务的计算负载。 6 Max CPU Time 803 单次最大 CPU 耗时。 关键指标。如果单次 \u003e 16ms (16000us)，极大概率导致掉帧。 7 Latency (micros) 13929 端到端总延迟。包含：传输耗时 + 排队耗时 + CPU 耗时。 关键指标。反映调用方的真实等待时间。 8 Max Latency 3325 单次最大延迟。 客户端感知的最严重卡顿时长。 9 Exception Count 0 异常次数。 检查是否存在权限错误或参数错误导致的 Crash。 10 Max Req Size 640 最大请求包 (Bytes)。 如果接近 1MB，可能触发 TransactionTooLargeException 崩溃。 11 Max Reply Size 8 最大响应包 (Bytes)。 同上，检查服务端返回的数据量。 12 Recorded Count 19 实际捕获次数。 采样后的样本数。 13 Call Count 19 估算总次数。 样本数 x 采样率。反映调用频率（频次过高即使单次不耗时也可能导致 CPU 飙升）。 分析技巧：CPU Time vs Latency 在分析性能瓶颈时，通过对比这两个字段可以定位问题根源：\n场景 A：Code Slow (代码慢)\n现象：Latency ≈ CPU Time (且两者都很高) 结论：系统服务的方法本身逻辑太复杂，计算耗时。 对策：优化 Framework 层该方法的算法或逻辑。 场景 B：Contention / Starvation (锁竞争/调度延迟)\n现象：Latency » CPU Time (例如 Latency 500ms, CPU Time 5ms) 结论：请求发出去后，在 Binder 队列里排队了很久才被执行。说明 system_server 线程池耗尽，或者有一把全局锁（如 AMS Lock）被长期占用。 对策：检查死锁，检查是否有其他高频 Binder 调用占满了线程池。 5. 局限性 范围限制：仅记录以 system_server 为服务端的调用。无法监控 App 之间的 Binder 通信，也无法监控 Native Service (如 SurfaceFlinger)。 性能开销：开启详细追踪（Detailed Tracking）会有轻微的 CPU 开销，建议仅在 Debug 期间开启。 如果想 Trace 特定进程的 IPC，该怎么办？ 方案 A: 使用 Perfetto Systrace (推荐 - 性能分析) 如果你只关心“谁调用了 binder”以及“耗时多久”，不需要具体的 Java 堆栈：\nadb shell perfetto \\ -t 10s \\ -o /data/misc/perfetto-traces/trace.pftrace \\ sched binder_driver -a com.example.app 优点: 性能开销小，能看到该进程的所有 Binder 通信时序。 缺点: 看不到 Java 堆栈（不知道是哪行代码调用的）。 方案 B: 使用 Java Method Tracing (定位代码) 如果你需要知道是哪行代码发起的 Binder 调用，可以使用方法追踪：\nadb shell am profile start --sampling 1000 com.example.app /data/local/tmp/app.trace # 操作应用... adb shell am profile stop com.example.app 然后用 Android Studio 打开 .trace 文件，在 Thread Chart 中找 BinderProxy.transact 的调用者。 ","wordCount":"432","inLanguage":"en","datePublished":"2025-09-29T11:36:11+08:00","dateModified":"2025-09-29T11:36:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/bindercallsstatsservice/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a></div><h1 class="post-title entry-hint-parent">BinderCallsStatsService 技术详解</h1><div class=post-meta><span title='2025-09-29 11:36:11 +0800 CST'>September 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;432 words</div></header><div class=post-content><h2 id=1-简介>1. 简介<a hidden class=anchor aria-hidden=true href=#1-简介>#</a></h2><p><code>BinderCallsStatsService</code> 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 <code>system_server</code> 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。</p><p>它能够回答以下关键问题：</p><ul><li>哪个 App 在疯狂调用系统服务？</li><li>哪个系统 API（如 <code>startActivity</code>）是当前的性能瓶颈？</li><li>系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？</li></ul><hr><h2 id=2-实现原理>2. 实现原理<a hidden class=anchor aria-hidden=true href=#2-实现原理>#</a></h2><h3 id=21-核心机制>2.1 核心机制<a hidden class=anchor aria-hidden=true href=#21-核心机制>#</a></h3><p><code>BinderCallsStatsService</code> 的实现基于 Android Binder 框架提供的 <strong>Observer（观察者）模式</strong>。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。</p><ol><li><strong>注入 (Injection)</strong>: 服务启动时，通过 <code>Binder.setObserver()</code> 将自身注册为全局 Binder 监听器。</li><li><strong>拦截 (Interception)</strong>: 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 <code>AMS.startActivity</code>）之前，都会先经过 <code>Binder.execTransact</code>。</li><li><strong>统计 (Measurement)</strong>:<ul><li><strong>Call Started</strong>: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。</li><li><strong>Call Ended</strong>: 记录结束时间，计算差值，并统计数据包大小。</li></ul></li><li><strong>聚合 (Aggregation)</strong>: 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。</li></ol><h3 id=22-架构时序图-plantuml>2.2 架构时序图 (PlantUML)<a hidden class=anchor aria-hidden=true href=#22-架构时序图-plantuml>#</a></h3><p>以下图表展示了 Binder 调用是如何被拦截和统计的：</p><p><img src=/ethenslab/images/BinderCallsStatsService.png alt></p><hr><h2 id=3-配置与使用指南>3. 配置与使用指南<a hidden class=anchor aria-hidden=true href=#3-配置与使用指南>#</a></h2><p>默认情况下，为了节省性能，该服务开启了 <strong>高采样率 (1/1000)</strong> 且 <strong>仅在电池供电时关闭统计</strong>。在开发调试阶段，我们需要强制开启全量记录。</p><h3 id=31-调试流程>3.1 调试流程<a hidden class=anchor aria-hidden=true href=#31-调试流程>#</a></h3><p>由于系统默认的“省电策略”，连接 USB 调试时通常无法获取数据。请严格按照以下顺序操作：</p><h4 id=步骤-1解除限制并配置>步骤 1：解除限制并配置<a hidden class=anchor aria-hidden=true href=#步骤-1解除限制并配置>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 强制开启详细追踪（记录具体的类名和方法名，而不仅仅是 Transaction Code）</span>
</span></span><span style=display:flex><span>adb shell dumpsys binder_calls_stats --enable-detailed-tracking
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 关闭采样限制（记录每一次调用，默认是 1000 次记 1 次）</span>
</span></span><span style=display:flex><span>adb shell dumpsys binder_calls_stats --no-sampling
</span></span></code></pre></div><h4 id=步骤-2解决充电状态不记录的问题>步骤 2：解决“充电状态不记录”的问题<a hidden class=anchor aria-hidden=true href=#步骤-2解决充电状态不记录的问题>#</a></h4><p>这是最容易被忽略的一步。系统默认认为充电时不需要关注功耗，因此不记录 Stats。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 欺骗系统，伪装成“拔掉电源”状态</span>
</span></span><span style=display:flex><span>adb shell dumpsys battery unplug
</span></span></code></pre></div><h4 id=步骤-3重置与复现>步骤 3：重置与复现<a hidden class=anchor aria-hidden=true href=#步骤-3重置与复现>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 清空历史数据</span>
</span></span><span style=display:flex><span>adb shell dumpsys binder_calls_stats --reset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ... 此时操作手机复现卡顿或运行 App ...</span>
</span></span></code></pre></div><h4 id=步骤-4获取报告>步骤 4：获取报告<a hidden class=anchor aria-hidden=true href=#步骤-4获取报告>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 输出统计结果</span>
</span></span><span style=display:flex><span>adb shell dumpsys binder_calls_stats -a
</span></span></code></pre></div><h4 id=步骤-5恢复环境-调试结束后>步骤 5：恢复环境 (调试结束后)<a hidden class=anchor aria-hidden=true href=#步骤-5恢复环境-调试结束后>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell dumpsys battery reset
</span></span><span style=display:flex><span>adb shell dumpsys binder_calls_stats --disable-detailed-tracking
</span></span></code></pre></div><hr><h2 id=4-dumpsys-结果字段详解>4. Dumpsys 结果字段详解<a hidden class=anchor aria-hidden=true href=#4-dumpsys-结果字段详解>#</a></h2><p>运行命令后会得到一段 CSV 格式的 <code>Per-UID raw data</code>。以下是各列字段的详细定义与分析思路。</p><p><strong>数据示例：</strong>
<code>shared:android.uid.system/1000,shared:android.uid.system/1000,com.android.server.am.ActivityManagerService#bindServiceInstance,false,7498,803,13929,3325,0,640,8,19,19</code></p><table><thead><tr><th style=text-align:left>序号</th><th style=text-align:left>字段名 (Key)</th><th style=text-align:left>示例值</th><th style=text-align:left>含义解释</th><th style=text-align:left>性能分析价值</th></tr></thead><tbody><tr><td style=text-align:left>1</td><td style=text-align:left><strong>UID / Package</strong></td><td style=text-align:left><code>...system/1000</code></td><td style=text-align:left><strong>调用方</strong>。谁发起的请求。</td><td style=text-align:left>找出“元凶”APP。</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left><strong>WorkSource</strong></td><td style=text-align:left><code>...system/1000</code></td><td style=text-align:left><strong>归属方</strong>。通常同 UID，但在代理任务中显示实际责任人。</td><td style=text-align:left>辅助确认真实的资源消耗者。</td></tr><tr><td style=text-align:left>3</td><td style=text-align:left><strong>Call Desc</strong></td><td style=text-align:left><code>AMS#bindService</code></td><td style=text-align:left><strong>接口名</strong>。具体的服务类和方法名。</td><td style=text-align:left>核心字段。确定是哪个功能点（如启动 Activity、查询 Package）在耗时。</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left><strong>Screen Interactive</strong></td><td style=text-align:left><code>false</code></td><td style=text-align:left><strong>屏幕状态</strong>。true=亮屏，false=灭屏。</td><td style=text-align:left>检查 App 是否在灭屏后依然频繁唤醒系统服务（异常耗电）。</td></tr><tr><td style=text-align:left>5</td><td style=text-align:left><strong>CPU Time</strong> (micros)</td><td style=text-align:left><code>7498</code></td><td style=text-align:left><strong>服务端 CPU 总耗时</strong>。代码在 CPU 上实际运行的时间总和。</td><td style=text-align:left>衡量系统服务的<strong>计算负载</strong>。</td></tr><tr><td style=text-align:left>6</td><td style=text-align:left><strong>Max CPU Time</strong></td><td style=text-align:left><code>803</code></td><td style=text-align:left><strong>单次最大 CPU 耗时</strong>。</td><td style=text-align:left><strong>关键指标</strong>。如果单次 > 16ms (16000us)，极大概率导致掉帧。</td></tr><tr><td style=text-align:left>7</td><td style=text-align:left><strong>Latency</strong> (micros)</td><td style=text-align:left><code>13929</code></td><td style=text-align:left><strong>端到端总延迟</strong>。包含：传输耗时 + <strong>排队耗时</strong> + CPU 耗时。</td><td style=text-align:left><strong>关键指标</strong>。反映调用方的真实等待时间。</td></tr><tr><td style=text-align:left>8</td><td style=text-align:left><strong>Max Latency</strong></td><td style=text-align:left><code>3325</code></td><td style=text-align:left><strong>单次最大延迟</strong>。</td><td style=text-align:left>客户端感知的最严重卡顿时长。</td></tr><tr><td style=text-align:left>9</td><td style=text-align:left><strong>Exception Count</strong></td><td style=text-align:left><code>0</code></td><td style=text-align:left><strong>异常次数</strong>。</td><td style=text-align:left>检查是否存在权限错误或参数错误导致的 Crash。</td></tr><tr><td style=text-align:left>10</td><td style=text-align:left><strong>Max Req Size</strong></td><td style=text-align:left><code>640</code></td><td style=text-align:left><strong>最大请求包 (Bytes)</strong>。</td><td style=text-align:left>如果接近 1MB，可能触发 <code>TransactionTooLargeException</code> 崩溃。</td></tr><tr><td style=text-align:left>11</td><td style=text-align:left><strong>Max Reply Size</strong></td><td style=text-align:left><code>8</code></td><td style=text-align:left><strong>最大响应包 (Bytes)</strong>。</td><td style=text-align:left>同上，检查服务端返回的数据量。</td></tr><tr><td style=text-align:left>12</td><td style=text-align:left><strong>Recorded Count</strong></td><td style=text-align:left><code>19</code></td><td style=text-align:left><strong>实际捕获次数</strong>。</td><td style=text-align:left>采样后的样本数。</td></tr><tr><td style=text-align:left>13</td><td style=text-align:left><strong>Call Count</strong></td><td style=text-align:left><code>19</code></td><td style=text-align:left><strong>估算总次数</strong>。</td><td style=text-align:left>样本数 x 采样率。反映调用频率（频次过高即使单次不耗时也可能导致 CPU 飙升）。</td></tr></tbody></table><h3 id=分析技巧cpu-time-vs-latency>分析技巧：CPU Time vs Latency<a hidden class=anchor aria-hidden=true href=#分析技巧cpu-time-vs-latency>#</a></h3><p>在分析性能瓶颈时，通过对比这两个字段可以定位问题根源：</p><ul><li><p><strong>场景 A：Code Slow (代码慢)</strong></p><ul><li>现象：<code>Latency</code> ≈ <code>CPU Time</code> (且两者都很高)</li><li>结论：系统服务的方法本身逻辑太复杂，计算耗时。</li><li>对策：优化 Framework 层该方法的算法或逻辑。</li></ul></li><li><p><strong>场景 B：Contention / Starvation (锁竞争/调度延迟)</strong></p><ul><li>现象：<code>Latency</code> &#187; <code>CPU Time</code> (例如 Latency 500ms, CPU Time 5ms)</li><li>结论：请求发出去后，在 Binder 队列里排队了很久才被执行。说明 system_server 线程池耗尽，或者有一把全局锁（如 AMS Lock）被长期占用。</li><li>对策：检查死锁，检查是否有其他高频 Binder 调用占满了线程池。</li></ul></li></ul><h2 id=5-局限性>5. 局限性<a hidden class=anchor aria-hidden=true href=#5-局限性>#</a></h2><ul><li><strong>范围限制</strong>：仅记录以 <code>system_server</code> 为服务端的调用。无法监控 App 之间的 Binder 通信，也无法监控 Native Service (如 SurfaceFlinger)。</li><li><strong>性能开销</strong>：开启详细追踪（Detailed Tracking）会有轻微的 CPU 开销，建议仅在 Debug 期间开启。</li></ul><h3 id=如果想-trace-特定进程的-ipc该怎么办>如果想 Trace 特定进程的 IPC，该怎么办？<a hidden class=anchor aria-hidden=true href=#如果想-trace-特定进程的-ipc该怎么办>#</a></h3><h4 id=方案-a-使用-perfetto-systrace-推荐---性能分析>方案 A: 使用 Perfetto Systrace (推荐 - 性能分析)<a hidden class=anchor aria-hidden=true href=#方案-a-使用-perfetto-systrace-推荐---性能分析>#</a></h4><p>如果你只关心“谁调用了 binder”以及“耗时多久”，不需要具体的 Java 堆栈：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell perfetto <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -t 10s <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -o /data/misc/perfetto-traces/trace.pftrace <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  sched binder_driver -a com.example.app
</span></span></code></pre></div><ul><li><strong>优点</strong>: 性能开销小，能看到该进程的所有 Binder 通信时序。</li><li><strong>缺点</strong>: 看不到 Java 堆栈（不知道是哪行代码调用的）。</li></ul><h4 id=方案-b-使用-java-method-tracing-定位代码>方案 B: 使用 Java Method Tracing (定位代码)<a hidden class=anchor aria-hidden=true href=#方案-b-使用-java-method-tracing-定位代码>#</a></h4><p>如果你需要知道是哪行代码发起的 Binder 调用，可以使用方法追踪：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>adb shell am profile start --sampling <span style=color:#ae81ff>1000</span> com.example.app /data/local/tmp/app.trace
</span></span><span style=display:flex><span><span style=color:#75715e># 操作应用...</span>
</span></span><span style=display:flex><span>adb shell am profile stop com.example.app
</span></span></code></pre></div><ul><li>然后用 Android Studio 打开 <code>.trace</code> 文件，在 Thread Chart 中找 <code>BinderProxy.transact</code> 的调用者。</li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/android_binderproxy_detection/><span class=title>« Prev</span><br><span>Android Binder Proxy 限制机制</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/windowmanager/inputmethod/><span class=title>Next »</span><br><span>Android 窗口焦点抢占与输入法连接断开技术时序分析</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>