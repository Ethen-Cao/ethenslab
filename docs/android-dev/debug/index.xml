<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Android 调试篇 on Ethen 的实验室</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/</link><description>Recent content in Android 调试篇 on Ethen 的实验室</description><generator>Hugo -- 0.152.2</generator><language>en</language><lastBuildDate>Wed, 01 Oct 2025 11:36:11 +0800</lastBuildDate><atom:link href="https://ethen-cao.github.io/ethenslab/android-dev/debug/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Visual Studio Code 高效开发 AOSP</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/vscode-aosp/</link><pubDate>Wed, 01 Oct 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/vscode-aosp/</guid><description>&lt;h2 id="概述"&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本文档旨在为 AOSP 开发者提供一份详尽的指南，说明如何将 Visual Studio Code (VS Code) 配置成一个功能强大、响应迅速的 C/C++/Java 代码开发环境。&lt;/p&gt;
&lt;p&gt;传统的 AOSP 开发可能依赖于功能强大但资源消耗巨大的 IDE（如 Android Studio for platform a.k.a. IntelliJ），或者纯文本编辑器搭配命令行工具。本指南采用 &lt;code&gt;VS Code&lt;/code&gt; + &lt;code&gt;clangd&lt;/code&gt; 的组合，旨在达到两者的平衡：既拥有现代 IDE 的强大代码导航和智能感知能力，又保持了轻量级编辑器的流畅体验。&lt;/p&gt;
&lt;h2 id="核心优势"&gt;&lt;strong&gt;核心优势&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;极致性能&lt;/strong&gt;：&lt;code&gt;clangd&lt;/code&gt; 提供了比其他方案更快的索引速度和近乎瞬时的代码补全、跳转响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度精确&lt;/strong&gt;：&lt;code&gt;clangd&lt;/code&gt; 与 AOSP 使用的 Clang 编译器同源，其代码分析、错误和警告提示与实际编译结果几乎完全一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源友好&lt;/strong&gt;：相较于大型 IDE，此方案在处理庞大的 AOSP 代码库时，内存和 CPU 占用更优。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度可定制&lt;/strong&gt;：可以根据个人习惯，通过丰富的 VS Code 扩展生态打造专属的开发环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="前期准备-prerequisites"&gt;&lt;strong&gt;前期准备 (Prerequisites)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在开始配置 VS Code 之前，请确保完成以下准备工作。&lt;/p&gt;
&lt;h3 id="硬件建议"&gt;&lt;strong&gt;硬件建议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;AOSP 是一个巨型项目。为了获得流畅体验，建议您的开发设备满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存 (RAM)&lt;/strong&gt;: 32 GB 或更多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储 (Storage)&lt;/strong&gt;: 高速 SSD，并确保有至少 500 GB 的可用空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt;: 8 核或更多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="aosp-源码同步"&gt;&lt;strong&gt;AOSP 源码同步&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;确保您已成功将 AOSP 源码同步到本地。本文档中的所有路径都将以 AOSP 的根目录作为基准。&lt;/p&gt;</description></item><item><title>Android App Java Crash 捕捉流程分析</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/android-exception-handler/</link><pubDate>Mon, 29 Sep 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/android-exception-handler/</guid><description>&lt;p&gt;在 Android 系统中，Java 层的崩溃（Crash）捕捉并不是一个简单的进程内行为，而是一套从 &lt;strong&gt;App 进程&lt;/strong&gt; 到 &lt;strong&gt;System Server 进程&lt;/strong&gt; 跨进程协作的复杂机制。理解这一流程对于定位稳定性问题至关重要，下面是详细的时序图：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-plantuml" data-lang="plantuml"&gt;@startuml
skinparam theme plain
skinparam shadowing false
skinparam DefaultFontName &amp;#34;SansSerif&amp;#34;
skinparam DefaultFontSize 12
skinparam ActivityIconSize 42
&amp;#39; 强制黑字以提高可见性
skinparam sequence {
ParticipantPadding 30
MessageAlign center
ArrowColor #263238
ActorBorderColor #263238
LifeLineBorderColor #263238
ParticipantBorderColor #263238
ParticipantBackgroundColor #ECEFF1
ParticipantFontColor #000000
GroupBorderColor #263238
GroupFontColor #000000
}
participant &amp;#34;App Process\n(JVM)&amp;#34; as App
participant &amp;#34;RuntimeInit&amp;#34; as RI
participant &amp;#34;ActivityManagerService\n(AMS)&amp;#34; as AMS
participant &amp;#34;AppErrors&amp;#34; as AE
participant &amp;#34;DropBoxManagerService&amp;#34; as DBMS
participant &amp;#34;Statsd\n(Native Daemon)&amp;#34; as Statsd
== 阶段 1: 异常捕获与堆栈提取 (App 进程) ==
App -&amp;gt; App : 抛出 Exception
note right: JVM 自动填充 Throwable 对象的 backtrace (Native 栈帧)
App -&amp;gt; RI : dispatchUncaughtException(e)
activate RI
RI -&amp;gt; RI : LoggingHandler.uncaughtException(e)
RI -&amp;gt; RI : logUncaught(..., e)
note right: **首次提取堆栈**：调用 e.printStackTrace() \n将内存堆栈转换为 String 输出至 Logcat
RI -&amp;gt; RI : new ParcelableCrashInfo(e)
note right: **堆栈封装**：将 Throwable 序列化为 \nCrashInfo 字符串，准备跨进程传输
RI -&amp;gt; AMS : handleApplicationCrash(token, crashInfo)
activate AMS
== 阶段 2: 系统级状态记录与统计 (system_server) ==
AMS -&amp;gt; AMS : handleApplicationCrashInner()
group 增量统计 (Incremental Metrics)
AMS -&amp;gt; AMS : 检查是否为 Incremental package
end
group 与 Statsd 交互 (FrameworkStatsLog)
AMS -&amp;gt; Statsd : FrameworkStatsLog.write(APP_CRASH_OCCURRED, ...)
note right: 包含 crashInfo 中的 Exception Name
end
group 持久化记录 (DropBox)
AMS -&amp;gt; DBMS : addErrorToDropBox(..., crashInfo)
activate DBMS
DBMS -&amp;gt; DBMS : 异步启动 Worker Thread
DBMS -&amp;gt; DBMS : **堆栈落盘**：将 crashInfo.stackTrace \n与其他 Header 信息拼接并写入 \n/data/system/dropbox/ 压缩文件
DBMS --&amp;gt; AMS : 返回
deactivate DBMS
end
== 阶段 3: 策略决策与 UI 处理 (AppErrors) ==
AMS -&amp;gt; AE : crashApplication(r, crashInfo)
activate AE
AE -&amp;gt; AE : noteAppKill()
note right: 将堆栈摘要存入 AppExitInfoManager
AE -&amp;gt; AE : handleAppCrashLSPB()
alt 达到崩溃上限 (Bad Process)
AE -&amp;gt; AE : markBadProcess(..., stackTrace)
note right: **持久化 Bad 状态**：将堆栈存入 mBadProcesses 内存映射
AE -&amp;gt; AMS : removeProcessLocked()
else 允许显示 UI
AE -&amp;gt; AMS : 发送 SHOW_ERROR_UI_MSG
AMS -&amp;gt; AE : AppErrorDialog.show(data)
note right: 对话框中的“显示详情”即展示 crashInfo.stackTrace
end
AE --&amp;gt; AMS : 返回结果
deactivate AE
== 阶段 4: 最终清理与自杀 (App 进程) ==
AMS --&amp;gt; RI : 处理完毕 (Binder 返回)
deactivate AMS
RI -&amp;gt; RI : Process.killProcess(myPid)
RI -&amp;gt; RI : System.exit(10)
deactivate RI
@enduml
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="1-流程概览"&gt;1. 流程概览&lt;/h2&gt;
&lt;p&gt;当 Java 异常未被捕获时，虚拟机将控制权交给 &lt;code&gt;Thread.UncaughtExceptionHandler&lt;/code&gt;。Android 默认通过 &lt;code&gt;RuntimeInit&lt;/code&gt; 类安装了自定义处理器，启动四个阶段的处理：&lt;/p&gt;</description></item><item><title>Android Binder Proxy 限制机制</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/android_binderproxy_detection/</link><pubDate>Mon, 29 Sep 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/android_binderproxy_detection/</guid><description>&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/binderproxy.drawio.png" alt="" /&gt;
本图描述了 Android 系统中 &lt;strong&gt;Binder Proxy 数量限制（BinderProxy Limit）&lt;/strong&gt; 的实现流程，涉及 &lt;code&gt;ActivityManagerService&lt;/code&gt;、&lt;code&gt;BinderInternal&lt;/code&gt;、JNI 层、&lt;code&gt;BpBinder&lt;/code&gt; 等关键组件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-关键模块"&gt;1. 关键模块&lt;/h2&gt;
&lt;h3 id="11-java-层"&gt;1.1 Java 层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ActivityManagerService (AMS)&lt;/strong&gt;
系统服务的核心，负责启用 Binder Proxy 限制，并设置回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BinderInternal&lt;/strong&gt;
桥接 AMS 与 Native 层的接口类，提供&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nSetBinderProxyCountEnabled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setBinderProxyCountCallback&lt;/code&gt;
等方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BinderProxyLimitListener / Delegate&lt;/strong&gt;
当达到 Binder Proxy 数量上限时被触发，执行对应的回调逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="12-native-层-jni"&gt;1.2 Native 层 (JNI)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;libandroid_runtime&lt;/strong&gt;
JNI 桥接库，实现了 &lt;code&gt;android_os_BinderInternal_setBinderProxyCountEnabled&lt;/code&gt; 与回调代理 &lt;code&gt;android_os_BinderInternal_proxyLimitcallback&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;libbinder&lt;/strong&gt;
Binder 内核通信库，负责 Binder 代理对象的创建与管理。
其中 &lt;code&gt;BpBinder::create&lt;/code&gt; 在生成 Binder 代理对象时进行计数与节流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-调用流程"&gt;2. 调用流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AMS 启动限制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ActivityManagerService&lt;/code&gt; 调用
&lt;code&gt;BinderInternal.nSetBinderProxyCountEnabled(true)&lt;/code&gt;
以启用 Binder Proxy 限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置回调&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>BinderCallsStatsService 技术详解</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/bindercallsstatsservice/</link><pubDate>Mon, 29 Sep 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/bindercallsstatsservice/</guid><description>&lt;h2 id="1-简介"&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BinderCallsStatsService&lt;/code&gt; 是 Android System Server 进程中的一个系统服务，用于收集和统计发往 &lt;code&gt;system_server&lt;/code&gt; 的 Binder 调用信息。它是分析系统级卡顿、高 CPU 占用以及排查 ANR（Application Not Responding）问题的核心工具。&lt;/p&gt;
&lt;p&gt;它能够回答以下关键问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪个 App 在疯狂调用系统服务？&lt;/li&gt;
&lt;li&gt;哪个系统 API（如 &lt;code&gt;startActivity&lt;/code&gt;）是当前的性能瓶颈？&lt;/li&gt;
&lt;li&gt;系统服务的卡顿是因为 CPU 耗时过长，还是因为锁竞争导致的排队？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-实现原理"&gt;2. 实现原理&lt;/h2&gt;
&lt;h3 id="21-核心机制"&gt;2.1 核心机制&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BinderCallsStatsService&lt;/code&gt; 的实现基于 Android Binder 框架提供的 &lt;strong&gt;Observer（观察者）模式&lt;/strong&gt;。它并不依赖底层的 Linux Kernel Trace，而是通过 Hook Java 层的 Binder 分发入口实现的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;注入 (Injection)&lt;/strong&gt;: 服务启动时，通过 &lt;code&gt;Binder.setObserver()&lt;/code&gt; 将自身注册为全局 Binder 监听器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拦截 (Interception)&lt;/strong&gt;: 所有发往当前进程（system_server）的 Binder 请求，在执行具体的 Service 方法（如 &lt;code&gt;AMS.startActivity&lt;/code&gt;）之前，都会先经过 &lt;code&gt;Binder.execTransact&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计 (Measurement)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Call Started&lt;/strong&gt;: 记录开始时的 CPU 时间（Thread Time）和墙上时间（Realtime）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Call Ended&lt;/strong&gt;: 记录结束时间，计算差值，并统计数据包大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚合 (Aggregation)&lt;/strong&gt;: 数据存储在内存中的哈希表中，按 UID 和方法名聚合，避免无限增长。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="22-架构时序图-plantuml"&gt;2.2 架构时序图 (PlantUML)&lt;/h3&gt;
&lt;p&gt;以下图表展示了 Binder 调用是如何被拦截和统计的：&lt;/p&gt;</description></item><item><title>Binder spam detection原理</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/spamming-oneway/</link><pubDate>Sun, 28 Sep 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/spamming-oneway/</guid><description>&lt;h2 id="binder-spam-detection原理"&gt;Binder spam detection原理&lt;/h2&gt;
&lt;p&gt;当Binder异步通信消耗了过多的binder buffer的时候，会打印出如下log:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;IPCThreadState: Process seems to be sending too many oneway calls.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="核心原因"&gt;核心原因&lt;/h3&gt;
&lt;p&gt;这个日志的根本原因在于 &lt;strong&gt;Kernel 层的 Binder 驱动程序&lt;/strong&gt; 检测到某个进程发送了过多的 oneway（异步）调用，导致为 oneway 调用预留的 &lt;strong&gt;异步缓冲区空间 (async space) 严重不足&lt;/strong&gt;。这是一种保护机制，旨在防止某个进程因滥发 oneway 调用而耗尽 Binder 资源，影响系统其他进程的正常通信。&lt;/p&gt;
&lt;p&gt;整个检测和通知流程可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;客户端发起 Oneway 调用&lt;/strong&gt;：进程通过 &lt;code&gt;transact()&lt;/code&gt; 发起一个带有 &lt;code&gt;TF_ONE_WAY&lt;/code&gt; 标志的 Binder 调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核分配缓冲区&lt;/strong&gt;：Binder 驱动在内核空间为这个 oneway 事务分配内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核进行垃圾邮件检测 (Spam Detection)&lt;/strong&gt;：在分配内存时，内核会检查剩余的&lt;strong&gt;异步缓冲区空间&lt;/strong&gt;。如果空间低于某个阈值（总空间的 10%），驱动就会开始怀疑有进程在“滥发” oneway 调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标记可疑事务&lt;/strong&gt;：如果异步空间过低，驱动会进一步检查当前发起调用的这个进程，是否占用了过多的 oneway 缓冲区（例如，超过 50 个缓冲区或总大小超过总空间的 25%）。如果满足条件，内核就会给这个事务的缓冲区打上 &lt;code&gt;oneway_spam_suspect&lt;/code&gt; 的标记。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核返回特殊指令&lt;/strong&gt;：对于一个 oneway 调用，内核需要立即给客户端一个“完成”回执。此时，如果发现事务缓冲区有 &lt;code&gt;oneway_spam_suspect&lt;/code&gt; 标记，内核就不会返回常规的 &lt;code&gt;BR_TRANSACTION_COMPLETE&lt;/code&gt;，而是返回一个特殊的 &lt;code&gt;BR_ONEWAY_SPAM_SUSPECT&lt;/code&gt; 指令。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户空间打印日志&lt;/strong&gt;：客户端的 &lt;code&gt;IPCThreadState&lt;/code&gt; 在 &lt;code&gt;waitForResponse()&lt;/code&gt; 中接收并解析来自内核的指令。当它收到 &lt;code&gt;BR_ONEWAY_SPAM_SUSPECT&lt;/code&gt; 时，就会打印出这条我们看到的错误日志。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="代码分析"&gt;代码分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户空间日志打印点 (IPCThreadState.cpp)&lt;/strong&gt;
在 &lt;code&gt;IPCThreadState::waitForResponse&lt;/code&gt; 函数中，它处理从 Binder 驱动返回的各种指令 (&lt;code&gt;BR_*&lt;/code&gt;)。其中就包括 &lt;code&gt;BR_ONEWAY_SPAM_SUSPECT&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>深入解析 Android ProtoLog：高性能结构化日志系统</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/</link><pubDate>Thu, 28 Aug 2025 19:54:57 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/</guid><description>&lt;p&gt;在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 &lt;strong&gt;ProtoLog&lt;/strong&gt; 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。&lt;/p&gt;
&lt;h2 id="1-简介protolog-是什么"&gt;&lt;strong&gt;1. 简介：ProtoLog 是什么？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ProtoLog&lt;/strong&gt; 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。&lt;/p&gt;
&lt;p&gt;与传统的 android.util.Log 不同，ProtoLog &lt;strong&gt;不会在设备运行时处理和拼接日志字符串&lt;/strong&gt;。相反，它通过一个精巧的&lt;strong&gt;编译时转换&lt;/strong&gt;机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;极致性能&lt;/strong&gt;：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制格式&lt;/strong&gt;：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译时处理&lt;/strong&gt;：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态控制&lt;/strong&gt;：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-架构与工作机制"&gt;&lt;strong&gt;2. 架构与工作机制&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ProtoLog API&lt;/strong&gt;：供开发者调用的日志接口，如 ProtoLog.d(GROUP, &amp;ldquo;format string %d&amp;rdquo;, value)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Javac 编译器插件&lt;/strong&gt;：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制日志流&lt;/strong&gt;：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Viewer (查看器) 工具&lt;/strong&gt;：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="工作流程详解"&gt;&lt;strong&gt;工作流程详解&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;让我们通过一个例子来理解其完整的工作流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写代码&lt;br&gt;
开发者在代码中写入一条 ProtoLog 日志：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; com.android.server.wm.ProtoLogGroup;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;import&lt;/span&gt; com.android.internal.protolog.common.ProtoLog;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// ... &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ProtoLog.&lt;span style="color:#a6e22e"&gt;v&lt;/span&gt;(ProtoLogGroup.&lt;span style="color:#a6e22e"&gt;WM_DEBUG_ORIENTATION&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#34;Setting orientation to %d&amp;#34;&lt;/span&gt;, newOrientation);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译时转换 (关键步骤)&lt;br&gt;
当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：&lt;/p&gt;</description></item><item><title>Android log机制</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/log/</link><pubDate>Wed, 27 Aug 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/log/</guid><description>&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/android-eventlog.png" alt="" /&gt;&lt;/p&gt;
&lt;h3 id="架構圖詳解"&gt;架構圖詳解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日誌寫入路徑 (Write Path)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;起點&lt;/strong&gt;: 應用程式或 Android 框架服務 (如 &lt;code&gt;ActivityManagerService&lt;/code&gt;) 調用 &lt;code&gt;android.util.EventLog.writeEvent()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轉換&lt;/strong&gt;: 呼叫通過 JNI 進入原生層，由 &lt;code&gt;liblog.so&lt;/code&gt; 這個 C/C++ 函式庫接管。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信接口&lt;/strong&gt;: &lt;code&gt;liblog&lt;/code&gt; 通過一個名為 &lt;code&gt;/dev/socket/logdw&lt;/code&gt; (logd writer) 的 UNIX Domain Socket，將事件日誌以高效的二進位格式 (&lt;code&gt;logger_entry&lt;/code&gt; 結構) 發送給 &lt;code&gt;logd&lt;/code&gt; 守護進程。這是一個單向的寫入操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;logd&lt;/code&gt; 內部實現 (Log Daemon Internals)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Socket Listener&lt;/strong&gt;: &lt;code&gt;logd&lt;/code&gt; 內部有一個專門的線程，負責監聽 &lt;code&gt;/dev/socket/logdw&lt;/code&gt; 接口，接收來自系統中所有進程的日誌數據。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ring Buffers&lt;/strong&gt;: 接收到的日誌會被分門別類地存入對應的&lt;strong&gt;內存中環形緩衝區 (In-Memory Ring Buffers)&lt;/strong&gt;。對於 EventLog，數據被寫入名為 &lt;code&gt;events&lt;/code&gt; 的緩衝區。這是一個高效的內存數據結構，當寫滿時會自動覆蓋最舊的紀錄。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Command Listener&lt;/strong&gt;: &lt;code&gt;logd&lt;/code&gt; 同時也監聽另一個 Socket &lt;code&gt;/dev/socket/logdr&lt;/code&gt; (logd reader)，用於接收來自 &lt;code&gt;logcat&lt;/code&gt; 等客戶端的讀取指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日誌讀取與解析路徑 (Read &amp;amp; Parse Path)&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>Protocol Buffers (Protobuf) 技术指南</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/</link><pubDate>Wed, 27 Aug 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/</guid><description>&lt;h2 id="1-简介"&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Protocol Buffers&lt;/strong&gt; (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的&lt;strong&gt;序列化结构数据&lt;/strong&gt;的机制。&lt;/p&gt;
&lt;p&gt;相比于 XML 和 JSON，Protobuf 的主要特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;体积更小&lt;/strong&gt;：二进制格式，数据紧凑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;速度更快&lt;/strong&gt;：解析和序列化速度极快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强类型&lt;/strong&gt;：通过 &lt;code&gt;.proto&lt;/code&gt; 文件定义数据结构，编译时自动生成代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：良好的向后兼容性支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-工作流程与架构"&gt;2. 工作流程与架构&lt;/h2&gt;
&lt;p&gt;Protobuf 的核心工作流分为：&lt;strong&gt;定义&lt;/strong&gt;、&lt;strong&gt;编译&lt;/strong&gt;、&lt;strong&gt;使用&lt;/strong&gt;、&lt;strong&gt;序列化/反序列化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/Protobuf.png" alt="" /&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="3-语法指南-proto"&gt;3. 语法指南 (.proto)&lt;/h2&gt;
&lt;p&gt;目前主流版本为 &lt;strong&gt;proto3&lt;/strong&gt;。以下是一个典型的 &lt;code&gt;.proto&lt;/code&gt; 文件示例。&lt;/p&gt;
&lt;h3 id="31-基础结构"&gt;3.1 基础结构&lt;/h3&gt;
&lt;p&gt;创建一个名为 &lt;code&gt;car_event.proto&lt;/code&gt; 的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-protobuf" data-lang="protobuf"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;// 1. 指定语法版本 (必须)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;syntax &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;proto3&amp;#34;&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;// 2. 定义包名 (防止命名冲突)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#f92672"&gt;package&lt;/span&gt; com&lt;span style="color:#f92672"&gt;.&lt;/span&gt;example.cockpit;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;// 3. 配置生成选项 (Java相关)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;option&lt;/span&gt; java_package &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;com.example.cockpit.proto&amp;#34;&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 生成的Java包路径
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;option&lt;/span&gt; java_outer_classname &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#e6db74"&gt;&amp;#34;CarEventProto&amp;#34;&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 生成的Java外层类名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt;&lt;span style="color:#75715e"&gt;// 4. 定义消息 (Message)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;message&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;VehicleStatus&lt;/span&gt; {&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 字段格式: 类型 字段名 = 字段编号;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 标量类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int32&lt;/span&gt; speed &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 整数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; vin_code &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 字符串
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; is_moving &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 布尔值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 枚举类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;enum&lt;/span&gt; Gear {&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; GEAR_UNKNOWN &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// proto3 枚举第一个值必须为0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; GEAR_P &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; GEAR_R &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; GEAR_N &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;3&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; GEAR_D &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; }&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; Gear current_gear &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 嵌套消息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; EngineInfo engine &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;5&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#75715e"&gt;// 数组 (Repeated)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;repeated&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;string&lt;/span&gt; error_codes &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;6&lt;/span&gt;; &lt;span style="color:#75715e"&gt;// 相当于 List&amp;lt;String&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;}&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;message&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;EngineInfo&lt;/span&gt; {&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;float&lt;/span&gt; rpm &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;float&lt;/span&gt; temperature &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;;&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#960050;background-color:#1e0010"&gt;&lt;/span&gt;}&lt;span style="color:#960050;background-color:#1e0010"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="32-关键概念"&gt;3.2 关键概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;字段编号 (Field Number)&lt;/strong&gt;：例如 &lt;code&gt;speed = 1&lt;/code&gt; 中的 &lt;code&gt;1&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非常重要&lt;/strong&gt;：这是二进制数据中字段的唯一标识，而不是字段名。&lt;/li&gt;
&lt;li&gt;一旦数据投入使用，&lt;strong&gt;绝对不能修改&lt;/strong&gt;已存在字段的编号。&lt;/li&gt;
&lt;li&gt;1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型映射&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int32/int64&lt;/code&gt; -&amp;gt; Java &lt;code&gt;int/long&lt;/code&gt;, C++ &lt;code&gt;int32_t/int64_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; -&amp;gt; Java &lt;code&gt;String&lt;/code&gt;, C++ &lt;code&gt;std::string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt; -&amp;gt; Java &lt;code&gt;boolean&lt;/code&gt;, C++ &lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="4-编译方法"&gt;4. 编译方法&lt;/h2&gt;
&lt;p&gt;将 &lt;code&gt;.proto&lt;/code&gt; 文件转换为目标语言代码。&lt;/p&gt;</description></item><item><title>使用AndroidStudio调试AOSP</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/using-androidstudio-to-debug-aosp/</link><pubDate>Fri, 08 Aug 2025 11:36:11 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/using-androidstudio-to-debug-aosp/</guid><description>&lt;h2 id="调试java进程"&gt;调试Java进程&lt;/h2&gt;
&lt;p&gt;本文介绍如何在 Android Studio 中调试 AOSP (Android Open Source Project) 进程，尤其是像 system_server 这样的系统进程。调试 AOSP 与普通应用调试有所不同，需要借助 JDWP 协议和 adb 端口转发。&lt;/p&gt;
&lt;h3 id="前置条件"&gt;前置条件&lt;/h3&gt;
&lt;p&gt;环境准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一台可以刷入 AOSP 的设备或模拟器&lt;/li&gt;
&lt;li&gt;已编译好的 AOSP（推荐 userdebug 或 eng 构建）&lt;/li&gt;
&lt;li&gt;PC 上安装 Android Studio（最新版）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备必须支持 adb root&lt;/li&gt;
&lt;li&gt;设备需要打开调试属性，例如：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;adb root
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;adb shell setprop persist.system_server.debuggable &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;adb shell stop
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;adb shell start
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;上述命令让 system_server 在启动时支持调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="调试原理"&gt;调试原理&lt;/h3&gt;
&lt;p&gt;Android 使用 JDWP (Java Debug Wire Protocol) 进行 Java 进程调试：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_server 内部：包含一个 JDWP Listener 线程，负责接收调试命令并执行（挂起线程、返回堆栈、单步执行等）。&lt;/li&gt;
&lt;li&gt;adb：提供 adb forward 功能，将 PC 本地端口与设备进程的 JDWP 通道连接起来。&lt;/li&gt;
&lt;li&gt;Android Studio：作为调试器，通过 JDWP 协议与 system_server 通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据流示意：&lt;/p&gt;</description></item><item><title>crash_dump流程</title><link>https://ethen-cao.github.io/ethenslab/android-dev/debug/native_crash_process/</link><pubDate>Mon, 29 Jul 2024 10:00:00 +0800</pubDate><guid>https://ethen-cao.github.io/ethenslab/android-dev/debug/native_crash_process/</guid><description>&lt;p&gt;下图展示了从信号捕获、&lt;code&gt;crash_dump&lt;/code&gt; 介入、Tombstone 生成、通知 AMS 到最后日志输出的交互细节。&lt;/p&gt;
&lt;h3 id="native-process-crash-处理时序图"&gt;Native Process Crash 处理时序图&lt;/h3&gt;
&lt;!-- ![](/ethenslab/images/android-Native-Process-Crash.png) --&gt;
&lt;p&gt;&lt;img src="https://ethen-cao.github.io/ethenslab/images/android-Native-Process-Crash.png" alt="Native Crash" /&gt;&lt;/p&gt;
&lt;h3 id="关键流程代码依据解析"&gt;关键流程代码依据解析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;信号拦截 (debuggerd_signal_handler)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 Native 进程 Crash 时，内核回调 &lt;code&gt;debuggerd_signal_handler&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;代码中显式使用了 &lt;code&gt;pthread_mutex_lock&lt;/code&gt; 确保同一时间只有一个线程处理 Crash。&lt;/li&gt;
&lt;li&gt;为了在不耗尽原进程文件描述符（FD）的情况下执行操作，代码调用 &lt;code&gt;clone&lt;/code&gt; 创建了一个 &lt;strong&gt;Pseudothread&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动 crash_dump (Exec)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pseudothread 调用 &lt;code&gt;execle&lt;/code&gt; 启动 &lt;code&gt;/apex/com.android.runtime/bin/crash_dump64&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;这里通过管道（Pipe）传递了 &lt;code&gt;Crashing TID&lt;/code&gt; 和 &lt;code&gt;Pseudothread TID&lt;/code&gt; 给 &lt;code&gt;crash_dump&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;握手与 Ptrace&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;crash_dump&lt;/code&gt; 启动后，首先 &lt;code&gt;ptrace&lt;/code&gt; 附着（Seize）目标进程的所有线程 。&lt;/li&gt;
&lt;li&gt;为了安全地读取内存，&lt;code&gt;crash_dump&lt;/code&gt; 通过管道写 &lt;code&gt;\1&lt;/code&gt; 通知 Pseudothread 。&lt;/li&gt;
&lt;li&gt;Pseudothread 收到通知后，调用 &lt;code&gt;create_vm_process()&lt;/code&gt; ，本质上是 &lt;code&gt;fork&lt;/code&gt; 出一个子进程（镜像），供 &lt;code&gt;crash_dump&lt;/code&gt; 读取内存，防止在读取过程中因目标进程内存损坏而卡死。&lt;/li&gt;
&lt;li&gt;Pseudothread 将 &lt;code&gt;CrashInfo&lt;/code&gt;（包含寄存器信息 &lt;code&gt;ucontext&lt;/code&gt;）写入管道发送给 &lt;code&gt;crash_dump&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接 Tombstoned&lt;/strong&gt;&lt;/p&gt;</description></item></channel></rss>