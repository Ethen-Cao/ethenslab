<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入解析 Android ProtoLog：高性能结构化日志系统 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 ProtoLog 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。
1. 简介：ProtoLog 是什么？
ProtoLog 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。
与传统的 android.util.Log 不同，ProtoLog 不会在设备运行时处理和拼接日志字符串。相反，它通过一个精巧的编译时转换机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。
核心优势：

极致性能：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。
二进制格式：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。
编译时处理：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。
动态控制：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。

2. 架构与工作机制
ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：

ProtoLog API：供开发者调用的日志接口，如 ProtoLog.d(GROUP, &ldquo;format string %d&rdquo;, value)。
Javac 编译器插件：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。
二进制日志流：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。
Viewer (查看器) 工具：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。

工作流程详解
让我们通过一个例子来理解其完整的工作流程：


编写代码
开发者在代码中写入一条 ProtoLog 日志：
import com.android.server.wm.ProtoLogGroup;  
import com.android.internal.protolog.common.ProtoLog;

// ...  
ProtoLog.v(ProtoLogGroup.WM_DEBUG_ORIENTATION, "Setting orientation to %d", newOrientation);


编译时转换 (关键步骤)
当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="深入解析 Android ProtoLog：高性能结构化日志系统"><meta property="og:description" content='在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 ProtoLog 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。
1. 简介：ProtoLog 是什么？ ProtoLog 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。
与传统的 android.util.Log 不同，ProtoLog 不会在设备运行时处理和拼接日志字符串。相反，它通过一个精巧的编译时转换机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。
核心优势：
极致性能：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。 二进制格式：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。 编译时处理：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。 动态控制：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。 2. 架构与工作机制 ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：
ProtoLog API：供开发者调用的日志接口，如 ProtoLog.d(GROUP, “format string %d”, value)。 Javac 编译器插件：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。 二进制日志流：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。 Viewer (查看器) 工具：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。 工作流程详解 让我们通过一个例子来理解其完整的工作流程：
编写代码
开发者在代码中写入一条 ProtoLog 日志：
import com.android.server.wm.ProtoLogGroup; import com.android.internal.protolog.common.ProtoLog; // ... ProtoLog.v(ProtoLogGroup.WM_DEBUG_ORIENTATION, "Setting orientation to %d", newOrientation); 编译时转换 (关键步骤)
当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-08-28T19:54:57+08:00"><meta property="article:modified_time" content="2025-08-28T19:54:57+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入解析 Android ProtoLog：高性能结构化日志系统"><meta name=twitter:description content='在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 ProtoLog 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。
1. 简介：ProtoLog 是什么？
ProtoLog 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。
与传统的 android.util.Log 不同，ProtoLog 不会在设备运行时处理和拼接日志字符串。相反，它通过一个精巧的编译时转换机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。
核心优势：

极致性能：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。
二进制格式：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。
编译时处理：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。
动态控制：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。

2. 架构与工作机制
ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：

ProtoLog API：供开发者调用的日志接口，如 ProtoLog.d(GROUP, &ldquo;format string %d&rdquo;, value)。
Javac 编译器插件：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。
二进制日志流：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。
Viewer (查看器) 工具：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。

工作流程详解
让我们通过一个例子来理解其完整的工作流程：


编写代码
开发者在代码中写入一条 ProtoLog 日志：
import com.android.server.wm.ProtoLogGroup;  
import com.android.internal.protolog.common.ProtoLog;

// ...  
ProtoLog.v(ProtoLogGroup.WM_DEBUG_ORIENTATION, "Setting orientation to %d", newOrientation);


编译时转换 (关键步骤)
当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"Android 调试篇","item":"https://ethen-cao.github.io/ethenslab/android-dev/debug/"},{"@type":"ListItem","position":3,"name":"深入解析 Android ProtoLog：高性能结构化日志系统","item":"https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入解析 Android ProtoLog：高性能结构化日志系统","name":"深入解析 Android ProtoLog：高性能结构化日志系统","description":"在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 ProtoLog 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。\n1. 简介：ProtoLog 是什么？ ProtoLog 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。\n与传统的 android.util.Log 不同，ProtoLog 不会在设备运行时处理和拼接日志字符串。相反，它通过一个精巧的编译时转换机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。\n核心优势：\n极致性能：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。 二进制格式：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。 编译时处理：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。 动态控制：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。 2. 架构与工作机制 ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：\nProtoLog API：供开发者调用的日志接口，如 ProtoLog.d(GROUP, \u0026ldquo;format string %d\u0026rdquo;, value)。 Javac 编译器插件：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。 二进制日志流：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。 Viewer (查看器) 工具：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。 工作流程详解 让我们通过一个例子来理解其完整的工作流程：\n编写代码\n开发者在代码中写入一条 ProtoLog 日志：\nimport com.android.server.wm.ProtoLogGroup; import com.android.internal.protolog.common.ProtoLog; // ... ProtoLog.v(ProtoLogGroup.WM_DEBUG_ORIENTATION, \u0026#34;Setting orientation to %d\u0026#34;, newOrientation); 编译时转换 (关键步骤)\n当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：\n","keywords":[],"articleBody":"在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 ProtoLog 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。\n1. 简介：ProtoLog 是什么？ ProtoLog 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。\n与传统的 android.util.Log 不同，ProtoLog 不会在设备运行时处理和拼接日志字符串。相反，它通过一个精巧的编译时转换机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。\n核心优势：\n极致性能：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。 二进制格式：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。 编译时处理：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。 动态控制：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。 2. 架构与工作机制 ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：\nProtoLog API：供开发者调用的日志接口，如 ProtoLog.d(GROUP, “format string %d”, value)。 Javac 编译器插件：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。 二进制日志流：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。 Viewer (查看器) 工具：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。 工作流程详解 让我们通过一个例子来理解其完整的工作流程：\n编写代码\n开发者在代码中写入一条 ProtoLog 日志：\nimport com.android.server.wm.ProtoLogGroup; import com.android.internal.protolog.common.ProtoLog; // ... ProtoLog.v(ProtoLogGroup.WM_DEBUG_ORIENTATION, \"Setting orientation to %d\", newOrientation); 编译时转换 (关键步骤)\n当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：\n提取格式化字符串：插件找到 “Setting orientation to %d” 这个字符串。\n生成唯一哈希 ID：为这个字符串计算一个稳定且唯一的哈希值（例如 0x1A2B3C4D）。\n代码替换：插件将原始的 ProtoLog.v(…) 调用替换为一个高度优化的内部调用。替换后的代码大致等效于：\n// 伪代码，实际实现更复杂\nif (ProtoLogImpl.isEnabled(ProtoLogGroup.WM_DEBUG_ORIENTATION)) { ProtoLogImpl.log(LogLevel.VERBOSE, 0x1A2B3C4D, newOrientation); } 注意，原始的字符串已经消失了，只剩下哈希 ID 和参数 (newOrientation)。\n生成 Viewer 映射文件\n在编译过程中，插件还会将所有提取出的 “哈希 ID -\u003e 格式化字符串” 的映射关系记录到一个 JSON 格式的配置文件中。这个文件是后续解码日志的关键。\n设备上运行\n当设备上的代码执行到被替换后的日志点时：\n它首先检查 WM_DEBUG_ORIENTATION 这个日志组是否被启用。 如果已启用，它会将日志级别、哈希 ID (0x1A2B3C4D) 和参数 (newOrientation 的值) 以紧凑的二进制格式写入专用的 protolog 日志缓冲区。整个过程不涉及任何字符串操作。 如果未启用，这个 if 判断会直接跳过，几乎没有性能开销。 日志解码与查看\n当开发者抓取日志时，看到的是二进制原始数据，无法直接阅读。此时，需要使用专门的工具（如 AOSP 中的 protologtool 脚本），并提供第 3 步生成的映射文件，才能将二进制日志解码成可读的文本：\n# 二进制流中的片段: [VERBOSE, 0x1A2B3C4D, 1] # 解码工具 + 映射文件 -\u003e # 输出: V WM_DEBUG_ORIENTATION: Setting orientation to 1 这个流程巧妙地将最耗费性能的字符串处理工作从设备运行时转移到了开发者的编译机上，从而实现了其高性能的目标。\n3. 使用场景 由于其设计特点，ProtoLog 特别适用于以下场景：\n性能关键路径：在 Android Framework 的核心组件中，如 WindowManager、ActivityManagerService、SystemUI 等，这些代码对性能极其敏感，使用 ProtoLog 可以添加详细日志而不影响流畅度。 高频事件监控：当需要记录频繁触发的事件时（例如，触摸事件处理、网络包收发、传感器数据更新），传统日志会迅速刷屏并拖慢系统，而 ProtoLog 则可以轻松应对。 在 Release 版本中保留调试信息：开发者可以在代码中保留大量的 ProtoLog 日志。在发布给用户的版本中，这些日志默认是关闭的，开销为零。当需要诊断特定问题时，可以通过 adb 命令远程开启相关日志组来收集信息，极大地提升了问题排查的效率。 系统健康与行为分析：通过在系统各处埋点，可以安全地收集大量结构化数据，用于后续的自动化分析和性能回归测试。 4. 扩展：ROM 开发者如何自定义 ProtoLog 对于 ROM 开发者或设备制造商，可以定义自己的 ProtoLog 日志组，并将其集成到系统代码中。\n步骤 1：定义新的 ProtoLog Group 首先，你需要创建一个类来定义你的日志组。每个组由一个布尔标志和一个标签（Tag）组成。\n// file: packages/services/MyCustomService/src/com/android/server/mycustom/MyProtoLogGroup.java package com.android.server.mycustom; import com.android.internal.protolog.common.ProtoLog; public enum MyProtoLogGroup implements ProtoLog.LogGroup { // 定义一个名为 MY_CUSTOM_SERVICE_DEBUG 的日志组 MY_CUSTOM_SERVICE_DEBUG(true, \"MyCustomSvc\", ProtoLog.LogLevel.DEBUG); private final boolean mEnabled; private final String mTag; private final ProtoLog.LogLevel mLogLevel; MyProtoLogGroup(boolean enabled, String tag, ProtoLog.LogLevel level) { this.mEnabled = enabled; this.mTag = tag; this.mLogLevel = level; } @Override public boolean isEnabled() { // isEnabled() 的返回值会被编译时插件优化 return mEnabled; } @Override public String getTag() { return mTag; } } 步骤 2：在构建系统 (Android.bp) 中集成 接下来，需要修改模块的 Android.bp 文件，通过 Soong 插件机制启用 ProtoLog。\n// file: packages/services/MyCustomService/Android.bp java_library { name: \"my-custom-service-lib\", srcs: [\"src/**/*.java\"], // ... 其他依赖 // 1. 通过 Soong 插件机制启用 ProtoLog 编译器插件 plugins: [\"protolog-plugin\"], // 2. 指定 Viewer 映射文件的输出路径 protolog: { output: \"my-custom-service-protolog.json\", }, // 3. 告知插件在哪里可以找到你的日志组定义 // 这通常是包含 MyProtoLogGroup.java 的模块本身 static_libs: [ \"my-custom-service-lib-protolog-groups\", ], } // 4. 单独定义一个包含 ProtoLog Group 定义的库 java_library { name: \"my-custom-service-lib-protolog-groups\", srcs: [\"src/com/android/server/mycustom/MyProtoLogGroup.java\"], } 步骤 3：在代码中使用新的日志组 现在你可以在你的服务代码中使用刚刚定义的日志组了。\nimport static com.android.server.mycustom.MyProtoLogGroup.MY\\_CUSTOM\\_SERVICE\\_DEBUG; import com.android.internal.protolog.common.ProtoLog; public class MyCustomService { void doSomething() { ProtoLog.d(MY_CUSTOM_SERVICE_DEBUG, \"Doing something important with value %d.\", 42); } } 步骤 4：在设备上控制和查看日志 编译并刷写系统后，你可以通过 adb shell 来控制日志的开关。\n# 方法一：通过 setprop 启用你的日志组 (Tag 是你在枚举中定义的 \"MyCustomSvc\") $ adb shell setprop persist.log.tag.MyCustomSvc DEBUG # 禁用 $ adb shell setprop persist.log.tag.MyCustomSvc \"\" # 注意：不同 Android 版本可能存在其他控制方式，例如通过 settings 命令。 # 请参考您所使用的 AOSP 版本的具体文档。 # 查看日志 (必须指定 protolog 缓冲区) # 1. 从编译输出目录 (out/...) 中找到 my-custom-service-protolog.json # 2. 运行解码脚本 $ adb logcat -b protolog | path/to/aosp/protologtool --viewer-conf my-custom-service-protolog.json 通过以上步骤，ROM 开发者就可以将 ProtoLog 的强大能力无缝集成到自己的定制化模块中，实现高效、可控的日志记录。\n系统ProtoLog 打开 WindowManagerService 的ProtoLog:\n查看可以打开的ProtoGroup： frameworks/base/core/java/com/android/internal/protolog/ProtoLogGroup.java 运行命令： adb shell cmd window logging enable-text XXX adb logcat ","wordCount":"442","inLanguage":"en","datePublished":"2025-08-28T19:54:57+08:00","dateModified":"2025-08-28T19:54:57+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/debug/protolog/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/debug/>Android 调试篇</a></div><h1 class="post-title entry-hint-parent">深入解析 Android ProtoLog：高性能结构化日志系统</h1><div class=post-meta><span title='2025-08-28 19:54:57 +0800 CST'>August 28, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;442 words</div></header><div class=post-content><p>在 Android 系统开发和性能优化中，日志记录是一个不可或缺的工具。然而，传统的字符串日志（如 Log.d, Log.e）在高频或性能敏感的场景下会带来显著的开销。为了解决这个问题，Android 团队引入了一套名为 <strong>ProtoLog</strong> 的高性能日志系统。本文将深入探讨 ProtoLog 的设计理念、工作机制、使用场景以及如何为 ROM 开发进行扩展。</p><h2 id=1-简介protolog-是什么><strong>1. 简介：ProtoLog 是什么？</strong><a hidden class=anchor aria-hidden=true href=#1-简介protolog-是什么>#</a></h2><p><strong>ProtoLog</strong> 是一套高性能、低开销的日志记录框架，深度集成在 Android 开源项目 (AOSP) 中。它的核心思想是将日志记录对运行时性能的影响降到最低。</p><p>与传统的 android.util.Log 不同，ProtoLog <strong>不会在设备运行时处理和拼接日志字符串</strong>。相反，它通过一个精巧的<strong>编译时转换</strong>机制，将日志调用替换为写入紧凑二进制数据的指令。这使得即使在生产环境中开启大量日志，也不会对设备性能造成明显影响。</p><p><strong>核心优势：</strong></p><ul><li><strong>极致性能</strong>：避免了运行时的字符串操作、格式化和内存分配，CPU 和内存开销极低。</li><li><strong>二进制格式</strong>：日志以高效的 Protocol Buffers (Protobuf) 格式写入流中，体积小，便于机器解析。</li><li><strong>编译时处理</strong>：大部分工作（如解析格式化字符串）在编译代码时完成，而非在设备上。</li><li><strong>动态控制</strong>：可以通过 adb 命令动态开启或关闭不同的日志组，无需重新编译或重启设备。</li></ul><h2 id=2-架构与工作机制><strong>2. 架构与工作机制</strong><a hidden class=anchor aria-hidden=true href=#2-架构与工作机制>#</a></h2><p>ProtoLog 的魔力在于其独特的编译时处理流程。它主要由以下几个部分组成：</p><ul><li><strong>ProtoLog API</strong>：供开发者调用的日志接口，如 ProtoLog.d(GROUP, &ldquo;format string %d&rdquo;, value)。</li><li><strong>Javac 编译器插件</strong>：这是 ProtoLog 的核心。在 Java 代码编译期间，该插件会扫描所有 ProtoLog API 调用。</li><li><strong>二进制日志流</strong>：设备上实际记录的数据格式，它不包含原始的字符串，并被写入一个专用的 protolog 日志缓冲区。</li><li><strong>Viewer (查看器) 工具</strong>：用于将设备上捕获的二进制日志流转换回人类可读的文本格式。</li></ul><h4 id=工作流程详解><strong>工作流程详解</strong><a hidden class=anchor aria-hidden=true href=#工作流程详解>#</a></h4><p>让我们通过一个例子来理解其完整的工作流程：</p><ol><li><p>编写代码<br>开发者在代码中写入一条 ProtoLog 日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.android.server.wm.ProtoLogGroup;  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.android.internal.protolog.common.ProtoLog;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...  </span>
</span></span><span style=display:flex><span>ProtoLog.<span style=color:#a6e22e>v</span>(ProtoLogGroup.<span style=color:#a6e22e>WM_DEBUG_ORIENTATION</span>, <span style=color:#e6db74>&#34;Setting orientation to %d&#34;</span>, newOrientation);
</span></span></code></pre></div></li><li><p>编译时转换 (关键步骤)<br>当编译器（Javac）处理这段代码时，ProtoLog 的编译器插件会执行以下操作：</p><ul><li><p><strong>提取格式化字符串</strong>：插件找到 &ldquo;Setting orientation to %d&rdquo; 这个字符串。</p></li><li><p><strong>生成唯一哈希 ID</strong>：为这个字符串计算一个稳定且唯一的哈希值（例如 0x1A2B3C4D）。</p></li><li><p><strong>代码替换</strong>：插件将原始的 ProtoLog.v(&mldr;) 调用替换为一个高度优化的内部调用。替换后的代码大致等效于：<br>// 伪代码，实际实现更复杂</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (ProtoLogImpl.<span style=color:#a6e22e>isEnabled</span>(ProtoLogGroup.<span style=color:#a6e22e>WM_DEBUG_ORIENTATION</span>)) {  
</span></span><span style=display:flex><span>    ProtoLogImpl.<span style=color:#a6e22e>log</span>(LogLevel.<span style=color:#a6e22e>VERBOSE</span>, 0x1A2B3C4D, newOrientation);  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，原始的字符串已经消失了，只剩下<strong>哈希 ID</strong> 和<strong>参数</strong> (newOrientation)。</p></li></ul></li><li><p>生成 Viewer 映射文件<br>在编译过程中，插件还会将所有提取出的 “哈希 ID -> 格式化字符串” 的映射关系记录到一个 JSON 格式的配置文件中。这个文件是后续解码日志的关键。</p></li><li><p>设备上运行<br>当设备上的代码执行到被替换后的日志点时：</p><ul><li>它首先检查 <strong>WM_DEBUG_ORIENTATION</strong> 这个日志组是否被启用。</li><li>如果已启用，它会将日志级别、哈希 ID (0x1A2B3C4D) 和参数 (newOrientation 的值) 以紧凑的二进制格式写入专用的 protolog 日志缓冲区。整个过程不涉及任何字符串操作。</li><li>如果未启用，这个 if 判断会直接跳过，几乎没有性能开销。</li></ul></li><li><p>日志解码与查看<br>当开发者抓取日志时，看到的是二进制原始数据，无法直接阅读。此时，需要使用专门的工具（如 AOSP 中的 protologtool 脚本），并提供第 3 步生成的映射文件，才能将二进制日志解码成可读的文本：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span># 二进制流中的片段: [VERBOSE, 0x1A2B3C4D, 1]  
</span></span><span style=display:flex><span># 解码工具 + 映射文件 -&gt;  
</span></span><span style=display:flex><span># 输出: V WM_DEBUG_ORIENTATION: Setting orientation to 1
</span></span></code></pre></div></li></ol><p>这个流程巧妙地将最耗费性能的字符串处理工作从设备运行时转移到了开发者的编译机上，从而实现了其高性能的目标。</p><h2 id=3-使用场景><strong>3. 使用场景</strong><a hidden class=anchor aria-hidden=true href=#3-使用场景>#</a></h2><p>由于其设计特点，ProtoLog 特别适用于以下场景：</p><ul><li><strong>性能关键路径</strong>：在 Android Framework 的核心组件中，如 WindowManager、ActivityManagerService、SystemUI 等，这些代码对性能极其敏感，使用 ProtoLog 可以添加详细日志而不影响流畅度。</li><li><strong>高频事件监控</strong>：当需要记录频繁触发的事件时（例如，触摸事件处理、网络包收发、传感器数据更新），传统日志会迅速刷屏并拖慢系统，而 ProtoLog 则可以轻松应对。</li><li><strong>在 Release 版本中保留调试信息</strong>：开发者可以在代码中保留大量的 ProtoLog 日志。在发布给用户的版本中，这些日志默认是关闭的，开销为零。当需要诊断特定问题时，可以通过 adb 命令远程开启相关日志组来收集信息，极大地提升了问题排查的效率。</li><li><strong>系统健康与行为分析</strong>：通过在系统各处埋点，可以安全地收集大量结构化数据，用于后续的自动化分析和性能回归测试。</li></ul><h2 id=4-扩展rom-开发者如何自定义-protolog><strong>4. 扩展：ROM 开发者如何自定义 ProtoLog</strong><a hidden class=anchor aria-hidden=true href=#4-扩展rom-开发者如何自定义-protolog>#</a></h2><p>对于 ROM 开发者或设备制造商，可以定义自己的 ProtoLog 日志组，并将其集成到系统代码中。</p><h3 id=步骤-1定义新的-protolog-group><strong>步骤 1：定义新的 ProtoLog Group</strong><a hidden class=anchor aria-hidden=true href=#步骤-1定义新的-protolog-group>#</a></h3><p>首先，你需要创建一个类来定义你的日志组。每个组由一个布尔标志和一个标签（Tag）组成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// file: packages/services/MyCustomService/src/com/android/server/mycustom/MyProtoLogGroup.java</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> com.android.server.mycustom;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.android.internal.protolog.common.ProtoLog;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> MyProtoLogGroup <span style=color:#66d9ef>implements</span> ProtoLog.<span style=color:#a6e22e>LogGroup</span> {  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个名为 MY_CUSTOM_SERVICE_DEBUG 的日志组  </span>
</span></span><span style=display:flex><span>    MY_CUSTOM_SERVICE_DEBUG(<span style=color:#66d9ef>true</span>, <span style=color:#e6db74>&#34;MyCustomSvc&#34;</span>, ProtoLog.<span style=color:#a6e22e>LogLevel</span>.<span style=color:#a6e22e>DEBUG</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> mEnabled;  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String mTag;  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ProtoLog.<span style=color:#a6e22e>LogLevel</span> mLogLevel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MyProtoLogGroup(<span style=color:#66d9ef>boolean</span> enabled, String tag, ProtoLog.<span style=color:#a6e22e>LogLevel</span> level) {  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mEnabled</span> <span style=color:#f92672>=</span> enabled;  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mTag</span> <span style=color:#f92672>=</span> tag;  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mLogLevel</span> <span style=color:#f92672>=</span> level;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isEnabled</span>() {  
</span></span><span style=display:flex><span>        <span style=color:#75715e>// isEnabled() 的返回值会被编译时插件优化  </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mEnabled;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getTag</span>() {  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mTag;  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=步骤-2在构建系统-androidbp-中集成><strong>步骤 2：在构建系统 (Android.bp) 中集成</strong><a hidden class=anchor aria-hidden=true href=#步骤-2在构建系统-androidbp-中集成>#</a></h3><p>接下来，需要修改模块的 Android.bp 文件，通过 Soong 插件机制启用 ProtoLog。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-txt data-lang=txt><span style=display:flex><span>// file: packages/services/MyCustomService/Android.bp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>java_library {  
</span></span><span style=display:flex><span>    name: &#34;my-custom-service-lib&#34;,  
</span></span><span style=display:flex><span>    srcs: [&#34;src/**/*.java&#34;],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // ... 其他依赖
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 1. 通过 Soong 插件机制启用 ProtoLog 编译器插件  
</span></span><span style=display:flex><span>    plugins: [&#34;protolog-plugin&#34;],
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 2. 指定 Viewer 映射文件的输出路径  
</span></span><span style=display:flex><span>    protolog: {  
</span></span><span style=display:flex><span>        output: &#34;my-custom-service-protolog.json&#34;,  
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 3. 告知插件在哪里可以找到你的日志组定义  
</span></span><span style=display:flex><span>    //   这通常是包含 MyProtoLogGroup.java 的模块本身  
</span></span><span style=display:flex><span>    static_libs: [  
</span></span><span style=display:flex><span>        &#34;my-custom-service-lib-protolog-groups&#34;,  
</span></span><span style=display:flex><span>    ],  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 4. 单独定义一个包含 ProtoLog Group 定义的库  
</span></span><span style=display:flex><span>java_library {  
</span></span><span style=display:flex><span>    name: &#34;my-custom-service-lib-protolog-groups&#34;,  
</span></span><span style=display:flex><span>    srcs: [&#34;src/com/android/server/mycustom/MyProtoLogGroup.java&#34;],  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=步骤-3在代码中使用新的日志组><strong>步骤 3：在代码中使用新的日志组</strong><a hidden class=anchor aria-hidden=true href=#步骤-3在代码中使用新的日志组>#</a></h3><p>现在你可以在你的服务代码中使用刚刚定义的日志组了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import static</span> com.android.server.mycustom.MyProtoLogGroup.MY<span style=color:#960050;background-color:#1e0010>\</span>_CUSTOM<span style=color:#960050;background-color:#1e0010>\</span>_SERVICE<span style=color:#960050;background-color:#1e0010>\</span>_DEBUG;  
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.android.internal.protolog.common.ProtoLog;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCustomService</span> {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doSomething</span>() {  
</span></span><span style=display:flex><span>        ProtoLog.<span style=color:#a6e22e>d</span>(MY_CUSTOM_SERVICE_DEBUG, <span style=color:#e6db74>&#34;Doing something important with value %d.&#34;</span>, 42);  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=步骤-4在设备上控制和查看日志><strong>步骤 4：在设备上控制和查看日志</strong><a hidden class=anchor aria-hidden=true href=#步骤-4在设备上控制和查看日志>#</a></h3><p>编译并刷写系统后，你可以通过 adb shell 来控制日志的开关。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 方法一：通过 setprop 启用你的日志组 (Tag 是你在枚举中定义的 &#34;MyCustomSvc&#34;)  </span>
</span></span><span style=display:flex><span>$ adb shell setprop persist.log.tag.MyCustomSvc DEBUG
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 禁用  </span>
</span></span><span style=display:flex><span>$ adb shell setprop persist.log.tag.MyCustomSvc <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 注意：不同 Android 版本可能存在其他控制方式，例如通过 settings 命令。  </span>
</span></span><span style=display:flex><span><span style=color:#75715e># 请参考您所使用的 AOSP 版本的具体文档。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查看日志 (必须指定 protolog 缓冲区)  </span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 从编译输出目录 (out/...) 中找到 my-custom-service-protolog.json  </span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 运行解码脚本  </span>
</span></span><span style=display:flex><span>$ adb logcat -b protolog | path/to/aosp/protologtool --viewer-conf my-custom-service-protolog.json
</span></span></code></pre></div><p>通过以上步骤，ROM 开发者就可以将 ProtoLog 的强大能力无缝集成到自己的定制化模块中，实现高效、可控的日志记录。</p><h2 id=系统protolog>系统ProtoLog<a hidden class=anchor aria-hidden=true href=#系统protolog>#</a></h2><ol><li><p>打开 WindowManagerService 的ProtoLog:</p><ul><li>查看可以打开的ProtoGroup：
frameworks/base/core/java/com/android/internal/protolog/ProtoLogGroup.java</li><li>运行命令： adb shell cmd window logging enable-text XXX</li><li>adb logcat</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/perf--stability/spamming-oneway/><span class=title>« Prev</span><br><span>Binder spam detection原理</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/basic-communication-mechanism/binder/><span class=title>Next »</span><br><span>Android Binder 通信模型与内存管理机制详解</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>