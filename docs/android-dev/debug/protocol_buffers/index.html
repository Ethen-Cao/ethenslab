<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Protocol Buffers (Protobuf) 技术指南 | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 简介
Protocol Buffers (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化结构数据的机制。
相比于 XML 和 JSON，Protobuf 的主要特点是：

体积更小：二进制格式，数据紧凑。
速度更快：解析和序列化速度极快。
强类型：通过 .proto 文件定义数据结构，编译时自动生成代码。
兼容性：良好的向后兼容性支持。

在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。

2. 工作流程与架构
Protobuf 的核心工作流分为：定义、编译、使用、序列化/反序列化。


3. 语法指南 (.proto)
目前主流版本为 proto3。以下是一个典型的 .proto 文件示例。
3.1 基础结构
创建一个名为 car_event.proto 的文件：
// 1. 指定语法版本 (必须)
syntax = "proto3";

// 2. 定义包名 (防止命名冲突)
package com.example.cockpit;

// 3. 配置生成选项 (Java相关)
option java_package = "com.example.cockpit.proto"; // 生成的Java包路径
option java_outer_classname = "CarEventProto";   // 生成的Java外层类名

// 4. 定义消息 (Message)
message VehicleStatus {
    // 字段格式: 类型 字段名 = 字段编号;
    
    // 标量类型
    int32 speed = 1;          // 整数
    string vin_code = 2;      // 字符串
    bool is_moving = 3;       // 布尔值
    
    // 枚举类型
    enum Gear {
        GEAR_UNKNOWN = 0; // proto3 枚举第一个值必须为0
        GEAR_P = 1;
        GEAR_R = 2;
        GEAR_N = 3;
        GEAR_D = 4;
    }
    Gear current_gear = 4;

    // 嵌套消息
    EngineInfo engine = 5;

    // 数组 (Repeated)
    repeated string error_codes = 6; // 相当于 List<String>
}

message EngineInfo {
    float rpm = 1;
    float temperature = 2;
}
3.2 关键概念

字段编号 (Field Number)：例如 speed = 1 中的 1。

非常重要：这是二进制数据中字段的唯一标识，而不是字段名。
一旦数据投入使用，绝对不能修改已存在字段的编号。
1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。


类型映射：

int32/int64 -> Java int/long, C++ int32_t/int64_t
string -> Java String, C++ std::string
bool -> Java boolean, C++ bool




4. 编译方法
将 .proto 文件转换为目标语言代码。'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Protocol Buffers (Protobuf) 技术指南"><meta property="og:description" content='1. 简介 Protocol Buffers (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化结构数据的机制。
相比于 XML 和 JSON，Protobuf 的主要特点是：
体积更小：二进制格式，数据紧凑。 速度更快：解析和序列化速度极快。 强类型：通过 .proto 文件定义数据结构，编译时自动生成代码。 兼容性：良好的向后兼容性支持。 在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。
2. 工作流程与架构 Protobuf 的核心工作流分为：定义、编译、使用、序列化/反序列化。
3. 语法指南 (.proto) 目前主流版本为 proto3。以下是一个典型的 .proto 文件示例。
3.1 基础结构 创建一个名为 car_event.proto 的文件：
// 1. 指定语法版本 (必须) syntax = "proto3"; // 2. 定义包名 (防止命名冲突) package com.example.cockpit; // 3. 配置生成选项 (Java相关) option java_package = "com.example.cockpit.proto"; // 生成的Java包路径 option java_outer_classname = "CarEventProto"; // 生成的Java外层类名 // 4. 定义消息 (Message) message VehicleStatus { // 字段格式: 类型 字段名 = 字段编号; // 标量类型 int32 speed = 1; // 整数 string vin_code = 2; // 字符串 bool is_moving = 3; // 布尔值 // 枚举类型 enum Gear { GEAR_UNKNOWN = 0; // proto3 枚举第一个值必须为0 GEAR_P = 1; GEAR_R = 2; GEAR_N = 3; GEAR_D = 4; } Gear current_gear = 4; // 嵌套消息 EngineInfo engine = 5; // 数组 (Repeated) repeated string error_codes = 6; // 相当于 List<String> } message EngineInfo { float rpm = 1; float temperature = 2; } 3.2 关键概念 字段编号 (Field Number)：例如 speed = 1 中的 1。 非常重要：这是二进制数据中字段的唯一标识，而不是字段名。 一旦数据投入使用，绝对不能修改已存在字段的编号。 1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。 类型映射： int32/int64 -> Java int/long, C++ int32_t/int64_t string -> Java String, C++ std::string bool -> Java boolean, C++ bool 4. 编译方法 将 .proto 文件转换为目标语言代码。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="android-dev"><meta property="article:published_time" content="2025-08-27T11:36:11+08:00"><meta property="article:modified_time" content="2025-08-27T11:36:11+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Protocol Buffers (Protobuf) 技术指南"><meta name=twitter:description content='1. 简介
Protocol Buffers (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化结构数据的机制。
相比于 XML 和 JSON，Protobuf 的主要特点是：

体积更小：二进制格式，数据紧凑。
速度更快：解析和序列化速度极快。
强类型：通过 .proto 文件定义数据结构，编译时自动生成代码。
兼容性：良好的向后兼容性支持。

在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。

2. 工作流程与架构
Protobuf 的核心工作流分为：定义、编译、使用、序列化/反序列化。


3. 语法指南 (.proto)
目前主流版本为 proto3。以下是一个典型的 .proto 文件示例。
3.1 基础结构
创建一个名为 car_event.proto 的文件：
// 1. 指定语法版本 (必须)
syntax = "proto3";

// 2. 定义包名 (防止命名冲突)
package com.example.cockpit;

// 3. 配置生成选项 (Java相关)
option java_package = "com.example.cockpit.proto"; // 生成的Java包路径
option java_outer_classname = "CarEventProto";   // 生成的Java外层类名

// 4. 定义消息 (Message)
message VehicleStatus {
    // 字段格式: 类型 字段名 = 字段编号;
    
    // 标量类型
    int32 speed = 1;          // 整数
    string vin_code = 2;      // 字符串
    bool is_moving = 3;       // 布尔值
    
    // 枚举类型
    enum Gear {
        GEAR_UNKNOWN = 0; // proto3 枚举第一个值必须为0
        GEAR_P = 1;
        GEAR_R = 2;
        GEAR_N = 3;
        GEAR_D = 4;
    }
    Gear current_gear = 4;

    // 嵌套消息
    EngineInfo engine = 5;

    // 数组 (Repeated)
    repeated string error_codes = 6; // 相当于 List<String>
}

message EngineInfo {
    float rpm = 1;
    float temperature = 2;
}
3.2 关键概念

字段编号 (Field Number)：例如 speed = 1 中的 1。

非常重要：这是二进制数据中字段的唯一标识，而不是字段名。
一旦数据投入使用，绝对不能修改已存在字段的编号。
1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。


类型映射：

int32/int64 -> Java int/long, C++ int32_t/int64_t
string -> Java String, C++ std::string
bool -> Java boolean, C++ bool




4. 编译方法
将 .proto 文件转换为目标语言代码。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Android系统开发","item":"https://ethen-cao.github.io/ethenslab/android-dev/"},{"@type":"ListItem","position":2,"name":"Android 调试篇","item":"https://ethen-cao.github.io/ethenslab/android-dev/debug/"},{"@type":"ListItem","position":3,"name":"Protocol Buffers (Protobuf) 技术指南","item":"https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protocol Buffers (Protobuf) 技术指南","name":"Protocol Buffers (Protobuf) 技术指南","description":"1. 简介 Protocol Buffers (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化结构数据的机制。\n相比于 XML 和 JSON，Protobuf 的主要特点是：\n体积更小：二进制格式，数据紧凑。 速度更快：解析和序列化速度极快。 强类型：通过 .proto 文件定义数据结构，编译时自动生成代码。 兼容性：良好的向后兼容性支持。 在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。\n2. 工作流程与架构 Protobuf 的核心工作流分为：定义、编译、使用、序列化/反序列化。\n3. 语法指南 (.proto) 目前主流版本为 proto3。以下是一个典型的 .proto 文件示例。\n3.1 基础结构 创建一个名为 car_event.proto 的文件：\n// 1. 指定语法版本 (必须) syntax = \u0026#34;proto3\u0026#34;; // 2. 定义包名 (防止命名冲突) package com.example.cockpit; // 3. 配置生成选项 (Java相关) option java_package = \u0026#34;com.example.cockpit.proto\u0026#34;; // 生成的Java包路径 option java_outer_classname = \u0026#34;CarEventProto\u0026#34;; // 生成的Java外层类名 // 4. 定义消息 (Message) message VehicleStatus { // 字段格式: 类型 字段名 = 字段编号; // 标量类型 int32 speed = 1; // 整数 string vin_code = 2; // 字符串 bool is_moving = 3; // 布尔值 // 枚举类型 enum Gear { GEAR_UNKNOWN = 0; // proto3 枚举第一个值必须为0 GEAR_P = 1; GEAR_R = 2; GEAR_N = 3; GEAR_D = 4; } Gear current_gear = 4; // 嵌套消息 EngineInfo engine = 5; // 数组 (Repeated) repeated string error_codes = 6; // 相当于 List\u0026lt;String\u0026gt; } message EngineInfo { float rpm = 1; float temperature = 2; } 3.2 关键概念 字段编号 (Field Number)：例如 speed = 1 中的 1。 非常重要：这是二进制数据中字段的唯一标识，而不是字段名。 一旦数据投入使用，绝对不能修改已存在字段的编号。 1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。 类型映射： int32/int64 -\u0026gt; Java int/long, C++ int32_t/int64_t string -\u0026gt; Java String, C++ std::string bool -\u0026gt; Java boolean, C++ bool 4. 编译方法 将 .proto 文件转换为目标语言代码。\n","keywords":[],"articleBody":"1. 简介 Protocol Buffers (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化结构数据的机制。\n相比于 XML 和 JSON，Protobuf 的主要特点是：\n体积更小：二进制格式，数据紧凑。 速度更快：解析和序列化速度极快。 强类型：通过 .proto 文件定义数据结构，编译时自动生成代码。 兼容性：良好的向后兼容性支持。 在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。\n2. 工作流程与架构 Protobuf 的核心工作流分为：定义、编译、使用、序列化/反序列化。\n3. 语法指南 (.proto) 目前主流版本为 proto3。以下是一个典型的 .proto 文件示例。\n3.1 基础结构 创建一个名为 car_event.proto 的文件：\n// 1. 指定语法版本 (必须) syntax = \"proto3\"; // 2. 定义包名 (防止命名冲突) package com.example.cockpit; // 3. 配置生成选项 (Java相关) option java_package = \"com.example.cockpit.proto\"; // 生成的Java包路径 option java_outer_classname = \"CarEventProto\"; // 生成的Java外层类名 // 4. 定义消息 (Message) message VehicleStatus { // 字段格式: 类型 字段名 = 字段编号; // 标量类型 int32 speed = 1; // 整数 string vin_code = 2; // 字符串 bool is_moving = 3; // 布尔值 // 枚举类型 enum Gear { GEAR_UNKNOWN = 0; // proto3 枚举第一个值必须为0 GEAR_P = 1; GEAR_R = 2; GEAR_N = 3; GEAR_D = 4; } Gear current_gear = 4; // 嵌套消息 EngineInfo engine = 5; // 数组 (Repeated) repeated string error_codes = 6; // 相当于 List } message EngineInfo { float rpm = 1; float temperature = 2; } 3.2 关键概念 字段编号 (Field Number)：例如 speed = 1 中的 1。 非常重要：这是二进制数据中字段的唯一标识，而不是字段名。 一旦数据投入使用，绝对不能修改已存在字段的编号。 1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。 类型映射： int32/int64 -\u003e Java int/long, C++ int32_t/int64_t string -\u003e Java String, C++ std::string bool -\u003e Java boolean, C++ bool 4. 编译方法 将 .proto 文件转换为目标语言代码。\n4.1 使用标准 protoc 编译 Google 提供的标准编译器。\n编译为 Java 代码:\nprotoc --java_out=./src/main/java car_event.proto 编译为 C++ 代码:\n# 会生成 .pb.h 和 .pb.cc 文件 protoc --cpp_out=./src/main/cpp car_event.proto 4.2 在 Android 构建系统中编译 (Android.bp) Android 源码环境通常使用 Android.bp 自动处理。\njava_library { name: \"car-event-proto-java\", proto: { type: \"lite\", // 推荐移动端使用 lite 版本，体积更小 }, srcs: [\"src/proto/car_event.proto\"], sdk_version: \"current\", } cc_library { name: \"libcarevent_proto\", proto: { type: \"lite\", export_proto_headers: true, }, srcs: [\"src/proto/car_event.proto\"], } 5. 代码使用示例 5.1 Java 侧使用 (序列化与反序列化) Protobuf 使用 Builder 模式 来构建对象。\nimport com.example.cockpit.proto.CarEventProto.VehicleStatus; import com.example.cockpit.proto.CarEventProto.VehicleStatus.Gear; // 1. 构建对象 (序列化前) VehicleStatus status = VehicleStatus.newBuilder() .setSpeed(120) .setVinCode(\"example12345678\") .setIsMoving(true) .setCurrentGear(Gear.GEAR_D) .addErrorCodes(\"E001\") // 添加数组元素 .addErrorCodes(\"E002\") .build(); // 2. 序列化 (转为 byte[]) // 场景：通过 Socket 发送、存入文件、存入 StatsD byte[] data = status.toByteArray(); System.out.println(\"Binary Size: \" + data.length); // ------------------------------------------- // 3. 反序列化 (从 byte[] 转回对象) try { VehicleStatus receivedStatus = VehicleStatus.parseFrom(data); // 访问数据 System.out.println(\"Speed: \" + receivedStatus.getSpeed()); System.out.println(\"VIN: \" + receivedStatus.getVinCode()); } catch (InvalidProtocolBufferException e) { e.printStackTrace(); } 5.2 C++ 侧使用 #include \"car_event.pb.h\" #include #include using namespace com::example::cockpit; void serialization_example() { // 1. 构建对象 VehicleStatus status; status.set_speed(120); status.set_vin_code(\"example12345678\"); status.set_is_moving(true); status.set_current_gear(VehicleStatus::GEAR_D); // 添加数组元素 status.add_error_codes(\"E001\"); // 2. 序列化 (Serialize) std::string binary_output; if (status.SerializeToString(\u0026binary_output)) { // binary_output 现在包含了序列化后的数据，可以发送到 Socket } } void deserialization_example(const std::string\u0026 data_in) { // 3. 反序列化 (Deserialize) VehicleStatus status; if (status.ParseFromString(data_in)) { std::cout \u003c\u003c \"Speed: \" \u003c\u003c status.speed() \u003c\u003c std::endl; std::cout \u003c\u003c \"VIN: \" \u003c\u003c status.vin_code() \u003c\u003c std::endl; } } 6. 最佳实践与注意事项 字段编号管理： 永远不要修改已存在字段的 ID。如果必须修改，请新建一个字段，废弃旧字段。 可以使用 reserved 关键字保留已删除的 ID，防止后续误用： reserved 3, 5 to 7; reserved \"old_field_name\"; 默认值 (Proto3)： Proto3 不再支持手动设置 default 值。 基础类型的默认值为：int=0, bool=false, string=\"\"。 注意：如果一个字段的值等于默认值（例如 speed=0），序列化时该字段不会被写入二进制流（为了节省空间）。反序列化时如果读不到该字段，会直接赋予默认值。 兼容性设计： 新增字段：旧代码读取新数据时，会忽略新字段（向后兼容）。 删除字段：新代码读取旧数据时，已删除字段会获得默认值（向前兼容）。 ","wordCount":"460","inLanguage":"en","datePublished":"2025-08-27T11:36:11+08:00","dateModified":"2025-08-27T11:36:11+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/android-dev/debug/protocol_buffers/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/>Android系统开发</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/android-dev/debug/>Android 调试篇</a></div><h1 class="post-title entry-hint-parent">Protocol Buffers (Protobuf) 技术指南</h1><div class=post-meta><span title='2025-08-27 11:36:11 +0800 CST'>August 27, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words</div></header><div class=post-content><h2 id=1-简介>1. 简介<a hidden class=anchor aria-hidden=true href=#1-简介>#</a></h2><p><strong>Protocol Buffers</strong> (简称 Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的<strong>序列化结构数据</strong>的机制。</p><p>相比于 XML 和 JSON，Protobuf 的主要特点是：</p><ul><li><strong>体积更小</strong>：二进制格式，数据紧凑。</li><li><strong>速度更快</strong>：解析和序列化速度极快。</li><li><strong>强类型</strong>：通过 <code>.proto</code> 文件定义数据结构，编译时自动生成代码。</li><li><strong>兼容性</strong>：良好的向后兼容性支持。</li></ul><p>在 Android 系统中，Protobuf 被广泛用于 StatsD (指标上报)、Incidentd (事故报告)、Binder IPC 数据传输等场景。</p><hr><h2 id=2-工作流程与架构>2. 工作流程与架构<a hidden class=anchor aria-hidden=true href=#2-工作流程与架构>#</a></h2><p>Protobuf 的核心工作流分为：<strong>定义</strong>、<strong>编译</strong>、<strong>使用</strong>、<strong>序列化/反序列化</strong>。</p><p><img src=/ethenslab/images/Protobuf.png alt></p><hr><h2 id=3-语法指南-proto>3. 语法指南 (.proto)<a hidden class=anchor aria-hidden=true href=#3-语法指南-proto>#</a></h2><p>目前主流版本为 <strong>proto3</strong>。以下是一个典型的 <code>.proto</code> 文件示例。</p><h3 id=31-基础结构>3.1 基础结构<a hidden class=anchor aria-hidden=true href=#31-基础结构>#</a></h3><p>创建一个名为 <code>car_event.proto</code> 的文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#75715e>// 1. 指定语法版本 (必须)
</span></span></span><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 定义包名 (防止命名冲突)
</span></span></span><span style=display:flex><span><span style=color:#f92672>package</span> com<span style=color:#f92672>.</span>example.cockpit;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3. 配置生成选项 (Java相关)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>option</span> java_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;com.example.cockpit.proto&#34;</span>; <span style=color:#75715e>// 生成的Java包路径
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>option</span> java_outer_classname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;CarEventProto&#34;</span>;   <span style=color:#75715e>// 生成的Java外层类名
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 4. 定义消息 (Message)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>VehicleStatus</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 字段格式: 类型 字段名 = 字段编号;
</span></span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 标量类型
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int32</span> speed <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;          <span style=color:#75715e>// 整数
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> vin_code <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;      <span style=color:#75715e>// 字符串
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> is_moving <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;       <span style=color:#75715e>// 布尔值
</span></span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 枚举类型
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> Gear {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>        GEAR_UNKNOWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// proto3 枚举第一个值必须为0
</span></span></span><span style=display:flex><span>        GEAR_P <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>        GEAR_R <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>        GEAR_N <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>        GEAR_D <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    Gear current_gear <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 嵌套消息
</span></span></span><span style=display:flex><span>    EngineInfo engine <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 数组 (Repeated)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>repeated</span> <span style=color:#66d9ef>string</span> error_codes <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>; <span style=color:#75715e>// 相当于 List&lt;String&gt;
</span></span></span><span style=display:flex><span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>EngineInfo</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> rpm <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> temperature <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=32-关键概念>3.2 关键概念<a hidden class=anchor aria-hidden=true href=#32-关键概念>#</a></h3><ol><li><strong>字段编号 (Field Number)</strong>：例如 <code>speed = 1</code> 中的 <code>1</code>。<ul><li><strong>非常重要</strong>：这是二进制数据中字段的唯一标识，而不是字段名。</li><li>一旦数据投入使用，<strong>绝对不能修改</strong>已存在字段的编号。</li><li>1~15 占用 1 个字节，16~2047 占用 2 个字节（建议将频繁使用的字段放在 1~15）。</li></ul></li><li><strong>类型映射</strong>：<ul><li><code>int32/int64</code> -> Java <code>int/long</code>, C++ <code>int32_t/int64_t</code></li><li><code>string</code> -> Java <code>String</code>, C++ <code>std::string</code></li><li><code>bool</code> -> Java <code>boolean</code>, C++ <code>bool</code></li></ul></li></ol><hr><h2 id=4-编译方法>4. 编译方法<a hidden class=anchor aria-hidden=true href=#4-编译方法>#</a></h2><p>将 <code>.proto</code> 文件转换为目标语言代码。</p><h3 id=41-使用标准-protoc-编译>4.1 使用标准 protoc 编译<a hidden class=anchor aria-hidden=true href=#41-使用标准-protoc-编译>#</a></h3><p>Google 提供的标准编译器。</p><p><strong>编译为 Java 代码:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>protoc --java_out<span style=color:#f92672>=</span>./src/main/java car_event.proto
</span></span></code></pre></div><p><strong>编译为 C++ 代码:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 会生成 .pb.h 和 .pb.cc 文件</span>
</span></span><span style=display:flex><span>protoc --cpp_out<span style=color:#f92672>=</span>./src/main/cpp car_event.proto
</span></span></code></pre></div><h3 id=42-在-android-构建系统中编译-androidbp>4.2 在 Android 构建系统中编译 (Android.bp)<a hidden class=anchor aria-hidden=true href=#42-在-android-构建系统中编译-androidbp>#</a></h3><p>Android 源码环境通常使用 <code>Android.bp</code> 自动处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>java_library</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;car-event-proto-java&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>proto</span>: {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span>: <span style=color:#e6db74>&#34;lite&#34;</span>, <span style=color:#75715e>// 推荐移动端使用 lite 版本，体积更小</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>srcs</span>: [<span style=color:#e6db74>&#34;src/proto/car_event.proto&#34;</span>],
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sdk_version</span>: <span style=color:#e6db74>&#34;current&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc_library</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;libcarevent_proto&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>proto</span>: {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>type</span>: <span style=color:#e6db74>&#34;lite&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>export_proto_headers</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>srcs</span>: [<span style=color:#e6db74>&#34;src/proto/car_event.proto&#34;</span>],
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=5-代码使用示例>5. 代码使用示例<a hidden class=anchor aria-hidden=true href=#5-代码使用示例>#</a></h2><h3 id=51-java-侧使用-序列化与反序列化>5.1 Java 侧使用 (序列化与反序列化)<a hidden class=anchor aria-hidden=true href=#51-java-侧使用-序列化与反序列化>#</a></h3><p>Protobuf 使用 <strong>Builder 模式</strong> 来构建对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.example.cockpit.proto.CarEventProto.VehicleStatus;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.example.cockpit.proto.CarEventProto.VehicleStatus.Gear;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1. 构建对象 (序列化前)</span>
</span></span><span style=display:flex><span>VehicleStatus status <span style=color:#f92672>=</span> VehicleStatus.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>setSpeed</span>(120)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>setVinCode</span>(<span style=color:#e6db74>&#34;example12345678&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>setIsMoving</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>setCurrentGear</span>(Gear.<span style=color:#a6e22e>GEAR_D</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>addErrorCodes</span>(<span style=color:#e6db74>&#34;E001&#34;</span>) <span style=color:#75715e>// 添加数组元素</span>
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>addErrorCodes</span>(<span style=color:#e6db74>&#34;E002&#34;</span>)
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. 序列化 (转为 byte[])</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 场景：通过 Socket 发送、存入文件、存入 StatsD</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> data <span style=color:#f92672>=</span> status.<span style=color:#a6e22e>toByteArray</span>(); 
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Binary Size: &#34;</span> <span style=color:#f92672>+</span> data.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 反序列化 (从 byte[] 转回对象)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    VehicleStatus receivedStatus <span style=color:#f92672>=</span> VehicleStatus.<span style=color:#a6e22e>parseFrom</span>(data);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 访问数据</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Speed: &#34;</span> <span style=color:#f92672>+</span> receivedStatus.<span style=color:#a6e22e>getSpeed</span>());
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;VIN: &#34;</span> <span style=color:#f92672>+</span> receivedStatus.<span style=color:#a6e22e>getVinCode</span>());
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (InvalidProtocolBufferException e) {
</span></span><span style=display:flex><span>    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=52-c-侧使用>5.2 C++ 侧使用<a hidden class=anchor aria-hidden=true href=#52-c-侧使用>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;car_event.pb.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> com<span style=color:#f92672>::</span>example<span style=color:#f92672>::</span>cockpit;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>serialization_example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 构建对象
</span></span></span><span style=display:flex><span>    VehicleStatus status;
</span></span><span style=display:flex><span>    status.set_speed(<span style=color:#ae81ff>120</span>);
</span></span><span style=display:flex><span>    status.set_vin_code(<span style=color:#e6db74>&#34;example12345678&#34;</span>);
</span></span><span style=display:flex><span>    status.set_is_moving(true);
</span></span><span style=display:flex><span>    status.set_current_gear(VehicleStatus<span style=color:#f92672>::</span>GEAR_D);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 添加数组元素
</span></span></span><span style=display:flex><span>    status.add_error_codes(<span style=color:#e6db74>&#34;E001&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 序列化 (Serialize)
</span></span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string binary_output;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status.SerializeToString(<span style=color:#f92672>&amp;</span>binary_output)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// binary_output 现在包含了序列化后的数据，可以发送到 Socket
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deserialization_example</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> data_in) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 反序列化 (Deserialize)
</span></span></span><span style=display:flex><span>    VehicleStatus status;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status.ParseFromString(data_in)) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Speed: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> status.speed() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;VIN: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> status.vin_code() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=6-最佳实践与注意事项>6. 最佳实践与注意事项<a hidden class=anchor aria-hidden=true href=#6-最佳实践与注意事项>#</a></h2><ol><li><strong>字段编号管理</strong>：<ul><li><strong>永远不要</strong>修改已存在字段的 ID。如果必须修改，请新建一个字段，废弃旧字段。</li><li>可以使用 <code>reserved</code> 关键字保留已删除的 ID，防止后续误用：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>reserved <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span> <span style=color:#66d9ef>to</span> <span style=color:#ae81ff>7</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span>reserved <span style=color:#e6db74>&#34;old_field_name&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></li></ul></li><li><strong>默认值 (Proto3)</strong>：<ul><li>Proto3 不再支持手动设置 default 值。</li><li>基础类型的默认值为：<code>int=0</code>, <code>bool=false</code>, <code>string=""</code>。</li><li><strong>注意</strong>：如果一个字段的值等于默认值（例如 speed=0），序列化时该字段<strong>不会</strong>被写入二进制流（为了节省空间）。反序列化时如果读不到该字段，会直接赋予默认值。</li></ul></li><li><strong>兼容性设计</strong>：<ul><li><strong>新增字段</strong>：旧代码读取新数据时，会忽略新字段（向后兼容）。</li><li><strong>删除字段</strong>：新代码读取旧数据时，已删除字段会获得默认值（向前兼容）。</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ethen-cao.github.io/ethenslab/android-dev/debug/log/><span class=title>« Prev</span><br><span>Android log机制</span>
</a><a class=next href=https://ethen-cao.github.io/ethenslab/android-dev/media/widevine-l1-verification-process/><span class=title>Next »</span><br><span>高通平台 Widevine L1 认证实施流程</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>