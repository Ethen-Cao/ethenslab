<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image | Ethen 的实验室</title><meta name=keywords content><meta name=description content='1. 概述
本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 Virtio-blk 协议高效地访问 Host 侧的物理存储设备。该架构采用 Userspace Backend 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 qcrosvm）的用户态进程中。

  @startuml
!theme plain
skinparam componentStyle rectangle
skinparam shadowing false

top to bottom direction

legend right
<color:#1F77B4>━━ Shared Memory / Data Plane（共享内存，非数据流）</color>
<color:#FF7F0E>━━ Control Plane（kick / irq / 状态推进）</color>
endlegend

&#39; =======================
&#39; Guest
&#39; =======================
frame "Android Guest (VM)" as G #E3F2FD {
  component "Android App" as App
  component "VFS / FS" as FS
  component "Block Layer" as BL
  component "virtio-blk\n(frontend driver)" as FE

  App --> FS
  FS --> BL
  BL --> FE : submit block request
}

&#39; =======================
&#39; Shared Memory (Guest-owned, Host-mapped)
&#39; =======================
frame "Guest RAM (Shared Memory)" as RAM #ECEFF1 {
  component "Virtqueue\n- Descriptor Table\n- Avail Ring\n- Used Ring" as VQ
  component "Guest Data Buffers\n(Block I/O payload)" as BUF
}

&#39; =======================
&#39; Host
&#39; =======================
frame "Linux Host" as H #E8F5E9 {

  frame "User Space" as USER {
    component "qcrosvm\n(VMM + virtio-blk backend)" as BE
  }

  frame "Linux Kernel" as KERNEL {
    component "Host Block Layer / FS" as HBLK
  }
}

&#39; =======================
&#39; Hardware
&#39; =======================
frame "Hardware" as HW {
  component "Physical Block Device\n(eMMC / UFS / NVMe)" as DISK
}

&#39; =======================
&#39; Hypervisor (mechanism only)
&#39; =======================
rectangle "Gunyah Hypervisor\n(Memory Mapping, eventfd, irqfd)" as HV #F5F5F5

&#39; =======================
&#39; Data Plane (shared memory access, NOT data flow)
&#39; =======================
FE ..[#1F77B4]..> VQ  : access
FE ..[#1F77B4]..> BUF : access

BE ..[#1F77B4]..> VQ  : access
BE ..[#1F77B4]..> BUF : access

&#39; =======================
&#39; Control Plane
&#39; =======================
FE -[#FF7F0E]-> HV : QueueNotify (kick)
HV -[#FF7F0E]-> BE : eventfd wakeup

BE -[#FF7F0E]-> HV : inject IRQ (irqfd)
HV -[#FF7F0E]-> FE : virtual interrupt

&#39; =======================
&#39; Backend I/O Path
&#39; =======================
BE --> HBLK : read / write
HBLK --> DISK

@enduml
2. 核心组件与角色


Guest (Android VM):'><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/gunyah/gunyah-virtio-blk/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/gunyah/gunyah-virtio-blk/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/gunyah/gunyah-virtio-blk/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image"><meta property="og:description" content='1. 概述 本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 Virtio-blk 协议高效地访问 Host 侧的物理存储设备。该架构采用 Userspace Backend 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 qcrosvm）的用户态进程中。
@startuml !theme plain skinparam componentStyle rectangle skinparam shadowing false top to bottom direction legend right <color:#1F77B4>━━ Shared Memory / Data Plane（共享内存，非数据流）</color> <color:#FF7F0E>━━ Control Plane（kick / irq / 状态推进）</color> endlegend &#39; ======================= &#39; Guest &#39; ======================= frame "Android Guest (VM)" as G #E3F2FD { component "Android App" as App component "VFS / FS" as FS component "Block Layer" as BL component "virtio-blk\n(frontend driver)" as FE App --> FS FS --> BL BL --> FE : submit block request } &#39; ======================= &#39; Shared Memory (Guest-owned, Host-mapped) &#39; ======================= frame "Guest RAM (Shared Memory)" as RAM #ECEFF1 { component "Virtqueue\n- Descriptor Table\n- Avail Ring\n- Used Ring" as VQ component "Guest Data Buffers\n(Block I/O payload)" as BUF } &#39; ======================= &#39; Host &#39; ======================= frame "Linux Host" as H #E8F5E9 { frame "User Space" as USER { component "qcrosvm\n(VMM + virtio-blk backend)" as BE } frame "Linux Kernel" as KERNEL { component "Host Block Layer / FS" as HBLK } } &#39; ======================= &#39; Hardware &#39; ======================= frame "Hardware" as HW { component "Physical Block Device\n(eMMC / UFS / NVMe)" as DISK } &#39; ======================= &#39; Hypervisor (mechanism only) &#39; ======================= rectangle "Gunyah Hypervisor\n(Memory Mapping, eventfd, irqfd)" as HV #F5F5F5 &#39; ======================= &#39; Data Plane (shared memory access, NOT data flow) &#39; ======================= FE ..[#1F77B4]..> VQ : access FE ..[#1F77B4]..> BUF : access BE ..[#1F77B4]..> VQ : access BE ..[#1F77B4]..> BUF : access &#39; ======================= &#39; Control Plane &#39; ======================= FE -[#FF7F0E]-> HV : QueueNotify (kick) HV -[#FF7F0E]-> BE : eventfd wakeup BE -[#FF7F0E]-> HV : inject IRQ (irqfd) HV -[#FF7F0E]-> FE : virtual interrupt &#39; ======================= &#39; Backend I/O Path &#39; ======================= BE --> HBLK : read / write HBLK --> DISK @enduml 2. 核心组件与角色 Guest (Android VM):'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="gunyah"><meta property="article:published_time" content="2025-08-04T09:49:58+08:00"><meta property="article:modified_time" content="2025-08-04T09:49:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image"><meta name=twitter:description content='1. 概述
本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 Virtio-blk 协议高效地访问 Host 侧的物理存储设备。该架构采用 Userspace Backend 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 qcrosvm）的用户态进程中。

  @startuml
!theme plain
skinparam componentStyle rectangle
skinparam shadowing false

top to bottom direction

legend right
<color:#1F77B4>━━ Shared Memory / Data Plane（共享内存，非数据流）</color>
<color:#FF7F0E>━━ Control Plane（kick / irq / 状态推进）</color>
endlegend

&#39; =======================
&#39; Guest
&#39; =======================
frame "Android Guest (VM)" as G #E3F2FD {
  component "Android App" as App
  component "VFS / FS" as FS
  component "Block Layer" as BL
  component "virtio-blk\n(frontend driver)" as FE

  App --> FS
  FS --> BL
  BL --> FE : submit block request
}

&#39; =======================
&#39; Shared Memory (Guest-owned, Host-mapped)
&#39; =======================
frame "Guest RAM (Shared Memory)" as RAM #ECEFF1 {
  component "Virtqueue\n- Descriptor Table\n- Avail Ring\n- Used Ring" as VQ
  component "Guest Data Buffers\n(Block I/O payload)" as BUF
}

&#39; =======================
&#39; Host
&#39; =======================
frame "Linux Host" as H #E8F5E9 {

  frame "User Space" as USER {
    component "qcrosvm\n(VMM + virtio-blk backend)" as BE
  }

  frame "Linux Kernel" as KERNEL {
    component "Host Block Layer / FS" as HBLK
  }
}

&#39; =======================
&#39; Hardware
&#39; =======================
frame "Hardware" as HW {
  component "Physical Block Device\n(eMMC / UFS / NVMe)" as DISK
}

&#39; =======================
&#39; Hypervisor (mechanism only)
&#39; =======================
rectangle "Gunyah Hypervisor\n(Memory Mapping, eventfd, irqfd)" as HV #F5F5F5

&#39; =======================
&#39; Data Plane (shared memory access, NOT data flow)
&#39; =======================
FE ..[#1F77B4]..> VQ  : access
FE ..[#1F77B4]..> BUF : access

BE ..[#1F77B4]..> VQ  : access
BE ..[#1F77B4]..> BUF : access

&#39; =======================
&#39; Control Plane
&#39; =======================
FE -[#FF7F0E]-> HV : QueueNotify (kick)
HV -[#FF7F0E]-> BE : eventfd wakeup

BE -[#FF7F0E]-> HV : inject IRQ (irqfd)
HV -[#FF7F0E]-> FE : virtual interrupt

&#39; =======================
&#39; Backend I/O Path
&#39; =======================
BE --> HBLK : read / write
HBLK --> DISK

@enduml
2. 核心组件与角色


Guest (Android VM):'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Gunyah开发笔记","item":"https://ethen-cao.github.io/ethenslab/gunyah/"},{"@type":"ListItem","position":2,"name":"高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image","item":"https://ethen-cao.github.io/ethenslab/gunyah/gunyah-virtio-blk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image","name":"高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image","description":"1. 概述 本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 Virtio-blk 协议高效地访问 Host 侧的物理存储设备。该架构采用 Userspace Backend 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 qcrosvm）的用户态进程中。\n@startuml !theme plain skinparam componentStyle rectangle skinparam shadowing false top to bottom direction legend right \u0026lt;color:#1F77B4\u0026gt;━━ Shared Memory / Data Plane（共享内存，非数据流）\u0026lt;/color\u0026gt; \u0026lt;color:#FF7F0E\u0026gt;━━ Control Plane（kick / irq / 状态推进）\u0026lt;/color\u0026gt; endlegend \u0026#39; ======================= \u0026#39; Guest \u0026#39; ======================= frame \u0026#34;Android Guest (VM)\u0026#34; as G #E3F2FD { component \u0026#34;Android App\u0026#34; as App component \u0026#34;VFS / FS\u0026#34; as FS component \u0026#34;Block Layer\u0026#34; as BL component \u0026#34;virtio-blk\\n(frontend driver)\u0026#34; as FE App --\u0026gt; FS FS --\u0026gt; BL BL --\u0026gt; FE : submit block request } \u0026#39; ======================= \u0026#39; Shared Memory (Guest-owned, Host-mapped) \u0026#39; ======================= frame \u0026#34;Guest RAM (Shared Memory)\u0026#34; as RAM #ECEFF1 { component \u0026#34;Virtqueue\\n- Descriptor Table\\n- Avail Ring\\n- Used Ring\u0026#34; as VQ component \u0026#34;Guest Data Buffers\\n(Block I/O payload)\u0026#34; as BUF } \u0026#39; ======================= \u0026#39; Host \u0026#39; ======================= frame \u0026#34;Linux Host\u0026#34; as H #E8F5E9 { frame \u0026#34;User Space\u0026#34; as USER { component \u0026#34;qcrosvm\\n(VMM \u0026#43; virtio-blk backend)\u0026#34; as BE } frame \u0026#34;Linux Kernel\u0026#34; as KERNEL { component \u0026#34;Host Block Layer / FS\u0026#34; as HBLK } } \u0026#39; ======================= \u0026#39; Hardware \u0026#39; ======================= frame \u0026#34;Hardware\u0026#34; as HW { component \u0026#34;Physical Block Device\\n(eMMC / UFS / NVMe)\u0026#34; as DISK } \u0026#39; ======================= \u0026#39; Hypervisor (mechanism only) \u0026#39; ======================= rectangle \u0026#34;Gunyah Hypervisor\\n(Memory Mapping, eventfd, irqfd)\u0026#34; as HV #F5F5F5 \u0026#39; ======================= \u0026#39; Data Plane (shared memory access, NOT data flow) \u0026#39; ======================= FE ..[#1F77B4]..\u0026gt; VQ : access FE ..[#1F77B4]..\u0026gt; BUF : access BE ..[#1F77B4]..\u0026gt; VQ : access BE ..[#1F77B4]..\u0026gt; BUF : access \u0026#39; ======================= \u0026#39; Control Plane \u0026#39; ======================= FE -[#FF7F0E]-\u0026gt; HV : QueueNotify (kick) HV -[#FF7F0E]-\u0026gt; BE : eventfd wakeup BE -[#FF7F0E]-\u0026gt; HV : inject IRQ (irqfd) HV -[#FF7F0E]-\u0026gt; FE : virtual interrupt \u0026#39; ======================= \u0026#39; Backend I/O Path \u0026#39; ======================= BE --\u0026gt; HBLK : read / write HBLK --\u0026gt; DISK @enduml 2. 核心组件与角色 Guest (Android VM):\n","keywords":[],"articleBody":"1. 概述 本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 Virtio-blk 协议高效地访问 Host 侧的物理存储设备。该架构采用 Userspace Backend 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 qcrosvm）的用户态进程中。\n@startuml !theme plain skinparam componentStyle rectangle skinparam shadowing false top to bottom direction legend right ━━ Shared Memory / Data Plane（共享内存，非数据流） ━━ Control Plane（kick / irq / 状态推进） endlegend ' ======================= ' Guest ' ======================= frame \"Android Guest (VM)\" as G #E3F2FD { component \"Android App\" as App component \"VFS / FS\" as FS component \"Block Layer\" as BL component \"virtio-blk\\n(frontend driver)\" as FE App --\u003e FS FS --\u003e BL BL --\u003e FE : submit block request } ' ======================= ' Shared Memory (Guest-owned, Host-mapped) ' ======================= frame \"Guest RAM (Shared Memory)\" as RAM #ECEFF1 { component \"Virtqueue\\n- Descriptor Table\\n- Avail Ring\\n- Used Ring\" as VQ component \"Guest Data Buffers\\n(Block I/O payload)\" as BUF } ' ======================= ' Host ' ======================= frame \"Linux Host\" as H #E8F5E9 { frame \"User Space\" as USER { component \"qcrosvm\\n(VMM + virtio-blk backend)\" as BE } frame \"Linux Kernel\" as KERNEL { component \"Host Block Layer / FS\" as HBLK } } ' ======================= ' Hardware ' ======================= frame \"Hardware\" as HW { component \"Physical Block Device\\n(eMMC / UFS / NVMe)\" as DISK } ' ======================= ' Hypervisor (mechanism only) ' ======================= rectangle \"Gunyah Hypervisor\\n(Memory Mapping, eventfd, irqfd)\" as HV #F5F5F5 ' ======================= ' Data Plane (shared memory access, NOT data flow) ' ======================= FE ..[#1F77B4]..\u003e VQ : access FE ..[#1F77B4]..\u003e BUF : access BE ..[#1F77B4]..\u003e VQ : access BE ..[#1F77B4]..\u003e BUF : access ' ======================= ' Control Plane ' ======================= FE -[#FF7F0E]-\u003e HV : QueueNotify (kick) HV -[#FF7F0E]-\u003e BE : eventfd wakeup BE -[#FF7F0E]-\u003e HV : inject IRQ (irqfd) HV -[#FF7F0E]-\u003e FE : virtual interrupt ' ======================= ' Backend I/O Path ' ======================= BE --\u003e HBLK : read / write HBLK --\u003e DISK @enduml 2. 核心组件与角色 Guest (Android VM):\nVirtio-blk Frontend: 运行在 Android 内核中的驱动程序。它不进行实际的数据拷贝，而是负责将上层文件系统（App/VFS）的读写请求封装成 Virtio 格式的描述符。\nBlock Layer: 生成标准的块 I/O 请求。\nShared Memory (数据平面):\n这是 Guest 的部分 RAM，被 Hypervisor 映射给 Host 侧的 qcrosvm 访问。\nVirtqueue (VQ): 核心数据结构，包含描述符表（Descriptors）、可用环（Avail Ring）和已用环（Used Ring）。\nData Buffers: 实际存放读写数据的内存区域。\n机制: 前后端通过共享内存直接读写数据，实现了 Zero-Copy（零拷贝） 的高效数据传输。\nHost (Linux \u0026 qcrosvm):\nqcrosvm (VMM + Backend): 这是宿主机上的虚拟机管理进程。它内部集成了 virtio-blk 的后端逻辑，负责从共享内存中取出请求，并将其转化为宿主机的文件读写操作。\nHost Block Layer: Linux 内核的通用块设备层，负责最终驱动物理硬件。\nHypervisor (Gunyah):\n负责特权级切换、内存映射管理、以及中断和通知（Kick）的路由（通过 eventfd 和 irqfd）。\n3. I/O 处理流程详解 整个 I/O 周期可以分为 请求提交、通知与处理、中断完成 三个阶段：\n阶段一：请求提交 (Guest -\u003e Shared Memory)\nAndroid App 发起读写请求，经过 VFS 和 Block Layer，到达 virtio-blk 前端驱动。 前端驱动将请求的数据缓冲区地址和长度写入 Shared Memory 中的 Virtqueue (Descriptor Table)。 前端更新 Avail Ring，表示有新的请求待处理。 阶段二：通知与处理 (Kick -\u003e Backend Processing)\nKick (Notify): 前端驱动执行 MMIO 写操作（QueueNotify）。 Trap \u0026 Signal: Gunyah Hypervisor 捕获该 MMIO 操作，识别为通知事件，通过 eventfd 唤醒处于用户态的 qcrosvm 进程。 Process: qcrosvm 被唤醒后： 直接访问共享内存中的 Virtqueue，读取请求详情。 根据描述符找到 Data Buffer。 向 Host Linux Kernel 发起实际的读写系统调用（read/write 或 io_uring）。 硬件完成 I/O 后，数据被写入/读出物理磁盘。 阶段三：完成与中断 (Backend -\u003e Guest)\nReply: qcrosvm 将处理结果写回 Used Ring。 Inject IRQ: qcrosvm 通过写 irqfd 通知 Hypervisor。 Virtual Interrupt: Gunyah Hypervisor 将虚拟中断注入给 Android Guest。 Guest 收到中断，前端驱动处理 Used Ring 中的结果，完成 I/O 流程，向上层应用返回数据。 4. 架构特点总结 简单高效: 相比 vhost-user，这种将后端集成在 VMM 内部的模式配置更简单，调试更容易，适合大多数标准场景。 内存安全: Guest 与 Host 之间的数据交换完全通过受控的共享内存进行，无额外数据搬运。 轻量级通知: 利用 eventfd 和 irqfd 避免了繁重的上下文切换开销。 ","wordCount":"481","inLanguage":"en","datePublished":"2025-08-04T09:49:58+08:00","dateModified":"2025-08-04T09:49:58+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/gunyah/gunyah-virtio-blk/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/gunyah/>Gunyah开发笔记</a></div><h1 class="post-title entry-hint-parent">高通 Gunyah 虚拟化平台设备树 (Device Tree) 全解：从源码到 Boot Image</h1><div class=post-meta><span title='2025-08-04 09:49:58 +0800 CST'>August 4, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;481 words</div></header><div class=post-content><h4 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h4><p>本图展示了在 Android 虚拟化场景下，Guest OS（Android 虚拟机）如何通过 <strong>Virtio-blk</strong> 协议高效地访问 Host 侧的物理存储设备。该架构采用 <strong>Userspace Backend</strong> 模式，即虚拟磁盘的后端处理逻辑集成在 VMM（此处为 <code>qcrosvm</code>）的用户态进程中。</p><pre class=plantuml-container hidden>
  <code class=language-plantuml>@startuml
!theme plain
skinparam componentStyle rectangle
skinparam shadowing false

top to bottom direction

legend right
&lt;color:#1F77B4&gt;━━ Shared Memory / Data Plane（共享内存，非数据流）&lt;/color&gt;
&lt;color:#FF7F0E&gt;━━ Control Plane（kick / irq / 状态推进）&lt;/color&gt;
endlegend

&#39; =======================
&#39; Guest
&#39; =======================
frame &#34;Android Guest (VM)&#34; as G #E3F2FD {
  component &#34;Android App&#34; as App
  component &#34;VFS / FS&#34; as FS
  component &#34;Block Layer&#34; as BL
  component &#34;virtio-blk\n(frontend driver)&#34; as FE

  App --&gt; FS
  FS --&gt; BL
  BL --&gt; FE : submit block request
}

&#39; =======================
&#39; Shared Memory (Guest-owned, Host-mapped)
&#39; =======================
frame &#34;Guest RAM (Shared Memory)&#34; as RAM #ECEFF1 {
  component &#34;Virtqueue\n- Descriptor Table\n- Avail Ring\n- Used Ring&#34; as VQ
  component &#34;Guest Data Buffers\n(Block I/O payload)&#34; as BUF
}

&#39; =======================
&#39; Host
&#39; =======================
frame &#34;Linux Host&#34; as H #E8F5E9 {

  frame &#34;User Space&#34; as USER {
    component &#34;qcrosvm\n(VMM &#43; virtio-blk backend)&#34; as BE
  }

  frame &#34;Linux Kernel&#34; as KERNEL {
    component &#34;Host Block Layer / FS&#34; as HBLK
  }
}

&#39; =======================
&#39; Hardware
&#39; =======================
frame &#34;Hardware&#34; as HW {
  component &#34;Physical Block Device\n(eMMC / UFS / NVMe)&#34; as DISK
}

&#39; =======================
&#39; Hypervisor (mechanism only)
&#39; =======================
rectangle &#34;Gunyah Hypervisor\n(Memory Mapping, eventfd, irqfd)&#34; as HV #F5F5F5

&#39; =======================
&#39; Data Plane (shared memory access, NOT data flow)
&#39; =======================
FE ..[#1F77B4]..&gt; VQ  : access
FE ..[#1F77B4]..&gt; BUF : access

BE ..[#1F77B4]..&gt; VQ  : access
BE ..[#1F77B4]..&gt; BUF : access

&#39; =======================
&#39; Control Plane
&#39; =======================
FE -[#FF7F0E]-&gt; HV : QueueNotify (kick)
HV -[#FF7F0E]-&gt; BE : eventfd wakeup

BE -[#FF7F0E]-&gt; HV : inject IRQ (irqfd)
HV -[#FF7F0E]-&gt; FE : virtual interrupt

&#39; =======================
&#39; Backend I/O Path
&#39; =======================
BE --&gt; HBLK : read / write
HBLK --&gt; DISK

@enduml</code>
</pre><h4 id=2-核心组件与角色>2. 核心组件与角色<a hidden class=anchor aria-hidden=true href=#2-核心组件与角色>#</a></h4><ul><li><p><strong>Guest (Android VM):</strong></p></li><li><p><strong>Virtio-blk Frontend:</strong> 运行在 Android 内核中的驱动程序。它不进行实际的数据拷贝，而是负责将上层文件系统（App/VFS）的读写请求封装成 Virtio 格式的描述符。</p></li><li><p><strong>Block Layer:</strong> 生成标准的块 I/O 请求。</p></li><li><p><strong>Shared Memory (数据平面):</strong></p></li><li><p>这是 Guest 的部分 RAM，被 Hypervisor 映射给 Host 侧的 <code>qcrosvm</code> 访问。</p></li><li><p><strong>Virtqueue (VQ):</strong> 核心数据结构，包含描述符表（Descriptors）、可用环（Avail Ring）和已用环（Used Ring）。</p></li><li><p><strong>Data Buffers:</strong> 实际存放读写数据的内存区域。</p></li><li><p><strong>机制:</strong> 前后端通过共享内存直接读写数据，实现了 <strong>Zero-Copy（零拷贝）</strong> 的高效数据传输。</p></li><li><p><strong>Host (Linux & qcrosvm):</strong></p></li><li><p><strong>qcrosvm (VMM + Backend):</strong> 这是宿主机上的虚拟机管理进程。它内部集成了 virtio-blk 的后端逻辑，负责从共享内存中取出请求，并将其转化为宿主机的文件读写操作。</p></li><li><p><strong>Host Block Layer:</strong> Linux 内核的通用块设备层，负责最终驱动物理硬件。</p></li><li><p><strong>Hypervisor (Gunyah):</strong></p></li><li><p>负责特权级切换、内存映射管理、以及中断和通知（Kick）的路由（通过 <code>eventfd</code> 和 <code>irqfd</code>）。</p></li></ul><h4 id=3-io-处理流程详解>3. I/O 处理流程详解<a hidden class=anchor aria-hidden=true href=#3-io-处理流程详解>#</a></h4><p>整个 I/O 周期可以分为 <strong>请求提交</strong>、<strong>通知与处理</strong>、<strong>中断完成</strong> 三个阶段：</p><p><strong>阶段一：请求提交 (Guest -> Shared Memory)</strong></p><ol><li>Android App 发起读写请求，经过 VFS 和 Block Layer，到达 <code>virtio-blk</code> 前端驱动。</li><li>前端驱动将请求的数据缓冲区地址和长度写入 <strong>Shared Memory</strong> 中的 <strong>Virtqueue (Descriptor Table)</strong>。</li><li>前端更新 <strong>Avail Ring</strong>，表示有新的请求待处理。</li></ol><p><strong>阶段二：通知与处理 (Kick -> Backend Processing)</strong></p><ol><li><strong>Kick (Notify):</strong> 前端驱动执行 MMIO 写操作（<code>QueueNotify</code>）。</li><li><strong>Trap & Signal:</strong> Gunyah Hypervisor 捕获该 MMIO 操作，识别为通知事件，通过 <strong>eventfd</strong> 唤醒处于用户态的 <code>qcrosvm</code> 进程。</li><li><strong>Process:</strong> <code>qcrosvm</code> 被唤醒后：</li></ol><ul><li>直接访问共享内存中的 Virtqueue，读取请求详情。</li><li>根据描述符找到 Data Buffer。</li><li>向 Host Linux Kernel 发起实际的读写系统调用（<code>read/write</code> 或 <code>io_uring</code>）。</li><li>硬件完成 I/O 后，数据被写入/读出物理磁盘。</li></ul><p><strong>阶段三：完成与中断 (Backend -> Guest)</strong></p><ol><li><strong>Reply:</strong> <code>qcrosvm</code> 将处理结果写回 <strong>Used Ring</strong>。</li><li><strong>Inject IRQ:</strong> <code>qcrosvm</code> 通过写 <strong>irqfd</strong> 通知 Hypervisor。</li><li><strong>Virtual Interrupt:</strong> Gunyah Hypervisor 将虚拟中断注入给 Android Guest。</li><li>Guest 收到中断，前端驱动处理 Used Ring 中的结果，完成 I/O 流程，向上层应用返回数据。</li></ol><h4 id=4-架构特点总结>4. 架构特点总结<a hidden class=anchor aria-hidden=true href=#4-架构特点总结>#</a></h4><ul><li><strong>简单高效:</strong> 相比 vhost-user，这种将后端集成在 VMM 内部的模式配置更简单，调试更容易，适合大多数标准场景。</li><li><strong>内存安全:</strong> Guest 与 Host 之间的数据交换完全通过受控的共享内存进行，无额外数据搬运。</li><li><strong>轻量级通知:</strong> 利用 <code>eventfd</code> 和 <code>irqfd</code> 避免了繁重的上下文切换开销。</li></ul><hr></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>