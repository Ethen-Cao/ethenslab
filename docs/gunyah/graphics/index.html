<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ethen 的实验室</title><meta name=keywords content><meta name=description content="这是一份经过全面融合、深度完善的终极版 Wiki 文档。
它整合了我们在过去对话中讨论的所有核心技术点，包括 Android 16 BLAST 架构、Vulkan 与 OpenGL 的并行支持、Skia 的角色以及 Gunyah 虚拟化驱动的深层机制。
您可以直接使用此文档作为项目组的官方架构说明书。
+++
date = &lsquo;2026-01-13T10:00:00+08:00&rsquo;
draft = false
title = &lsquo;Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)&rsquo;
tags = [&ldquo;Android&rdquo;, &ldquo;Graphics&rdquo;, &ldquo;Virtualization&rdquo;, &ldquo;Gunyah&rdquo;, &ldquo;Qualcomm&rdquo;]
+++
1. 概述
本文档详细描述了在基于 Qualcomm SA8295/SA8255 (Gen5) 智能座舱平台中，Android Guest VM 的图形渲染软件架构。
在该平台中，Android 运行在 Gunyah Hypervisor 之上作为客户机（Guest VM）。图形系统采用前后端分离的虚拟化架构 (Split-Rendering Architecture)。Android 侧（Guest）负责生成渲染指令，通过 HGSL (Hypervisor Graphics Service Layer) 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。
本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。"><meta name=author content><link rel=canonical href=https://ethen-cao.github.io/ethenslab/gunyah/graphics/><link crossorigin=anonymous href=/ethenslab/assets/css/stylesheet.a1917769c3c78460b110da6d7905321bb53af4a56f22ba4cc0de824cf4d097ab.css integrity="sha256-oZF3acPHhGCxENpteQUyG7U69KVvIrpMwN6CTPTQl6s=" rel="preload stylesheet" as=style><link rel=icon href=https://ethen-cao.github.io/ethenslab/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ethen-cao.github.io/ethenslab/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ethen-cao.github.io/ethenslab/favicon-32x32.png><link rel=apple-touch-icon href=https://ethen-cao.github.io/ethenslab/apple-touch-icon.png><link rel=mask-icon href=https://ethen-cao.github.io/ethenslab/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ethen-cao.github.io/ethenslab/gunyah/graphics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://ethen-cao.github.io/ethenslab/gunyah/graphics/"><meta property="og:site_name" content="Ethen 的实验室"><meta property="og:title" content="Ethen 的实验室"><meta property="og:description" content="这是一份经过全面融合、深度完善的终极版 Wiki 文档。
它整合了我们在过去对话中讨论的所有核心技术点，包括 Android 16 BLAST 架构、Vulkan 与 OpenGL 的并行支持、Skia 的角色以及 Gunyah 虚拟化驱动的深层机制。
您可以直接使用此文档作为项目组的官方架构说明书。
+++ date = ‘2026-01-13T10:00:00+08:00’ draft = false title = ‘Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)’ tags = [“Android”, “Graphics”, “Virtualization”, “Gunyah”, “Qualcomm”] +++
1. 概述 本文档详细描述了在基于 Qualcomm SA8295/SA8255 (Gen5) 智能座舱平台中，Android Guest VM 的图形渲染软件架构。
在该平台中，Android 运行在 Gunyah Hypervisor 之上作为客户机（Guest VM）。图形系统采用前后端分离的虚拟化架构 (Split-Rendering Architecture)。Android 侧（Guest）负责生成渲染指令，通过 HGSL (Hypervisor Graphics Service Layer) 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。
本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="gunyah"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="这是一份经过全面融合、深度完善的终极版 Wiki 文档。
它整合了我们在过去对话中讨论的所有核心技术点，包括 Android 16 BLAST 架构、Vulkan 与 OpenGL 的并行支持、Skia 的角色以及 Gunyah 虚拟化驱动的深层机制。
您可以直接使用此文档作为项目组的官方架构说明书。
+++
date = &lsquo;2026-01-13T10:00:00+08:00&rsquo;
draft = false
title = &lsquo;Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)&rsquo;
tags = [&ldquo;Android&rdquo;, &ldquo;Graphics&rdquo;, &ldquo;Virtualization&rdquo;, &ldquo;Gunyah&rdquo;, &ldquo;Qualcomm&rdquo;]
+++
1. 概述
本文档详细描述了在基于 Qualcomm SA8295/SA8255 (Gen5) 智能座舱平台中，Android Guest VM 的图形渲染软件架构。
在该平台中，Android 运行在 Gunyah Hypervisor 之上作为客户机（Guest VM）。图形系统采用前后端分离的虚拟化架构 (Split-Rendering Architecture)。Android 侧（Guest）负责生成渲染指令，通过 HGSL (Hypervisor Graphics Service Layer) 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。
本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Gunyah开发笔记","item":"https://ethen-cao.github.io/ethenslab/gunyah/"},{"@type":"ListItem","position":2,"name":"","item":"https://ethen-cao.github.io/ethenslab/gunyah/graphics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"这是一份经过全面融合、深度完善的终极版 Wiki 文档。\n它整合了我们在过去对话中讨论的所有核心技术点，包括 Android 16 BLAST 架构、Vulkan 与 OpenGL 的并行支持、Skia 的角色以及 Gunyah 虚拟化驱动的深层机制。\n您可以直接使用此文档作为项目组的官方架构说明书。\n+++ date = \u0026lsquo;2026-01-13T10:00:00+08:00\u0026rsquo; draft = false title = \u0026lsquo;Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)\u0026rsquo; tags = [\u0026ldquo;Android\u0026rdquo;, \u0026ldquo;Graphics\u0026rdquo;, \u0026ldquo;Virtualization\u0026rdquo;, \u0026ldquo;Gunyah\u0026rdquo;, \u0026ldquo;Qualcomm\u0026rdquo;] +++\n1. 概述 本文档详细描述了在基于 Qualcomm SA8295/SA8255 (Gen5) 智能座舱平台中，Android Guest VM 的图形渲染软件架构。\n在该平台中，Android 运行在 Gunyah Hypervisor 之上作为客户机（Guest VM）。图形系统采用前后端分离的虚拟化架构 (Split-Rendering Architecture)。Android 侧（Guest）负责生成渲染指令，通过 HGSL (Hypervisor Graphics Service Layer) 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。\n本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。\n","keywords":[],"articleBody":"这是一份经过全面融合、深度完善的终极版 Wiki 文档。\n它整合了我们在过去对话中讨论的所有核心技术点，包括 Android 16 BLAST 架构、Vulkan 与 OpenGL 的并行支持、Skia 的角色以及 Gunyah 虚拟化驱动的深层机制。\n您可以直接使用此文档作为项目组的官方架构说明书。\n+++ date = ‘2026-01-13T10:00:00+08:00’ draft = false title = ‘Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)’ tags = [“Android”, “Graphics”, “Virtualization”, “Gunyah”, “Qualcomm”] +++\n1. 概述 本文档详细描述了在基于 Qualcomm SA8295/SA8255 (Gen5) 智能座舱平台中，Android Guest VM 的图形渲染软件架构。\n在该平台中，Android 运行在 Gunyah Hypervisor 之上作为客户机（Guest VM）。图形系统采用前后端分离的虚拟化架构 (Split-Rendering Architecture)。Android 侧（Guest）负责生成渲染指令，通过 HGSL (Hypervisor Graphics Service Layer) 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。\n本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。\n2. 整体架构图 下图展示了从应用层 ViewRootImpl 到底层内核驱动 gh_dbl 的完整调用链路。架构清晰地展示了 BLASTBufferQueue 的引入、OpenGL ES / Vulkan 的双链路支持，以及内核态的快慢通道分离设计。\n3. 应用层：从 UI 到渲染线程 (Application UI Layer) 在 Android 16+ 架构中，应用层不仅负责 UI 逻辑，还直接参与图形缓冲区的管理。\nViewRootImpl \u0026 BLASTBufferQueue ViewRootImpl：它是 View 树的管理者。在现代架构中，它直接持有并管理 BLASTBufferQueue 实例。 BLASTBufferQueue (BBQ)： 这是 Android 图形架构的重大变革。BufferQueue 的生产者逻辑现在运行在应用进程内部。 它负责将应用绘制的内容与窗口属性（位置、大小）打包成原子化的 Transaction 提交给 SurfaceFlinger，从而彻底解决了画面与窗口不同步（Tearing/Desync）的问题。 本地 Surface：应用使用的 ANativeWindow (Surface) 直接连接到进程内的 BBQ，因此申请缓冲区 (dequeueBuffer) 是极快的进程内操作，不再频繁依赖 IPC 请求 SurfaceFlinger。 录制与同步 (Record \u0026 Sync) View / Canvas (RecordingCanvas)：\n当 onDraw() 被调用时，Canvas 实际上是一个指令录制器。开发者调用的 drawRect 等 API 并没有产生像素，而是生成了 RenderNode 中的绘图指令（DisplayList Ops）。\nThreadedRenderer：\n负责将 UI 线程录制好的 RenderNode 数据，通过 SyncFrame 机制同步给 Native 层的渲染线程 (RenderThread)。\n4. 用户空间组件 (Native User Space) 用户空间组件构成了 Android 的渲染管线，负责将高层绘图指令转换为 GPU 可识别的微码。\n渲染管线核心 RenderThread (渲染线程) 职责：libhwui 库拥有的核心线程。它从主线程接收同步后的数据，并驱动后续的渲染流程。它是 GPU 工作负载的发起者。 libhwui.so (Hardware UI Library) 职责：Android 的 2D 硬件加速核心库，扮演“管理者”角色。 功能： 环境管理：根据系统属性（debug.hwui.renderer），实例化 EglManager (OpenGL) 或 VulkanManager (Vulkan)。 缓冲区管理：通过 ANativeWindow 接口操作本地的 BLASTBufferQueue 进行 dequeue/queue。 任务分发：将具体的绘制任务转交给 Skia 引擎。 libskia.so (Skia Graphics Engine) 职责：Google 开发的跨平台图形引擎，扮演“执行者”角色。 功能： 光栅化：将矢量图形（路径、文字）转换为像素数据。 后端适配 (Ganesh/Graphite)：Skia 包含多种 GPU 后端。在 Android 16 中，Graphite 后端能够高效地生成 Vulkan Command Buffer，减少 CPU 开销。 Shader 生成：动态生成 GLSL 或 SPIR-V 代码供驱动编译。 系统接口层 (System Stubs) libGLESv2.so (OpenGL ES Stub)：提供标准 GL 符号，通过内部的 gl_hooks 分发表跳转到厂商驱动。\nlibvulkan.so (Vulkan System Loader)：\nVulkan API 的统一入口。\n注意：Vulkan 驱动的加载不依赖 libEGL。Loader 会直接扫描并加载厂商的 ICD (vulkan.adreno.so)。\nlibEGL.so (EGL Loader)：负责 OpenGL 环境初始化，通过 dlopen 加载厂商 GL 驱动。\n厂商驱动层 (Vendor Implementation) libGLESv2_adreno.so / vulkan.adreno.so\n职责：Qualcomm 提供的 OpenGL ES 和 Vulkan 用户态驱动。\n功能：将 API 调用编译为 Adreno GPU 专用的硬件指令，并打包到 IB (Indirect Buffer) 中。\n汇聚点：无论上层使用 GL 还是 VK，底层均统一调用 libgsl。\nlibgsl.so (Graphics Service Layer Library)\n职责：内核交互网关。\n功能：封装所有对 /dev/hgsl 的 ioctl 调用。它是 Guest OS 与 Hypervisor 通信的最后一道用户态防线。\n5. 内核空间组件 (Linux Kernel - Guest) 内核空间驱动负责资源管理，并通过虚拟化通道将请求转发给 Host。\n核心驱动 qcom_hgsl.ko (HGSL Driver Core) 职责：HGSL 驱动核心。 功能：管理 GPU 上下文（Context）、内存分配（SMMU Mapping）、时间戳同步。它是“快慢通道”分流的决策者。 通道分流设计 (The Split Architecture) 为了平衡控制灵活性与绘图性能，HGSL 设计了两条截然不同的通信路径：\n慢速控制通道 (Control RPC) 组件：hgsl_hyp.c 场景：低频、高延迟操作（如 Device Open, Context Create, Power Control）。 机制：使用 RPC 协议，将请求序列化后通过 HAB 发送，线程会阻塞等待 Host 返回。 快速数据通道 (Data Path / Doorbell) 组件：Shared Memory Queue (Ring Buffer) 场景：高频、低延迟的绘图指令提交 (ISSUE_IB)。 机制： 零拷贝：用户态生成的 GPU 命令流直接写入与 Host 共享的 DMA-BUF 内存。 门铃机制：写入完成后，仅发送一个轻量级的信号（Doorbell）通知 Host。Host 直接从共享内存取指执行，无 RPC 开销。 虚拟化传输层 msm_hab.ko (Hypervisor Abstraction Bridge) 职责：虚拟化通信的抽象层，提供类似 Socket 的管道通信能力，屏蔽底层 Hypervisor 差异。 gh_dbl.ko (Gunyah Doorbell) 职责：Gunyah Hypervisor 特有的门铃驱动。 功能：利用 Hypercalls 触发跨虚拟机中断，是 Guest 通知 Host 的物理手段。 6. 关键工作流 (Workflows) 6.1 初始化流程 (Driver Loading) GL 路径：libhwui -\u003e libEGL -\u003e dlopen(\"libGLESv2_adreno.so\")。 VK 路径：libhwui -\u003e libvulkan -\u003e dlopen(\"vulkan.adreno.so\")。 内核握手：驱动 -\u003e libgsl -\u003e ioctl -\u003e qcom_hgsl -\u003e RPC 通道 -\u003e Host。 6.2 每一帧的渲染流程 (Frame Rendering) 录制 (UI Thread)：View 调用 canvas.draw()，指令被录制到 RenderNode。 同步 (Sync)：ThreadedRenderer 将 RenderNode 数据同步给 RenderThread。 回放 (RenderThread)：libhwui 驱动 libskia 生成 GPU 指令。 编译与打包：Adreno 驱动将指令编译并写入 IB。 提交：通过 libgsl -\u003e qcom_hgsl。 传输：元数据写入 Shared Memory，触发 Doorbell。 执行：Host 端 GPU 响应并渲染像素到 Buffer。 上屏：libhwui 将 Buffer 交给 BLASTBufferQueue，打包为 Transaction 发送给 SurfaceFlinger。 ","wordCount":"473","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ethen-cao.github.io/ethenslab/gunyah/graphics/"},"publisher":{"@type":"Organization","name":"Ethen 的实验室","logo":{"@type":"ImageObject","url":"https://ethen-cao.github.io/ethenslab/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ethen-cao.github.io/ethenslab/ accesskey=h title="Ethen 的实验室 (Alt + H)">Ethen 的实验室</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ethen-cao.github.io/ethenslab/android-dev/ title=Android系统开发><span>Android系统开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/android-automotive-os-dev/ title="Android Automotive"><span>Android Automotive</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/qnx/ title=QNX开发><span>QNX开发</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/gunyah/ title=Gunyah><span>Gunyah</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/ivi-solution/ title=智能座舱方案><span>智能座舱方案</span></a></li><li><a href=https://ethen-cao.github.io/ethenslab/explore-ai title="Explore AI"><span>Explore AI</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ethen-cao.github.io/ethenslab/>Home</a>&nbsp;»&nbsp;<a href=https://ethen-cao.github.io/ethenslab/gunyah/>Gunyah开发笔记</a></div><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>3 min&nbsp;·&nbsp;473 words</div></header><div class=post-content><p>这是一份经过全面融合、深度完善的<strong>终极版 Wiki 文档</strong>。</p><p>它整合了我们在过去对话中讨论的所有核心技术点，包括 <strong>Android 16 BLAST 架构</strong>、<strong>Vulkan 与 OpenGL 的并行支持</strong>、<strong>Skia 的角色</strong>以及 <strong>Gunyah 虚拟化驱动的深层机制</strong>。</p><p>您可以直接使用此文档作为项目组的官方架构说明书。</p><p>+++
date = &lsquo;2026-01-13T10:00:00+08:00&rsquo;
draft = false
title = &lsquo;Android 图形渲染架构详解 (Gunyah Hypervisor / Qualcomm Gen5)&rsquo;
tags = [&ldquo;Android&rdquo;, &ldquo;Graphics&rdquo;, &ldquo;Virtualization&rdquo;, &ldquo;Gunyah&rdquo;, &ldquo;Qualcomm&rdquo;]
+++</p><h2 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><p>本文档详细描述了在基于 <strong>Qualcomm SA8295/SA8255 (Gen5)</strong> 智能座舱平台中，Android Guest VM 的图形渲染软件架构。</p><p>在该平台中，Android 运行在 <strong>Gunyah Hypervisor</strong> 之上作为客户机（Guest VM）。图形系统采用<strong>前后端分离的虚拟化架构 (Split-Rendering Architecture)</strong>。Android 侧（Guest）负责生成渲染指令，通过 <strong>HGSL (Hypervisor Graphics Service Layer)</strong> 驱动栈穿透虚拟机边界，最终由 Host 端的物理驱动操控 Adreno GPU 硬件执行渲染。</p><p>本文档涵盖了从应用层 View 系统、Native 渲染管线、到内核虚拟化驱动的全链路技术细节。</p><h2 id=2-整体架构图>2. 整体架构图<a hidden class=anchor aria-hidden=true href=#2-整体架构图>#</a></h2><p>下图展示了从应用层 <code>ViewRootImpl</code> 到底层内核驱动 <code>gh_dbl</code> 的完整调用链路。架构清晰地展示了 <strong>BLASTBufferQueue</strong> 的引入、<strong>OpenGL ES / Vulkan</strong> 的双链路支持，以及内核态的<strong>快慢通道分离</strong>设计。</p><p><img src=/ethenslab/images/gunyah-graphics.png.png alt></p><h2 id=3-应用层从-ui-到渲染线程-application-ui-layer>3. 应用层：从 UI 到渲染线程 (Application UI Layer)<a hidden class=anchor aria-hidden=true href=#3-应用层从-ui-到渲染线程-application-ui-layer>#</a></h2><p>在 Android 16+ 架构中，应用层不仅负责 UI 逻辑，还直接参与图形缓冲区的管理。</p><h3 id=viewrootimpl--blastbufferqueue><strong>ViewRootImpl & BLASTBufferQueue</strong><a hidden class=anchor aria-hidden=true href=#viewrootimpl--blastbufferqueue>#</a></h3><ul><li><strong>ViewRootImpl</strong>：它是 View 树的管理者。在现代架构中，它直接持有并管理 <strong><code>BLASTBufferQueue</code></strong> 实例。</li><li><strong>BLASTBufferQueue (BBQ)</strong>：</li><li>这是 Android 图形架构的重大变革。BufferQueue 的生产者逻辑现在运行在<strong>应用进程内部</strong>。</li><li>它负责将应用绘制的内容与窗口属性（位置、大小）打包成原子化的 <strong>Transaction</strong> 提交给 SurfaceFlinger，从而彻底解决了画面与窗口不同步（Tearing/Desync）的问题。</li><li><strong>本地 Surface</strong>：应用使用的 <code>ANativeWindow</code> (Surface) 直接连接到进程内的 BBQ，因此申请缓冲区 (<code>dequeueBuffer</code>) 是极快的<strong>进程内操作</strong>，不再频繁依赖 IPC 请求 SurfaceFlinger。</li></ul><h3 id=录制与同步-record--sync><strong>录制与同步 (Record & Sync)</strong><a hidden class=anchor aria-hidden=true href=#录制与同步-record--sync>#</a></h3><ul><li><p><strong>View / Canvas (RecordingCanvas)</strong>：</p></li><li><p>当 <code>onDraw()</code> 被调用时，Canvas 实际上是一个<strong>指令录制器</strong>。开发者调用的 <code>drawRect</code> 等 API 并没有产生像素，而是生成了 <strong>RenderNode</strong> 中的绘图指令（DisplayList Ops）。</p></li><li><p><strong>ThreadedRenderer</strong>：</p></li><li><p>负责将 UI 线程录制好的 RenderNode 数据，通过 <strong>SyncFrame</strong> 机制同步给 Native 层的渲染线程 (<code>RenderThread</code>)。</p></li></ul><h2 id=4-用户空间组件-native-user-space>4. 用户空间组件 (Native User Space)<a hidden class=anchor aria-hidden=true href=#4-用户空间组件-native-user-space>#</a></h2><p>用户空间组件构成了 Android 的渲染管线，负责将高层绘图指令转换为 GPU 可识别的微码。</p><h3 id=渲染管线核心><strong>渲染管线核心</strong><a hidden class=anchor aria-hidden=true href=#渲染管线核心>#</a></h3><h4 id=renderthread-渲染线程><strong>RenderThread (渲染线程)</strong><a hidden class=anchor aria-hidden=true href=#renderthread-渲染线程>#</a></h4><ul><li><strong>职责</strong>：<code>libhwui</code> 库拥有的核心线程。它从主线程接收同步后的数据，并驱动后续的渲染流程。它是 GPU 工作负载的<strong>发起者</strong>。</li></ul><h4 id=libhwuiso-hardware-ui-library><strong>libhwui.so (Hardware UI Library)</strong><a hidden class=anchor aria-hidden=true href=#libhwuiso-hardware-ui-library>#</a></h4><ul><li><strong>职责</strong>：Android 的 2D 硬件加速核心库，扮演“管理者”角色。</li><li><strong>功能</strong>：</li><li><strong>环境管理</strong>：根据系统属性（<code>debug.hwui.renderer</code>），实例化 <code>EglManager</code> (OpenGL) 或 <code>VulkanManager</code> (Vulkan)。</li><li><strong>缓冲区管理</strong>：通过 <code>ANativeWindow</code> 接口操作本地的 <code>BLASTBufferQueue</code> 进行 <code>dequeue/queue</code>。</li><li><strong>任务分发</strong>：将具体的绘制任务转交给 Skia 引擎。</li></ul><h4 id=libskiaso-skia-graphics-engine><strong>libskia.so (Skia Graphics Engine)</strong><a hidden class=anchor aria-hidden=true href=#libskiaso-skia-graphics-engine>#</a></h4><ul><li><strong>职责</strong>：Google 开发的跨平台图形引擎，扮演“执行者”角色。</li><li><strong>功能</strong>：</li><li><strong>光栅化</strong>：将矢量图形（路径、文字）转换为像素数据。</li><li><strong>后端适配 (Ganesh/Graphite)</strong>：Skia 包含多种 GPU 后端。在 Android 16 中，<strong>Graphite</strong> 后端能够高效地生成 Vulkan Command Buffer，减少 CPU 开销。</li><li><strong>Shader 生成</strong>：动态生成 GLSL 或 SPIR-V 代码供驱动编译。</li></ul><h3 id=系统接口层-system-stubs><strong>系统接口层 (System Stubs)</strong><a hidden class=anchor aria-hidden=true href=#系统接口层-system-stubs>#</a></h3><ul><li><p><strong>libGLESv2.so (OpenGL ES Stub)</strong>：提供标准 GL 符号，通过内部的 <code>gl_hooks</code> 分发表跳转到厂商驱动。</p></li><li><p><strong>libvulkan.so (Vulkan System Loader)</strong>：</p></li><li><p>Vulkan API 的统一入口。</p></li><li><p><strong>注意</strong>：Vulkan 驱动的加载<strong>不依赖 libEGL</strong>。Loader 会直接扫描并加载厂商的 ICD (<code>vulkan.adreno.so</code>)。</p></li><li><p><strong>libEGL.so (EGL Loader)</strong>：负责 OpenGL 环境初始化，通过 <code>dlopen</code> 加载厂商 GL 驱动。</p></li></ul><h3 id=厂商驱动层-vendor-implementation><strong>厂商驱动层 (Vendor Implementation)</strong><a hidden class=anchor aria-hidden=true href=#厂商驱动层-vendor-implementation>#</a></h3><ul><li><p><strong>libGLESv2_adreno.so / vulkan.adreno.so</strong></p></li><li><p><strong>职责</strong>：Qualcomm 提供的 OpenGL ES 和 Vulkan 用户态驱动。</p></li><li><p><strong>功能</strong>：将 API 调用编译为 Adreno GPU 专用的硬件指令，并打包到 <strong>IB (Indirect Buffer)</strong> 中。</p></li><li><p><strong>汇聚点</strong>：无论上层使用 GL 还是 VK，底层均统一调用 <code>libgsl</code>。</p></li><li><p><strong>libgsl.so (Graphics Service Layer Library)</strong></p></li><li><p><strong>职责</strong>：内核交互网关。</p></li><li><p><strong>功能</strong>：封装所有对 <code>/dev/hgsl</code> 的 <code>ioctl</code> 调用。它是 Guest OS 与 Hypervisor 通信的最后一道用户态防线。</p></li></ul><h2 id=5-内核空间组件-linux-kernel---guest>5. 内核空间组件 (Linux Kernel - Guest)<a hidden class=anchor aria-hidden=true href=#5-内核空间组件-linux-kernel---guest>#</a></h2><p>内核空间驱动负责资源管理，并通过虚拟化通道将请求转发给 Host。</p><h3 id=核心驱动><strong>核心驱动</strong><a hidden class=anchor aria-hidden=true href=#核心驱动>#</a></h3><h4 id=qcom_><strong>qcom_hgsl.ko (HGSL Driver Core)</strong><a hidden class=anchor aria-hidden=true href=#qcom_>#</a></h4><ul><li><strong>职责</strong>：HGSL 驱动核心。</li><li><strong>功能</strong>：管理 GPU 上下文（Context）、内存分配（SMMU Mapping）、时间戳同步。它是“快慢通道”分流的决策者。</li></ul><h3 id=通道分流设计-the-split-architecture><strong>通道分流设计 (The Split Architecture)</strong><a hidden class=anchor aria-hidden=true href=#通道分流设计-the-split-architecture>#</a></h3><p>为了平衡控制灵活性与绘图性能，HGSL 设计了两条截然不同的通信路径：</p><ol><li><strong>慢速控制通道 (Control RPC)</strong></li></ol><ul><li><strong>组件</strong>：<code>hgsl_hyp.c</code></li><li><strong>场景</strong>：低频、高延迟操作（如 <code>Device Open</code>, <code>Context Create</code>, <code>Power Control</code>）。</li><li><strong>机制</strong>：使用 <strong>RPC</strong> 协议，将请求序列化后通过 HAB 发送，线程会阻塞等待 Host 返回。</li></ul><ol start=2><li><strong>快速数据通道 (Data Path / Doorbell)</strong></li></ol><ul><li><strong>组件</strong>：<strong>Shared Memory Queue (Ring Buffer)</strong></li><li><strong>场景</strong>：高频、低延迟的绘图指令提交 (<code>ISSUE_IB</code>)。</li><li><strong>机制</strong>：</li><li><strong>零拷贝</strong>：用户态生成的 GPU 命令流直接写入与 Host 共享的 DMA-BUF 内存。</li><li><strong>门铃机制</strong>：写入完成后，仅发送一个轻量级的信号（Doorbell）通知 Host。Host 直接从共享内存取指执行，无 RPC 开销。</li></ul><h3 id=虚拟化传输层><strong>虚拟化传输层</strong><a hidden class=anchor aria-hidden=true href=#虚拟化传输层>#</a></h3><h4 id=msm_><strong>msm_hab.ko (Hypervisor Abstraction Bridge)</strong><a hidden class=anchor aria-hidden=true href=#msm_>#</a></h4><ul><li><strong>职责</strong>：虚拟化通信的抽象层，提供类似 Socket 的管道通信能力，屏蔽底层 Hypervisor 差异。</li></ul><h4 id=gh_><strong>gh_dbl.ko (Gunyah Doorbell)</strong><a hidden class=anchor aria-hidden=true href=#gh_>#</a></h4><ul><li><strong>职责</strong>：<strong>Gunyah Hypervisor</strong> 特有的门铃驱动。</li><li><strong>功能</strong>：利用 Hypercalls 触发跨虚拟机中断，是 Guest 通知 Host 的物理手段。</li></ul><h2 id=6-关键工作流-workflows>6. 关键工作流 (Workflows)<a hidden class=anchor aria-hidden=true href=#6-关键工作流-workflows>#</a></h2><h3 id=61-初始化流程-driver-loading>6.1 初始化流程 (Driver Loading)<a hidden class=anchor aria-hidden=true href=#61-初始化流程-driver-loading>#</a></h3><ol><li><strong>GL 路径</strong>：<code>libhwui</code> -> <code>libEGL</code> -> <code>dlopen("libGLESv2_adreno.so")</code>。</li><li><strong>VK 路径</strong>：<code>libhwui</code> -> <code>libvulkan</code> -> <code>dlopen("vulkan.adreno.so")</code>。</li><li><strong>内核握手</strong>：驱动 -> <code>libgsl</code> -> <code>ioctl</code> -> <code>qcom_hgsl</code> -> <strong>RPC 通道</strong> -> Host。</li></ol><h3 id=62-每一帧的渲染流程-frame-rendering>6.2 每一帧的渲染流程 (Frame Rendering)<a hidden class=anchor aria-hidden=true href=#62-每一帧的渲染流程-frame-rendering>#</a></h3><ol><li><strong>录制 (UI Thread)</strong>：View 调用 <code>canvas.draw()</code>，指令被录制到 RenderNode。</li><li><strong>同步 (Sync)</strong>：<code>ThreadedRenderer</code> 将 RenderNode 数据同步给 <code>RenderThread</code>。</li><li><strong>回放 (RenderThread)</strong>：<code>libhwui</code> 驱动 <code>libskia</code> 生成 GPU 指令。</li><li><strong>编译与打包</strong>：Adreno 驱动将指令编译并写入 <strong>IB</strong>。</li><li><strong>提交</strong>：通过 <code>libgsl</code> -> <code>qcom_hgsl</code>。</li><li><strong>传输</strong>：元数据写入 <strong>Shared Memory</strong>，触发 <strong>Doorbell</strong>。</li><li><strong>执行</strong>：Host 端 GPU 响应并渲染像素到 Buffer。</li><li><strong>上屏</strong>：<code>libhwui</code> 将 Buffer 交给 <code>BLASTBufferQueue</code>，打包为 Transaction 发送给 SurfaceFlinger。</li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://ethen-cao.github.io/ethenslab/>Ethen 的实验室</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:"default"})</script><script src=https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js></script><script>(function(){const e=document.querySelectorAll("pre > code.language-plantuml, pre > code.language-planuml");e.forEach(e=>{const s=e.innerText,o=plantumlEncoder.encode(s),i="https://www.plantuml.com/plantuml/svg/"+o,t=document.createElement("img");t.src=i,t.alt="PlantUML Diagram",t.style.maxWidth="100%";const n=e.parentNode;n.parentNode.replaceChild(t,n)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>