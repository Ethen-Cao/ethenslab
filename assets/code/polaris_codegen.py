import csv
import os
import sys
from dataclasses import dataclass
from typing import List, Set
from jinja2 import Environment, BaseLoader

# ==========================================
# 1. å…¨å±€é…ç½®ä¸è§„èŒƒå®šä¹‰
# ==========================================

OUTPUT_DIR = "generated"

# ç±»å‹æ˜ å°„è¡¨ (Spec 7.1)
TYPE_MAPPING = {
    "int":    ("int", "int32_t"),
    "long":   ("long", "int64_t"),
    "string": ("String", "std::string"),
    "float":  ("float", "float"),
    "bool":   ("boolean", "bool"),
}

# è§„èŒƒ 3.2: åç¼€ç™½åå• (åŒ…å«æœ€æ–°çš„ _STAT)
VALID_SUFFIXES = {
    # è‡´å‘½å¼‚å¸¸
    "_CRASH", "_ANR", "_RESET", "_OOM", "_KILLED", "_BLANK",
    # æ€§èƒ½ä½“éªŒ
    "_SLOW", "_BLOCK", "_JANK", "_TIMEOUT", "_BUSY",
    # èµ„æºæ³„æ¼
    "_LEAK", "_HIGH", "_LOW",
    # é“¾è·¯ç®¡æ§
    "_LOST", "_REJECT", "_FAIL",
    # ç»Ÿè®¡ä¸è¶‹åŠ¿ (New)
    "_STAT"
}

# ç³»ç»Ÿä¿ç•™å­—æ®µ (Common Fields)ï¼Œä¸¥ç¦å‡ºç°åœ¨ Desc_Schema ç”Ÿæˆçš„ä»£ç ä¸­
RESERVED_FIELDS = {"tid", "pid", "proc", "ver", "logf"}

# ==========================================
# 2. æ•°æ®æ¨¡å‹
# ==========================================

@dataclass
class Field:
    name: str
    schema_type: str
    is_optional: bool

    @property
    def java_type(self):
        return TYPE_MAPPING[self.schema_type][0]

    @property
    def cpp_type(self):
        return TYPE_MAPPING[self.schema_type][1]

    @property
    def name_capitalized(self):
        return self.name[0].upper() + self.name[1:]


@dataclass
class EventContext:
    event_id: str
    event_name: str
    logical_module: str
    owner: str
    sdk_type: str
    sdk_level: str
    status: str
    fields: List[Field]

    @property
    def class_name(self):
        # Rule: PascalCase + Context
        # GVM_APP_ANR -> GvmAppAnrContext
        parts = self.event_name.split('_')
        return "".join(p.capitalize() for p in parts) + "Context"

    @property
    def scope(self):
        # Rule: Extract first part of EventName as Scope
        # GVM_APP_ANR -> gvm
        parts = self.event_name.split('_')
        if not parts:
            raise ValueError(f"Invalid EventName format: {self.event_name}")
        return parts[0].lower()

    @property
    def module_clean(self):
        # Rule: Logical_Module to lowercase, remove spaces
        # "AppManager" -> "appmanager"
        return self.logical_module.lower().replace(" ", "")

    @property
    def package_name(self):
        # Java Package: com.polaris.events.<scope>.<logical_module>
        return f"com.polaris.events.{self.scope}.{self.module_clean}"

    @property
    def cpp_namespace(self):
        # C++ Namespace: polaris::events::<scope>::<logical_module>
        return f"polaris::events::{self.scope}::{self.module_clean}"

    @property
    def is_deprecated(self):
        return self.status.lower() == "deprecated"

    @property
    def required_fields(self):
        return [f for f in self.fields if not f.is_optional]

    @property
    def optional_fields(self):
        return [f for f in self.fields if f.is_optional]


# ==========================================
# 3. æ¨¡æ¿å®šä¹‰ (Jinja2)
# ==========================================

# Java Template
# æ›´æ–°ç‚¹ï¼šä¸ç”Ÿæˆ Common å­—æ®µï¼›æ”¯æŒ setLogRef ç­‰
JAVA_TEMPLATE = """package {{ event.package_name }};

import com.polaris.constants.PolarisEvents;
import com.polaris.core.BasePolarisContext;
import com.polaris.core.PolarisAgent;
import org.json.JSONObject;

/**
 * Auto-generated by polaris-codegen.
 * Event: {{ event.event_name }} ({{ event.event_id }})
 * Logic Module: {{ event.logical_module }}
 * Owner: {{ event.owner }}
 */
{% if event.is_deprecated %}@Deprecated{% endif %}
public class {{ event.class_name }} extends BasePolarisContext {

    // SDK Metadata
    private final int sdkType = {{ event.sdk_type }};
    private final int sdkLevel = {{ event.sdk_level }};

    // Business Fields (Desc_Schema)
    {% for field in event.fields %}
    private {{ field.java_type }} {{ field.name }};
    {% endfor %}

    // Constructor (Required Fields Only)
    public {{ event.class_name }}({% for field in event.required_fields %}{{ field.java_type }} {{ field.name }}{% if not loop.last %}, {% endif %}{% endfor %}) {
        super(PolarisEvents.{{ event.event_name }});
        {% for field in event.required_fields %}
        this.{{ field.name }} = {{ field.name }};
        {% endfor %}
    }

    // Setters (Optional Fields)
    {% for field in event.optional_fields %}
    public {{ event.class_name }} set{{ field.name_capitalized }}({{ field.java_type }} {{ field.name }}) {
        this.{{ field.name }} = {{ field.name }};
        return this;
    }
    {% endfor %}

    @Override
    public boolean validate() {
        {% for field in event.required_fields %}
        {% if field.schema_type == 'string' %}
        if (this.{{ field.name }} == null) return false;
        {% endif %}
        {% endfor %}
        return true;
    }

    @Override
    public JSONObject toJson() {
        JSONObject json = new JSONObject();
        // Desc_Schema Fields
        {% for field in event.fields %}
        json.put("{{ field.name }}", this.{{ field.name }});
        {% endfor %}
        return json;
    }

    // Reporting
    public void report() {
        PolarisAgent.getInstance().report(this);
    }
}
"""

# C++ Template
CPP_TEMPLATE = """#pragma once

#include <string>
#include <nlohmann/json.hpp>
#include "polaris/constants/PolarisEvents.h"
#include "polaris/core/BasePolarisContext.h"

namespace {{ event.cpp_namespace }} {

/**
 * Event: {{ event.event_name }} ({{ event.event_id }})
 */
{% if event.is_deprecated %}[[deprecated]]{% endif %}
class {{ event.class_name }} : public polaris::core::BasePolarisContext {
public:
    const int32_t sdk_type = {{ event.sdk_type }};
    const int32_t sdk_level = {{ event.sdk_level }};

    {% for field in event.fields %}
    {{ field.cpp_type }} {{ field.name }};
    {% endfor %}

    {{ event.class_name }}({% for field in event.required_fields %}{{ field.cpp_type }} {{ field.name }}_in{% if not loop.last %}, {% endif %}{% endfor %}) 
        : BasePolarisContext(polaris::constants::{{ event.event_name }}) {
        {% for field in event.required_fields %}
        this->{{ field.name }} = {{ field.name }}_in;
        {% endfor %}
    }

    {% for field in event.optional_fields %}
    {{ event.class_name }}& set{{ field.name_capitalized }}({{ field.cpp_type }} {{ field.name }}_in) {
        this->{{ field.name }} = {{ field.name }}_in;
        return *this;
    }
    {% endfor %}

    nlohmann::json toJson() const override {
        nlohmann::json j;
        {% for field in event.fields %}
        j["{{ field.name }}"] = this->{{ field.name }};
        {% endfor %}
        return j;
    }
};

} // namespace
"""

# Constants Java Template (é˜²æ­¢å†…è”)
CONSTANTS_JAVA_TEMPLATE = """package com.polaris.constants;

/**
 * Auto-generated Event IDs.
 * Source of Truth: events.csv
 * NOTE: IDs are initialized in a static block to prevent Java compiler inlining.
 */
public final class PolarisEvents {
    // Definitions
    {% for event in events %}
    public static final long {{ event.event_name }};
    {% endfor %}

    // Initialization
    static {
        {% for event in events %}
        {{ event.event_name }} = {{ event.event_id }}L;
        {% endfor %}
    }
}
"""

# Constants C++ Template
CONSTANTS_CPP_TEMPLATE = """#pragma once
#include <cstdint>

namespace polaris::constants {
    {% for event in events %}
    constexpr int64_t {{ event.event_name }} = {{ event.event_id }};
    {% endfor %}
}
"""

# ==========================================
# 4. é€»è¾‘å¤„ç†å‡½æ•°
# ==========================================

def parse_schema(schema_str: str, event_name: str) -> List[Field]:
    fields = []
    if not schema_str or schema_str.upper() == 'NONE':
        return fields

    # æ”¯æŒåˆ†å·æˆ–é€—å·åˆ†éš” "pid:int; reason:string"
    delimiter = ';' if ';' in schema_str else ','
    
    for item in [x.strip() for x in schema_str.split(delimiter)]:
        if ':' not in item: continue

        name, raw_type = item.split(':')
        name = name.strip()
        
        # [Defensive] è‡ªåŠ¨è¿‡æ»¤ç³»ç»Ÿä¿ç•™å­—æ®µ
        if name in RESERVED_FIELDS:
            print(f"âš ï¸ Warning: Ignored reserved field '{name}' in {event_name}. It is handled by BaseContext.")
            continue
            
        is_optional = raw_type.endswith('?')
        schema_type = raw_type.rstrip('?')

        if schema_type not in TYPE_MAPPING:
            raise ValueError(f"âŒ Type Error in {event_name}: Unsupported type '{schema_type}'")

        fields.append(Field(name, schema_type, is_optional))

    return fields

def validate_event_name_suffix(name: str):
    valid = False
    for suffix in VALID_SUFFIXES:
        if name.endswith(suffix):
            valid = True
            break
    if not valid:
        raise ValueError(f"âŒ Naming Violation: '{name}' suffix not in whitelist.")

# ==========================================
# 5. ä¸»ç”Ÿæˆæµç¨‹
# ==========================================

def generate_code():
    print("ğŸš€ Starting Polaris Codegen...")
    
    # ç›®å½•æ£€æŸ¥
    if not os.path.exists("generated"):
        os.makedirs("generated")

    events: List[EventContext] = []
    
    try:
        with open("events.csv", mode="r", encoding="utf-8-sig") as f:
            reader = csv.DictReader(f)
            for row in reader:
                if not row.get("EventID"): continue
                
                eid = row["EventID"]
                ename = row["EventName"]
                
                # æ ¡éªŒ
                validate_event_name_suffix(ename)
                
                # è§£æ Schema (è‡ªåŠ¨å»é™¤ Common å­—æ®µ)
                fields = parse_schema(row["Desc_Schema"], ename)

                event = EventContext(
                    event_id=eid,
                    event_name=ename,
                    logical_module=row["Logical_Module"], # e.g. "AppManager"
                    owner=row["Owner"],
                    sdk_type=row["SDK_Type"],
                    sdk_level=row["SDK_Level"],
                    status=row["Status"],
                    fields=fields
                )
                events.append(event)

    except Exception as e:
        print(f"âŒ Error: {e}")
        sys.exit(1)

    env = Environment(loader=BaseLoader())

    # ç”Ÿæˆ Java/C++ Context ç±»
    for event in events:
        # Java Path: generated/java/com/polaris/events/<scope>/<module>/
        java_pkg_path = event.package_name.replace('.', '/')
        java_full_path = os.path.join(OUTPUT_DIR, "java", java_pkg_path)
        os.makedirs(java_full_path, exist_ok=True)
        
        with open(os.path.join(java_full_path, f"{event.class_name}.java"), "w") as f:
            f.write(env.from_string(JAVA_TEMPLATE).render(event=event))

        # C++ Path: generated/cpp/include/polaris/events/<scope>/<module>/
        # å¯¹åº” namespace: polaris::events::<scope>::<module>
        cpp_ns_path = os.path.join("polaris", "events", event.scope, event.module_clean)
        cpp_full_path = os.path.join(OUTPUT_DIR, "cpp", "include", cpp_ns_path)
        os.makedirs(cpp_full_path, exist_ok=True)

        with open(os.path.join(cpp_full_path, f"{event.class_name}.h"), "w") as f:
            f.write(env.from_string(CPP_TEMPLATE).render(event=event))

    # ç”Ÿæˆ Constants
    # Java
    const_java_path = os.path.join(OUTPUT_DIR, "java", "com", "polaris", "constants")
    os.makedirs(const_java_path, exist_ok=True)
    with open(os.path.join(const_java_path, "PolarisEvents.java"), "w") as f:
        f.write(env.from_string(CONSTANTS_JAVA_TEMPLATE).render(events=events))
        
    # C++
    const_cpp_path = os.path.join(OUTPUT_DIR, "cpp", "include", "polaris", "constants")
    os.makedirs(const_cpp_path, exist_ok=True)
    with open(os.path.join(const_cpp_path, "PolarisEvents.h"), "w") as f:
        f.write(env.from_string(CONSTANTS_CPP_TEMPLATE).render(events=events))

    print(f"âœ… Generated {len(events)} events.")
    print(f"ğŸ“‚ Java Root: {os.path.join(OUTPUT_DIR, 'java')}")
    print(f"ğŸ“‚ C++ Root:  {os.path.join(OUTPUT_DIR, 'cpp')}")

if __name__ == "__main__":
    generate_code()